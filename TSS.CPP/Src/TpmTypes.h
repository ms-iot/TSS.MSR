/*++

Copyright (c) 2013, 2014  Microsoft Corporation
Microsoft Confidential

*/
#pragma once
#include "TpmStructureBase.h"

_TPMCPP_BEGIN

// *************************************************************************************
//
// NOTE! Do not edit this file, it is auto generated! This source is TpmTypes_skel.h.
//
// *************************************************************************************

class _DLLEXP_ Tpm2;

// Identifier for all TPM-related types
enum class TpmTypeId
{
    None,
    TPM2B_XX_ID,
    TPML_XX_ID,
    sbyte_ID = 3,
    byte_ID = 4,
    short_ID = 5,
    ushort_ID = 6,
    int_ID = 7,
    uint_ID = 8,
    long_ID = 9,
    ulong_ID = 10,
    bool_ID = 11,
    INT8_ID = 12,
    UINT8_ID = 13,
    BYTE_ID = 14,
    UINT16_ID = 15,
    INT16_ID = 16,
    UINT32_ID = 17,
    INT32_ID = 18,
    UINT64_ID = 19,
    INT64_ID = 20,
    BOOL_ID = 21,
    NameUnionTagValues_ID = 22,
    TPMS_NULL_UNION_ID = 23,
    TPM_ALG_ID_ID = 24,
    TPMT_HA_ID = 25,
    TPM_ECC_CURVE_ID = 26,
    SHA1_ID = 27,
    SHA256_ID = 28,
    SHA384_ID = 29,
    SHA512_ID = 30,
    SM3_256_ID = 31,
    ImplementationConstants_ID = 32,
    TPMU_HA_ID = 33,
    Logic_ID = 34,
    TPM_ALGORITHM_ID_ID = 35,
    TPM_MODIFIER_INDICATOR_ID = 36,
    TPM_AUTHORIZATION_SIZE_ID = 37,
    TPM_PARAMETER_SIZE_ID = 38,
    TPM_KEY_SIZE_ID = 39,
    TPM_KEY_BITS_ID = 40,
    TPM_SPEC_ID = 41,
    TPM_GENERATED_ID = 42,
    TPM_CC_ID = 43,
    TPM_RC_ID = 44,
    TPM_CLOCK_ADJUST_ID = 45,
    TPM_EO_ID = 46,
    TPM_ST_ID = 47,
    TPM_SU_ID = 48,
    TPM_SE_ID = 49,
    TPM_CAP_ID = 50,
    TPM_PT_ID = 51,
    TPM_PT_PCR_ID = 52,
    TPM_PS_ID = 53,
    TPM_HT_ID = 54,
    TPM_RH_ID = 55,
    TPM_HANDLE_ID = 56,
    TPMA_ALGORITHM_ID = 57,
    TPMA_OBJECT_ID = 58,
    TPMA_SESSION_ID = 59,
    TPMA_LOCALITY_ID = 60,
    TPMA_PERMANENT_ID = 61,
    TPMA_STARTUP_CLEAR_ID = 62,
    TPMA_MEMORY_ID = 63,
    TPMA_CC_ID = 64,
    TPMA_MODES_ID = 65,
    TPMA_X509_KEY_USAGE_ID = 66,
    TPMI_YES_NO_ID = 67,
    TPMI_DH_OBJECT_ID = 68,
    TPMI_DH_PARENT_ID = 69,
    TPMI_DH_PERSISTENT_ID = 70,
    TPMI_DH_ENTITY_ID = 71,
    TPMI_DH_PCR_ID = 72,
    TPMI_SH_AUTH_SESSION_ID = 73,
    TPMI_SH_HMAC_ID = 74,
    TPMI_SH_POLICY_ID = 75,
    TPMI_DH_CONTEXT_ID = 76,
    TPMI_DH_SAVED_ID = 77,
    TPMI_RH_HIERARCHY_ID = 78,
    TPMI_RH_ENABLES_ID = 79,
    TPMI_RH_HIERARCHY_AUTH_ID = 80,
    TPMI_RH_PLATFORM_ID = 81,
    TPMI_RH_OWNER_ID = 82,
    TPMI_RH_ENDORSEMENT_ID = 83,
    TPMI_RH_PROVISION_ID = 84,
    TPMI_RH_CLEAR_ID = 85,
    TPMI_RH_NV_AUTH_ID = 86,
    TPMI_RH_LOCKOUT_ID = 87,
    TPMI_RH_NV_INDEX_ID = 88,
    TPMI_RH_AC_ID = 89,
    TPMI_ALG_HASH_ID = 90,
    TPMI_ALG_ASYM_ID = 91,
    TPMI_ALG_SYM_ID = 92,
    TPMI_ALG_SYM_OBJECT_ID = 93,
    TPMI_ALG_SYM_MODE_ID = 94,
    TPMI_ALG_KDF_ID = 95,
    TPMI_ALG_SIG_SCHEME_ID = 96,
    TPMI_ECC_KEY_EXCHANGE_ID = 97,
    TPMI_ST_COMMAND_TAG_ID = 98,
    TPMI_ALG_MAC_SCHEME_ID = 99,
    TPMI_ALG_CIPHER_MODE_ID = 100,
    TPMS_EMPTY_ID = 101,
    TPMS_ALGORITHM_DESCRIPTION_ID = 102,
    TPM2B_DIGEST_ID = 103,
    TPM2B_DATA_ID = 104,
    TPM2B_NONCE_ID = 105,
    TPM2B_AUTH_ID = 106,
    TPM2B_OPERAND_ID = 107,
    TPM2B_EVENT_ID = 108,
    TPM2B_MAX_BUFFER_ID = 109,
    TPM2B_MAX_NV_BUFFER_ID = 110,
    TPM2B_TIMEOUT_ID = 111,
    TPM2B_IV_ID = 112,
    TPMU_NAME_ID = 113,
    TPM2B_NAME_ID = 114,
    TPMS_PCR_SELECT_ID = 115,
    TPMS_PCR_SELECTION_ID = 116,
    TPMT_TK_CREATION_ID = 117,
    TPMT_TK_VERIFIED_ID = 118,
    TPMT_TK_AUTH_ID = 119,
    TPMT_TK_HASHCHECK_ID = 120,
    TPMS_ALG_PROPERTY_ID = 121,
    TPMS_TAGGED_PROPERTY_ID = 122,
    TPMS_TAGGED_PCR_SELECT_ID = 123,
    TPMS_TAGGED_POLICY_ID = 124,
    TPML_CC_ID = 125,
    TPML_CCA_ID = 126,
    TPML_ALG_ID = 127,
    TPML_HANDLE_ID = 128,
    TPML_DIGEST_ID = 129,
    TPML_DIGEST_VALUES_ID = 130,
    TPML_PCR_SELECTION_ID = 131,
    TPML_ALG_PROPERTY_ID = 132,
    TPML_TAGGED_TPM_PROPERTY_ID = 133,
    TPML_TAGGED_PCR_PROPERTY_ID = 134,
    TPML_ECC_CURVE_ID = 135,
    TPML_TAGGED_POLICY_ID = 136,
    TPMU_CAPABILITIES_ID = 137,
    TPMS_CAPABILITY_DATA_ID = 138,
    TPMS_CLOCK_INFO_ID = 139,
    TPMS_TIME_INFO_ID = 140,
    TPMS_TIME_ATTEST_INFO_ID = 141,
    TPMS_CERTIFY_INFO_ID = 142,
    TPMS_QUOTE_INFO_ID = 143,
    TPMS_COMMAND_AUDIT_INFO_ID = 144,
    TPMS_SESSION_AUDIT_INFO_ID = 145,
    TPMS_CREATION_INFO_ID = 146,
    TPMS_NV_CERTIFY_INFO_ID = 147,
    TPMS_NV_DIGEST_CERTIFY_INFO_ID = 148,
    TPMI_ST_ATTEST_ID = 149,
    TPMU_ATTEST_ID = 150,
    TPMS_ATTEST_ID = 151,
    TPM2B_ATTEST_ID = 152,
    TPMS_AUTH_COMMAND_ID = 153,
    AUTHResponse_ID = 154,
    TPMI_TDES_KEY_BITS_ID = 155,
    TPMI_AES_KEY_BITS_ID = 156,
    TPMI_SM4_KEY_BITS_ID = 157,
    TPMI_CAMELLIA_KEY_BITS_ID = 158,
    TPMS_NULL_SYM_KEY_BITS_ID = 159,
    TPMU_SYM_KEY_BITS_ID = 160,
    TPMS_XOR_SYM_MODE_ID = 161,
    TPMS_NULL_SYM_MODE_ID = 162,
    TPMU_SYM_MODE_ID = 163,
    TPMS_TDES_SYM_DETAILS_ID = 164,
    TPMS_AES_SYM_DETAILS_ID = 165,
    TPMS_SM4_SYM_DETAILS_ID = 166,
    TPMS_CAMELLIA_SYM_DETAILS_ID = 167,
    TPMS_ANY_SYM_DETAILS_ID = 168,
    TPMS_XOR_SYM_DETAILS_ID = 169,
    TPMS_NULL_SYM_DETAILS_ID = 170,
    TPMU_SYM_DETAILS_ID = 171,
    TPMT_SYM_DEF_ID = 172,
    TPMT_SYM_DEF_OBJECT_ID = 173,
    TPM2B_SYM_KEY_ID = 174,
    TPMS_SYMCIPHER_PARMS_ID = 175,
    TPM2B_LABEL_ID = 176,
    TPMS_DERIVE_ID = 177,
    TPM2B_DERIVE_ID = 178,
    TPMU_SENSITIVE_CREATE_ID = 179,
    TPM2B_SENSITIVE_DATA_ID = 180,
    TPMS_SENSITIVE_CREATE_ID = 181,
    TPM2B_SENSITIVE_CREATE_ID = 182,
    TPMS_SCHEME_HASH_ID = 183,
    TPMS_SCHEME_ECDAA_ID = 184,
    TPMI_ALG_KEYEDHASH_SCHEME_ID = 185,
    TPMS_SCHEME_HMAC_ID = 186,
    TPMS_SCHEME_XOR_ID = 187,
    TPMS_NULL_SCHEME_KEYEDHASH_ID = 188,
    TPMU_SCHEME_KEYEDHASH_ID = 189,
    TPMT_KEYEDHASH_SCHEME_ID = 190,
    TPMS_SIG_SCHEME_RSASSA_ID = 191,
    TPMS_SIG_SCHEME_RSAPSS_ID = 192,
    TPMS_SIG_SCHEME_ECDSA_ID = 193,
    TPMS_SIG_SCHEME_SM2_ID = 194,
    TPMS_SIG_SCHEME_ECSCHNORR_ID = 195,
    TPMS_SIG_SCHEME_ECDAA_ID = 196,
    TPMS_NULL_SIG_SCHEME_ID = 197,
    TPMU_SIG_SCHEME_ID = 198,
    TPMT_SIG_SCHEME_ID = 199,
    TPMS_ENC_SCHEME_OAEP_ID = 200,
    TPMS_ENC_SCHEME_RSAES_ID = 201,
    TPMS_KEY_SCHEME_ECDH_ID = 202,
    TPMS_KEY_SCHEME_ECMQV_ID = 203,
    TPMS_SCHEME_MGF1_ID = 204,
    TPMS_SCHEME_KDF1_SP800_56A_ID = 205,
    TPMS_SCHEME_KDF2_ID = 206,
    TPMS_SCHEME_KDF1_SP800_108_ID = 207,
    TPMS_NULL_KDF_SCHEME_ID = 208,
    TPMU_KDF_SCHEME_ID = 209,
    TPMT_KDF_SCHEME_ID = 210,
    TPMI_ALG_ASYM_SCHEME_ID = 211,
    TPMS_NULL_ASYM_SCHEME_ID = 212,
    TPMU_ASYM_SCHEME_ID = 213,
    TPMT_ASYM_SCHEME_ID = 214,
    TPMI_ALG_RSA_SCHEME_ID = 215,
    TPMT_RSA_SCHEME_ID = 216,
    TPMI_ALG_RSA_DECRYPT_ID = 217,
    TPMT_RSA_DECRYPT_ID = 218,
    TPM2B_PUBLIC_KEY_RSA_ID = 219,
    TPMI_RSA_KEY_BITS_ID = 220,
    TPM2B_PRIVATE_KEY_RSA_ID = 221,
    TPM2B_ECC_PARAMETER_ID = 222,
    TPMS_ECC_POINT_ID = 223,
    TPM2B_ECC_POINT_ID = 224,
    TPMI_ALG_ECC_SCHEME_ID = 225,
    TPMI_ECC_CURVE_ID = 226,
    TPMT_ECC_SCHEME_ID = 227,
    TPMS_ALGORITHM_DETAIL_ECC_ID = 228,
    TPMS_SIGNATURE_RSA_ID = 229,
    TPMS_SIGNATURE_RSASSA_ID = 230,
    TPMS_SIGNATURE_RSAPSS_ID = 231,
    TPMS_SIGNATURE_ECC_ID = 232,
    TPMS_SIGNATURE_ECDSA_ID = 233,
    TPMS_SIGNATURE_ECDAA_ID = 234,
    TPMS_SIGNATURE_SM2_ID = 235,
    TPMS_SIGNATURE_ECSCHNORR_ID = 236,
    TPMS_NULL_SIGNATURE_ID = 237,
    TPMU_SIGNATURE_ID = 238,
    TPMT_SIGNATURE_ID = 239,
    TPMU_ENCRYPTED_SECRET_ID = 240,
    TPM2B_ENCRYPTED_SECRET_ID = 241,
    TPMI_ALG_PUBLIC_ID = 242,
    TPMU_PUBLIC_ID_ID = 243,
    TPMS_KEYEDHASH_PARMS_ID = 244,
    TPMS_ASYM_PARMS_ID = 245,
    TPMS_RSA_PARMS_ID = 246,
    TPMS_ECC_PARMS_ID = 247,
    TPMU_PUBLIC_PARMS_ID = 248,
    TPMT_PUBLIC_PARMS_ID = 249,
    TPMT_PUBLIC_ID = 250,
    TPM2B_PUBLIC_ID = 251,
    TPM2B_TEMPLATE_ID = 252,
    TPM2B_PRIVATE_VENDOR_SPECIFIC_ID = 253,
    TPMU_SENSITIVE_COMPOSITE_ID = 254,
    TPMT_SENSITIVE_ID = 255,
    TPM2B_SENSITIVE_ID = 256,
    _PRIVATE_ID = 257,
    TPM2B_PRIVATE_ID = 258,
    TPMS_ID_OBJECT_ID = 259,
    TPM2B_ID_OBJECT_ID = 260,
    TPM_NV_INDEX_ID = 261,
    TPM_NT_ID = 262,
    TPMS_NV_PIN_COUNTER_PARAMETERS_ID = 263,
    TPMA_NV_ID = 264,
    TPMS_NV_PUBLIC_ID = 265,
    TPM2B_NV_PUBLIC_ID = 266,
    TPM2B_CONTEXT_SENSITIVE_ID = 267,
    TPMS_CONTEXT_DATA_ID = 268,
    TPM2B_CONTEXT_DATA_ID = 269,
    TPMS_CONTEXT_ID = 270,
    TPMS_CREATION_DATA_ID = 271,
    TPM2B_CREATION_DATA_ID = 272,
    TPM_AT_ID = 273,
    TPM_AE_ID = 274,
    TPMS_AC_OUTPUT_ID = 275,
    TPML_AC_CAPABILITIES_ID = 276,
    PLATFORM_ID = 277,
    BSIZE_ID = 278,
    CONTEXT_SLOT_ID = 279,
    CONTEXT_COUNTER_ID = 280,
    Implementation_ID = 281,
    TPM_HC_ID = 282,
    TPM2_Startup_REQUEST_ID = 283,
    StartupResponse_ID = 284,
    TPM2_Shutdown_REQUEST_ID = 285,
    ShutdownResponse_ID = 286,
    TPM2_SelfTest_REQUEST_ID = 287,
    SelfTestResponse_ID = 288,
    TPM2_IncrementalSelfTest_REQUEST_ID = 289,
    IncrementalSelfTestResponse_ID = 290,
    TPM2_GetTestResult_REQUEST_ID = 291,
    GetTestResultResponse_ID = 292,
    TPM2_StartAuthSession_REQUEST_ID = 293,
    StartAuthSessionResponse_ID = 294,
    TPM2_PolicyRestart_REQUEST_ID = 295,
    PolicyRestartResponse_ID = 296,
    TPM2_Create_REQUEST_ID = 297,
    CreateResponse_ID = 298,
    TPM2_Load_REQUEST_ID = 299,
    LoadResponse_ID = 300,
    TPM2_LoadExternal_REQUEST_ID = 301,
    LoadExternalResponse_ID = 302,
    TPM2_ReadPublic_REQUEST_ID = 303,
    ReadPublicResponse_ID = 304,
    TPM2_ActivateCredential_REQUEST_ID = 305,
    ActivateCredentialResponse_ID = 306,
    TPM2_MakeCredential_REQUEST_ID = 307,
    MakeCredentialResponse_ID = 308,
    TPM2_Unseal_REQUEST_ID = 309,
    UnsealResponse_ID = 310,
    TPM2_ObjectChangeAuth_REQUEST_ID = 311,
    ObjectChangeAuthResponse_ID = 312,
    TPM2_CreateLoaded_REQUEST_ID = 313,
    CreateLoadedResponse_ID = 314,
    TPM2_Duplicate_REQUEST_ID = 315,
    DuplicateResponse_ID = 316,
    TPM2_Rewrap_REQUEST_ID = 317,
    RewrapResponse_ID = 318,
    TPM2_Import_REQUEST_ID = 319,
    ImportResponse_ID = 320,
    TPM2_RSA_Encrypt_REQUEST_ID = 321,
    RSA_EncryptResponse_ID = 322,
    TPM2_RSA_Decrypt_REQUEST_ID = 323,
    RSA_DecryptResponse_ID = 324,
    TPM2_ECDH_KeyGen_REQUEST_ID = 325,
    ECDH_KeyGenResponse_ID = 326,
    TPM2_ECDH_ZGen_REQUEST_ID = 327,
    ECDH_ZGenResponse_ID = 328,
    TPM2_ECC_Parameters_REQUEST_ID = 329,
    ECC_ParametersResponse_ID = 330,
    TPM2_ZGen_2Phase_REQUEST_ID = 331,
    ZGen_2PhaseResponse_ID = 332,
    TPM2_EncryptDecrypt_REQUEST_ID = 333,
    EncryptDecryptResponse_ID = 334,
    TPM2_EncryptDecrypt2_REQUEST_ID = 335,
    EncryptDecrypt2Response_ID = 336,
    TPM2_Hash_REQUEST_ID = 337,
    HashResponse_ID = 338,
    TPM2_HMAC_REQUEST_ID = 339,
    HMACResponse_ID = 340,
    TPM2_MAC_REQUEST_ID = 341,
    MACResponse_ID = 342,
    TPM2_GetRandom_REQUEST_ID = 343,
    GetRandomResponse_ID = 344,
    TPM2_StirRandom_REQUEST_ID = 345,
    StirRandomResponse_ID = 346,
    TPM2_HMAC_Start_REQUEST_ID = 347,
    HMAC_StartResponse_ID = 348,
    TPM2_MAC_Start_REQUEST_ID = 349,
    MAC_StartResponse_ID = 350,
    TPM2_HashSequenceStart_REQUEST_ID = 351,
    HashSequenceStartResponse_ID = 352,
    TPM2_SequenceUpdate_REQUEST_ID = 353,
    SequenceUpdateResponse_ID = 354,
    TPM2_SequenceComplete_REQUEST_ID = 355,
    SequenceCompleteResponse_ID = 356,
    TPM2_EventSequenceComplete_REQUEST_ID = 357,
    EventSequenceCompleteResponse_ID = 358,
    TPM2_Certify_REQUEST_ID = 359,
    CertifyResponse_ID = 360,
    TPM2_CertifyCreation_REQUEST_ID = 361,
    CertifyCreationResponse_ID = 362,
    TPM2_Quote_REQUEST_ID = 363,
    QuoteResponse_ID = 364,
    TPM2_GetSessionAuditDigest_REQUEST_ID = 365,
    GetSessionAuditDigestResponse_ID = 366,
    TPM2_GetCommandAuditDigest_REQUEST_ID = 367,
    GetCommandAuditDigestResponse_ID = 368,
    TPM2_GetTime_REQUEST_ID = 369,
    GetTimeResponse_ID = 370,
    TPM2_CertifyX509_REQUEST_ID = 371,
    CertifyX509Response_ID = 372,
    TPM2_Commit_REQUEST_ID = 373,
    CommitResponse_ID = 374,
    TPM2_EC_Ephemeral_REQUEST_ID = 375,
    EC_EphemeralResponse_ID = 376,
    TPM2_VerifySignature_REQUEST_ID = 377,
    VerifySignatureResponse_ID = 378,
    TPM2_Sign_REQUEST_ID = 379,
    SignResponse_ID = 380,
    TPM2_SetCommandCodeAuditStatus_REQUEST_ID = 381,
    SetCommandCodeAuditStatusResponse_ID = 382,
    TPM2_PCR_Extend_REQUEST_ID = 383,
    PCR_ExtendResponse_ID = 384,
    TPM2_PCR_Event_REQUEST_ID = 385,
    PCR_EventResponse_ID = 386,
    TPM2_PCR_Read_REQUEST_ID = 387,
    PCR_ReadResponse_ID = 388,
    TPM2_PCR_Allocate_REQUEST_ID = 389,
    PCR_AllocateResponse_ID = 390,
    TPM2_PCR_SetAuthPolicy_REQUEST_ID = 391,
    PCR_SetAuthPolicyResponse_ID = 392,
    TPM2_PCR_SetAuthValue_REQUEST_ID = 393,
    PCR_SetAuthValueResponse_ID = 394,
    TPM2_PCR_Reset_REQUEST_ID = 395,
    PCR_ResetResponse_ID = 396,
    TPM2_PolicySigned_REQUEST_ID = 397,
    PolicySignedResponse_ID = 398,
    TPM2_PolicySecret_REQUEST_ID = 399,
    PolicySecretResponse_ID = 400,
    TPM2_PolicyTicket_REQUEST_ID = 401,
    PolicyTicketResponse_ID = 402,
    TPM2_PolicyOR_REQUEST_ID = 403,
    PolicyORResponse_ID = 404,
    TPM2_PolicyPCR_REQUEST_ID = 405,
    PolicyPCRResponse_ID = 406,
    TPM2_PolicyLocality_REQUEST_ID = 407,
    PolicyLocalityResponse_ID = 408,
    TPM2_PolicyNV_REQUEST_ID = 409,
    PolicyNVResponse_ID = 410,
    TPM2_PolicyCounterTimer_REQUEST_ID = 411,
    PolicyCounterTimerResponse_ID = 412,
    TPM2_PolicyCommandCode_REQUEST_ID = 413,
    PolicyCommandCodeResponse_ID = 414,
    TPM2_PolicyPhysicalPresence_REQUEST_ID = 415,
    PolicyPhysicalPresenceResponse_ID = 416,
    TPM2_PolicyCpHash_REQUEST_ID = 417,
    PolicyCpHashResponse_ID = 418,
    TPM2_PolicyNameHash_REQUEST_ID = 419,
    PolicyNameHashResponse_ID = 420,
    TPM2_PolicyDuplicationSelect_REQUEST_ID = 421,
    PolicyDuplicationSelectResponse_ID = 422,
    TPM2_PolicyAuthorize_REQUEST_ID = 423,
    PolicyAuthorizeResponse_ID = 424,
    TPM2_PolicyAuthValue_REQUEST_ID = 425,
    PolicyAuthValueResponse_ID = 426,
    TPM2_PolicyPassword_REQUEST_ID = 427,
    PolicyPasswordResponse_ID = 428,
    TPM2_PolicyGetDigest_REQUEST_ID = 429,
    PolicyGetDigestResponse_ID = 430,
    TPM2_PolicyNvWritten_REQUEST_ID = 431,
    PolicyNvWrittenResponse_ID = 432,
    TPM2_PolicyTemplate_REQUEST_ID = 433,
    PolicyTemplateResponse_ID = 434,
    TPM2_PolicyAuthorizeNV_REQUEST_ID = 435,
    PolicyAuthorizeNVResponse_ID = 436,
    TPM2_CreatePrimary_REQUEST_ID = 437,
    CreatePrimaryResponse_ID = 438,
    TPM2_HierarchyControl_REQUEST_ID = 439,
    HierarchyControlResponse_ID = 440,
    TPM2_SetPrimaryPolicy_REQUEST_ID = 441,
    SetPrimaryPolicyResponse_ID = 442,
    TPM2_ChangePPS_REQUEST_ID = 443,
    ChangePPSResponse_ID = 444,
    TPM2_ChangeEPS_REQUEST_ID = 445,
    ChangeEPSResponse_ID = 446,
    TPM2_Clear_REQUEST_ID = 447,
    ClearResponse_ID = 448,
    TPM2_ClearControl_REQUEST_ID = 449,
    ClearControlResponse_ID = 450,
    TPM2_HierarchyChangeAuth_REQUEST_ID = 451,
    HierarchyChangeAuthResponse_ID = 452,
    TPM2_DictionaryAttackLockReset_REQUEST_ID = 453,
    DictionaryAttackLockResetResponse_ID = 454,
    TPM2_DictionaryAttackParameters_REQUEST_ID = 455,
    DictionaryAttackParametersResponse_ID = 456,
    TPM2_PP_Commands_REQUEST_ID = 457,
    PP_CommandsResponse_ID = 458,
    TPM2_SetAlgorithmSet_REQUEST_ID = 459,
    SetAlgorithmSetResponse_ID = 460,
    TPM2_FieldUpgradeStart_REQUEST_ID = 461,
    FieldUpgradeStartResponse_ID = 462,
    TPM2_FieldUpgradeData_REQUEST_ID = 463,
    FieldUpgradeDataResponse_ID = 464,
    TPM2_FirmwareRead_REQUEST_ID = 465,
    FirmwareReadResponse_ID = 466,
    TPM2_ContextSave_REQUEST_ID = 467,
    ContextSaveResponse_ID = 468,
    TPM2_ContextLoad_REQUEST_ID = 469,
    ContextLoadResponse_ID = 470,
    TPM2_FlushContext_REQUEST_ID = 471,
    FlushContextResponse_ID = 472,
    TPM2_EvictControl_REQUEST_ID = 473,
    EvictControlResponse_ID = 474,
    TPM2_ReadClock_REQUEST_ID = 475,
    ReadClockResponse_ID = 476,
    TPM2_ClockSet_REQUEST_ID = 477,
    ClockSetResponse_ID = 478,
    TPM2_ClockRateAdjust_REQUEST_ID = 479,
    ClockRateAdjustResponse_ID = 480,
    TPM2_GetCapability_REQUEST_ID = 481,
    GetCapabilityResponse_ID = 482,
    TPM2_TestParms_REQUEST_ID = 483,
    TestParmsResponse_ID = 484,
    TPM2_NV_DefineSpace_REQUEST_ID = 485,
    NV_DefineSpaceResponse_ID = 486,
    TPM2_NV_UndefineSpace_REQUEST_ID = 487,
    NV_UndefineSpaceResponse_ID = 488,
    TPM2_NV_UndefineSpaceSpecial_REQUEST_ID = 489,
    NV_UndefineSpaceSpecialResponse_ID = 490,
    TPM2_NV_ReadPublic_REQUEST_ID = 491,
    NV_ReadPublicResponse_ID = 492,
    TPM2_NV_Write_REQUEST_ID = 493,
    NV_WriteResponse_ID = 494,
    TPM2_NV_Increment_REQUEST_ID = 495,
    NV_IncrementResponse_ID = 496,
    TPM2_NV_Extend_REQUEST_ID = 497,
    NV_ExtendResponse_ID = 498,
    TPM2_NV_SetBits_REQUEST_ID = 499,
    NV_SetBitsResponse_ID = 500,
    TPM2_NV_WriteLock_REQUEST_ID = 501,
    NV_WriteLockResponse_ID = 502,
    TPM2_NV_GlobalWriteLock_REQUEST_ID = 503,
    NV_GlobalWriteLockResponse_ID = 504,
    TPM2_NV_Read_REQUEST_ID = 505,
    NV_ReadResponse_ID = 506,
    TPM2_NV_ReadLock_REQUEST_ID = 507,
    NV_ReadLockResponse_ID = 508,
    TPM2_NV_ChangeAuth_REQUEST_ID = 509,
    NV_ChangeAuthResponse_ID = 510,
    TPM2_NV_Certify_REQUEST_ID = 511,
    NV_CertifyResponse_ID = 512,
    TPM2_AC_GetCapability_REQUEST_ID = 513,
    AC_GetCapabilityResponse_ID = 514,
    TPM2_AC_Send_REQUEST_ID = 515,
    AC_SendResponse_ID = 516,
    TPM2_Policy_AC_SendSelect_REQUEST_ID = 517,
    Policy_AC_SendSelectResponse_ID = 518,
    TPM2_Vendor_TCG_Test_REQUEST_ID = 519,
    Vendor_TCG_TestResponse_ID = 520,
    ALG_ID_VALUE_ID = 521,
    TPMS_SCHEME_RSASSA_ID = TPMS_SIG_SCHEME_RSASSA_ID,
    TPMS_SCHEME_RSAPSS_ID = TPMS_SIG_SCHEME_RSAPSS_ID,
    TPMS_SCHEME_ECDSA_ID = TPMS_SIG_SCHEME_ECDSA_ID,
    TPMS_SCHEME_SM2_ID = TPMS_SIG_SCHEME_SM2_ID,
    TPMS_SCHEME_ECSCHNORR_ID = TPMS_SIG_SCHEME_ECSCHNORR_ID,
    TPMS_SCHEME_OAEP_ID = TPMS_ENC_SCHEME_OAEP_ID,
    TPMS_SCHEME_RSAES_ID = TPMS_ENC_SCHEME_RSAES_ID,
    TPMS_SCHEME_ECDH_ID = TPMS_KEY_SCHEME_ECDH_ID,
    TPMS_SCHEME_ECMQV_ID = TPMS_KEY_SCHEME_ECMQV_ID,
    TssObject_ID = 522,
    PcrValue_ID = 523,
    SessionIn_ID = 524,
    SessionOut_ID = 525,
    CommandHeader_ID = 526,
    TSS_KEY_ID = 527,
    TPM2B_DIGEST_Symcipher_ID = 528,
    TPM2B_DIGEST_Keyedhash_ID = 529
};

enum class TPM_CAP : UINT32;

/// <summary>
/// Selector type for TPMU_NAME [TSS]
/// </summary>
enum class NameUnionTagValues : byte
{
    TAG_TPMU_NAME_TPMT_HA = 0,
    TAG_TPMU_NAME_TPM_HANDLE = 1
};
/// <summary>
/// Table 2 is the list of algorithms to which the TCG has assigned an algorithm identifier along with its numeric identifier.
/// </summary>
enum class TPM_ALG_ID : UINT16
{
    /// <summary>
    /// should not occur
    /// </summary>
    _ERROR = 0x0000,
    /// <summary>
    /// an object type that contains an RSA key
    /// </summary>
    FIRST = 0x0001,
    /// <summary>
    /// an object type that contains an RSA key
    /// </summary>
    RSA = 0x0001,
    TDES = 0x0003,
    /// <summary>
    /// hash algorithm producing a 160-bit digest
    /// </summary>
    SHA = 0x0004,
    /// <summary>
    /// redefinition for documentation consistency
    /// </summary>
    SHA1 = 0x0004,
    /// <summary>
    /// Hash Message Authentication Code (HMAC) algorithm
    /// </summary>
    HMAC = 0x0005,
    /// <summary>
    /// block cipher with various key sizes
    /// </summary>
    AES = 0x0006,
    /// <summary>
    /// hash-based mask-generation function
    /// </summary>
    MGF1 = 0x0007,
    /// <summary>
    /// an object type that may use XOR for encryption or an HMAC for signing and may also refer to a data object that is neither signing nor encrypting
    /// </summary>
    KEYEDHASH = 0x0008,
    /// <summary>
    /// hash-based stream cipher
    /// </summary>
    XOR = 0x000A,
    /// <summary>
    /// hash algorithm producing a 256-bit digest
    /// </summary>
    SHA256 = 0x000B,
    /// <summary>
    /// hash algorithm producing a 384-bit digest
    /// </summary>
    SHA384 = 0x000C,
    /// <summary>
    /// hash algorithm producing a 512-bit digest
    /// </summary>
    SHA512 = 0x000D,
    /// <summary>
    /// Indication that no algorithm is selected
    /// </summary>
    _NULL = 0x0010,
    /// <summary>
    /// hash algorithm producing a 256-bit digest
    /// </summary>
    SM3_256 = 0x0012,
    /// <summary>
    /// symmetric block cipher with 128 bit key
    /// </summary>
    SM4 = 0x0013,
    /// <summary>
    /// a signature algorithm defined in section 8.2 (RSASSA-PKCS1-v1_5)
    /// </summary>
    RSASSA = 0x0014,
    /// <summary>
    /// a padding algorithm defined in section 7.2 (RSAES-PKCS1-v1_5)
    /// </summary>
    RSAES = 0x0015,
    /// <summary>
    /// a signature algorithm defined in section 8.1 (RSASSA-PSS)
    /// </summary>
    RSAPSS = 0x0016,
    /// <summary>
    /// a padding algorithm defined in Section 7.1 (RSAES_OAEP)
    /// </summary>
    OAEP = 0x0017,
    /// <summary>
    /// signature algorithm using elliptic curve cryptography (ECC)
    /// </summary>
    ECDSA = 0x0018,
    /// <summary>
    /// secret sharing using ECC Based on context, this can be either One-Pass Diffie-Hellman, C(1, 1, ECC CDH) defined in 6.2.2.2 or Full Unified Model C(2, 2, ECC CDH) defined in 6.1.1.2
    /// </summary>
    ECDH = 0x0019,
    /// <summary>
    /// elliptic-curve based, anonymous signing scheme
    /// </summary>
    ECDAA = 0x001A,
    /// <summary>
    /// depending on context, either an elliptic-curve based, signature algorithm or a key exchange protocol
    /// NOTE	Type listed as signing but, other uses are allowed according to context.
    /// </summary>
    SM2 = 0x001B,
    /// <summary>
    /// elliptic-curve based Schnorr signature
    /// </summary>
    ECSCHNORR = 0x001C,
    /// <summary>
    /// two-phase elliptic-curve key exchange  C(2, 2, ECC MQV) Section 6.1.1.4
    /// </summary>
    ECMQV = 0x001D,
    /// <summary>
    /// concatenation key derivation function (approved alternative 1) Section 5.8.1
    /// </summary>
    KDF1_SP800_56A = 0x0020,
    /// <summary>
    /// key derivation function KDF2 Section 13.2
    /// </summary>
    KDF2 = 0x0021,
    /// <summary>
    /// a key derivation method SP800-108, Section 5.1 KDF in Counter Mode
    /// </summary>
    KDF1_SP800_108 = 0x0022,
    /// <summary>
    /// prime field ECC
    /// </summary>
    ECC = 0x0023,
    /// <summary>
    /// the object type for a symmetric block cipher key
    /// </summary>
    SYMCIPHER = 0x0025,
    /// <summary>
    /// symmetric block cipher with various key sizes
    /// </summary>
    CAMELLIA = 0x0026,
    CMAC = 0x003F,
    /// <summary>
    /// Counter mode  if implemented, all symmetric block ciphers (S type) implemented shall be capable of using this mode.
    /// </summary>
    CTR = 0x0040,
    /// <summary>
    /// Output Feedback mode  if implemented, all symmetric block ciphers (S type) implemented shall be capable of using this mode.
    /// </summary>
    OFB = 0x0041,
    /// <summary>
    /// Cipher Block Chaining mode  if implemented, all symmetric block ciphers (S type) implemented shall be capable of using this mode.
    /// </summary>
    CBC = 0x0042,
    /// <summary>
    /// Cipher Feedback mode  if implemented, all symmetric block ciphers (S type) implemented shall be capable of using this mode.
    /// </summary>
    CFB = 0x0043,
    /// <summary>
    /// Electronic Codebook mode  if implemented, all implemented symmetric block ciphers (S type) shall be capable of using this mode.
    /// NOTE This mode is not recommended for uses unless the key is frequently rotated such as in video codecs
    /// </summary>
    ECB = 0x0044,
    LAST = 0x0044,
    /// <summary>
    /// Phony alg ID to be used for the first union member with no selector
    /// </summary>
    ANY = 0x7FFF,
    /// <summary>
    /// Phony alg ID to be used for the second union member with no selector
    /// </summary>
    ANY2 = 0x7FFE
};
/// <summary>
/// Table 3 is the list of identifiers for TCG-registered curve ID values for elliptic curve cryptography.
/// </summary>
enum class TPM_ECC_CURVE : UINT16
{
    NONE = 0x0000,
    NIST_P192 = 0x0001,
    NIST_P224 = 0x0002,
    NIST_P256 = 0x0003,
    NIST_P384 = 0x0004,
    NIST_P521 = 0x0005,
    /// <summary>
    /// curve to support ECDAA
    /// </summary>
    BN_P256 = 0x0010,
    /// <summary>
    /// curve to support ECDAA
    /// </summary>
    BN_P638 = 0x0011,
    SM2_P256 = 0x0020
};
/// <summary>
/// Table 12  Defines for SHA1 Hash Values
/// </summary>
enum class SHA1 : UINT32
{
    /// <summary>
    /// size of digest in octets
    /// </summary>
    DIGEST_SIZE = 20,
    /// <summary>
    /// size of hash block in octets
    /// </summary>
    BLOCK_SIZE = 64,
    /// <summary>
    /// size of the DER in octets
    /// </summary>
    DER_SIZE = 15,
};
/// <summary>
/// Table 13  Defines for SHA256 Hash Values
/// </summary>
enum class SHA256 : UINT32
{
    /// <summary>
    /// size of digest
    /// </summary>
    DIGEST_SIZE = 32,
    /// <summary>
    /// size of hash block
    /// </summary>
    BLOCK_SIZE = 64,
    /// <summary>
    /// size of the DER in octets
    /// </summary>
    DER_SIZE = 19,
};
/// <summary>
/// Table 14  Defines for SHA384 Hash Values
/// </summary>
enum class SHA384 : UINT32
{
    /// <summary>
    /// size of digest in octets
    /// </summary>
    DIGEST_SIZE = 48,
    /// <summary>
    /// size of hash block in octets
    /// </summary>
    BLOCK_SIZE = 128,
    /// <summary>
    /// size of the DER in octets
    /// </summary>
    DER_SIZE = 19,
};
/// <summary>
/// Table 15  Defines for SHA512 Hash Values
/// </summary>
enum class SHA512 : UINT32
{
    /// <summary>
    /// size of digest in octets
    /// </summary>
    DIGEST_SIZE = 64,
    /// <summary>
    /// size of hash block in octets
    /// </summary>
    BLOCK_SIZE = 128,
    /// <summary>
    /// size of the DER in octets
    /// </summary>
    DER_SIZE = 19,
};
/// <summary>
/// Table 16  Defines for SM3_256 Hash Values
/// </summary>
enum class SM3_256 : UINT32
{
    /// <summary>
    /// size of digest in octets
    /// </summary>
    DIGEST_SIZE = 32,
    /// <summary>
    /// size of hash block in octets
    /// </summary>
    BLOCK_SIZE = 64,
    /// <summary>
    /// size of the DER in octets
    /// </summary>
    DER_SIZE = 18,
};
/// <summary>
/// Architecturally defined constants
/// </summary>
enum class ImplementationConstants : UINT32
{
    OSSL = 1,
    LTC = 2,
    MSBN = 3,
    SYMCRYPT = 4,
    HASH_COUNT = 3,
    MAX_SYM_KEY_BITS = 256,
    MAX_SYM_KEY_BYTES = ((UINT32(ImplementationConstants::MAX_SYM_KEY_BITS) + 7) / 8),
    MAX_SYM_BLOCK_SIZE = 16,
    MAX_CAP_CC = UINT32(0x197/*TPM_CC::LAST*/),
    MAX_RSA_KEY_BYTES = 256,
    MAX_AES_KEY_BYTES = 32,
    MAX_ECC_KEY_BYTES = 48,
    LABEL_MAX_BUFFER = 32,
    MAX_CAP_DATA = (UINT32(0x400/*Implementation::MAX_CAP_BUFFER*/)-sizeof(TPM_CAP)-sizeof(UINT32)),
    MAX_CAP_ALGS = (UINT32(ImplementationConstants::MAX_CAP_DATA) / 0x6 /*sizeof(TPMS_ALG_PROPERTY)*/),
    MAX_CAP_HANDLES = (UINT32(ImplementationConstants::MAX_CAP_DATA) / 0x4 /*sizeof(TPM_HANDLE)*/),
    MAX_TPM_PROPERTIES = (UINT32(ImplementationConstants::MAX_CAP_DATA) / 0x8 /*sizeof(TPMS_TAGGED_PROPERTY)*/),
    MAX_PCR_PROPERTIES = (UINT32(ImplementationConstants::MAX_CAP_DATA) / 0x8 /*sizeof(TPMS_TAGGED_PCR_SELECT)*/),
    MAX_ECC_CURVES = (UINT32(ImplementationConstants::MAX_CAP_DATA) / sizeof(TPM_ECC_CURVE)),
    MAX_TAGGED_POLICIES = (UINT32(ImplementationConstants::MAX_CAP_DATA) / 0x36 /*sizeof(TPMS_TAGGED_POLICY)*/),
    MAX_AC_CAPABILITIES = (UINT32(ImplementationConstants::MAX_CAP_DATA) / 0x8 /*sizeof(TPMS_AC_OUTPUT)*/)
};
/// <summary>
/// Table 4  Defines for Logic Values
/// </summary>
enum class Logic : byte
{
    YES = 1,
    NO = 0,
    SET = 1,
    CLEAR = 0
};
/// <summary>
/// These values are readable with TPM2_GetCapability() (see 6.13 for the format).
/// </summary>
enum class TPM_SPEC : UINT32
{
    /// <summary>
    /// ASCII 2.0 with null terminator
    /// </summary>
    FAMILY = 0x322E3000,
    /// <summary>
    /// the level number for the specification
    /// </summary>
    LEVEL = 00,
    /// <summary>
    /// the version number of the spec (001.53 * 100)
    /// </summary>
    VERSION = 153,
    /// <summary>
    /// the year of the version
    /// </summary>
    YEAR = 2019,
    /// <summary>
    /// the day of the year (February 19)
    /// </summary>
    DAY_OF_YEAR = 28
};
/// <summary>
/// This constant value differentiates TPM-generated structures from non-TPM structures.
/// </summary>
enum class TPM_GENERATED : UINT32
{
    /// <summary>
    /// 0xFF TCG (FF 54 43 4716)
    /// </summary>
    VALUE = 0xff544347
};
/// <summary>
/// Table 12 lists the command codes assigned to each command name. The Dep column indicates whether the command has a dependency on the implementation of a specific algorithm.
/// </summary>
enum class TPM_CC : UINT32
{
    /// <summary>
    /// Compile variable. May decrease based on implementation.
    /// </summary>
    FIRST = 0x0000011F,
    NV_UndefineSpaceSpecial = 0x0000011F,
    EvictControl = 0x00000120,
    HierarchyControl = 0x00000121,
    NV_UndefineSpace = 0x00000122,
    ChangeEPS = 0x00000124,
    ChangePPS = 0x00000125,
    Clear = 0x00000126,
    ClearControl = 0x00000127,
    ClockSet = 0x00000128,
    HierarchyChangeAuth = 0x00000129,
    NV_DefineSpace = 0x0000012A,
    PCR_Allocate = 0x0000012B,
    PCR_SetAuthPolicy = 0x0000012C,
    PP_Commands = 0x0000012D,
    SetPrimaryPolicy = 0x0000012E,
    FieldUpgradeStart = 0x0000012F,
    ClockRateAdjust = 0x00000130,
    CreatePrimary = 0x00000131,
    NV_GlobalWriteLock = 0x00000132,
    GetCommandAuditDigest = 0x00000133,
    NV_Increment = 0x00000134,
    NV_SetBits = 0x00000135,
    NV_Extend = 0x00000136,
    NV_Write = 0x00000137,
    NV_WriteLock = 0x00000138,
    DictionaryAttackLockReset = 0x00000139,
    DictionaryAttackParameters = 0x0000013A,
    NV_ChangeAuth = 0x0000013B,
    /// <summary>
    /// PCR
    /// </summary>
    PCR_Event = 0x0000013C,
    /// <summary>
    /// PCR
    /// </summary>
    PCR_Reset = 0x0000013D,
    SequenceComplete = 0x0000013E,
    SetAlgorithmSet = 0x0000013F,
    SetCommandCodeAuditStatus = 0x00000140,
    FieldUpgradeData = 0x00000141,
    IncrementalSelfTest = 0x00000142,
    SelfTest = 0x00000143,
    Startup = 0x00000144,
    Shutdown = 0x00000145,
    StirRandom = 0x00000146,
    ActivateCredential = 0x00000147,
    Certify = 0x00000148,
    /// <summary>
    /// Policy
    /// </summary>
    PolicyNV = 0x00000149,
    CertifyCreation = 0x0000014A,
    Duplicate = 0x0000014B,
    GetTime = 0x0000014C,
    GetSessionAuditDigest = 0x0000014D,
    NV_Read = 0x0000014E,
    NV_ReadLock = 0x0000014F,
    ObjectChangeAuth = 0x00000150,
    /// <summary>
    /// Policy
    /// </summary>
    PolicySecret = 0x00000151,
    Rewrap = 0x00000152,
    Create = 0x00000153,
    ECDH_ZGen = 0x00000154,
    /// <summary>
    /// See NOTE 1
    /// </summary>
    HMAC = 0x00000155,
    /// <summary>
    /// See NOTE 1
    /// </summary>
    MAC = 0x00000155,
    Import = 0x00000156,
    Load = 0x00000157,
    Quote = 0x00000158,
    RSA_Decrypt = 0x00000159,
    /// <summary>
    /// See NOTE 1
    /// </summary>
    HMAC_Start = 0x0000015B,
    /// <summary>
    /// See NOTE 1
    /// </summary>
    MAC_Start = 0x0000015B,
    SequenceUpdate = 0x0000015C,
    Sign = 0x0000015D,
    Unseal = 0x0000015E,
    /// <summary>
    /// Policy
    /// </summary>
    PolicySigned = 0x00000160,
    /// <summary>
    /// Context
    /// </summary>
    ContextLoad = 0x00000161,
    /// <summary>
    /// Context
    /// </summary>
    ContextSave = 0x00000162,
    ECDH_KeyGen = 0x00000163,
    EncryptDecrypt = 0x00000164,
    /// <summary>
    /// Context
    /// </summary>
    FlushContext = 0x00000165,
    LoadExternal = 0x00000167,
    MakeCredential = 0x00000168,
    /// <summary>
    /// NV
    /// </summary>
    NV_ReadPublic = 0x00000169,
    /// <summary>
    /// Policy
    /// </summary>
    PolicyAuthorize = 0x0000016A,
    /// <summary>
    /// Policy
    /// </summary>
    PolicyAuthValue = 0x0000016B,
    /// <summary>
    /// Policy
    /// </summary>
    PolicyCommandCode = 0x0000016C,
    /// <summary>
    /// Policy
    /// </summary>
    PolicyCounterTimer = 0x0000016D,
    /// <summary>
    /// Policy
    /// </summary>
    PolicyCpHash = 0x0000016E,
    /// <summary>
    /// Policy
    /// </summary>
    PolicyLocality = 0x0000016F,
    /// <summary>
    /// Policy
    /// </summary>
    PolicyNameHash = 0x00000170,
    /// <summary>
    /// Policy
    /// </summary>
    PolicyOR = 0x00000171,
    /// <summary>
    /// Policy
    /// </summary>
    PolicyTicket = 0x00000172,
    ReadPublic = 0x00000173,
    RSA_Encrypt = 0x00000174,
    StartAuthSession = 0x00000176,
    VerifySignature = 0x00000177,
    ECC_Parameters = 0x00000178,
    FirmwareRead = 0x00000179,
    GetCapability = 0x0000017A,
    GetRandom = 0x0000017B,
    GetTestResult = 0x0000017C,
    Hash = 0x0000017D,
    /// <summary>
    /// PCR
    /// </summary>
    PCR_Read = 0x0000017E,
    /// <summary>
    /// Policy
    /// </summary>
    PolicyPCR = 0x0000017F,
    PolicyRestart = 0x00000180,
    ReadClock = 0x00000181,
    PCR_Extend = 0x00000182,
    PCR_SetAuthValue = 0x00000183,
    NV_Certify = 0x00000184,
    EventSequenceComplete = 0x00000185,
    HashSequenceStart = 0x00000186,
    /// <summary>
    /// Policy
    /// </summary>
    PolicyPhysicalPresence = 0x00000187,
    /// <summary>
    /// Policy
    /// </summary>
    PolicyDuplicationSelect = 0x00000188,
    /// <summary>
    /// Policy
    /// </summary>
    PolicyGetDigest = 0x00000189,
    TestParms = 0x0000018A,
    Commit = 0x0000018B,
    /// <summary>
    /// Policy
    /// </summary>
    PolicyPassword = 0x0000018C,
    ZGen_2Phase = 0x0000018D,
    EC_Ephemeral = 0x0000018E,
    /// <summary>
    /// Policy
    /// </summary>
    PolicyNvWritten = 0x0000018F,
    /// <summary>
    /// Policy
    /// </summary>
    PolicyTemplate = 0x00000190,
    CreateLoaded = 0x00000191,
    /// <summary>
    /// Policy
    /// </summary>
    PolicyAuthorizeNV = 0x00000192,
    EncryptDecrypt2 = 0x00000193,
    AC_GetCapability = 0x00000194,
    AC_Send = 0x00000195,
    /// <summary>
    /// Policy
    /// </summary>
    Policy_AC_SendSelect = 0x00000196,
    CertifyX509 = 0x00000197,
    /// <summary>
    /// Compile variable. May increase based on implementation.
    /// </summary>
    LAST = 0x00000197,
    CC_VEND = 0x20000000,
    /// <summary>
    /// Used for testing of command dispatch
    /// </summary>
    Vendor_TCG_Test = UINT32(TPM_CC::CC_VEND)+0x0000
};
/// <summary>
/// In general, response codes defined in TPM 2.0 Part 2 will be unmarshaling errors and will have the F (format) bit SET. Codes that are unique to TPM 2.0 Part 3 will have the F bit CLEAR but the V (version) attribute will be SET to indicate that it is a TPM 2.0 response code. See Response Code Details in TPM 2.0 Part 1.
/// </summary>
enum class TPM_RC : UINT32
{
    SUCCESS = 0x000,
    /// <summary>
    /// defined for compatibility with TPM 1.2
    /// </summary>
    BAD_TAG = 0x01E,
    /// <summary>
    /// set for all format 0 response codes
    /// </summary>
    RC_VER1 = 0x100,
    /// <summary>
    /// TPM not initialized by TPM2_Startup or already initialized
    /// </summary>
    INITIALIZE = UINT32(TPM_RC::RC_VER1) + 0x000,
    /// <summary>
    /// commands not being accepted because of a TPM failure
    /// NOTE	This may be returned by TPM2_GetTestResult() as the testResult parameter.
    /// </summary>
    FAILURE = UINT32(TPM_RC::RC_VER1) + 0x001,
    /// <summary>
    /// improper use of a sequence handle
    /// </summary>
    SEQUENCE = UINT32(TPM_RC::RC_VER1) + 0x003,
    /// <summary>
    /// not currently used
    /// </summary>
    PRIVATE = UINT32(TPM_RC::RC_VER1) + 0x00B,
    /// <summary>
    /// not currently used
    /// </summary>
    HMAC = UINT32(TPM_RC::RC_VER1) + 0x019,
    /// <summary>
    /// the command is disabled
    /// </summary>
    DISABLED = UINT32(TPM_RC::RC_VER1) + 0x020,
    /// <summary>
    /// command failed because audit sequence required exclusivity
    /// </summary>
    EXCLUSIVE = UINT32(TPM_RC::RC_VER1) + 0x021,
    /// <summary>
    /// authorization handle is not correct for command
    /// </summary>
    AUTH_TYPE = UINT32(TPM_RC::RC_VER1) + 0x024,
    /// <summary>
    /// command requires an authorization session for handle and it is not present.
    /// </summary>
    AUTH_MISSING = UINT32(TPM_RC::RC_VER1) + 0x025,
    /// <summary>
    /// policy failure in math operation or an invalid authPolicy value
    /// </summary>
    POLICY = UINT32(TPM_RC::RC_VER1) + 0x026,
    /// <summary>
    /// PCR check fail
    /// </summary>
    PCR = UINT32(TPM_RC::RC_VER1) + 0x027,
    /// <summary>
    /// PCR have changed since checked.
    /// </summary>
    PCR_CHANGED = UINT32(TPM_RC::RC_VER1) + 0x028,
    /// <summary>
    /// for all commands other than TPM2_FieldUpgradeData(), this code indicates that the TPM is in field upgrade mode; for TPM2_FieldUpgradeData(), this code indicates that the TPM is not in field upgrade mode
    /// </summary>
    UPGRADE = UINT32(TPM_RC::RC_VER1) + 0x02D,
    /// <summary>
    /// context ID counter is at maximum.
    /// </summary>
    TOO_MANY_CONTEXTS = UINT32(TPM_RC::RC_VER1) + 0x02E,
    /// <summary>
    /// authValue or authPolicy is not available for selected entity.
    /// </summary>
    AUTH_UNAVAILABLE = UINT32(TPM_RC::RC_VER1) + 0x02F,
    /// <summary>
    /// a _TPM_Init and Startup(CLEAR) is required before the TPM can resume operation.
    /// </summary>
    REBOOT = UINT32(TPM_RC::RC_VER1) + 0x030,
    /// <summary>
    /// the protection algorithms (hash and symmetric) are not reasonably balanced. The digest size of the hash must be larger than the key size of the symmetric algorithm.
    /// </summary>
    UNBALANCED = UINT32(TPM_RC::RC_VER1) + 0x031,
    /// <summary>
    /// command commandSize value is inconsistent with contents of the command buffer; either the size is not the same as the octets loaded by the hardware interface layer or the value is not large enough to hold a command header
    /// </summary>
    COMMAND_SIZE = UINT32(TPM_RC::RC_VER1) + 0x042,
    /// <summary>
    /// command code not supported
    /// </summary>
    COMMAND_CODE = UINT32(TPM_RC::RC_VER1) + 0x043,
    /// <summary>
    /// the value of authorizationSize is out of range or the number of octets in the Authorization Area is greater than required
    /// </summary>
    AUTHSIZE = UINT32(TPM_RC::RC_VER1) + 0x044,
    /// <summary>
    /// use of an authorization session with a context command or another command that cannot have an authorization session.
    /// </summary>
    AUTH_CONTEXT = UINT32(TPM_RC::RC_VER1) + 0x045,
    /// <summary>
    /// NV offset+size is out of range.
    /// </summary>
    NV_RANGE = UINT32(TPM_RC::RC_VER1) + 0x046,
    /// <summary>
    /// Requested allocation size is larger than allowed.
    /// </summary>
    NV_SIZE = UINT32(TPM_RC::RC_VER1) + 0x047,
    /// <summary>
    /// NV access locked.
    /// </summary>
    NV_LOCKED = UINT32(TPM_RC::RC_VER1) + 0x048,
    /// <summary>
    /// NV access authorization fails in command actions (this failure does not affect lockout.action)
    /// </summary>
    NV_AUTHORIZATION = UINT32(TPM_RC::RC_VER1) + 0x049,
    /// <summary>
    /// an NV Index is used before being initialized or the state saved by TPM2_Shutdown(STATE) could not be restored
    /// </summary>
    NV_UNINITIALIZED = UINT32(TPM_RC::RC_VER1) + 0x04A,
    /// <summary>
    /// insufficient space for NV allocation
    /// </summary>
    NV_SPACE = UINT32(TPM_RC::RC_VER1) + 0x04B,
    /// <summary>
    /// NV Index or persistent object already defined
    /// </summary>
    NV_DEFINED = UINT32(TPM_RC::RC_VER1) + 0x04C,
    /// <summary>
    /// context in TPM2_ContextLoad() is not valid
    /// </summary>
    BAD_CONTEXT = UINT32(TPM_RC::RC_VER1) + 0x050,
    /// <summary>
    /// cpHash value already set or not correct for use
    /// </summary>
    CPHASH = UINT32(TPM_RC::RC_VER1) + 0x051,
    /// <summary>
    /// handle for parent is not a valid parent
    /// </summary>
    PARENT = UINT32(TPM_RC::RC_VER1) + 0x052,
    /// <summary>
    /// some function needs testing.
    /// </summary>
    NEEDS_TEST = UINT32(TPM_RC::RC_VER1) + 0x053,
    /// <summary>
    /// returned when an internal function cannot process a request due to an unspecified problem. This code is usually related to invalid parameters that are not properly filtered by the input unmarshaling code.
    /// </summary>
    NO_RESULT = UINT32(TPM_RC::RC_VER1) + 0x054,
    /// <summary>
    /// the sensitive area did not unmarshal correctly after decryption  this code is used in lieu of the other unmarshaling errors so that an attacker cannot determine where the unmarshaling error occurred
    /// </summary>
    SENSITIVE = UINT32(TPM_RC::RC_VER1) + 0x055,
    /// <summary>
    /// largest version 1 code that is not a warning
    /// </summary>
    RC_MAX_FM0 = UINT32(TPM_RC::RC_VER1) + 0x07F,
    /// <summary>
    /// This bit is SET in all format 1 response codes
    /// The codes in this group may have a value added to them to indicate the handle, session, or parameter to which they apply.
    /// </summary>
    RC_FMT1 = 0x080,
    /// <summary>
    /// asymmetric algorithm not supported or not correct
    /// </summary>
    ASYMMETRIC = UINT32(TPM_RC::RC_FMT1) + 0x001,
    /// <summary>
    /// inconsistent attributes
    /// </summary>
    ATTRIBUTES = UINT32(TPM_RC::RC_FMT1) + 0x002,
    /// <summary>
    /// hash algorithm not supported or not appropriate
    /// </summary>
    HASH = UINT32(TPM_RC::RC_FMT1) + 0x003,
    /// <summary>
    /// value is out of range or is not correct for the context
    /// </summary>
    VALUE = UINT32(TPM_RC::RC_FMT1) + 0x004,
    /// <summary>
    /// hierarchy is not enabled or is not correct for the use
    /// </summary>
    HIERARCHY = UINT32(TPM_RC::RC_FMT1) + 0x005,
    /// <summary>
    /// key size is not supported
    /// </summary>
    KEY_SIZE = UINT32(TPM_RC::RC_FMT1) + 0x007,
    /// <summary>
    /// mask generation function not supported
    /// </summary>
    MGF = UINT32(TPM_RC::RC_FMT1) + 0x008,
    /// <summary>
    /// mode of operation not supported
    /// </summary>
    MODE = UINT32(TPM_RC::RC_FMT1) + 0x009,
    /// <summary>
    /// the type of the value is not appropriate for the use
    /// </summary>
    TYPE = UINT32(TPM_RC::RC_FMT1) + 0x00A,
    /// <summary>
    /// the handle is not correct for the use
    /// </summary>
    HANDLE = UINT32(TPM_RC::RC_FMT1) + 0x00B,
    /// <summary>
    /// unsupported key derivation function or function not appropriate for use
    /// </summary>
    KDF = UINT32(TPM_RC::RC_FMT1) + 0x00C,
    /// <summary>
    /// value was out of allowed range.
    /// </summary>
    RANGE = UINT32(TPM_RC::RC_FMT1) + 0x00D,
    /// <summary>
    /// the authorization HMAC check failed and DA counter incremented
    /// </summary>
    AUTH_FAIL = UINT32(TPM_RC::RC_FMT1) + 0x00E,
    /// <summary>
    /// invalid nonce size or nonce value mismatch
    /// </summary>
    NONCE = UINT32(TPM_RC::RC_FMT1) + 0x00F,
    /// <summary>
    /// authorization requires assertion of PP
    /// </summary>
    PP = UINT32(TPM_RC::RC_FMT1) + 0x010,
    /// <summary>
    /// unsupported or incompatible scheme
    /// </summary>
    SCHEME = UINT32(TPM_RC::RC_FMT1) + 0x012,
    /// <summary>
    /// structure is the wrong size
    /// </summary>
    SIZE = UINT32(TPM_RC::RC_FMT1) + 0x015,
    /// <summary>
    /// unsupported symmetric algorithm or key size, or not appropriate for instance
    /// </summary>
    SYMMETRIC = UINT32(TPM_RC::RC_FMT1) + 0x016,
    /// <summary>
    /// incorrect structure tag
    /// </summary>
    TAG = UINT32(TPM_RC::RC_FMT1) + 0x017,
    /// <summary>
    /// union selector is incorrect
    /// </summary>
    SELECTOR = UINT32(TPM_RC::RC_FMT1) + 0x018,
    /// <summary>
    /// the TPM was unable to unmarshal a value because there were not enough octets in the input buffer
    /// </summary>
    INSUFFICIENT = UINT32(TPM_RC::RC_FMT1) + 0x01A,
    /// <summary>
    /// the signature is not valid
    /// </summary>
    SIGNATURE = UINT32(TPM_RC::RC_FMT1) + 0x01B,
    /// <summary>
    /// key fields are not compatible with the selected use
    /// </summary>
    KEY = UINT32(TPM_RC::RC_FMT1) + 0x01C,
    /// <summary>
    /// a policy check failed
    /// </summary>
    POLICY_FAIL = UINT32(TPM_RC::RC_FMT1) + 0x01D,
    /// <summary>
    /// integrity check failed
    /// </summary>
    INTEGRITY = UINT32(TPM_RC::RC_FMT1) + 0x01F,
    /// <summary>
    /// invalid ticket
    /// </summary>
    TICKET = UINT32(TPM_RC::RC_FMT1) + 0x020,
    /// <summary>
    /// authorization failure without DA implications
    /// </summary>
    BAD_AUTH = UINT32(TPM_RC::RC_FMT1) + 0x022,
    /// <summary>
    /// the policy has expired
    /// </summary>
    EXPIRED = UINT32(TPM_RC::RC_FMT1) + 0x023,
    /// <summary>
    /// the commandCode in the policy is not the commandCode of the command or the command code in a policy command references a command that is not implemented
    /// </summary>
    POLICY_CC = UINT32(TPM_RC::RC_FMT1) + 0x024,
    /// <summary>
    /// public and sensitive portions of an object are not cryptographically bound
    /// </summary>
    BINDING = UINT32(TPM_RC::RC_FMT1) + 0x025,
    /// <summary>
    /// curve not supported
    /// </summary>
    CURVE = UINT32(TPM_RC::RC_FMT1) + 0x026,
    /// <summary>
    /// point is not on the required curve.
    /// </summary>
    ECC_POINT = UINT32(TPM_RC::RC_FMT1) + 0x027,
    /// <summary>
    /// set for warning response codes
    /// </summary>
    RC_WARN = 0x900,
    /// <summary>
    /// gap for context ID is too large
    /// </summary>
    CONTEXT_GAP = UINT32(TPM_RC::RC_WARN) + 0x001,
    /// <summary>
    /// out of memory for object contexts
    /// </summary>
    OBJECT_MEMORY = UINT32(TPM_RC::RC_WARN) + 0x002,
    /// <summary>
    /// out of memory for session contexts
    /// </summary>
    SESSION_MEMORY = UINT32(TPM_RC::RC_WARN) + 0x003,
    /// <summary>
    /// out of shared object/session memory or need space for internal operations
    /// </summary>
    MEMORY = UINT32(TPM_RC::RC_WARN) + 0x004,
    /// <summary>
    /// out of session handles  a session must be flushed before a new session may be created
    /// </summary>
    SESSION_HANDLES = UINT32(TPM_RC::RC_WARN) + 0x005,
    /// <summary>
    /// out of object handles  the handle space for objects is depleted and a reboot is required
    /// NOTE 1	This cannot occur on the reference implementation.
    /// NOTE 2	There is no reason why an implementation would implement a design that would deplete handle space. Platform specifications are encouraged to forbid it.
    /// </summary>
    OBJECT_HANDLES = UINT32(TPM_RC::RC_WARN) + 0x006,
    /// <summary>
    /// bad locality
    /// </summary>
    LOCALITY = UINT32(TPM_RC::RC_WARN) + 0x007,
    /// <summary>
    /// the TPM has suspended operation on the command; forward progress was made and the command may be retried
    /// See TPM 2.0 Part 1, Multi-tasking.
    /// NOTE	This cannot occur on the reference implementation.
    /// </summary>
    YIELDED = UINT32(TPM_RC::RC_WARN) + 0x008,
    /// <summary>
    /// the command was canceled
    /// </summary>
    CANCELED = UINT32(TPM_RC::RC_WARN) + 0x009,
    /// <summary>
    /// TPM is performing self-tests
    /// </summary>
    TESTING = UINT32(TPM_RC::RC_WARN) + 0x00A,
    /// <summary>
    /// the 1st handle in the handle area references a transient object or session that is not loaded
    /// </summary>
    REFERENCE_H0 = UINT32(TPM_RC::RC_WARN) + 0x010,
    /// <summary>
    /// the 2nd handle in the handle area references a transient object or session that is not loaded
    /// </summary>
    REFERENCE_H1 = UINT32(TPM_RC::RC_WARN) + 0x011,
    /// <summary>
    /// the 3rd handle in the handle area references a transient object or session that is not loaded
    /// </summary>
    REFERENCE_H2 = UINT32(TPM_RC::RC_WARN) + 0x012,
    /// <summary>
    /// the 4th handle in the handle area references a transient object or session that is not loaded
    /// </summary>
    REFERENCE_H3 = UINT32(TPM_RC::RC_WARN) + 0x013,
    /// <summary>
    /// the 5th handle in the handle area references a transient object or session that is not loaded
    /// </summary>
    REFERENCE_H4 = UINT32(TPM_RC::RC_WARN) + 0x014,
    /// <summary>
    /// the 6th handle in the handle area references a transient object or session that is not loaded
    /// </summary>
    REFERENCE_H5 = UINT32(TPM_RC::RC_WARN) + 0x015,
    /// <summary>
    /// the 7th handle in the handle area references a transient object or session that is not loaded
    /// </summary>
    REFERENCE_H6 = UINT32(TPM_RC::RC_WARN) + 0x016,
    /// <summary>
    /// the 1st authorization session handle references a session that is not loaded
    /// </summary>
    REFERENCE_S0 = UINT32(TPM_RC::RC_WARN) + 0x018,
    /// <summary>
    /// the 2nd authorization session handle references a session that is not loaded
    /// </summary>
    REFERENCE_S1 = UINT32(TPM_RC::RC_WARN) + 0x019,
    /// <summary>
    /// the 3rd authorization session handle references a session that is not loaded
    /// </summary>
    REFERENCE_S2 = UINT32(TPM_RC::RC_WARN) + 0x01A,
    /// <summary>
    /// the 4th authorization session handle references a session that is not loaded
    /// </summary>
    REFERENCE_S3 = UINT32(TPM_RC::RC_WARN) + 0x01B,
    /// <summary>
    /// the 5th session handle references a session that is not loaded
    /// </summary>
    REFERENCE_S4 = UINT32(TPM_RC::RC_WARN) + 0x01C,
    /// <summary>
    /// the 6th session handle references a session that is not loaded
    /// </summary>
    REFERENCE_S5 = UINT32(TPM_RC::RC_WARN) + 0x01D,
    /// <summary>
    /// the 7th authorization session handle references a session that is not loaded
    /// </summary>
    REFERENCE_S6 = UINT32(TPM_RC::RC_WARN) + 0x01E,
    /// <summary>
    /// the TPM is rate-limiting accesses to prevent wearout of NV
    /// </summary>
    NV_RATE = UINT32(TPM_RC::RC_WARN) + 0x020,
    /// <summary>
    /// authorizations for objects subject to DA protection are not allowed at this time because the TPM is in DA lockout mode
    /// </summary>
    LOCKOUT = UINT32(TPM_RC::RC_WARN) + 0x021,
    /// <summary>
    /// the TPM was not able to start the command
    /// </summary>
    RETRY = UINT32(TPM_RC::RC_WARN) + 0x022,
    /// <summary>
    /// the command may require writing of NV and NV is not current accessible
    /// </summary>
    NV_UNAVAILABLE = UINT32(TPM_RC::RC_WARN) + 0x023,
    /// <summary>
    /// this value is reserved and shall not be returned by the TPM
    /// </summary>
    NOT_USED = UINT32(TPM_RC::RC_WARN) + 0x7F,
    /// <summary>
    /// add to a handle-related error
    /// </summary>
    H = 0x000,
    /// <summary>
    /// add to a parameter-related error
    /// </summary>
    P = 0x040,
    /// <summary>
    /// add to a session-related error
    /// </summary>
    S = 0x800,
    /// <summary>
    /// add to a parameter-, handle-, or session-related error
    /// </summary>
    _1 = 0x100,
    /// <summary>
    /// add to a parameter-, handle-, or session-related error
    /// </summary>
    _2 = 0x200,
    /// <summary>
    /// add to a parameter-, handle-, or session-related error
    /// </summary>
    _3 = 0x300,
    /// <summary>
    /// add to a parameter-, handle-, or session-related error
    /// </summary>
    _4 = 0x400,
    /// <summary>
    /// add to a parameter-, handle-, or session-related error
    /// </summary>
    _5 = 0x500,
    /// <summary>
    /// add to a parameter-, handle-, or session-related error
    /// </summary>
    _6 = 0x600,
    /// <summary>
    /// add to a parameter-, handle-, or session-related error
    /// </summary>
    _7 = 0x700,
    /// <summary>
    /// add to a parameter-related error
    /// </summary>
    _8 = 0x800,
    /// <summary>
    /// add to a parameter-related error
    /// </summary>
    _9 = 0x900,
    /// <summary>
    /// add to a parameter-related error
    /// </summary>
    A = 0xA00,
    /// <summary>
    /// add to a parameter-related error
    /// </summary>
    B = 0xB00,
    /// <summary>
    /// add to a parameter-related error
    /// </summary>
    C = 0xC00,
    /// <summary>
    /// add to a parameter-related error
    /// </summary>
    D = 0xD00,
    /// <summary>
    /// add to a parameter-related error
    /// </summary>
    E = 0xE00,
    /// <summary>
    /// add to a parameter-related error
    /// </summary>
    F = 0xF00,
    /// <summary>
    /// number mask
    /// </summary>
    N_MASK = 0xF00,
    /// <summary>
    /// Response buffer returned by the TPM is too short
    /// </summary>
    TSS_TCP_BAD_HANDSHAKE_RESP = 0x40280001,
    /// <summary>
    /// Too old TCP server version
    /// </summary>
    TSS_TCP_SERVER_TOO_OLD = 0x40280002,
    /// <summary>
    /// Bad ack from the TCP end point
    /// </summary>
    TSS_TCP_BAD_ACK = 0x40280003,
    /// <summary>
    /// Wrong length of the response buffer returned by the TPM
    /// </summary>
    TSS_TCP_BAD_RESP_LEN = 0x40280004,
    /// <summary>
    /// TPM2_Startup returned unexpected response code
    /// </summary>
    TSS_TCP_UNEXPECTED_STARTUP_RESP = 0x40280005,
    /// <summary>
    /// Invalid size tag in the TPM response TCP packet
    /// </summary>
    TSS_TCP_INVALID_SIZE_TAG = 0x40280006,
    /// <summary>
    /// TPM over TCP device is not connected
    /// </summary>
    TSS_TCP_DISCONNECTED = 0x40280007,
    /// <summary>
    /// General TPM command dispatch failure
    /// </summary>
    TSS_DISPATCH_FAILED = 0x40280010,
    /// <summary>
    /// Sending data to TPM failed
    /// </summary>
    TSS_SEND_OP_FAILED = 0x40280011,
    /// <summary>
    /// Response buffer returned by the TPM is too short
    /// </summary>
    TSS_RESP_BUF_TOO_SHORT = 0x40280021,
    /// <summary>
    /// Invalid tag in the response buffer returned by the TPM
    /// </summary>
    TSS_RESP_BUF_INVALID_SESSION_TAG = 0x40280022,
    /// <summary>
    /// Windows TBS error TPM_E_COMMAND_BLOCKED
    /// </summary>
    TBS_COMMAND_BLOCKED = 0x80280400,
    /// <summary>
    /// Windows TBS error TPM_E_INVALID_HANDLE
    /// </summary>
    TBS_INVALID_HANDLE = 0x80280401,
    /// <summary>
    /// Windows TBS error TPM_E_DUPLICATE_VHANDLE
    /// </summary>
    TBS_DUPLICATE_V_HANDLE = 0x80280402,
    /// <summary>
    /// Windows TBS error TPM_E_EMBEDDED_COMMAND_BLOCKED
    /// </summary>
    TBS_EMBEDDED_COMMAND_BLOCKED = 0x80280403,
    /// <summary>
    /// Windows TBS error TPM_E_EMBEDDED_COMMAND_UNSUPPORTED
    /// </summary>
    TBS_EMBEDDED_COMMAND_UNSUPPORTED = 0x80280404,
    /// <summary>
    /// Windows TBS returned success but empty response buffer
    /// </summary>
    TBS_UNKNOWN_ERROR = 0x80284000,
    /// <summary>
    /// Windows TBS error TBS_E_INTERNAL_ERROR
    /// </summary>
    TBS_INTERNAL_ERROR = 0x80284001,
    /// <summary>
    /// Windows TBS error TBS_E_BAD_PARAMETER
    /// </summary>
    TBS_BAD_PARAMETER = 0x80284002,
    /// <summary>
    /// Windows TBS error TBS_E_INVALID_OUTPUT_POINTER
    /// </summary>
    TBS_INVALID_OUTPUT_POINTER = 0x80284003,
    /// <summary>
    /// Windows TBS error TBS_E_INVALID_CONTEXT
    /// </summary>
    TBS_INVALID_CONTEXT = 0x80284004,
    /// <summary>
    /// Windows TBS error TBS_E_INSUFFICIENT_BUFFER
    /// </summary>
    TBS_INSUFFICIENT_BUFFER = 0x80284005,
    /// <summary>
    /// Windows TBS error TBS_E_IOERROR
    /// </summary>
    TBS_IO_ERROR = 0x80284006,
    /// <summary>
    /// Windows TBS error TBS_E_INVALID_CONTEXT_PARAM
    /// </summary>
    TBS_INVALID_CONTEXT_PARAM = 0x80284007,
    /// <summary>
    /// Windows TBS error TBS_E_SERVICE_NOT_RUNNING
    /// </summary>
    TBS_SERVICE_NOT_RUNNING = 0x80284008,
    /// <summary>
    /// Windows TBS error TBS_E_TOO_MANY_TBS_CONTEXTS
    /// </summary>
    TBS_TOO_MANY_CONTEXTS = 0x80284009,
    /// <summary>
    /// Windows TBS error TBS_E_TOO_MANY_TBS_RESOURCES
    /// </summary>
    TBS_TOO_MANY_RESOURCES = 0x8028400A,
    /// <summary>
    /// Windows TBS error TBS_E_SERVICE_START_PENDING
    /// </summary>
    TBS_SERVICE_START_PENDING = 0x8028400B,
    /// <summary>
    /// Windows TBS error TBS_E_PPI_NOT_SUPPORTED
    /// </summary>
    TBS_PPI_NOT_SUPPORTED = 0x8028400C,
    /// <summary>
    /// Windows TBS error TBS_E_COMMAND_CANCELED
    /// </summary>
    TBS_COMMAND_CANCELED = 0x8028400D,
    /// <summary>
    /// Windows TBS error TBS_E_BUFFER_TOO_LARGE
    /// </summary>
    TBS_BUFFER_TOO_LARGE = 0x8028400E,
    /// <summary>
    /// Windows TBS error TBS_E_TPM_NOT_FOUND
    /// </summary>
    TBS_NOT_FOUND = 0x8028400F,
    /// <summary>
    /// Windows TBS error TBS_E_SERVICE_DISABLED
    /// </summary>
    TBS_SERVICE_DISABLED = 0x80284010,
    /// <summary>
    /// Windows TBS error TBS_E_ACCESS_DENIED
    /// </summary>
    TBS_ACCESS_DENIED = 0x80284012,
    /// <summary>
    /// Windows TBS error TBS_E_PPI_FUNCTION_UNSUPPORTED
    /// </summary>
    TBS_PPI_FUNCTION_NOT_SUPPORTED = 0x80284014,
    /// <summary>
    /// Windows TBS error TBS_E_OWNERAUTH_NOT_FOUND
    /// </summary>
    TBS_OWNER_AUTH_NOT_FOUND = 0x80284015
};
/// <summary>
/// A TPM_CLOCK_ADJUST value is used to change the rate at which the TPM internal oscillator is divided. A change to the divider will change the rate at which Clock and Time change.
/// </summary>
enum class TPM_CLOCK_ADJUST : char
{
    /// <summary>
    /// Slow the Clock update rate by one coarse adjustment step.
    /// </summary>
    COARSE_SLOWER = static_cast<char>(-3),
    /// <summary>
    /// Slow the Clock update rate by one medium adjustment step.
    /// </summary>
    MEDIUM_SLOWER = static_cast<char>(-2),
    /// <summary>
    /// Slow the Clock update rate by one fine adjustment step.
    /// </summary>
    FINE_SLOWER = static_cast<char>(-1),
    /// <summary>
    /// No change to the Clock update rate.
    /// </summary>
    NO_CHANGE = static_cast<char>(0),
    /// <summary>
    /// Speed the Clock update rate by one fine adjustment step.
    /// </summary>
    FINE_FASTER = static_cast<char>(1),
    /// <summary>
    /// Speed the Clock update rate by one medium adjustment step.
    /// </summary>
    MEDIUM_FASTER = static_cast<char>(2),
    /// <summary>
    /// Speed the Clock update rate by one coarse adjustment step.
    /// </summary>
    COARSE_FASTER = static_cast<char>(3)
};
/// <summary>
/// Table 18  Definition of (UINT16) TPM_EO Constants <IN/OUT>
/// </summary>
enum class TPM_EO : UINT16
{
    /// <summary>
    /// A = B
    /// </summary>
    EQ = 0x0000,
    /// <summary>
    /// A  B
    /// </summary>
    NEQ = 0x0001,
    /// <summary>
    /// A > B signed
    /// </summary>
    SIGNED_GT = 0x0002,
    /// <summary>
    /// A > B unsigned
    /// </summary>
    UNSIGNED_GT = 0x0003,
    /// <summary>
    /// A < B signed
    /// </summary>
    SIGNED_LT = 0x0004,
    /// <summary>
    /// A < B unsigned
    /// </summary>
    UNSIGNED_LT = 0x0005,
    /// <summary>
    /// A  B signed
    /// </summary>
    SIGNED_GE = 0x0006,
    /// <summary>
    /// A  B unsigned
    /// </summary>
    UNSIGNED_GE = 0x0007,
    /// <summary>
    /// A  B signed
    /// </summary>
    SIGNED_LE = 0x0008,
    /// <summary>
    /// A  B unsigned
    /// </summary>
    UNSIGNED_LE = 0x0009,
    /// <summary>
    /// All bits SET in B are SET in A. ((A&B)=B)
    /// </summary>
    BITSET = 0x000A,
    /// <summary>
    /// All bits SET in B are CLEAR in A. ((A&B)=0)
    /// </summary>
    BITCLEAR = 0x000B
};
/// <summary>
/// Structure tags are used to disambiguate structures. They are 16-bit values with the most significant bit SET so that they do not overlap TPM_ALG_ID values. A single exception is made for the value associated with TPM_ST_RSP_COMMAND (0x00C4), which has the same value as the TPM_TAG_RSP_COMMAND tag from earlier versions of this specification. This value is used when the TPM is compatible with a previous TPM specification and the TPM cannot determine which family of response code to return because the command tag is not valid.
/// </summary>
enum class TPM_ST : UINT16
{
    /// <summary>
    /// tag value for a response; used when there is an error in the tag. This is also the value returned from a TPM 1.2 when an error occurs. This value is used in this specification because an error in the command tag may prevent determination of the family. When this tag is used in the response, the response code will be TPM_RC_BAD_TAG (0 1E16), which has the same numeric value as the TPM 1.2 response code for TPM_BADTAG.
    /// NOTE	In a previously published version of this specification, TPM_RC_BAD_TAG was incorrectly assigned a value of 0x030 instead of 30 (0x01e). Some implementations my return the old value instead of the new value.
    /// </summary>
    RSP_COMMAND = 0x00C4,
    /// <summary>
    /// no structure type specified
    /// </summary>
    _NULL = 0X8000,
    /// <summary>
    /// tag value for a command/response for a command defined in this specification; indicating that the command/response has no attached sessions and no authorizationSize/parameterSize value is present
    /// If the responseCode from the TPM is not TPM_RC_SUCCESS, then the response tag shall have this value.
    /// </summary>
    NO_SESSIONS = 0x8001,
    /// <summary>
    /// tag value for a command/response for a command defined in this specification; indicating that the command/response has one or more attached sessions and the authorizationSize/parameterSize field is present
    /// </summary>
    SESSIONS = 0x8002,
    /// <summary>
    /// tag for an attestation structure
    /// </summary>
    ATTEST_NV = 0x8014,
    /// <summary>
    /// tag for an attestation structure
    /// </summary>
    ATTEST_COMMAND_AUDIT = 0x8015,
    /// <summary>
    /// tag for an attestation structure
    /// </summary>
    ATTEST_SESSION_AUDIT = 0x8016,
    /// <summary>
    /// tag for an attestation structure
    /// </summary>
    ATTEST_CERTIFY = 0x8017,
    /// <summary>
    /// tag for an attestation structure
    /// </summary>
    ATTEST_QUOTE = 0x8018,
    /// <summary>
    /// tag for an attestation structure
    /// </summary>
    ATTEST_TIME = 0x8019,
    /// <summary>
    /// tag for an attestation structure
    /// </summary>
    ATTEST_CREATION = 0x801A,
    /// <summary>
    /// tag for an attestation structure
    /// </summary>
    ATTEST_NV_DIGEST = 0x801C,
    /// <summary>
    /// tag for a ticket type
    /// </summary>
    CREATION = 0x8021,
    /// <summary>
    /// tag for a ticket type
    /// </summary>
    VERIFIED = 0x8022,
    /// <summary>
    /// tag for a ticket type
    /// </summary>
    AUTH_SECRET = 0x8023,
    /// <summary>
    /// tag for a ticket type
    /// </summary>
    HASHCHECK = 0x8024,
    /// <summary>
    /// tag for a ticket type
    /// </summary>
    AUTH_SIGNED = 0x8025,
    /// <summary>
    /// tag for a structure describing a Field Upgrade Policy
    /// </summary>
    FU_MANIFEST = 0x8029
};
/// <summary>
/// These values are used in TPM2_Startup() to indicate the shutdown and startup mode. The defined startup sequences are:
/// </summary>
enum class TPM_SU : UINT16
{
    /// <summary>
    /// on TPM2_Shutdown(), indicates that the TPM should prepare for loss of power and save state required for an orderly startup (TPM Reset).
    /// on TPM2_Startup(), indicates that the TPM should perform TPM Reset or TPM Restart
    /// </summary>
    CLEAR = 0x0000,
    /// <summary>
    /// on TPM2_Shutdown(), indicates that the TPM should prepare for loss of power and save state required for an orderly startup (TPM Restart or TPM Resume)
    /// on TPM2_Startup(), indicates that the TPM should restore the state saved by TPM2_Shutdown(TPM_SU_STATE)
    /// </summary>
    STATE = 0x0001
};
/// <summary>
/// This type is used in TPM2_StartAuthSession() to indicate the type of the session to be created.
/// </summary>
enum class TPM_SE : byte
{
    HMAC = 0x00,
    POLICY = 0x01,
    /// <summary>
    /// The policy session is being used to compute the policyHash and not for command authorization.
    /// This setting modifies some policy commands and prevents session from being used to authorize a command.
    /// </summary>
    TRIAL = 0x03
};
/// <summary>
/// The TPM_CAP values are used in TPM2_GetCapability() to select the type of the value to be returned. The format of the response varies according to the type of the value.
/// </summary>
enum class TPM_CAP : UINT32
{
    FIRST = 0x00000000,
    /// <summary>
    /// TPML_ALG_PROPERTY
    /// </summary>
    ALGS = 0x00000000,
    /// <summary>
    /// TPML_HANDLE
    /// </summary>
    HANDLES = 0x00000001,
    /// <summary>
    /// TPML_CCA
    /// </summary>
    COMMANDS = 0x00000002,
    /// <summary>
    /// TPML_CC
    /// </summary>
    PP_COMMANDS = 0x00000003,
    /// <summary>
    /// TPML_CC
    /// </summary>
    AUDIT_COMMANDS = 0x00000004,
    /// <summary>
    /// TPML_PCR_SELECTION
    /// </summary>
    PCRS = 0x00000005,
    /// <summary>
    /// TPML_TAGGED_TPM_PROPERTY
    /// </summary>
    TPM_PROPERTIES = 0x00000006,
    /// <summary>
    /// TPML_TAGGED_PCR_PROPERTY
    /// </summary>
    PCR_PROPERTIES = 0x00000007,
    /// <summary>
    /// TPML_ECC_CURVE
    /// </summary>
    ECC_CURVES = 0x00000008,
    /// <summary>
    /// TPML_TAGGED_POLICY
    /// </summary>
    AUTH_POLICIES = 0x00000009,
    LAST = 0x00000009,
    /// <summary>
    /// manufacturer-specific values
    /// </summary>
    VENDOR_PROPERTY = 0x00000100
};
/// <summary>
/// The TPM_PT constants are used in TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES) to indicate the property being selected or returned.
/// </summary>
enum class TPM_PT : UINT32
{
    /// <summary>
    /// indicates no property type
    /// </summary>
    NONE = 0x00000000,
    /// <summary>
    /// The number of properties in each group.
    /// NOTE The first group with any properties is group 1 (PT_GROUP * 1). Group 0 is reserved.
    /// </summary>
    PT_GROUP = 0x00000100,
    /// <summary>
    /// the group of fixed properties returned as TPMS_TAGGED_PROPERTY
    /// The values in this group are only changed due to a firmware change in the TPM.
    /// </summary>
    PT_FIXED = UINT32(TPM_PT::PT_GROUP) * 1,
    /// <summary>
    /// a 4-octet character string containing the TPM Family value (TPM_SPEC_FAMILY)
    /// </summary>
    FAMILY_INDICATOR = UINT32(TPM_PT::PT_FIXED) + 0,
    /// <summary>
    /// the level of the specification
    /// NOTE 1	For this specification, the level is zero.
    /// NOTE 2	The level is on the title page of the specification.
    /// </summary>
    LEVEL = UINT32(TPM_PT::PT_FIXED) + 1,
    /// <summary>
    /// the specification Revision times 100
    /// EXAMPLE	Revision 01.01 would have a value of 101.
    /// NOTE	The Revision value is on the title page of the specification.
    /// </summary>
    REVISION = UINT32(TPM_PT::PT_FIXED) + 2,
    /// <summary>
    /// the specification day of year using TCG calendar
    /// EXAMPLE	November 15, 2010, has a day of year value of 319 (0000013F16).
    /// NOTE The specification date is on the title page of the specification or errata (see 6.1).
    /// </summary>
    DAY_OF_YEAR = UINT32(TPM_PT::PT_FIXED) + 3,
    /// <summary>
    /// the specification year using the CE
    /// EXAMPLE	The year 2010 has a value of 000007DA16.
    /// NOTE The specification date is on the title page of the specification or errata (see 6.1).
    /// </summary>
    YEAR = UINT32(TPM_PT::PT_FIXED) + 4,
    /// <summary>
    /// the vendor ID unique to each TPM manufacturer
    /// </summary>
    MANUFACTURER = UINT32(TPM_PT::PT_FIXED) + 5,
    /// <summary>
    /// the first four characters of the vendor ID string
    /// NOTE	When the vendor string is fewer than 16 octets, the additional property values do not have to be present. A vendor string of 4 octets can be represented in one 32-bit value and no null terminating character is required.
    /// </summary>
    VENDOR_STRING_1 = UINT32(TPM_PT::PT_FIXED) + 6,
    /// <summary>
    /// the second four characters of the vendor ID string
    /// </summary>
    VENDOR_STRING_2 = UINT32(TPM_PT::PT_FIXED) + 7,
    /// <summary>
    /// the third four characters of the vendor ID string
    /// </summary>
    VENDOR_STRING_3 = UINT32(TPM_PT::PT_FIXED) + 8,
    /// <summary>
    /// the fourth four characters of the vendor ID sting
    /// </summary>
    VENDOR_STRING_4 = UINT32(TPM_PT::PT_FIXED) + 9,
    /// <summary>
    /// vendor-defined value indicating the TPM model
    /// </summary>
    VENDOR_TPM_TYPE = UINT32(TPM_PT::PT_FIXED) + 10,
    /// <summary>
    /// the most-significant 32 bits of a TPM vendor-specific value indicating the version number of the firmware. See 10.12.2 and 10.12.9.
    /// </summary>
    FIRMWARE_VERSION_1 = UINT32(TPM_PT::PT_FIXED) + 11,
    /// <summary>
    /// the least-significant 32 bits of a TPM vendor-specific value indicating the version number of the firmware. See 10.12.2 and 10.12.9.
    /// </summary>
    FIRMWARE_VERSION_2 = UINT32(TPM_PT::PT_FIXED) + 12,
    /// <summary>
    /// the maximum size of a parameter (typically, a TPM2B_MAX_BUFFER)
    /// </summary>
    INPUT_BUFFER = UINT32(TPM_PT::PT_FIXED) + 13,
    /// <summary>
    /// the minimum number of transient objects that can be held in TPM RAM
    /// NOTE	This minimum shall be no less than the minimum value required by the platform-specific specification to which the TPM is built.
    /// </summary>
    HR_TRANSIENT_MIN = UINT32(TPM_PT::PT_FIXED) + 14,
    /// <summary>
    /// the minimum number of persistent objects that can be held in TPM NV memory
    /// NOTE	This minimum shall be no less than the minimum value required by the platform-specific specification to which the TPM is built.
    /// </summary>
    HR_PERSISTENT_MIN = UINT32(TPM_PT::PT_FIXED) + 15,
    /// <summary>
    /// the minimum number of authorization sessions that can be held in TPM RAM
    /// NOTE	This minimum shall be no less than the minimum value required by the platform-specific specification to which the TPM is built.
    /// </summary>
    HR_LOADED_MIN = UINT32(TPM_PT::PT_FIXED) + 16,
    /// <summary>
    /// the number of authorization sessions that may be active at a time
    /// A session is active when it has a context associated with its handle. The context may either be in TPM RAM or be context saved.
    /// NOTE	This value shall be no less than the minimum value required by the platform-specific specification to which the TPM is built.
    /// </summary>
    ACTIVE_SESSIONS_MAX = UINT32(TPM_PT::PT_FIXED) + 17,
    /// <summary>
    /// the number of PCR implemented
    /// NOTE	This number is determined by the defined attributes, not the number of PCR that are populated.
    /// </summary>
    PCR_COUNT = UINT32(TPM_PT::PT_FIXED) + 18,
    /// <summary>
    /// the minimum number of octets in a TPMS_PCR_SELECT.sizeOfSelect
    /// NOTE	This value is not determined by the number of PCR implemented but by the number of PCR required by the platform-specific specification with which the TPM is compliant or by the implementer if not adhering to a platform-specific specification.
    /// </summary>
    PCR_SELECT_MIN = UINT32(TPM_PT::PT_FIXED) + 19,
    /// <summary>
    /// the maximum allowed difference (unsigned) between the contextID values of two saved session contexts
    /// This value shall be 2n-1, where n is at least 16.
    /// </summary>
    CONTEXT_GAP_MAX = UINT32(TPM_PT::PT_FIXED) + 20,
    /// <summary>
    /// the maximum number of NV Indexes that are allowed to have the TPM_NT_COUNTER attribute
    /// NOTE 1	It is allowed for this value to be larger than the number of NV Indexes that can be defined. This would be indicative of a TPM implementation that did not use different implementation technology for different NV Index types.
    /// NOTE 2 The value zero indicates that there is no fixed maximum. The number of counter indexes is determined by the available NV memory pool.
    /// </summary>
    NV_COUNTERS_MAX = UINT32(TPM_PT::PT_FIXED) + 22,
    /// <summary>
    /// the maximum size of an NV Index data area
    /// </summary>
    NV_INDEX_MAX = UINT32(TPM_PT::PT_FIXED) + 23,
    /// <summary>
    /// a TPMA_MEMORY indicating the memory management method for the TPM
    /// </summary>
    MEMORY = UINT32(TPM_PT::PT_FIXED) + 24,
    /// <summary>
    /// interval, in milliseconds, between updates to the copy of TPMS_CLOCK_INFO.clock in NV
    /// </summary>
    CLOCK_UPDATE = UINT32(TPM_PT::PT_FIXED) + 25,
    /// <summary>
    /// the algorithm used for the integrity HMAC on saved contexts and for hashing the fuData of TPM2_FirmwareRead()
    /// </summary>
    CONTEXT_HASH = UINT32(TPM_PT::PT_FIXED) + 26,
    /// <summary>
    /// TPM_ALG_ID, the algorithm used for encryption of saved contexts
    /// </summary>
    CONTEXT_SYM = UINT32(TPM_PT::PT_FIXED) + 27,
    /// <summary>
    /// TPM_KEY_BITS, the size of the key used for encryption of saved contexts
    /// </summary>
    CONTEXT_SYM_SIZE = UINT32(TPM_PT::PT_FIXED) + 28,
    /// <summary>
    /// the modulus - 1 of the count for NV update of an orderly counter
    /// The returned value is MAX_ORDERLY_COUNT.
    /// This will have a value of 2N  1 where 1  N  32
    /// NOTE 1	An orderly counter is an NV Index with an TPM_NT of TPM_NV_COUNTER and TPMA_NV_ORDERLY SET.
    /// NOTE 2	When the low-order bits of a counter equal this value, an NV write occurs on the next increment.
    /// </summary>
    ORDERLY_COUNT = UINT32(TPM_PT::PT_FIXED) + 29,
    /// <summary>
    /// the maximum value for commandSize in a command
    /// </summary>
    MAX_COMMAND_SIZE = UINT32(TPM_PT::PT_FIXED) + 30,
    /// <summary>
    /// the maximum value for responseSize in a response
    /// </summary>
    MAX_RESPONSE_SIZE = UINT32(TPM_PT::PT_FIXED) + 31,
    /// <summary>
    /// the maximum size of a digest that can be produced by the TPM
    /// </summary>
    MAX_DIGEST = UINT32(TPM_PT::PT_FIXED) + 32,
    /// <summary>
    /// the maximum size of an object context that will be returned by TPM2_ContextSave
    /// </summary>
    MAX_OBJECT_CONTEXT = UINT32(TPM_PT::PT_FIXED) + 33,
    /// <summary>
    /// the maximum size of a session context that will be returned by TPM2_ContextSave
    /// </summary>
    MAX_SESSION_CONTEXT = UINT32(TPM_PT::PT_FIXED) + 34,
    /// <summary>
    /// platform-specific family (a TPM_PS value)(see Table 25)
    /// NOTE	The platform-specific values for the TPM_PT_PS parameters are in the relevant platform-specific specification. In the reference implementation, all of these values are 0.
    /// </summary>
    PS_FAMILY_INDICATOR = UINT32(TPM_PT::PT_FIXED) + 35,
    /// <summary>
    /// the level of the platform-specific specification
    /// </summary>
    PS_LEVEL = UINT32(TPM_PT::PT_FIXED) + 36,
    /// <summary>
    /// a platform specific value
    /// </summary>
    PS_REVISION = UINT32(TPM_PT::PT_FIXED) + 37,
    /// <summary>
    /// the platform-specific TPM specification day of year using TCG calendar
    /// EXAMPLE	November 15, 2010, has a day of year value of 319 (0000013F16).
    /// </summary>
    PS_DAY_OF_YEAR = UINT32(TPM_PT::PT_FIXED) + 38,
    /// <summary>
    /// the platform-specific TPM specification year using the CE
    /// EXAMPLE	The year 2010 has a value of 000007DA16.
    /// </summary>
    PS_YEAR = UINT32(TPM_PT::PT_FIXED) + 39,
    /// <summary>
    /// the number of split signing operations supported by the TPM
    /// </summary>
    SPLIT_MAX = UINT32(TPM_PT::PT_FIXED) + 40,
    /// <summary>
    /// total number of commands implemented in the TPM
    /// </summary>
    TOTAL_COMMANDS = UINT32(TPM_PT::PT_FIXED) + 41,
    /// <summary>
    /// number of commands from the TPM library that are implemented
    /// </summary>
    LIBRARY_COMMANDS = UINT32(TPM_PT::PT_FIXED) + 42,
    /// <summary>
    /// number of vendor commands that are implemented
    /// </summary>
    VENDOR_COMMANDS = UINT32(TPM_PT::PT_FIXED) + 43,
    /// <summary>
    /// the maximum data size in one NV write or NV read command
    /// </summary>
    NV_BUFFER_MAX = UINT32(TPM_PT::PT_FIXED) + 44,
    /// <summary>
    /// a TPMA_MODES value, indicating that the TPM is designed for these modes.
    /// </summary>
    MODES = UINT32(TPM_PT::PT_FIXED) + 45,
    /// <summary>
    /// the maximum size of a TPMS_CAPABILITY_DATA structure returned in TPM2_GetCapability().
    /// </summary>
    MAX_CAP_BUFFER = UINT32(TPM_PT::PT_FIXED) + 46,
    /// <summary>
    /// the group of variable properties returned as TPMS_TAGGED_PROPERTY
    /// The properties in this group change because of a Protected Capability other than a firmware update. The values are not necessarily persistent across all power transitions.
    /// </summary>
    PT_VAR = UINT32(TPM_PT::PT_GROUP) * 2,
    /// <summary>
    /// TPMA_PERMANENT
    /// </summary>
    PERMANENT = UINT32(TPM_PT::PT_VAR) + 0,
    /// <summary>
    /// TPMA_STARTUP_CLEAR
    /// </summary>
    STARTUP_CLEAR = UINT32(TPM_PT::PT_VAR) + 1,
    /// <summary>
    /// the number of NV Indexes currently defined
    /// </summary>
    HR_NV_INDEX = UINT32(TPM_PT::PT_VAR) + 2,
    /// <summary>
    /// the number of authorization sessions currently loaded into TPM RAM
    /// </summary>
    HR_LOADED = UINT32(TPM_PT::PT_VAR) + 3,
    /// <summary>
    /// the number of additional authorization sessions, of any type, that could be loaded into TPM RAM
    /// This value is an estimate. If this value is at least 1, then at least one authorization session of any type may be loaded. Any command that changes the RAM memory allocation can make this estimate invalid.
    /// NOTE	A valid implementation may return 1 even if more than one authorization session would fit into RAM.
    /// </summary>
    HR_LOADED_AVAIL = UINT32(TPM_PT::PT_VAR) + 4,
    /// <summary>
    /// the number of active authorization sessions currently being tracked by the TPM
    /// This is the sum of the loaded and saved sessions.
    /// </summary>
    HR_ACTIVE = UINT32(TPM_PT::PT_VAR) + 5,
    /// <summary>
    /// the number of additional authorization sessions, of any type, that could be created
    /// This value is an estimate. If this value is at least 1, then at least one authorization session of any type may be created. Any command that changes the RAM memory allocation can make this estimate invalid.
    /// NOTE	A valid implementation may return 1 even if more than one authorization session could be created.
    /// </summary>
    HR_ACTIVE_AVAIL = UINT32(TPM_PT::PT_VAR) + 6,
    /// <summary>
    /// estimate of the number of additional transient objects that could be loaded into TPM RAM
    /// This value is an estimate. If this value is at least 1, then at least one object of any type may be loaded. Any command that changes the memory allocation can make this estimate invalid.
    /// NOTE	A valid implementation may return 1 even if more than one transient object would fit into RAM.
    /// </summary>
    HR_TRANSIENT_AVAIL = UINT32(TPM_PT::PT_VAR) + 7,
    /// <summary>
    /// the number of persistent objects currently loaded into TPM NV memory
    /// </summary>
    HR_PERSISTENT = UINT32(TPM_PT::PT_VAR) + 8,
    /// <summary>
    /// the number of additional persistent objects that could be loaded into NV memory
    /// This value is an estimate. If this value is at least 1, then at least one object of any type may be made persistent. Any command that changes the NV memory allocation can make this estimate invalid.
    /// NOTE	A valid implementation may return 1 even if more than one persistent object would fit into NV memory.
    /// </summary>
    HR_PERSISTENT_AVAIL = UINT32(TPM_PT::PT_VAR) + 9,
    /// <summary>
    /// the number of defined NV Indexes that have NV the TPM_NT_COUNTER attribute
    /// </summary>
    NV_COUNTERS = UINT32(TPM_PT::PT_VAR) + 10,
    /// <summary>
    /// the number of additional NV Indexes that can be defined with their TPM_NT of TPM_NV_COUNTER and the TPMA_NV_ORDERLY attribute SET
    /// This value is an estimate. If this value is at least 1, then at least one NV Index may be created with a TPM_NT of TPM_NV_COUNTER and the TPMA_NV_ORDERLY attributes. Any command that changes the NV memory allocation can make this estimate invalid.
    /// NOTE	A valid implementation may return 1 even if more than one NV counter could be defined.
    /// </summary>
    NV_COUNTERS_AVAIL = UINT32(TPM_PT::PT_VAR) + 11,
    /// <summary>
    /// code that limits the algorithms that may be used with the TPM
    /// </summary>
    ALGORITHM_SET = UINT32(TPM_PT::PT_VAR) + 12,
    /// <summary>
    /// the number of loaded ECC curves
    /// </summary>
    LOADED_CURVES = UINT32(TPM_PT::PT_VAR) + 13,
    /// <summary>
    /// the current value of the lockout counter (failedTries)
    /// </summary>
    LOCKOUT_COUNTER = UINT32(TPM_PT::PT_VAR) + 14,
    /// <summary>
    /// the number of authorization failures before DA lockout is invoked
    /// </summary>
    MAX_AUTH_FAIL = UINT32(TPM_PT::PT_VAR) + 15,
    /// <summary>
    /// the number of seconds before the value reported by TPM_PT_LOCKOUT_COUNTER is decremented
    /// </summary>
    LOCKOUT_INTERVAL = UINT32(TPM_PT::PT_VAR) + 16,
    /// <summary>
    /// the number of seconds after a lockoutAuth failure before use of lockoutAuth may be attempted again
    /// </summary>
    LOCKOUT_RECOVERY = UINT32(TPM_PT::PT_VAR) + 17,
    /// <summary>
    /// number of milliseconds before the TPM will accept another command that will modify NV
    /// This value is an approximation and may go up or down over time.
    /// </summary>
    NV_WRITE_RECOVERY = UINT32(TPM_PT::PT_VAR) + 18,
    /// <summary>
    /// the high-order 32 bits of the command audit counter
    /// </summary>
    AUDIT_COUNTER_0 = UINT32(TPM_PT::PT_VAR) + 19,
    /// <summary>
    /// the low-order 32 bits of the command audit counter
    /// </summary>
    AUDIT_COUNTER_1 = UINT32(TPM_PT::PT_VAR) + 20
};
/// <summary>
/// The TPM_PT_PCR constants are used in TPM2_GetCapability() to indicate the property being selected or returned. The PCR properties can be read when capability == TPM_CAP_PCR_PROPERTIES. If there is no property that corresponds to the value of property, the next higher value is returned, if it exists.
/// </summary>
enum class TPM_PT_PCR : UINT32
{
    /// <summary>
    /// bottom of the range of TPM_PT_PCR properties
    /// </summary>
    FIRST = 0x00000000,
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR is saved and restored by TPM_SU_STATE
    /// </summary>
    SAVE = 0x00000000,
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 0
    /// This property is only present if a locality other than 0 is implemented.
    /// </summary>
    EXTEND_L0 = 0x00000001,
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset() from locality 0
    /// </summary>
    RESET_L0 = 0x00000002,
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 1 This property is only present if locality 1 is implemented.
    /// </summary>
    EXTEND_L1 = 0x00000003,
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset() from locality 1
    /// This property is only present if locality 1 is implemented.
    /// </summary>
    RESET_L1 = 0x00000004,
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 2 This property is only present if localities 1 and 2 are implemented.
    /// </summary>
    EXTEND_L2 = 0x00000005,
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset() from locality 2
    /// This property is only present if localities 1 and 2 are implemented.
    /// </summary>
    RESET_L2 = 0x00000006,
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 3
    /// This property is only present if localities 1, 2, and 3 are implemented.
    /// </summary>
    EXTEND_L3 = 0x00000007,
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset() from locality 3
    /// This property is only present if localities 1, 2, and 3 are implemented.
    /// </summary>
    RESET_L3 = 0x00000008,
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 4
    /// This property is only present if localities 1, 2, 3, and 4 are implemented.
    /// </summary>
    EXTEND_L4 = 0x00000009,
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset() from locality 4
    /// This property is only present if localities 1, 2, 3, and 4 are implemented.
    /// </summary>
    RESET_L4 = 0x0000000A,
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that modifications to this PCR (reset or Extend) will not increment the pcrUpdateCounter
    /// </summary>
    NO_INCREMENT = 0x00000011,
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR is reset by a D-RTM event
    /// These PCR are reset to -1 on TPM2_Startup() and reset to 0 on a _TPM_Hash_End event following a _TPM_Hash_Start event.
    /// </summary>
    DRTM_RESET = 0x00000012,
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR is controlled by policy
    /// This property is only present if the TPM supports policy control of a PCR.
    /// </summary>
    POLICY = 0x00000013,
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR is controlled by an authorization value
    /// This property is only present if the TPM supports authorization control of a PCR.
    /// </summary>
    AUTH = 0x00000014,
    /// <summary>
    /// top of the range of TPM_PT_PCR properties of the implementation
    /// If the TPM receives a request for a PCR property with a value larger than this, the TPM will return a zero length list and set the moreData parameter to NO.
    /// NOTE	This is an implementation-specific value. The value shown reflects the reference code implementation.
    /// </summary>
    LAST = 0x00000014
};
/// <summary>
/// The platform values in Table 25 are used for the TPM_PT_PS_FAMILY_INDICATOR.
/// </summary>
enum class TPM_PS : UINT32
{
    /// <summary>
    /// not platform specific
    /// </summary>
    MAIN = 0x00000000,
    /// <summary>
    /// PC Client
    /// </summary>
    PC = 0x00000001,
    /// <summary>
    /// PDA (includes all mobile devices that are not specifically cell phones)
    /// </summary>
    PDA = 0x00000002,
    /// <summary>
    /// Cell Phone
    /// </summary>
    CELL_PHONE = 0x00000003,
    /// <summary>
    /// Server WG
    /// </summary>
    SERVER = 0x00000004,
    /// <summary>
    /// Peripheral WG
    /// </summary>
    PERIPHERAL = 0x00000005,
    /// <summary>
    /// TSS WG (deprecated)
    /// </summary>
    TSS = 0x00000006,
    /// <summary>
    /// Storage WG
    /// </summary>
    STORAGE = 0x00000007,
    /// <summary>
    /// Authentication WG
    /// </summary>
    AUTHENTICATION = 0x00000008,
    /// <summary>
    /// Embedded WG
    /// </summary>
    EMBEDDED = 0x00000009,
    /// <summary>
    /// Hardcopy WG
    /// </summary>
    HARDCOPY = 0x0000000A,
    /// <summary>
    /// Infrastructure WG (deprecated)
    /// </summary>
    INFRASTRUCTURE = 0x0000000B,
    /// <summary>
    /// Virtualization WG
    /// </summary>
    VIRTUALIZATION = 0x0000000C,
    /// <summary>
    /// Trusted Network Connect WG (deprecated)
    /// </summary>
    TNC = 0x0000000D,
    /// <summary>
    /// Multi-tenant WG (deprecated)
    /// </summary>
    MULTI_TENANT = 0x0000000E,
    /// <summary>
    /// Technical Committee (deprecated)
    /// </summary>
    TC = 0x0000000F
};
/// <summary>
/// The 32-bit handle space is divided into 256 regions of equal size with 224 values in each. Each of these ranges represents a handle type.
/// </summary>
enum class TPM_HT : byte
{
    /// <summary>
    /// PCR  consecutive numbers, starting at 0, that reference the PCR registers
    /// A platform-specific specification will set the minimum number of PCR and an implementation may have more.
    /// </summary>
    PCR = 0x00,
    /// <summary>
    /// NV Index  assigned by the caller
    /// </summary>
    NV_INDEX = 0x01,
    /// <summary>
    /// HMAC Authorization Session  assigned by the TPM when the session is created
    /// </summary>
    HMAC_SESSION = 0x02,
    /// <summary>
    /// Loaded Authorization Session  used only in the context of TPM2_GetCapability
    /// This type references both loaded HMAC and loaded policy authorization sessions.
    /// </summary>
    LOADED_SESSION = 0x02,
    /// <summary>
    /// Policy Authorization Session  assigned by the TPM when the session is created
    /// </summary>
    POLICY_SESSION = 0x03,
    /// <summary>
    /// Saved Authorization Session  used only in the context of TPM2_GetCapability
    /// This type references saved authorization session contexts for which the TPM is maintaining tracking information.
    /// </summary>
    SAVED_SESSION = 0x03,
    /// <summary>
    /// Permanent Values  assigned by this specification in Table 28
    /// </summary>
    PERMANENT = 0x40,
    /// <summary>
    /// Transient Objects  assigned by the TPM when an object is loaded into transient-object memory or when a persistent object is converted to a transient object
    /// </summary>
    TRANSIENT = 0x80,
    /// <summary>
    /// Persistent Objects  assigned by the TPM when a loaded transient object is made persistent
    /// </summary>
    PERSISTENT = 0x81,
    /// <summary>
    /// Attached Component  handle for an Attached Component.
    /// </summary>
    AC = 0x90
};
/// <summary>
/// Table 28 lists the architecturally defined handles that cannot be changed. The handles include authorization handles, and special handles.
/// </summary>
enum class TPM_RH : UINT32
{
    FIRST = 0x40000000,
    /// <summary>
    /// not used1
    /// </summary>
    SRK = 0x40000000,
    /// <summary>
    /// handle references the Storage Primary Seed (SPS), the ownerAuth, and the ownerPolicy
    /// </summary>
    OWNER = 0x40000001,
    /// <summary>
    /// not used1
    /// </summary>
    REVOKE = 0x40000002,
    /// <summary>
    /// not used1
    /// </summary>
    TRANSPORT = 0x40000003,
    /// <summary>
    /// not used1
    /// </summary>
    OPERATOR = 0x40000004,
    /// <summary>
    /// not used1
    /// </summary>
    ADMIN = 0x40000005,
    /// <summary>
    /// not used1
    /// </summary>
    EK = 0x40000006,
    /// <summary>
    /// a handle associated with the null hierarchy, an EmptyAuth authValue, and an Empty Policy authPolicy.
    /// </summary>
    _NULL = 0x40000007,
    /// <summary>
    /// value reserved to the TPM to indicate a handle location that has not been initialized or assigned
    /// </summary>
    UNASSIGNED = 0x40000008,
    /// <summary>
    /// authorization value used to indicate a password authorization session
    /// </summary>
    RS_PW = 0x40000009,
    /// <summary>
    /// references the authorization associated with the dictionary attack lockout reset
    /// </summary>
    LOCKOUT = 0x4000000A,
    /// <summary>
    /// references the Endorsement Primary Seed (EPS), endorsementAuth, and endorsementPolicy
    /// </summary>
    ENDORSEMENT = 0x4000000B,
    /// <summary>
    /// references the Platform Primary Seed (PPS), platformAuth, and platformPolicy
    /// </summary>
    PLATFORM = 0x4000000C,
    /// <summary>
    /// for phEnableNV
    /// </summary>
    PLATFORM_NV = 0x4000000D,
    /// <summary>
    /// Start of a range of authorization values that are vendor-specific. A TPM may support any of the values in this range as are needed for vendor-specific purposes.
    /// Disabled if ehEnable is CLEAR.
    /// NOTE Any includes none.
    /// </summary>
    AUTH_00 = 0x40000010,
    /// <summary>
    /// End of the range of vendor-specific authorization values.
    /// </summary>
    AUTH_FF = 0x4000010F,
    /// <summary>
    /// the top of the reserved handle area
    /// This is set to allow TPM2_GetCapability() to know where to stop. It may vary as implementations add to the permanent handle area.
    /// </summary>
    LAST = 0x4000010F
};
/// <summary>
/// This table lists the values of the TPM_NT field of a TPMA_NV. See Table 210 for usage.
/// </summary>
enum class TPM_NT : UINT32
{
    /// <summary>
    /// Ordinary  contains data that is opaque to the TPM that can only be modified using TPM2_NV_Write().
    /// </summary>
    ORDINARY = 0x0,
    /// <summary>
    /// Counter  contains an 8-octet value that is to be used as a counter and can only be modified with TPM2_NV_Increment()
    /// </summary>
    COUNTER = 0x1,
    /// <summary>
    /// Bit Field  contains an 8-octet value to be used as a bit field and can only be modified with TPM2_NV_SetBits().
    /// </summary>
    BITS = 0x2,
    /// <summary>
    /// Extend  contains a digest-sized value used like a PCR. The Index can only be modified using TPM2_NV_Extend(). The extend will use the nameAlg of the Index.
    /// </summary>
    EXTEND = 0x4,
    /// <summary>
    /// PIN Fail - contains pinCount that increments on a PIN authorization failure and a pinLimit
    /// </summary>
    PIN_FAIL = 0x8,
    /// <summary>
    /// PIN Pass - contains pinCount that increments on a PIN authorization success and a pinLimit
    /// </summary>
    PIN_PASS = 0x9
};
/// <summary>
/// These constants are used in TPM2_AC_GetCapability() to indicate the first tagged value returned from an attached component.
/// </summary>
enum class TPM_AT : UINT32
{
    /// <summary>
    /// in a command, a non-specific request for AC information; in a response, indicates that outputData is not meaningful
    /// </summary>
    ANY = 0x00000000,
    /// <summary>
    /// indicates a TCG defined, device-specific error
    /// </summary>
    _ERROR = 0x00000001,
    /// <summary>
    /// indicates the most significant 32 bits of a pairing value for the AC
    /// </summary>
    PV1 = 0x00000002,
    /// <summary>
    /// value added to a TPM_AT to indicate a vendor-specific tag value
    /// </summary>
    VEND = 0x80000000
};
/// <summary>
/// These constants are the TCG-defined error values returned by an AC.
/// </summary>
enum class TPM_AE : UINT32
{
    /// <summary>
    /// in a command, a non-specific request for AC information; in a response, indicates that outputData is not meaningful
    /// </summary>
    NONE = 0x00000000
};
/// <summary>
/// These values are readable with TPM2_GetCapability(). They are the TPM_PT_PS_xxx values.
/// </summary>
enum class PLATFORM : UINT32
{
    FAMILY = UINT32(TPM_SPEC::FAMILY),
    LEVEL = UINT32(TPM_SPEC::LEVEL),
    VERSION = UINT32(TPM_SPEC::VERSION),
    YEAR = UINT32(TPM_SPEC::YEAR),
    DAY_OF_YEAR = UINT32(TPM_SPEC::DAY_OF_YEAR)
};
/// <summary>
/// This table contains a collection of values used in various parts of the reference code. The values shown are illustrative.
/// </summary>
enum class Implementation : UINT32
{
    /// <summary>
    /// temporary define
    /// </summary>
    FIELD_UPGRADE_IMPLEMENTED = UINT32(Logic::NO),
    /// <summary>
    /// The number of bits in a word. This is used in the big number library to set the unit of allocation. The reference implementation allows values of 32 and 64. It should be set to a value that is compatible with libraries that are used (e.g, OpenSSL).
    /// </summary>
    RADIX_BITS = 32,
    /// <summary>
    /// The byte alignment for hash structure
    /// </summary>
    HASH_ALIGNMENT = 4,
    /// <summary>
    /// The alignment for symmetric structures.
    /// </summary>
    SYMMETRIC_ALIGNMENT = 4,
    /// <summary>
    /// Selection of the library that provides the basic hashing functions.
    /// </summary>
    HASH_LIB = UINT32(ImplementationConstants::OSSL),
    /// <summary>
    /// Selection of the library that provides the low-level symmetric cryptography. Choices are determined by the vendor (See LibSupport.h for implications).
    /// </summary>
    SYM_LIB = UINT32(ImplementationConstants::OSSL),
    /// <summary>
    /// Selection of the library that provides the big number math including ECC. Choices are determined by the vendor (See LibSupport.h for implications).
    /// </summary>
    MATH_LIB = UINT32(ImplementationConstants::OSSL),
    /// <summary>
    /// the number of PCR required by the relevant platform specification
    /// </summary>
    PLATFORM_PCR = 24,
    PCR_SELECT_MIN = ((UINT32(Implementation::PLATFORM_PCR) + 7) / 8),
    /// <summary>
    /// the number of PCR in the TPM
    /// </summary>
    IMPLEMENTATION_PCR = 24,
    PCR_SELECT_MAX = ((UINT32(Implementation::IMPLEMENTATION_PCR) + 7) / 8),
    /// <summary>
    /// the D-RTM PCR
    /// NOTE This value is not defined when the TPM does not implement D-RTM
    /// </summary>
    DRTM_PCR = 17,
    /// <summary>
    /// the PCR that will receive the H-CRTM value at TPM2_Startup. This value should not be changed.
    /// </summary>
    HCRTM_PCR = 0,
    /// <summary>
    /// the number of localities supported by the TPM
    /// This is expected to be either 5 for a PC, or 1 for just about everything else.
    /// </summary>
    NUM_LOCALITIES = 5,
    /// <summary>
    /// the maximum number of handles in the handle area
    /// This should be produced by the Part 3 parser but is here for now.
    /// </summary>
    MAX_HANDLE_NUM = 3,
    /// <summary>
    /// the number of simultaneously active sessions that are supported by the TPM implementation
    /// </summary>
    MAX_ACTIVE_SESSIONS = 64,
    /// <summary>
    /// the number of sessions that the TPM may have in memory
    /// </summary>
    MAX_LOADED_SESSIONS = 3,
    /// <summary>
    /// this is the current maximum value
    /// </summary>
    MAX_SESSION_NUM = 3,
    /// <summary>
    /// the number of simultaneously loaded objects that are supported by the TPM; this number does not include the objects that may be placed in NV memory by TPM2_EvictControl().
    /// </summary>
    MAX_LOADED_OBJECTS = 3,
    /// <summary>
    /// the minimum number of evict objects supported by the TPM
    /// </summary>
    MIN_EVICT_OBJECTS = 2,
    /// <summary>
    /// number of PCR groups that have individual policies
    /// </summary>
    NUM_POLICY_PCR_GROUP = 1,
    /// <summary>
    /// number of PCR groups that have individual authorization values
    /// </summary>
    NUM_AUTHVALUE_PCR_GROUP = 1,
    MAX_CONTEXT_SIZE = 1264,
    MAX_DIGEST_BUFFER = 1024,
    /// <summary>
    /// maximum data size allowed in an NV Index
    /// </summary>
    MAX_NV_INDEX_SIZE = 2048,
    /// <summary>
    /// maximum data size in one NV read or write command
    /// </summary>
    MAX_NV_BUFFER_SIZE = 1024,
    /// <summary>
    /// maximum size of a capability buffer
    /// </summary>
    MAX_CAP_BUFFER = 1024,
    /// <summary>
    /// size of NV memory in octets
    /// </summary>
    NV_MEMORY_SIZE = 16384,
    /// <summary>
    /// the TPM will not allocate a non-counter index if it would prevent allocation of this number of indices.
    /// </summary>
    MIN_COUNTER_INDICES = 8,
    NUM_STATIC_PCR = 16,
    /// <summary>
    /// number of algorithms that can be in a list
    /// </summary>
    MAX_ALG_LIST_SIZE = 64,
    /// <summary>
    /// size of the Primary Seed in octets
    /// </summary>
    PRIMARY_SEED_SIZE = 32,
    /// <summary>
    /// context encryption algorithm
    /// Cant use TPM_ALG_AES because it is defined as (TPM_ALG_ID)(ALG_AES_VALUE) and that cant be used in macro comparisons
    /// </summary>
    CONTEXT_ENCRYPT_ALG = UINT32(0x6/*ALG_ID_VALUE::AES_VALUE*/),
    /// <summary>
    /// the update interval expressed as a power of 2 seconds
    /// A value of 12 is 4,096 seconds (~68 minutes).
    /// </summary>
    NV_CLOCK_UPDATE_INTERVAL = 12,
    /// <summary>
    /// number of PCR groups that allow policy/auth
    /// </summary>
    NUM_POLICY_PCR = 1,
    /// <summary>
    /// maximum size of a command
    /// </summary>
    MAX_COMMAND_SIZE = 4096,
    /// <summary>
    /// maximum size of a response
    /// </summary>
    MAX_RESPONSE_SIZE = 4096,
    /// <summary>
    /// number between 1 and 32 inclusive
    /// </summary>
    ORDERLY_BITS = 8,
    /// <summary>
    /// the maximum number of octets that may be in a sealed blob; 128 is the minimum allowed value
    /// </summary>
    MAX_SYM_DATA = 128,
    MAX_RNG_ENTROPY_SIZE = 64,
    /// <summary>
    /// Number of bytes used for the RAM index space. If this is not large enough, it might not be possible to allocate orderly indices.
    /// </summary>
    RAM_INDEX_SPACE = 512,
    /// <summary>
    /// 216 + 1
    /// </summary>
    RSA_DEFAULT_PUBLIC_EXPONENT = 0x00010001,
    /// <summary>
    /// indicates if the TPM_PT_PCR_NO_INCREMENT group is implemented
    /// </summary>
    ENABLE_PCR_NO_INCREMENT = UINT32(Logic::YES),
    CRT_FORMAT_RSA = UINT32(Logic::YES),
    VENDOR_COMMAND_COUNT = 0,
    /// <summary>
    /// Maximum size of the vendor-specific buffer
    /// </summary>
    MAX_VENDOR_BUFFER_SIZE = 1024,
    /// <summary>
    /// L value for al derivation
    /// </summary>
    TPM_MAX_DERIVATION_BITS = 8192,
    /// <summary>
    /// Number of octets in the serial X509 certificate cerial number. This should not be made larger than 20.
    /// </summary>
    SIZE_OF_X509_SERIAL_NUMBER = 20,
    /// <summary>
    /// Set to 1/2 to have one prime in private. Set to 5/2 to have CRT values. This is used in a string substution.
    /// </summary>
    RSA_PRIVATE_SIZE = ((UINT32(ImplementationConstants::MAX_RSA_KEY_BYTES) * 5) / 2),
    /// <summary>
    /// This value may need to be increased if additional vendor-specific information is stored in the internal OBJECT structure.
    /// </summary>
    PRIVATE_VENDOR_SPECIFIC_BYTES = UINT32(Implementation::RSA_PRIVATE_SIZE)
};
/// <summary>
/// The definitions in Table 29 are used to define many of the interface data types.
/// </summary>
enum class TPM_HC : UINT32
{
    /// <summary>
    /// to mask off the HR
    /// </summary>
    HR_HANDLE_MASK = 0x00FFFFFF,
    /// <summary>
    /// to mask off the variable part
    /// </summary>
    HR_RANGE_MASK = 0xFF000000,
    HR_SHIFT = 24,
    HR_PCR = (UINT32(TPM_HT::PCR) << UINT32(TPM_HC::HR_SHIFT)),
    HR_HMAC_SESSION = (UINT32(TPM_HT::HMAC_SESSION) << UINT32(TPM_HC::HR_SHIFT)),
    HR_POLICY_SESSION = (UINT32(TPM_HT::POLICY_SESSION) << UINT32(TPM_HC::HR_SHIFT)),
    HR_TRANSIENT = (UINT32(TPM_HT::TRANSIENT) << UINT32(TPM_HC::HR_SHIFT)),
    HR_PERSISTENT = (UINT32(TPM_HT::PERSISTENT) << UINT32(TPM_HC::HR_SHIFT)),
    HR_NV_INDEX = (UINT32(TPM_HT::NV_INDEX) << UINT32(TPM_HC::HR_SHIFT)),
    HR_PERMANENT = (UINT32(TPM_HT::PERMANENT) << UINT32(TPM_HC::HR_SHIFT)),
    /// <summary>
    /// first PCR
    /// </summary>
    PCR_FIRST = (UINT32(TPM_HC::HR_PCR) + 0),
    /// <summary>
    /// last PCR
    /// </summary>
    PCR_LAST = (UINT32(TPM_HC::PCR_FIRST) + UINT32(Implementation::IMPLEMENTATION_PCR)-1),
    /// <summary>
    /// first HMAC session
    /// </summary>
    HMAC_SESSION_FIRST = (UINT32(TPM_HC::HR_HMAC_SESSION) + 0),
    /// <summary>
    /// last HMAC session
    /// </summary>
    HMAC_SESSION_LAST = (UINT32(TPM_HC::HMAC_SESSION_FIRST)+UINT32(Implementation::MAX_ACTIVE_SESSIONS)-1),
    /// <summary>
    /// used in GetCapability
    /// </summary>
    LOADED_SESSION_FIRST = UINT32(TPM_HC::HMAC_SESSION_FIRST),
    /// <summary>
    /// used in GetCapability
    /// </summary>
    LOADED_SESSION_LAST = UINT32(TPM_HC::HMAC_SESSION_LAST),
    /// <summary>
    /// first policy session
    /// </summary>
    POLICY_SESSION_FIRST = (UINT32(TPM_HC::HR_POLICY_SESSION) + 0),
    /// <summary>
    /// last policy session
    /// </summary>
    POLICY_SESSION_LAST = (UINT32(TPM_HC::POLICY_SESSION_FIRST) + UINT32(Implementation::MAX_ACTIVE_SESSIONS)-1),
    /// <summary>
    /// first transient object
    /// </summary>
    TRANSIENT_FIRST = (UINT32(TPM_HC::HR_TRANSIENT) + 0),
    /// <summary>
    /// used in GetCapability
    /// </summary>
    ACTIVE_SESSION_FIRST = UINT32(TPM_HC::POLICY_SESSION_FIRST),
    /// <summary>
    /// used in GetCapability
    /// </summary>
    ACTIVE_SESSION_LAST = UINT32(TPM_HC::POLICY_SESSION_LAST),
    /// <summary>
    /// last transient object
    /// </summary>
    TRANSIENT_LAST = (UINT32(TPM_HC::TRANSIENT_FIRST)+UINT32(Implementation::MAX_LOADED_OBJECTS)-1),
    /// <summary>
    /// first persistent object
    /// </summary>
    PERSISTENT_FIRST = (UINT32(TPM_HC::HR_PERSISTENT) + 0),
    /// <summary>
    /// last persistent object
    /// </summary>
    PERSISTENT_LAST = (UINT32(TPM_HC::PERSISTENT_FIRST) + 0x00FFFFFF),
    /// <summary>
    /// first platform persistent object
    /// </summary>
    PLATFORM_PERSISTENT = (UINT32(TPM_HC::PERSISTENT_FIRST) + 0x00800000),
    /// <summary>
    /// first allowed NV Index
    /// </summary>
    NV_INDEX_FIRST = (UINT32(TPM_HC::HR_NV_INDEX) + 0),
    /// <summary>
    /// last allowed NV Index
    /// </summary>
    NV_INDEX_LAST = (UINT32(TPM_HC::NV_INDEX_FIRST) + 0x00FFFFFF),
    PERMANENT_FIRST = UINT32(TPM_RH::FIRST),
    PERMANENT_LAST = UINT32(TPM_RH::LAST),
    /// <summary>
    /// AC aliased NV Index
    /// </summary>
    HR_NV_AC = ((UINT32(TPM_HT::NV_INDEX) << UINT32(TPM_HC::HR_SHIFT)) + 0xD00000),
    /// <summary>
    /// first NV Index aliased to Attached Component
    /// </summary>
    NV_AC_FIRST = (UINT32(TPM_HC::HR_NV_AC) + 0),
    /// <summary>
    /// last NV Index aliased to Attached Component
    /// </summary>
    NV_AC_LAST = (UINT32(TPM_HC::HR_NV_AC) + 0x0000FFFF),
    /// <summary>
    /// AC Handle
    /// </summary>
    HR_AC = (UINT32(TPM_HT::AC) << UINT32(TPM_HC::HR_SHIFT)),
    /// <summary>
    /// first Attached Component
    /// </summary>
    AC_FIRST = (UINT32(TPM_HC::HR_AC) + 0),
    /// <summary>
    /// last Attached Component
    /// </summary>
    AC_LAST = (UINT32(TPM_HC::HR_AC) + 0x0000FFFF)
};
/// <summary>
/// Proxy constants for TPM_ALG_ID enum
/// </summary>
enum class ALG_ID_VALUE : UINT16
{
    /// <summary>
    /// should not occur
    /// </summary>
    ERROR_VALUE = 0x0000,
    /// <summary>
    /// an object type that contains an RSA key
    /// </summary>
    FIRST_VALUE = 0x0001,
    /// <summary>
    /// an object type that contains an RSA key
    /// </summary>
    RSA_VALUE = 0x0001,
    TDES_VALUE = 0x0003,
    /// <summary>
    /// hash algorithm producing a 160-bit digest
    /// </summary>
    SHA_VALUE = 0x0004,
    /// <summary>
    /// redefinition for documentation consistency
    /// </summary>
    SHA1_VALUE = 0x0004,
    /// <summary>
    /// Hash Message Authentication Code (HMAC) algorithm
    /// </summary>
    HMAC_VALUE = 0x0005,
    /// <summary>
    /// block cipher with various key sizes
    /// </summary>
    AES_VALUE = 0x0006,
    /// <summary>
    /// hash-based mask-generation function
    /// </summary>
    MGF1_VALUE = 0x0007,
    /// <summary>
    /// an object type that may use XOR for encryption or an HMAC for signing and may also refer to a data object that is neither signing nor encrypting
    /// </summary>
    KEYEDHASH_VALUE = 0x0008,
    /// <summary>
    /// hash-based stream cipher
    /// </summary>
    XOR_VALUE = 0x000A,
    /// <summary>
    /// hash algorithm producing a 256-bit digest
    /// </summary>
    SHA256_VALUE = 0x000B,
    /// <summary>
    /// hash algorithm producing a 384-bit digest
    /// </summary>
    SHA384_VALUE = 0x000C,
    /// <summary>
    /// hash algorithm producing a 512-bit digest
    /// </summary>
    SHA512_VALUE = 0x000D,
    /// <summary>
    /// Indication that no algorithm is selected
    /// </summary>
    NULL_VALUE = 0x0010,
    /// <summary>
    /// hash algorithm producing a 256-bit digest
    /// </summary>
    SM3_256_VALUE = 0x0012,
    /// <summary>
    /// symmetric block cipher with 128 bit key
    /// </summary>
    SM4_VALUE = 0x0013,
    /// <summary>
    /// a signature algorithm defined in section 8.2 (RSASSA-PKCS1-v1_5)
    /// </summary>
    RSASSA_VALUE = 0x0014,
    /// <summary>
    /// a padding algorithm defined in section 7.2 (RSAES-PKCS1-v1_5)
    /// </summary>
    RSAES_VALUE = 0x0015,
    /// <summary>
    /// a signature algorithm defined in section 8.1 (RSASSA-PSS)
    /// </summary>
    RSAPSS_VALUE = 0x0016,
    /// <summary>
    /// a padding algorithm defined in Section 7.1 (RSAES_OAEP)
    /// </summary>
    OAEP_VALUE = 0x0017,
    /// <summary>
    /// signature algorithm using elliptic curve cryptography (ECC)
    /// </summary>
    ECDSA_VALUE = 0x0018,
    /// <summary>
    /// secret sharing using ECC Based on context, this can be either One-Pass Diffie-Hellman, C(1, 1, ECC CDH) defined in 6.2.2.2 or Full Unified Model C(2, 2, ECC CDH) defined in 6.1.1.2
    /// </summary>
    ECDH_VALUE = 0x0019,
    /// <summary>
    /// elliptic-curve based, anonymous signing scheme
    /// </summary>
    ECDAA_VALUE = 0x001A,
    /// <summary>
    /// depending on context, either an elliptic-curve based, signature algorithm or a key exchange protocol
    /// NOTE	Type listed as signing but, other uses are allowed according to context.
    /// </summary>
    SM2_VALUE = 0x001B,
    /// <summary>
    /// elliptic-curve based Schnorr signature
    /// </summary>
    ECSCHNORR_VALUE = 0x001C,
    /// <summary>
    /// two-phase elliptic-curve key exchange  C(2, 2, ECC MQV) Section 6.1.1.4
    /// </summary>
    ECMQV_VALUE = 0x001D,
    /// <summary>
    /// concatenation key derivation function (approved alternative 1) Section 5.8.1
    /// </summary>
    KDF1_SP800_56A_VALUE = 0x0020,
    /// <summary>
    /// key derivation function KDF2 Section 13.2
    /// </summary>
    KDF2_VALUE = 0x0021,
    /// <summary>
    /// a key derivation method SP800-108, Section 5.1 KDF in Counter Mode
    /// </summary>
    KDF1_SP800_108_VALUE = 0x0022,
    /// <summary>
    /// prime field ECC
    /// </summary>
    ECC_VALUE = 0x0023,
    /// <summary>
    /// the object type for a symmetric block cipher key
    /// </summary>
    SYMCIPHER_VALUE = 0x0025,
    /// <summary>
    /// symmetric block cipher with various key sizes
    /// </summary>
    CAMELLIA_VALUE = 0x0026,
    CMAC_VALUE = 0x003F,
    /// <summary>
    /// Counter mode  if implemented, all symmetric block ciphers (S type) implemented shall be capable of using this mode.
    /// </summary>
    CTR_VALUE = 0x0040,
    /// <summary>
    /// Output Feedback mode  if implemented, all symmetric block ciphers (S type) implemented shall be capable of using this mode.
    /// </summary>
    OFB_VALUE = 0x0041,
    /// <summary>
    /// Cipher Block Chaining mode  if implemented, all symmetric block ciphers (S type) implemented shall be capable of using this mode.
    /// </summary>
    CBC_VALUE = 0x0042,
    /// <summary>
    /// Cipher Feedback mode  if implemented, all symmetric block ciphers (S type) implemented shall be capable of using this mode.
    /// </summary>
    CFB_VALUE = 0x0043,
    /// <summary>
    /// Electronic Codebook mode  if implemented, all implemented symmetric block ciphers (S type) shall be capable of using this mode.
    /// NOTE This mode is not recommended for uses unless the key is frequently rotated such as in video codecs
    /// </summary>
    ECB_VALUE = 0x0044,
    LAST_VALUE = 0x0044,
    /// <summary>
    /// Phony alg ID to be used for the first union member with no selector
    /// </summary>
    ANY_VALUE = 0x7FFF,
    /// <summary>
    /// Phony alg ID to be used for the second union member with no selector
    /// </summary>
    ANY2_VALUE = 0x7FFE
};
/// <summary>
/// This structure defines the attributes of an algorithm.
/// </summary>
enum class TPMA_ALGORITHM : UINT32
{
    /// <summary>
    /// SET (1): an asymmetric algorithm with public and private portions
    /// CLEAR (0): not an asymmetric algorithm
    /// </summary>
    asymmetric = 0x1,
    /// <summary>
    /// SET (1): a symmetric block cipher
    /// CLEAR (0): not a symmetric block cipher
    /// </summary>
    symmetric = 0x2,
    /// <summary>
    /// SET (1): a hash algorithm
    /// CLEAR (0): not a hash algorithm
    /// </summary>
    hash = 0x4,
    /// <summary>
    /// SET (1): an algorithm that may be used as an object type
    /// CLEAR (0): an algorithm that is not used as an object type
    /// </summary>
    object = 0x8,
    /// <summary>
    /// SET (1): a signing algorithm. The setting of asymmetric, symmetric, and hash will indicate the type of signing algorithm.
    /// CLEAR (0): not a signing algorithm
    /// </summary>
    signing = 0x100,
    /// <summary>
    /// SET (1): an encryption/decryption algorithm. The setting of asymmetric, symmetric, and hash will indicate the type of encryption/decryption algorithm.
    /// CLEAR (0): not an encryption/decryption algorithm
    /// </summary>
    encrypting = 0x200,
    /// <summary>
    /// SET (1): a method such as a key derivative function (KDF)
    /// CLEAR (0): not a method
    /// </summary>
    method = 0x400
};
inline TPMA_ALGORITHM operator|(TPMA_ALGORITHM _a, TPMA_ALGORITHM _b) { return static_cast<TPMA_ALGORITHM>(static_cast<UINT32>(_a) + static_cast<UINT32>(_b)); }
/// <summary>
/// This attribute structure indicates an objects use, its authorization types, and its relationship to other objects.
/// </summary>
enum class TPMA_OBJECT : UINT32
{
    /// <summary>
    /// SET (1): The hierarchy of the object, as indicated by its Qualified Name, may not change.
    /// CLEAR (0): The hierarchy of the object may change as a result of this object or an ancestor key being duplicated for use in another hierarchy.
    /// NOTE	fixedTPM does not indicate that key material resides on a single TPM (see sensitiveDataOrigin).
    /// </summary>
    fixedTPM = 0x2,
    /// <summary>
    /// SET (1): Previously saved contexts of this object may not be loaded after Startup(CLEAR).
    /// CLEAR (0): Saved contexts of this object may be used after a Shutdown(STATE) and subsequent Startup().
    /// </summary>
    stClear = 0x4,
    /// <summary>
    /// SET (1): The parent of the object may not change.
    /// CLEAR (0): The parent of the object may change as the result of a TPM2_Duplicate() of the object.
    /// </summary>
    fixedParent = 0x10,
    /// <summary>
    /// SET (1): Indicates that, when the object was created with TPM2_Create() or TPM2_CreatePrimary(), the TPM generated all of the sensitive data other than the authValue.
    /// CLEAR (0): A portion of the sensitive data, other than the authValue, was provided by the caller.
    /// </summary>
    sensitiveDataOrigin = 0x20,
    /// <summary>
    /// SET (1): Approval of USER role actions with this object may be with an HMAC session or with a password using the authValue of the object or a policy session.
    /// CLEAR (0): Approval of USER role actions with this object may only be done with a policy session.
    /// </summary>
    userWithAuth = 0x40,
    /// <summary>
    /// SET (1): Approval of ADMIN role actions with this object may only be done with a policy session.
    /// CLEAR (0): Approval of ADMIN role actions with this object may be with an HMAC session or with a password using the authValue of the object or a policy session.
    /// </summary>
    adminWithPolicy = 0x80,
    /// <summary>
    /// SET (1): The object is not subject to dictionary attack protections.
    /// CLEAR (0): The object is subject to dictionary attack protections.
    /// </summary>
    noDA = 0x400,
    /// <summary>
    /// SET (1): If the object is duplicated, then symmetricAlg shall not be TPM_ALG_NULL and newParentHandle shall not be TPM_RH_NULL.
    /// CLEAR (0): The object may be duplicated without an inner wrapper on the private portion of the object and the new parent may be TPM_RH_NULL.
    /// </summary>
    encryptedDuplication = 0x800,
    /// <summary>
    /// SET (1): Key usage is restricted to manipulate structures of known format; the parent of this key shall have restricted SET.
    /// CLEAR (0): Key usage is not restricted to use on special formats.
    /// </summary>
    restricted = 0x10000,
    /// <summary>
    /// SET (1): The private portion of the key may be used to decrypt.
    /// CLEAR (0): The private portion of the key may not be used to decrypt.
    /// </summary>
    decrypt = 0x20000,
    /// <summary>
    /// SET (1): For a symmetric cipher object, the private portion of the key may be used to encrypt. For other objects, the private portion of the key may be used to sign.
    /// CLEAR (0): The private portion of the key may not be used to sign or encrypt.
    /// </summary>
    sign = 0x40000,
    /// <summary>
    /// Alias to the Sign value.
    /// </summary>
    encrypt = 0x40000,
    /// <summary>
    /// SET (1): An asymmetric key that may not be used to sign with TPM2_Sign()
    /// CLEAR (0): A key that may be used with TPM2_Sign() if sign is SET
    /// NOTE:	This attribute only has significance if sign is SET.
    /// </summary>
    x509sign = 0x80000
};
inline TPMA_OBJECT operator|(TPMA_OBJECT _a, TPMA_OBJECT _b) { return static_cast<TPMA_OBJECT>(static_cast<UINT32>(_a) + static_cast<UINT32>(_b)); }
/// <summary>
/// This octet in each session is used to identify the session type, indicate its relationship to any handles in the command, and indicate its use in parameter encryption.
/// </summary>
enum class TPMA_SESSION : byte
{
    /// <summary>
    /// SET (1): In a command, this setting indicates that the session is to remain active after successful completion of the command. In a response, it indicates that the session is still active. If SET in the command, this attribute shall be SET in the response.
    /// CLEAR (0): In a command, this setting indicates that the TPM should close the session and flush any related context when the command completes successfully. In a response, it indicates that the session is closed and the context is no longer active.
    /// This attribute has no meaning for a password authorization and the TPM will allow any setting of the attribute in the command and SET the attribute in the response.
    /// This attribute will only be CLEAR in one response for a logical session. If the attribute is CLEAR, the context associated with the session is no longer in use and the space is available. A session created after another session is ended may have the same handle but logically is not the same session.
    /// This attribute has no effect if the command does not complete successfully.
    /// </summary>
    continueSession = 0x1,
    /// <summary>
    /// SET (1): In a command, this setting indicates that the command should only be executed if the session is exclusive at the start of the command. In a response, it indicates that the session is exclusive. This setting is only allowed if the audit attribute is SET (TPM_RC_ATTRIBUTES).
    /// CLEAR (0): In a command, indicates that the session need not be exclusive at the start of the command. In a response, indicates that the session is not exclusive.
    /// </summary>
    auditExclusive = 0x2,
    /// <summary>
    /// SET (1): In a command, this setting indicates that the audit digest of the session should be initialized and the exclusive status of the session SET. This setting is only allowed if the audit attribute is SET (TPM_RC_ATTRIBUTES).
    /// CLEAR (0): In a command, indicates that the audit digest should not be initialized.
    /// This bit is always CLEAR in a response.
    /// </summary>
    auditReset = 0x4,
    /// <summary>
    /// SET (1): In a command, this setting indicates that the first parameter in the command is symmetrically encrypted using the parameter encryption scheme described in TPM 2.0 Part 1. The TPM will decrypt the parameter after performing any HMAC computations and before unmarshaling the parameter. In a response, the attribute is copied from the request but has no effect on the response.
    /// CLEAR (0): Session not used for encryption.
    /// For a password authorization, this attribute will be CLEAR in both the command and response.
    /// This attribute may be SET in a session that is not associated with a command handle. Such a session is provided for purposes of encrypting a parameter and not for authorization.
    /// This attribute may be SET in combination with any other session attributes.
    /// </summary>
    decrypt = 0x20,
    /// <summary>
    /// SET (1): In a command, this setting indicates that the TPM should use this session to encrypt the first parameter in the response. In a response, it indicates that the attribute was set in the command and that the TPM used the session to encrypt the first parameter in the response using the parameter encryption scheme described in TPM 2.0 Part 1.
    /// CLEAR (0): Session not used for encryption.
    /// For a password authorization, this attribute will be CLEAR in both the command and response.
    /// This attribute may be SET in a session that is not associated with a command handle. Such a session is provided for purposes of encrypting a parameter and not for authorization.
    /// </summary>
    encrypt = 0x40,
    /// <summary>
    /// SET (1): In a command or response, this setting indicates that the session is for audit and that auditExclusive and auditReset have meaning. This session may also be used for authorization, encryption, or decryption. The encrypted and encrypt fields may be SET or CLEAR.
    /// CLEAR (0): Session is not used for audit.
    /// If SET in the command, then this attribute will be SET in the response.
    /// </summary>
    audit = 0x80
};
inline TPMA_SESSION operator|(TPMA_SESSION _a, TPMA_SESSION _b) { return static_cast<TPMA_SESSION>(static_cast<UINT32>(_a) + static_cast<UINT32>(_b)); }
/// <summary>
/// In a TPMS_CREATION_DATA structure, this structure is used to indicate the locality of the command that created the object. No more than one of the locality attributes shall be set in the creation data.
/// </summary>
enum class TPMA_LOCALITY : byte
{
    LOC_ZERO = 0x1,
    LOC_ONE = 0x2,
    LOC_TWO = 0x4,
    LOC_THREE = 0x8,
    LOC_FOUR = 0x10,
    /// <summary>
    /// If any of these bits is set, an extended locality is indicated
    /// </summary>
    Extended_BIT_MASK = 0x000000E0,
    Extended_BIT_OFFSET = 5,
    Extended_BIT_LENGTH = 3,
    Extended_BIT_0 = 0x20,
    Extended_BIT_1 = 0x40,
    Extended_BIT_2 = 0x80
};
inline TPMA_LOCALITY operator|(TPMA_LOCALITY _a, TPMA_LOCALITY _b) { return static_cast<TPMA_LOCALITY>(static_cast<UINT32>(_a) + static_cast<UINT32>(_b)); }
/// <summary>
/// The attributes in this structure are persistent and are not changed as a result of _TPM_Init or any TPM2_Startup(). Some of the attributes in this structure may change as the result of specific Protected Capabilities. This structure may be read using TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_PERMANENT).
/// </summary>
enum class TPMA_PERMANENT : UINT32
{
    /// <summary>
    /// SET (1): TPM2_HierarchyChangeAuth() with ownerAuth has been executed since the last TPM2_Clear().
    /// CLEAR (0): ownerAuth has not been changed since TPM2_Clear().
    /// </summary>
    ownerAuthSet = 0x1,
    /// <summary>
    /// SET (1): TPM2_HierarchyChangeAuth() with endorsementAuth has been executed since the last TPM2_Clear().
    /// CLEAR (0): endorsementAuth has not been changed since TPM2_Clear().
    /// </summary>
    endorsementAuthSet = 0x2,
    /// <summary>
    /// SET (1): TPM2_HierarchyChangeAuth() with lockoutAuth has been executed since the last TPM2_Clear().
    /// CLEAR (0): lockoutAuth has not been changed since TPM2_Clear().
    /// </summary>
    lockoutAuthSet = 0x4,
    /// <summary>
    /// SET (1): TPM2_Clear() is disabled.
    /// CLEAR (0): TPM2_Clear() is enabled.
    /// NOTE	See TPM2_ClearControl in TPM 2.0 Part 3 for details on changing this attribute.
    /// </summary>
    disableClear = 0x100,
    /// <summary>
    /// SET (1): The TPM is in lockout, when failedTries is equal to maxTries.
    /// </summary>
    inLockout = 0x200,
    /// <summary>
    /// SET (1): The EPS was created by the TPM.
    /// CLEAR (0): The EPS was created outside of the TPM using a manufacturer-specific process.
    /// </summary>
    tpmGeneratedEPS = 0x400
};
inline TPMA_PERMANENT operator|(TPMA_PERMANENT _a, TPMA_PERMANENT _b) { return static_cast<TPMA_PERMANENT>(static_cast<UINT32>(_a) + static_cast<UINT32>(_b)); }
/// <summary>
/// This structure may be read using TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_STARTUP_CLEAR).
/// </summary>
enum class TPMA_STARTUP_CLEAR : UINT32
{
    /// <summary>
    /// SET (1): The platform hierarchy is enabled and platformAuth or platformPolicy may be used for authorization.
    /// CLEAR (0): platformAuth and platformPolicy may not be used for authorizations, and objects in the platform hierarchy, including persistent objects, cannot be used.
    /// NOTE	See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    /// </summary>
    phEnable = 0x1,
    /// <summary>
    /// SET (1): The Storage hierarchy is enabled and ownerAuth or ownerPolicy may be used for authorization. NV indices defined using owner authorization are accessible.
    /// CLEAR (0): ownerAuth and ownerPolicy may not be used for authorizations, and objects in the Storage hierarchy, persistent objects, and NV indices defined using owner authorization cannot be used.
    /// NOTE	See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    /// </summary>
    shEnable = 0x2,
    /// <summary>
    /// SET (1): The EPS hierarchy is enabled and Endorsement Authorization may be used to authorize commands.
    /// CLEAR (0): Endorsement Authorization may not be used for authorizations, and objects in the endorsement hierarchy, including persistent objects, cannot be used.
    /// NOTE	See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    /// </summary>
    ehEnable = 0x4,
    /// <summary>
    /// SET (1): NV indices that have TPMA_NV_PLATFORMCREATE SET may be read or written. The platform can create define and undefine indices.
    /// CLEAR (0): NV indices that have TPMA_NV_PLATFORMCREATE SET may not be read or written (TPM_RC_HANDLE). The platform cannot define (TPM_RC_HIERARCHY) or undefined (TPM_RC_HANDLE) indices.
    /// NOTE	See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    /// NOTE read refers to these commands: TPM2_NV_Read, TPM2_NV_ReadPublic, TPM_NV_Certify, TPM2_PolicyNV
    /// write refers to these commands: TPM2_NV_Write, TPM2_NV_Increment, TPM2_NV_Extend, TPM2_NV_SetBits
    /// NOTE The TPM must query the index TPMA_NV_PLATFORMCREATE attribute to determine whether phEnableNV is applicable. Since the TPM will return TPM_RC_HANDLE if the index does not exist, it also returns this error code if the index is disabled. Otherwise, the TPM would leak the existence of an index even when disabled.
    /// </summary>
    phEnableNV = 0x8,
    /// <summary>
    /// SET (1): The TPM received a TPM2_Shutdown() and a matching TPM2_Startup().
    /// CLEAR (0): TPM2_Startup(TPM_SU_CLEAR) was not preceded by a TPM2_Shutdown() of any type.
    /// NOTE A shutdown is orderly if the TPM receives a TPM2_Shutdown() of any type followed by a TPM2_Startup() of any type. However, the TPM will return an error if TPM2_Startup(TPM_SU_STATE) was not preceded by TPM2_Shutdown(TPM_SU_STATE).
    /// </summary>
    orderly = 0x80000000
};
inline TPMA_STARTUP_CLEAR operator|(TPMA_STARTUP_CLEAR _a, TPMA_STARTUP_CLEAR _b) { return static_cast<TPMA_STARTUP_CLEAR>(static_cast<UINT32>(_a) + static_cast<UINT32>(_b)); }
/// <summary>
/// This structure of this attribute is used to report the memory management method used by the TPM for transient objects and authorization sessions. This structure may be read using TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_MEMORY).
/// </summary>
enum class TPMA_MEMORY : UINT32
{
    /// <summary>
    /// SET (1): indicates that the RAM memory used for authorization session contexts is shared with the memory used for transient objects
    /// CLEAR (0): indicates that the memory used for authorization sessions is not shared with memory used for transient objects
    /// </summary>
    sharedRAM = 0x1,
    /// <summary>
    /// SET (1): indicates that the NV memory used for persistent objects is shared with the NV memory used for NV Index values
    /// CLEAR (0): indicates that the persistent objects and NV Index values are allocated from separate sections of NV
    /// </summary>
    sharedNV = 0x2,
    /// <summary>
    /// SET (1): indicates that the TPM copies persistent objects to a transient-object slot in RAM when the persistent object is referenced in a command. The TRM is required to make sure that an object slot is available.
    /// CLEAR (0): indicates that the TPM does not use transient-object slots when persistent objects are referenced
    /// </summary>
    objectCopiedToRam = 0x4
};
inline TPMA_MEMORY operator|(TPMA_MEMORY _a, TPMA_MEMORY _b) { return static_cast<TPMA_MEMORY>(static_cast<UINT32>(_a) + static_cast<UINT32>(_b)); }
/// <summary>
/// This structure defines the attributes of a command from a context management perspective. The fields of the structure indicate to the TPM Resource Manager (TRM) the number of resources required by a command and how the command affects the TPMs resources.
/// </summary>
enum class TPMA_CC : UINT32
{
    /// <summary>
    /// indicates the command being selected
    /// </summary>
    commandIndex_BIT_MASK = 0x0000FFFF,
    commandIndex_BIT_OFFSET = 0,
    commandIndex_BIT_LENGTH = 16,
    commandIndex_BIT_0 = 0x1,
    commandIndex_BIT_1 = 0x2,
    commandIndex_BIT_2 = 0x4,
    commandIndex_BIT_3 = 0x8,
    commandIndex_BIT_4 = 0x10,
    commandIndex_BIT_5 = 0x20,
    commandIndex_BIT_6 = 0x40,
    commandIndex_BIT_7 = 0x80,
    commandIndex_BIT_8 = 0x100,
    commandIndex_BIT_9 = 0x200,
    commandIndex_BIT_10 = 0x400,
    commandIndex_BIT_11 = 0x800,
    commandIndex_BIT_12 = 0x1000,
    commandIndex_BIT_13 = 0x2000,
    commandIndex_BIT_14 = 0x4000,
    commandIndex_BIT_15 = 0x8000,
    /// <summary>
    /// SET (1): indicates that the command may write to NV
    /// CLEAR (0): indicates that the command does not write to NV
    /// </summary>
    nv = 0x400000,
    /// <summary>
    /// SET (1): This command could flush any number of loaded contexts.
    /// CLEAR (0): no additional changes other than indicated by the flushed attribute
    /// </summary>
    extensive = 0x800000,
    /// <summary>
    /// SET (1): The context associated with any transient handle in the command will be flushed when this command completes.
    /// CLEAR (0): No context is flushed as a side effect of this command.
    /// </summary>
    flushed = 0x1000000,
    /// <summary>
    /// indicates the number of the handles in the handle area for this command
    /// </summary>
    cHandles_BIT_MASK = 0x0E000000,
    cHandles_BIT_OFFSET = 25,
    cHandles_BIT_LENGTH = 3,
    cHandles_BIT_0 = 0x2000000,
    cHandles_BIT_1 = 0x4000000,
    cHandles_BIT_2 = 0x8000000,
    /// <summary>
    /// SET (1): indicates the presence of the handle area in the response
    /// </summary>
    rHandle = 0x10000000,
    /// <summary>
    /// SET (1): indicates that the command is vendor-specific
    /// CLEAR (0): indicates that the command is defined in a version of this specification
    /// </summary>
    V = 0x20000000,
    /// <summary>
    /// allocated for software; shall be zero
    /// </summary>
    Res_BIT_MASK = 0xC0000000,
    Res_BIT_OFFSET = 30,
    Res_BIT_LENGTH = 2,
    Res_BIT_0 = 0x40000000,
    Res_BIT_1 = 0x80000000
};
inline TPMA_CC operator|(TPMA_CC _a, TPMA_CC _b) { return static_cast<TPMA_CC>(static_cast<UINT32>(_a) + static_cast<UINT32>(_b)); }
/// <summary>
/// This structure of this attribute is used to report that the TPM is designed for these modes. This structure may be read using TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_MODES).
/// </summary>
enum class TPMA_MODES : UINT32
{
    /// <summary>
    /// SET (1): indicates that the TPM is designed to comply with all of the FIPS 140-2 requirements at Level 1 or higher.
    /// </summary>
    FIPS_140_2 = 0x1
};
inline TPMA_MODES operator|(TPMA_MODES _a, TPMA_MODES _b) { return static_cast<TPMA_MODES>(static_cast<UINT32>(_a) + static_cast<UINT32>(_b)); }
/// <summary>
/// These attributes are as specified in clause 4.2.1.3. of RFC 5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile. For TPM2_CertifyX509, when a caller provides a DER encoded Key Usage in partialCertificate, the TPM will validate that the key to be certified meets the requirements of Key Usage.
/// </summary>
enum class TPMA_X509_KEY_USAGE : UINT32
{
    /// <summary>
    /// sign SET in Subject Key (objectHandle)
    /// </summary>
    digitalSignature = 0x1,
    /// <summary>
    /// fixedTPM SET in Subject Key (objectHandle)
    /// </summary>
    nonrepudiation = 0x2,
    /// <summary>
    /// Alias to the Nonrepudiation value.
    /// </summary>
    contentCommitment = 0x2,
    /// <summary>
    /// asymmetric key with decrypt and restricted SET  key has the attributes of a parent key
    /// </summary>
    keyEncipherment = 0x4,
    /// <summary>
    /// Attributes.Decrypt SET
    /// </summary>
    dataEncipherment = 0x8,
    /// <summary>
    /// ?
    /// </summary>
    keyAgreement = 0x10,
    /// <summary>
    /// Attributes.sign SET
    /// </summary>
    keyCertSign = 0x20,
    /// <summary>
    /// Attributes.sign SET
    /// </summary>
    crlSign = 0x40,
    /// <summary>
    /// ?
    /// </summary>
    encipherOnly = 0x80,
    /// <summary>
    /// Attributes.Decrypt SET
    /// </summary>
    decipherOnly = 0x100
};
inline TPMA_X509_KEY_USAGE operator|(TPMA_X509_KEY_USAGE _a, TPMA_X509_KEY_USAGE _b) { return static_cast<TPMA_X509_KEY_USAGE>(static_cast<UINT32>(_a) + static_cast<UINT32>(_b)); }
/// <summary>
/// A TPM_NV_INDEX is used to reference a defined location in NV memory. The format of the Index is changed from TPM 1.2 in order to include the Index in the reserved handle space. Handles in this range use the digest of the public area of the Index as the Name of the entity in authorization computations
/// </summary>
enum class TPM_NV_INDEX : UINT32
{
    /// <summary>
    /// The Index of the NV location
    /// </summary>
    index_BIT_MASK = 0x00FFFFFF,
    index_BIT_OFFSET = 0,
    index_BIT_LENGTH = 24,
    index_BIT_0 = 0x1,
    index_BIT_1 = 0x2,
    index_BIT_2 = 0x4,
    index_BIT_3 = 0x8,
    index_BIT_4 = 0x10,
    index_BIT_5 = 0x20,
    index_BIT_6 = 0x40,
    index_BIT_7 = 0x80,
    index_BIT_8 = 0x100,
    index_BIT_9 = 0x200,
    index_BIT_10 = 0x400,
    index_BIT_11 = 0x800,
    index_BIT_12 = 0x1000,
    index_BIT_13 = 0x2000,
    index_BIT_14 = 0x4000,
    index_BIT_15 = 0x8000,
    index_BIT_16 = 0x10000,
    index_BIT_17 = 0x20000,
    index_BIT_18 = 0x40000,
    index_BIT_19 = 0x80000,
    index_BIT_20 = 0x100000,
    index_BIT_21 = 0x200000,
    index_BIT_22 = 0x400000,
    index_BIT_23 = 0x800000,
    /// <summary>
    /// constant value of TPM_HT_NV_INDEX indicating the NV Index range
    /// </summary>
    RhNv_BIT_MASK = 0xFF000000,
    RhNv_BIT_OFFSET = 24,
    RhNv_BIT_LENGTH = 8,
    RhNv_BIT_0 = 0x1000000,
    RhNv_BIT_1 = 0x2000000,
    RhNv_BIT_2 = 0x4000000,
    RhNv_BIT_3 = 0x8000000,
    RhNv_BIT_4 = 0x10000000,
    RhNv_BIT_5 = 0x20000000,
    RhNv_BIT_6 = 0x40000000,
    RhNv_BIT_7 = 0x80000000
};
inline TPM_NV_INDEX operator|(TPM_NV_INDEX _a, TPM_NV_INDEX _b) { return static_cast<TPM_NV_INDEX>(static_cast<UINT32>(_a) + static_cast<UINT32>(_b)); }
/// <summary>
/// This structure allows the TPM to keep track of the data and permissions to manipulate an NV Index.
/// </summary>
enum class TPMA_NV : UINT32
{
    /// <summary>
    /// SET (1): The Index data can be written if Platform Authorization is provided.
    /// CLEAR (0): Writing of the Index data cannot be authorized with Platform Authorization.
    /// </summary>
    PPWRITE = 0x1,
    /// <summary>
    /// SET (1): The Index data can be written if Owner Authorization is provided.
    /// CLEAR (0): Writing of the Index data cannot be authorized with Owner Authorization.
    /// </summary>
    OWNERWRITE = 0x2,
    /// <summary>
    /// SET (1): Authorizations to change the Index contents that require USER role may be provided with an HMAC session or password.
    /// CLEAR (0): Authorizations to change the Index contents that require USER role may not be provided with an HMAC session or password.
    /// </summary>
    AUTHWRITE = 0x4,
    /// <summary>
    /// SET (1): Authorizations to change the Index contents that require USER role may be provided with a policy session.
    /// CLEAR (0): Authorizations to change the Index contents that require USER role may not be provided with a policy session.
    /// NOTE	TPM2_NV_ChangeAuth() always requires that authorization be provided in a policy session.
    /// </summary>
    POLICYWRITE = 0x8,
    /// <summary>
    /// Ordinary  contains data that is opaque to the TPM that can only be modified using TPM2_NV_Write().
    /// </summary>
    ORDINARY = 0x0,
    /// <summary>
    /// Counter  contains an 8-octet value that is to be used as a counter and can only be modified with TPM2_NV_Increment()
    /// </summary>
    COUNTER = 0x10,
    /// <summary>
    /// Bit Field  contains an 8-octet value to be used as a bit field and can only be modified with TPM2_NV_SetBits().
    /// </summary>
    BITS = 0x20,
    /// <summary>
    /// Extend  contains a digest-sized value used like a PCR. The Index can only be modified using TPM2_NV_Extend(). The extend will use the nameAlg of the Index.
    /// </summary>
    EXTEND = 0x40,
    /// <summary>
    /// PIN Fail - contains pinCount that increments on a PIN authorization failure and a pinLimit
    /// </summary>
    PIN_FAIL = 0x80,
    /// <summary>
    /// PIN Pass - contains pinCount that increments on a PIN authorization success and a pinLimit
    /// </summary>
    PIN_PASS = 0x90,
    /// <summary>
    /// The type of the index. NOTE A TPM is not required to support all TPM_NT values
    /// </summary>
    TpmNt_BIT_MASK = 0x000000F0,
    TpmNt_BIT_OFFSET = 4,
    TpmNt_BIT_LENGTH = 4,
    TpmNt_BIT_0 = 0x10,
    TpmNt_BIT_1 = 0x20,
    TpmNt_BIT_2 = 0x40,
    TpmNt_BIT_3 = 0x80,
    /// <summary>
    /// SET (1): Index may not be deleted unless the authPolicy is satisfied using TPM2_NV_UndefineSpaceSpecial().
    /// CLEAR (0): Index may be deleted with proper platform or owner authorization using TPM2_NV_UndefineSpace(). NOTE An Index with this attribute and a policy that cannot be satisfied (e.g., an Empty Policy) cannot be deleted.
    /// </summary>
    POLICY_DELETE = 0x400,
    /// <summary>
    /// SET (1): Index cannot be written.
    /// CLEAR (0): Index can be written.
    /// </summary>
    WRITELOCKED = 0x800,
    /// <summary>
    /// SET (1): A partial write of the Index data is not allowed. The write size shall match the defined space size.
    /// CLEAR (0): Partial writes are allowed. This setting is required if the .dataSize of the Index is larger than NV_MAX_BUFFER_SIZE for the implementation.
    /// </summary>
    WRITEALL = 0x1000,
    /// <summary>
    /// SET (1): TPM2_NV_WriteLock() may be used to prevent further writes to this location.
    /// CLEAR (0): TPM2_NV_WriteLock() does not block subsequent writes if TPMA_NV_WRITE_STCLEAR is also CLEAR.
    /// </summary>
    WRITEDEFINE = 0x2000,
    /// <summary>
    /// SET (1): TPM2_NV_WriteLock() may be used to prevent further writes to this location until the next TPM Reset or TPM Restart.
    /// CLEAR (0): TPM2_NV_WriteLock() does not block subsequent writes if TPMA_NV_WRITEDEFINE is also CLEAR.
    /// </summary>
    WRITE_STCLEAR = 0x4000,
    /// <summary>
    /// SET (1): If TPM2_NV_GlobalWriteLock() is successful, TPMA_NV_WRITELOCKED is set.
    /// CLEAR (0): TPM2_NV_GlobalWriteLock() has no effect on the writing of the data at this Index.
    /// </summary>
    GLOBALLOCK = 0x8000,
    /// <summary>
    /// SET (1): The Index data can be read if Platform Authorization is provided.
    /// CLEAR (0): Reading of the Index data cannot be authorized with Platform Authorization.
    /// </summary>
    PPREAD = 0x10000,
    /// <summary>
    /// SET (1): The Index data can be read if Owner Authorization is provided.
    /// CLEAR (0): Reading of the Index data cannot be authorized with Owner Authorization.
    /// </summary>
    OWNERREAD = 0x20000,
    /// <summary>
    /// SET (1): The Index data may be read if the authValue is provided.
    /// CLEAR (0): Reading of the Index data cannot be authorized with the Index authValue.
    /// </summary>
    AUTHREAD = 0x40000,
    /// <summary>
    /// SET (1): The Index data may be read if the authPolicy is satisfied.
    /// CLEAR (0): Reading of the Index data cannot be authorized with the Index authPolicy.
    /// </summary>
    POLICYREAD = 0x80000,
    /// <summary>
    /// SET (1): Authorization failures of the Index do not affect the DA logic and authorization of the Index is not blocked when the TPM is in Lockout mode.
    /// CLEAR (0): Authorization failures of the Index will increment the authorization failure counter and authorizations of this Index are not allowed when the TPM is in Lockout mode.
    /// </summary>
    NO_DA = 0x2000000,
    /// <summary>
    /// SET (1): NV Index state is only required to be saved when the TPM performs an orderly shutdown (TPM2_Shutdown()).
    /// CLEAR (0): NV Index state is required to be persistent after the command to update the Index completes successfully (that is, the NV update is synchronous with the update command).
    /// </summary>
    ORDERLY = 0x4000000,
    /// <summary>
    /// SET (1): TPMA_NV_WRITTEN for the Index is CLEAR by TPM Reset or TPM Restart.
    /// CLEAR (0): TPMA_NV_WRITTEN is not changed by TPM Restart.
    /// NOTE	This attribute may only be SET if TPM_NT is not TPM_NT_COUNTER.
    /// </summary>
    CLEAR_STCLEAR = 0x8000000,
    /// <summary>
    /// SET (1): Reads of the Index are blocked until the next TPM Reset or TPM Restart.
    /// CLEAR (0): Reads of the Index are allowed if proper authorization is provided.
    /// </summary>
    READLOCKED = 0x10000000,
    /// <summary>
    /// SET (1): Index has been written.
    /// CLEAR (0): Index has not been written.
    /// </summary>
    WRITTEN = 0x20000000,
    /// <summary>
    /// SET (1): This Index may be undefined with Platform Authorization but not with Owner Authorization.
    /// CLEAR (0): This Index may be undefined using Owner Authorization but not with Platform Authorization. The TPM will validate that this attribute is SET when the Index is defined using Platform Authorization and will validate that this attribute is CLEAR when the Index is defined using Owner Authorization.
    /// </summary>
    PLATFORMCREATE = 0x40000000,
    /// <summary>
    /// SET (1): TPM2_NV_ReadLock() may be used to SET TPMA_NV_READLOCKED for this Index.
    /// CLEAR (0): TPM2_NV_ReadLock() has no effect on this Index.
    /// </summary>
    READ_STCLEAR = 0x80000000
};
inline TPMA_NV operator|(TPMA_NV _a, TPMA_NV _b) { return static_cast<TPMA_NV>(static_cast<UINT32>(_a) + static_cast<UINT32>(_b)); }
/// <summary>
/// A common place for algorithm tokens is in a union of values that are dependent on the type of the algorithm
/// (One of [BYTE, BYTE, BYTE, BYTE, BYTE])
/// </summary>
class _DLLEXP_ TPMU_HA: public virtual TpmStructureBase
{
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_HA_ID;};
    public: virtual TpmStructureBase*  Clone() const {_ASSERT(FALSE);return NULL;};
};
/// <summary>
/// Table 88  Definition of TPMU_NAME Union <>
/// (One of [TpmHash, TPM_HANDLE])
/// </summary>
class _DLLEXP_ TPMU_NAME: public virtual TpmStructureBase
{
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_NAME_ID;};
    public: virtual TpmStructureBase*  Clone() const {_ASSERT(FALSE);return NULL;};
};
/// <summary>
/// Table 114  Definition of TPMU_CAPABILITIES Union <OUT>
/// (One of [TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_CC, TPML_PCR_SELECTION, TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE, TPML_TAGGED_POLICY])
/// </summary>
class _DLLEXP_ TPMU_CAPABILITIES: public virtual TpmStructureBase
{
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_CAPABILITIES_ID;};
    public: virtual TpmStructureBase*  Clone() const {_ASSERT(FALSE);return NULL;};
};
/// <summary>
/// Table 127  Definition of TPMU_ATTEST Union <OUT>
/// (One of [TPMS_CERTIFY_INFO, TPMS_CREATION_INFO, TPMS_QUOTE_INFO, TPMS_COMMAND_AUDIT_INFO, TPMS_SESSION_AUDIT_INFO, TPMS_TIME_ATTEST_INFO, TPMS_NV_CERTIFY_INFO, TPMS_NV_DIGEST_CERTIFY_INFO])
/// </summary>
class _DLLEXP_ TPMU_ATTEST: public virtual TpmStructureBase
{
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_ATTEST_ID;};
    public: virtual TpmStructureBase*  Clone() const {_ASSERT(FALSE);return NULL;};
};
/// <summary>
/// This union is used to collect the symmetric encryption key sizes.
/// (One of [TPMI_TDES_KEY_BITS, TPMI_AES_KEY_BITS, TPMI_SM4_KEY_BITS, TPMI_CAMELLIA_KEY_BITS, TPM_KEY_BITS, TPMI_ALG_HASH, TPMS_NULL_SYM_KEY_BITS])
/// </summary>
class _DLLEXP_ TPMU_SYM_KEY_BITS: public virtual TpmStructureBase
{
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_SYM_KEY_BITS_ID;};
    public: virtual TpmStructureBase*  Clone() const {_ASSERT(FALSE);return NULL;};
};
/// <summary>
/// This is the union of all modes for all symmetric algorithms.
/// (One of [TPMI_ALG_SYM_MODE, TPMI_ALG_SYM_MODE, TPMI_ALG_SYM_MODE, TPMI_ALG_SYM_MODE, TPMI_ALG_SYM_MODE, TPMS_XOR_SYM_MODE, TPMS_NULL_SYM_MODE])
/// </summary>
class _DLLEXP_ TPMU_SYM_MODE: public virtual TpmStructureBase
{
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_SYM_MODE_ID;};
    public: virtual TpmStructureBase*  Clone() const {_ASSERT(FALSE);return NULL;};
};
/// <summary>
/// This union allows additional parameters to be added for a symmetric cipher. Currently, no additional parameters are required for any of the symmetric algorithms.
/// (One of [TPMS_TDES_SYM_DETAILS, TPMS_AES_SYM_DETAILS, TPMS_SM4_SYM_DETAILS, TPMS_CAMELLIA_SYM_DETAILS, TPMS_ANY_SYM_DETAILS, TPMS_XOR_SYM_DETAILS, TPMS_NULL_SYM_DETAILS])
/// </summary>
class _DLLEXP_ TPMU_SYM_DETAILS: public virtual TpmStructureBase
{
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_SYM_DETAILS_ID;};
    public: virtual TpmStructureBase*  Clone() const {_ASSERT(FALSE);return NULL;};
};
/// <summary>
/// This structure allows a TPM2B_SENSITIVE_CREATE structure to carry either a TPM2B_SENSITVE_DATA or a TPM2B_DERIVE structure. The contents of the union are determined by context. When an object is being derived, the derivation values are present.
/// (One of [BYTE, TPMS_DERIVE])
/// </summary>
class _DLLEXP_ TPMU_SENSITIVE_CREATE: public virtual TpmStructureBase
{
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_SENSITIVE_CREATE_ID;};
    public: virtual TpmStructureBase*  Clone() const {_ASSERT(FALSE);return NULL;};
};
/// <summary>
/// Table 152  Definition of TPMU_SCHEME_KEYEDHASH Union <IN/OUT, S>
/// (One of [TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH])
/// </summary>
class _DLLEXP_ TPMU_SCHEME_KEYEDHASH: public virtual TpmStructureBase
{
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_SCHEME_KEYEDHASH_ID;};
    public: virtual TpmStructureBase*  Clone() const {_ASSERT(FALSE);return NULL;};
};
/// <summary>
/// This is the union of all of the signature schemes.
/// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
/// </summary>
class _DLLEXP_ TPMU_SIG_SCHEME: public virtual TpmStructureBase
{
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_SIG_SCHEME_ID;};
    public: virtual TpmStructureBase*  Clone() const {_ASSERT(FALSE);return NULL;};
};
/// <summary>
/// Table 161  Definition of TPMU_KDF_SCHEME Union <IN/OUT, S>
/// (One of [TPMS_SCHEME_MGF1, TPMS_SCHEME_KDF1_SP800_56A, TPMS_SCHEME_KDF2, TPMS_SCHEME_KDF1_SP800_108, TPMS_NULL_KDF_SCHEME])
/// </summary>
class _DLLEXP_ TPMU_KDF_SCHEME: public virtual TpmStructureBase
{
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_KDF_SCHEME_ID;};
    public: virtual TpmStructureBase*  Clone() const {_ASSERT(FALSE);return NULL;};
};
/// <summary>
/// This union of all asymmetric schemes is used in each of the asymmetric scheme structures. The actual scheme structure is defined by the interface type used for the selector (TPMI_ALG_ASYM_SCHEME).
/// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
/// </summary>
class _DLLEXP_ TPMU_ASYM_SCHEME: public virtual TpmStructureBase
{
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_ASYM_SCHEME_ID;};
    public: virtual TpmStructureBase*  Clone() const {_ASSERT(FALSE);return NULL;};
};
/// <summary>
/// A TPMU_SIGNATURE_COMPOSITE is a union of the various signatures that are supported by a particular TPM implementation. The union allows substitution of any signature algorithm wherever a signature is required in a structure.
/// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
/// </summary>
class _DLLEXP_ TPMU_SIGNATURE: public virtual TpmStructureBase
{
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_SIGNATURE_ID;};
    public: virtual TpmStructureBase*  Clone() const {_ASSERT(FALSE);return NULL;};
};
/// <summary>
/// This structure is used to hold either an ephemeral public point for ECDH, an OAEP-encrypted block for RSA, or a symmetrically encrypted value. This structure is defined for the limited purpose of determining the size of a TPM2B_ENCRYPTED_SECRET.
/// (One of [BYTE, BYTE, BYTE, BYTE])
/// </summary>
class _DLLEXP_ TPMU_ENCRYPTED_SECRET: public virtual TpmStructureBase
{
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_ENCRYPTED_SECRET_ID;};
    public: virtual TpmStructureBase*  Clone() const {_ASSERT(FALSE);return NULL;};
};
/// <summary>
/// This is the union of all values allowed in in the unique field of a TPMT_PUBLIC.
/// (One of [TPM2B_DIGEST_Keyedhash, TPM2B_DIGEST_Symcipher, TPM2B_PUBLIC_KEY_RSA, TPMS_ECC_POINT, TPMS_DERIVE])
/// </summary>
class _DLLEXP_ TPMU_PUBLIC_ID: public virtual TpmStructureBase
{
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_PUBLIC_ID_ID;};
    public: virtual TpmStructureBase*  Clone() const {_ASSERT(FALSE);return NULL;};
};
/// <summary>
/// Table 194 defines the possible parameter definition structures that may be contained in the public portion of a key. If the Object can be a parent, the first field must be a TPMT_SYM_DEF_OBJECT. See 11.1.7.
/// (One of [TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS, TPMS_ASYM_PARMS])
/// </summary>
class _DLLEXP_ TPMU_PUBLIC_PARMS: public virtual TpmStructureBase
{
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_PUBLIC_PARMS_ID;};
    public: virtual TpmStructureBase*  Clone() const {_ASSERT(FALSE);return NULL;};
};
/// <summary>
/// Table 200  Definition of TPMU_SENSITIVE_COMPOSITE Union <IN/OUT, S>
/// (One of [TPM2B_PRIVATE_KEY_RSA, TPM2B_ECC_PARAMETER, TPM2B_SENSITIVE_DATA, TPM2B_SYM_KEY, TPM2B_PRIVATE_VENDOR_SPECIFIC])
/// </summary>
class _DLLEXP_ TPMU_SENSITIVE_COMPOSITE: public virtual TpmStructureBase
{
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_SENSITIVE_COMPOSITE_ID;};
    public: virtual TpmStructureBase*  Clone() const {_ASSERT(FALSE);return NULL;};
};
/// <summary>
/// Base class for empty union elements.
/// An empty union element does not contain any data to marshal.
/// This data structure can be used in place of any other union
/// initialized with its own empty element.
/// </summary>
class _DLLEXP_ TPMS_NULL_UNION : public virtual TPMU_SYM_KEY_BITS, public virtual TPMU_SYM_MODE, public virtual TPMU_SYM_DETAILS, public virtual TPMU_SCHEME_KEYEDHASH, public virtual TPMU_SIG_SCHEME, public virtual TPMU_KDF_SCHEME, public virtual TPMU_ASYM_SCHEME, public virtual TPMU_SIGNATURE 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_NULL_UNION& operator=(const TPMS_NULL_UNION& rhs);
    public: TPMS_NULL_UNION(const TPMS_NULL_UNION& rhs);
    public:
    TPMS_NULL_UNION();
    virtual ~TPMS_NULL_UNION();
};
/// <summary>
/// TPM Hash structure
/// </summary>
class _DLLEXP_ TPMT_HA : public virtual TPMU_SIGNATURE 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// Algorithm
    /// </summary>
    public: TPM_ALG_ID hashAlg;
    /// <summary>
    /// Hash value
    /// </summary>
    public: std::vector<BYTE> digest;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMT_HA& operator=(const TPMT_HA& rhs);
    public: TPMT_HA(const TPMT_HA& rhs);
    public:
    TPMT_HA();
    virtual ~TPMT_HA();
    /// <summary>
    /// TPM Hash structure
    /// </summary>
    ///<param name = "hashAlg">Algorithm</param>
    ///<param name = "digest">Hash value</param>
    public: TPMT_HA(
        const TPM_ALG_ID& hashAlg,
        const std::vector<BYTE>& digest
    );
#include "Extensions/TPMT_HA.h"
};
/// <summary>
/// TPM object handle (and related data)
/// </summary>
class _DLLEXP_ TPM_HANDLE : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM key handle
    /// </summary>
    public: UINT32 handle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM_HANDLE& operator=(const TPM_HANDLE& rhs);
    public: TPM_HANDLE(const TPM_HANDLE& rhs);
    public:
    TPM_HANDLE();
    virtual ~TPM_HANDLE();
    /// <summary>
    /// TPM object handle (and related data)
    /// </summary>
    ///<param name = "handle">TPM key handle</param>
    public: TPM_HANDLE(
        const UINT32& handle
    );
#include "Extensions/TPM_HANDLE.h"
};
/// <summary>
/// This structure is used as a placeholder. In some cases, a union will have a selector value with no data to unmarshal when that type is selected. Rather than leave the entry empty, TPMS_EMPTY may be selected.
/// </summary>
class _DLLEXP_ TPMS_EMPTY : public virtual TPMU_ASYM_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_EMPTY& operator=(const TPMS_EMPTY& rhs);
    public: TPMS_EMPTY(const TPMS_EMPTY& rhs);
    public:
    TPMS_EMPTY();
    virtual ~TPMS_EMPTY();
};
/// <summary>
/// This structure is a return value for a TPM2_GetCapability() that reads the installed algorithms.
/// </summary>
class _DLLEXP_ TPMS_ALGORITHM_DESCRIPTION : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// an algorithm
    /// </summary>
    public: TPM_ALG_ID alg;
    /// <summary>
    /// the attributes of the algorithm
    /// </summary>
    public: TPMA_ALGORITHM attributes;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_ALGORITHM_DESCRIPTION& operator=(const TPMS_ALGORITHM_DESCRIPTION& rhs);
    public: TPMS_ALGORITHM_DESCRIPTION(const TPMS_ALGORITHM_DESCRIPTION& rhs);
    public:
    TPMS_ALGORITHM_DESCRIPTION();
    virtual ~TPMS_ALGORITHM_DESCRIPTION();
    /// <summary>
    /// This structure is a return value for a TPM2_GetCapability() that reads the installed algorithms.
    /// </summary>
    ///<param name = "alg">an algorithm</param>
    ///<param name = "attributes">the attributes of the algorithm</param>
    public: TPMS_ALGORITHM_DESCRIPTION(
        const TPM_ALG_ID& alg,
        const TPMA_ALGORITHM& attributes
    );
};
/// <summary>
/// This structure is used for a sized buffer that cannot be larger than the largest digest produced by any hash algorithm implemented on the TPM.
/// </summary>
class _DLLEXP_ TPM2B_DIGEST : public virtual TPMU_PUBLIC_ID 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// the buffer area that can be no larger than a digest
    /// </summary>
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_DIGEST& operator=(const TPM2B_DIGEST& rhs);
    public: TPM2B_DIGEST(const TPM2B_DIGEST& rhs);
    public:
    TPM2B_DIGEST();
    virtual ~TPM2B_DIGEST();
    /// <summary>
    /// This structure is used for a sized buffer that cannot be larger than the largest digest produced by any hash algorithm implemented on the TPM.
    /// </summary>
    ///<param name = "buffer">the buffer area that can be no larger than a digest</param>
    public: TPM2B_DIGEST(
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// This structure is used for a data buffer that is required to be no larger than the size of the Name of an object.
/// </summary>
class _DLLEXP_ TPM2B_DATA : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 size;
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_DATA& operator=(const TPM2B_DATA& rhs);
    public: TPM2B_DATA(const TPM2B_DATA& rhs);
    public:
    TPM2B_DATA();
    virtual ~TPM2B_DATA();
    /// <summary>
    /// This structure is used for a data buffer that is required to be no larger than the size of the Name of an object.
    /// </summary>
    ///<param name = "buffer"></param>
    public: TPM2B_DATA(
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// Table 80  Definition of Types for TPM2B_NONCE
/// </summary>
typedef TPM2B_DIGEST TPM2B_NONCE;
/// <summary>
/// This structure is used for an authorization value and limits an authValue to being no larger than the largest digest produced by a TPM. In order to ensure consistency within an object, the authValue may be no larger than the size of the digest produced by the objects nameAlg. This ensures that any TPM that can load the object will be able to handle the authValue of the object.
/// </summary>
typedef TPM2B_DIGEST TPM2B_AUTH;
/// <summary>
/// This type is a sized buffer that can hold an operand for a comparison with an NV Index location. The maximum size of the operand is implementation dependent but a TPM is required to support an operand size that is at least as big as the digest produced by any of the hash algorithms implemented on the TPM.
/// </summary>
typedef TPM2B_DIGEST TPM2B_OPERAND;
/// <summary>
/// This type is a sized buffer that can hold event data.
/// </summary>
class _DLLEXP_ TPM2B_EVENT : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the operand buffer
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// the operand
    /// </summary>
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_EVENT& operator=(const TPM2B_EVENT& rhs);
    public: TPM2B_EVENT(const TPM2B_EVENT& rhs);
    public:
    TPM2B_EVENT();
    virtual ~TPM2B_EVENT();
    /// <summary>
    /// This type is a sized buffer that can hold event data.
    /// </summary>
    ///<param name = "buffer">the operand</param>
    public: TPM2B_EVENT(
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// This type is a sized buffer that can hold a maximally sized buffer for commands that use a large data buffer such as TPM2_Hash(), TPM2_SequenceUpdate(), or TPM2_FieldUpgradeData().
/// </summary>
class _DLLEXP_ TPM2B_MAX_BUFFER : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// the operand
    /// </summary>
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_MAX_BUFFER& operator=(const TPM2B_MAX_BUFFER& rhs);
    public: TPM2B_MAX_BUFFER(const TPM2B_MAX_BUFFER& rhs);
    public:
    TPM2B_MAX_BUFFER();
    virtual ~TPM2B_MAX_BUFFER();
    /// <summary>
    /// This type is a sized buffer that can hold a maximally sized buffer for commands that use a large data buffer such as TPM2_Hash(), TPM2_SequenceUpdate(), or TPM2_FieldUpgradeData().
    /// </summary>
    ///<param name = "buffer">the operand</param>
    public: TPM2B_MAX_BUFFER(
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// This type is a sized buffer that can hold a maximally sized buffer for NV data commands such as TPM2_NV_Read(), TPM2_NV_Write(), and TPM2_NV_Certify().
/// </summary>
class _DLLEXP_ TPM2B_MAX_NV_BUFFER : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// the operand NOTE	MAX_NV_BUFFER_SIZE is TPM-dependent
    /// </summary>
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_MAX_NV_BUFFER& operator=(const TPM2B_MAX_NV_BUFFER& rhs);
    public: TPM2B_MAX_NV_BUFFER(const TPM2B_MAX_NV_BUFFER& rhs);
    public:
    TPM2B_MAX_NV_BUFFER();
    virtual ~TPM2B_MAX_NV_BUFFER();
    /// <summary>
    /// This type is a sized buffer that can hold a maximally sized buffer for NV data commands such as TPM2_NV_Read(), TPM2_NV_Write(), and TPM2_NV_Certify().
    /// </summary>
    ///<param name = "buffer">the operand NOTE	MAX_NV_BUFFER_SIZE is TPM-dependent</param>
    public: TPM2B_MAX_NV_BUFFER(
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// This TPM-dependent structure is used to provide the timeout value for an authorization. The size shall be 8 or less.
/// </summary>
class _DLLEXP_ TPM2B_TIMEOUT : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the timeout value
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// the timeout value
    /// </summary>
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_TIMEOUT& operator=(const TPM2B_TIMEOUT& rhs);
    public: TPM2B_TIMEOUT(const TPM2B_TIMEOUT& rhs);
    public:
    TPM2B_TIMEOUT();
    virtual ~TPM2B_TIMEOUT();
    /// <summary>
    /// This TPM-dependent structure is used to provide the timeout value for an authorization. The size shall be 8 or less.
    /// </summary>
    ///<param name = "buffer">the timeout value</param>
    public: TPM2B_TIMEOUT(
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// This structure is used for passing an initial value for a symmetric block cipher to or from the TPM. The size is set to be the largest block size of any implemented symmetric cipher implemented on the TPM.
/// </summary>
class _DLLEXP_ TPM2B_IV : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the IV value
    /// This value is fixed for a TPM implementation.
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// the IV value
    /// </summary>
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_IV& operator=(const TPM2B_IV& rhs);
    public: TPM2B_IV(const TPM2B_IV& rhs);
    public:
    TPM2B_IV();
    virtual ~TPM2B_IV();
    /// <summary>
    /// This structure is used for passing an initial value for a symmetric block cipher to or from the TPM. The size is set to be the largest block size of any implemented symmetric cipher implemented on the TPM.
    /// </summary>
    ///<param name = "buffer">the IV value</param>
    public: TPM2B_IV(
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// This buffer holds a Name for any entity type.
/// </summary>
class _DLLEXP_ TPM2B_NAME : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// the Name structure
    /// </summary>
    public: std::vector<BYTE> name;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_NAME& operator=(const TPM2B_NAME& rhs);
    public: TPM2B_NAME(const TPM2B_NAME& rhs);
    public:
    TPM2B_NAME();
    virtual ~TPM2B_NAME();
    /// <summary>
    /// This buffer holds a Name for any entity type.
    /// </summary>
    ///<param name = "name">the Name structure</param>
    public: TPM2B_NAME(
        const std::vector<BYTE>& name
    );
};
/// <summary>
/// This structure provides a standard method of specifying a list of PCR.
/// </summary>
class _DLLEXP_ TPMS_PCR_SELECT : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the size in octets of the pcrSelect array
    /// </summary>
    protected: mutable byte sizeofSelect;
    /// <summary>
    /// the bit map of selected PCR
    /// </summary>
    public: std::vector<BYTE> pcrSelect;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_PCR_SELECT& operator=(const TPMS_PCR_SELECT& rhs);
    public: TPMS_PCR_SELECT(const TPMS_PCR_SELECT& rhs);
    public:
    TPMS_PCR_SELECT();
    virtual ~TPMS_PCR_SELECT();
    /// <summary>
    /// This structure provides a standard method of specifying a list of PCR.
    /// </summary>
    ///<param name = "pcrSelect">the bit map of selected PCR</param>
    public: TPMS_PCR_SELECT(
        const std::vector<BYTE>& pcrSelect
    );
};
/// <summary>
/// Table 91  Definition of TPMS_PCR_SELECTION Structure
/// </summary>
class _DLLEXP_ TPMS_PCR_SELECTION : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the hash algorithm associated with the selection
    /// </summary>
    public: TPM_ALG_ID hash;
    /// <summary>
    /// the size in octets of the pcrSelect array
    /// </summary>
    protected: mutable byte sizeofSelect;
    /// <summary>
    /// the bit map of selected PCR
    /// </summary>
    public: std::vector<BYTE> pcrSelect;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_PCR_SELECTION& operator=(const TPMS_PCR_SELECTION& rhs);
    public: TPMS_PCR_SELECTION(const TPMS_PCR_SELECTION& rhs);
    public:
    TPMS_PCR_SELECTION();
    virtual ~TPMS_PCR_SELECTION();
    /// <summary>
    /// Table 91  Definition of TPMS_PCR_SELECTION Structure
    /// </summary>
    ///<param name = "hash">the hash algorithm associated with the selection</param>
    ///<param name = "pcrSelect">the bit map of selected PCR</param>
    public: TPMS_PCR_SELECTION(
        const TPM_ALG_ID& hash,
        const std::vector<BYTE>& pcrSelect
    );
#include "Extensions/TPMS_PCR_SELECTION.h"
};
/// <summary>
/// This ticket is produced by TPM2_Create() or TPM2_CreatePrimary(). It is used to bind the creation data to the object to which it applies. The ticket is computed by
/// </summary>
class _DLLEXP_ TPMT_TK_CREATION : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// ticket structure tag
    /// </summary>
    public: TPM_ST tag;
    /// <summary>
    /// the hierarchy containing name
    /// </summary>
    public: TPM_HANDLE hierarchy;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 digestSize;
    /// <summary>
    /// This shall be the HMAC produced using a proof value of hierarchy.
    /// </summary>
    public: std::vector<BYTE> digest;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMT_TK_CREATION& operator=(const TPMT_TK_CREATION& rhs);
    public: TPMT_TK_CREATION(const TPMT_TK_CREATION& rhs);
    public:
    TPMT_TK_CREATION();
    virtual ~TPMT_TK_CREATION();
    /// <summary>
    /// This ticket is produced by TPM2_Create() or TPM2_CreatePrimary(). It is used to bind the creation data to the object to which it applies. The ticket is computed by
    /// </summary>
    ///<param name = "tag">ticket structure tag</param>
    ///<param name = "hierarchy">the hierarchy containing name</param>
    ///<param name = "digest">This shall be the HMAC produced using a proof value of hierarchy.</param>
    public: TPMT_TK_CREATION(
        const TPM_ST& tag,
        const TPM_HANDLE& hierarchy,
        const std::vector<BYTE>& digest
    );
};
/// <summary>
/// This ticket is produced by TPM2_VerifySignature(). This formulation is used for multiple ticket uses. The ticket provides evidence that the TPM has validated that a digest was signed by a key with the Name of keyName. The ticket is computed by
/// </summary>
class _DLLEXP_ TPMT_TK_VERIFIED : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// ticket structure tag
    /// </summary>
    public: TPM_ST tag;
    /// <summary>
    /// the hierarchy containing keyName
    /// </summary>
    public: TPM_HANDLE hierarchy;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 digestSize;
    /// <summary>
    /// This shall be the HMAC produced using a proof value of hierarchy.
    /// </summary>
    public: std::vector<BYTE> digest;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMT_TK_VERIFIED& operator=(const TPMT_TK_VERIFIED& rhs);
    public: TPMT_TK_VERIFIED(const TPMT_TK_VERIFIED& rhs);
    public:
    TPMT_TK_VERIFIED();
    virtual ~TPMT_TK_VERIFIED();
    /// <summary>
    /// This ticket is produced by TPM2_VerifySignature(). This formulation is used for multiple ticket uses. The ticket provides evidence that the TPM has validated that a digest was signed by a key with the Name of keyName. The ticket is computed by
    /// </summary>
    ///<param name = "tag">ticket structure tag</param>
    ///<param name = "hierarchy">the hierarchy containing keyName</param>
    ///<param name = "digest">This shall be the HMAC produced using a proof value of hierarchy.</param>
    public: TPMT_TK_VERIFIED(
        const TPM_ST& tag,
        const TPM_HANDLE& hierarchy,
        const std::vector<BYTE>& digest
    );
};
/// <summary>
/// This ticket is produced by TPM2_PolicySigned() and TPM2_PolicySecret() when the authorization has an expiration time. If nonceTPM was provided in the policy command, the ticket is computed by
/// </summary>
class _DLLEXP_ TPMT_TK_AUTH : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// ticket structure tag
    /// </summary>
    public: TPM_ST tag;
    /// <summary>
    /// the hierarchy of the object used to produce the ticket
    /// </summary>
    public: TPM_HANDLE hierarchy;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 digestSize;
    /// <summary>
    /// This shall be the HMAC produced using a proof value of hierarchy.
    /// </summary>
    public: std::vector<BYTE> digest;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMT_TK_AUTH& operator=(const TPMT_TK_AUTH& rhs);
    public: TPMT_TK_AUTH(const TPMT_TK_AUTH& rhs);
    public:
    TPMT_TK_AUTH();
    virtual ~TPMT_TK_AUTH();
    /// <summary>
    /// This ticket is produced by TPM2_PolicySigned() and TPM2_PolicySecret() when the authorization has an expiration time. If nonceTPM was provided in the policy command, the ticket is computed by
    /// </summary>
    ///<param name = "tag">ticket structure tag</param>
    ///<param name = "hierarchy">the hierarchy of the object used to produce the ticket</param>
    ///<param name = "digest">This shall be the HMAC produced using a proof value of hierarchy.</param>
    public: TPMT_TK_AUTH(
        const TPM_ST& tag,
        const TPM_HANDLE& hierarchy,
        const std::vector<BYTE>& digest
    );
};
/// <summary>
/// This ticket is produced by TPM2_SequenceComplete() or TPM2_Hash() when the message that was digested did not start with TPM_GENERATED_VALUE. The ticket is computed by
/// </summary>
class _DLLEXP_ TPMT_TK_HASHCHECK : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// ticket structure tag
    /// </summary>
    public: TPM_ST tag;
    /// <summary>
    /// the hierarchy
    /// </summary>
    public: TPM_HANDLE hierarchy;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 digestSize;
    /// <summary>
    /// This shall be the HMAC produced using a proof value of hierarchy.
    /// </summary>
    public: std::vector<BYTE> digest;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMT_TK_HASHCHECK& operator=(const TPMT_TK_HASHCHECK& rhs);
    public: TPMT_TK_HASHCHECK(const TPMT_TK_HASHCHECK& rhs);
    public:
    TPMT_TK_HASHCHECK();
    virtual ~TPMT_TK_HASHCHECK();
    /// <summary>
    /// This ticket is produced by TPM2_SequenceComplete() or TPM2_Hash() when the message that was digested did not start with TPM_GENERATED_VALUE. The ticket is computed by
    /// </summary>
    ///<param name = "tag">ticket structure tag</param>
    ///<param name = "hierarchy">the hierarchy</param>
    ///<param name = "digest">This shall be the HMAC produced using a proof value of hierarchy.</param>
    public: TPMT_TK_HASHCHECK(
        const TPM_ST& tag,
        const TPM_HANDLE& hierarchy,
        const std::vector<BYTE>& digest
    );
#include "Extensions/TPMT_TK_HASHCHECK.h"
};
/// <summary>
/// This structure is used to report the properties of an algorithm identifier. It is returned in response to a TPM2_GetCapability() with capability = TPM_CAP_ALG.
/// </summary>
class _DLLEXP_ TPMS_ALG_PROPERTY : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// an algorithm identifier
    /// </summary>
    public: TPM_ALG_ID alg;
    /// <summary>
    /// the attributes of the algorithm
    /// </summary>
    public: TPMA_ALGORITHM algProperties;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_ALG_PROPERTY& operator=(const TPMS_ALG_PROPERTY& rhs);
    public: TPMS_ALG_PROPERTY(const TPMS_ALG_PROPERTY& rhs);
    public:
    TPMS_ALG_PROPERTY();
    virtual ~TPMS_ALG_PROPERTY();
    /// <summary>
    /// This structure is used to report the properties of an algorithm identifier. It is returned in response to a TPM2_GetCapability() with capability = TPM_CAP_ALG.
    /// </summary>
    ///<param name = "alg">an algorithm identifier</param>
    ///<param name = "algProperties">the attributes of the algorithm</param>
    public: TPMS_ALG_PROPERTY(
        const TPM_ALG_ID& alg,
        const TPMA_ALGORITHM& algProperties
    );
};
/// <summary>
/// This structure is used to report the properties that are UINT32 values. It is returned in response to a TPM2_GetCapability().
/// </summary>
class _DLLEXP_ TPMS_TAGGED_PROPERTY : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// a property identifier
    /// </summary>
    public: TPM_PT property;
    /// <summary>
    /// the value of the property
    /// </summary>
    public: UINT32 value;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_TAGGED_PROPERTY& operator=(const TPMS_TAGGED_PROPERTY& rhs);
    public: TPMS_TAGGED_PROPERTY(const TPMS_TAGGED_PROPERTY& rhs);
    public:
    TPMS_TAGGED_PROPERTY();
    virtual ~TPMS_TAGGED_PROPERTY();
    /// <summary>
    /// This structure is used to report the properties that are UINT32 values. It is returned in response to a TPM2_GetCapability().
    /// </summary>
    ///<param name = "property">a property identifier</param>
    ///<param name = "value">the value of the property</param>
    public: TPMS_TAGGED_PROPERTY(
        const TPM_PT& property,
        const UINT32& value
    );
};
/// <summary>
/// This structure is used in TPM2_GetCapability() to return the attributes of the PCR.
/// </summary>
class _DLLEXP_ TPMS_TAGGED_PCR_SELECT : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the property identifier
    /// </summary>
    public: TPM_PT_PCR tag;
    /// <summary>
    /// the size in octets of the pcrSelect array
    /// </summary>
    protected: mutable byte sizeofSelect;
    /// <summary>
    /// the bit map of PCR with the identified property
    /// </summary>
    public: std::vector<BYTE> pcrSelect;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_TAGGED_PCR_SELECT& operator=(const TPMS_TAGGED_PCR_SELECT& rhs);
    public: TPMS_TAGGED_PCR_SELECT(const TPMS_TAGGED_PCR_SELECT& rhs);
    public:
    TPMS_TAGGED_PCR_SELECT();
    virtual ~TPMS_TAGGED_PCR_SELECT();
    /// <summary>
    /// This structure is used in TPM2_GetCapability() to return the attributes of the PCR.
    /// </summary>
    ///<param name = "tag">the property identifier</param>
    ///<param name = "pcrSelect">the bit map of PCR with the identified property</param>
    public: TPMS_TAGGED_PCR_SELECT(
        const TPM_PT_PCR& tag,
        const std::vector<BYTE>& pcrSelect
    );
};
/// <summary>
/// This structure is used in TPM2_GetCapability() to return the policy associated with a permanent handle.
/// </summary>
class _DLLEXP_ TPMS_TAGGED_POLICY : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// a permanent handle
    /// </summary>
    public: TPM_HANDLE handle;
    /// <summary>
    /// the policy algorithm and hash
    /// </summary>
    public: TPMT_HA policyHash;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_TAGGED_POLICY& operator=(const TPMS_TAGGED_POLICY& rhs);
    public: TPMS_TAGGED_POLICY(const TPMS_TAGGED_POLICY& rhs);
    public:
    TPMS_TAGGED_POLICY();
    virtual ~TPMS_TAGGED_POLICY();
    /// <summary>
    /// This structure is used in TPM2_GetCapability() to return the policy associated with a permanent handle.
    /// </summary>
    ///<param name = "handle">a permanent handle</param>
    ///<param name = "policyHash">the policy algorithm and hash</param>
    public: TPMS_TAGGED_POLICY(
        const TPM_HANDLE& handle,
        const TPMT_HA& policyHash
    );
};
/// <summary>
/// A list of command codes may be input to the TPM or returned by the TPM depending on the command.
/// </summary>
class _DLLEXP_ TPML_CC : public virtual TPMU_CAPABILITIES 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of commands in the commandCode list; may be 0
    /// </summary>
    protected: mutable UINT32 count;
    /// <summary>
    /// a list of command codes
    /// The maximum only applies to a command code list in a command. The response size is limited only by the size of the parameter buffer.
    /// </summary>
    public: std::vector<TPM_CC> commandCodes;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPML_CC& operator=(const TPML_CC& rhs);
    public: TPML_CC(const TPML_CC& rhs);
    public:
    TPML_CC();
    virtual ~TPML_CC();
    /// <summary>
    /// A list of command codes may be input to the TPM or returned by the TPM depending on the command.
    /// </summary>
    ///<param name = "commandCodes">a list of command codes The maximum only applies to a command code list in a command. The response size is limited only by the size of the parameter buffer.</param>
    public: TPML_CC(
        const std::vector<TPM_CC>& commandCodes
    );
};
/// <summary>
/// This list is only used in TPM2_GetCapability(capability = TPM_CAP_COMMANDS).
/// </summary>
class _DLLEXP_ TPML_CCA : public virtual TPMU_CAPABILITIES 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of values in the commandAttributes list; may be 0
    /// </summary>
    protected: mutable UINT32 count;
    /// <summary>
    /// a list of command codes attributes
    /// </summary>
    public: std::vector<TPMA_CC> commandAttributes;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPML_CCA& operator=(const TPML_CCA& rhs);
    public: TPML_CCA(const TPML_CCA& rhs);
    public:
    TPML_CCA();
    virtual ~TPML_CCA();
    /// <summary>
    /// This list is only used in TPM2_GetCapability(capability = TPM_CAP_COMMANDS).
    /// </summary>
    ///<param name = "commandAttributes">a list of command codes attributes</param>
    public: TPML_CCA(
        const std::vector<TPMA_CC>& commandAttributes
    );
};
/// <summary>
/// This list is returned by TPM2_IncrementalSelfTest().
/// </summary>
class _DLLEXP_ TPML_ALG : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of algorithms in the algorithms list; may be 0
    /// </summary>
    protected: mutable UINT32 count;
    /// <summary>
    /// a list of algorithm IDs
    /// The maximum only applies to an algorithm list in a command. The response size is limited only by the size of the parameter buffer.
    /// </summary>
    public: std::vector<TPM_ALG_ID> algorithms;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPML_ALG& operator=(const TPML_ALG& rhs);
    public: TPML_ALG(const TPML_ALG& rhs);
    public:
    TPML_ALG();
    virtual ~TPML_ALG();
    /// <summary>
    /// This list is returned by TPM2_IncrementalSelfTest().
    /// </summary>
    ///<param name = "algorithms">a list of algorithm IDs The maximum only applies to an algorithm list in a command. The response size is limited only by the size of the parameter buffer.</param>
    public: TPML_ALG(
        const std::vector<TPM_ALG_ID>& algorithms
    );
};
/// <summary>
/// This structure is used when the TPM returns a list of loaded handles when the capability in TPM2_GetCapability() is TPM_CAP_HANDLE.
/// </summary>
class _DLLEXP_ TPML_HANDLE : public virtual TPMU_CAPABILITIES 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the number of handles in the list
    /// may have a value of 0
    /// </summary>
    protected: mutable UINT32 count;
    /// <summary>
    /// an array of handles
    /// </summary>
    public: std::vector<TPM_HANDLE> handle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPML_HANDLE& operator=(const TPML_HANDLE& rhs);
    public: TPML_HANDLE(const TPML_HANDLE& rhs);
    public:
    TPML_HANDLE();
    virtual ~TPML_HANDLE();
    /// <summary>
    /// This structure is used when the TPM returns a list of loaded handles when the capability in TPM2_GetCapability() is TPM_CAP_HANDLE.
    /// </summary>
    ///<param name = "handle">an array of handles</param>
    public: TPML_HANDLE(
        const std::vector<TPM_HANDLE>& handle
    );
};
/// <summary>
/// This list is used to convey a list of digest values. This type is used in TPM2_PolicyOR() and in TPM2_PCR_Read().
/// </summary>
class _DLLEXP_ TPML_DIGEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of digests in the list, minimum is two for TPM2_PolicyOR().
    /// </summary>
    protected: mutable UINT32 count;
    /// <summary>
    /// a list of digests
    /// For TPM2_PolicyOR(), all digests will have been computed using the digest of the policy session. For TPM2_PCR_Read(), each digest will be the size of the digest for the bank containing the PCR.
    /// </summary>
    public: std::vector<TPM2B_DIGEST> digests;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPML_DIGEST& operator=(const TPML_DIGEST& rhs);
    public: TPML_DIGEST(const TPML_DIGEST& rhs);
    public:
    TPML_DIGEST();
    virtual ~TPML_DIGEST();
    /// <summary>
    /// This list is used to convey a list of digest values. This type is used in TPM2_PolicyOR() and in TPM2_PCR_Read().
    /// </summary>
    ///<param name = "digests">a list of digests For TPM2_PolicyOR(), all digests will have been computed using the digest of the policy session. For TPM2_PCR_Read(), each digest will be the size of the digest for the bank containing the PCR.</param>
    public: TPML_DIGEST(
        const std::vector<TPM2B_DIGEST>& digests
    );
};
/// <summary>
/// This list is used to convey a list of digest values. This type is returned by TPM2_Event() and TPM2_SequenceComplete() and is an input for TPM2_PCR_Extend().
/// </summary>
class _DLLEXP_ TPML_DIGEST_VALUES : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of digests in the list
    /// </summary>
    protected: mutable UINT32 count;
    /// <summary>
    /// a list of tagged digests
    /// </summary>
    public: std::vector<TPMT_HA> digests;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPML_DIGEST_VALUES& operator=(const TPML_DIGEST_VALUES& rhs);
    public: TPML_DIGEST_VALUES(const TPML_DIGEST_VALUES& rhs);
    public:
    TPML_DIGEST_VALUES();
    virtual ~TPML_DIGEST_VALUES();
    /// <summary>
    /// This list is used to convey a list of digest values. This type is returned by TPM2_Event() and TPM2_SequenceComplete() and is an input for TPM2_PCR_Extend().
    /// </summary>
    ///<param name = "digests">a list of tagged digests</param>
    public: TPML_DIGEST_VALUES(
        const std::vector<TPMT_HA>& digests
    );
};
/// <summary>
/// This list is used to indicate the PCR that are included in a selection when more than one PCR value may be selected.
/// </summary>
class _DLLEXP_ TPML_PCR_SELECTION : public virtual TPMU_CAPABILITIES 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 count;
    /// <summary>
    /// list of selections
    /// </summary>
    public: std::vector<TPMS_PCR_SELECTION> pcrSelections;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPML_PCR_SELECTION& operator=(const TPML_PCR_SELECTION& rhs);
    public: TPML_PCR_SELECTION(const TPML_PCR_SELECTION& rhs);
    public:
    TPML_PCR_SELECTION();
    virtual ~TPML_PCR_SELECTION();
    /// <summary>
    /// This list is used to indicate the PCR that are included in a selection when more than one PCR value may be selected.
    /// </summary>
    ///<param name = "pcrSelections">list of selections</param>
    public: TPML_PCR_SELECTION(
        const std::vector<TPMS_PCR_SELECTION>& pcrSelections
    );
};
/// <summary>
/// This list is used to report on a list of algorithm attributes. It is returned in a TPM2_GetCapability().
/// </summary>
class _DLLEXP_ TPML_ALG_PROPERTY : public virtual TPMU_CAPABILITIES 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of algorithm properties structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 count;
    /// <summary>
    /// list of properties
    /// </summary>
    public: std::vector<TPMS_ALG_PROPERTY> algProperties;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPML_ALG_PROPERTY& operator=(const TPML_ALG_PROPERTY& rhs);
    public: TPML_ALG_PROPERTY(const TPML_ALG_PROPERTY& rhs);
    public:
    TPML_ALG_PROPERTY();
    virtual ~TPML_ALG_PROPERTY();
    /// <summary>
    /// This list is used to report on a list of algorithm attributes. It is returned in a TPM2_GetCapability().
    /// </summary>
    ///<param name = "algProperties">list of properties</param>
    public: TPML_ALG_PROPERTY(
        const std::vector<TPMS_ALG_PROPERTY>& algProperties
    );
};
/// <summary>
/// This list is used to report on a list of properties that are TPMS_TAGGED_PROPERTY values. It is returned by a TPM2_GetCapability().
/// </summary>
class _DLLEXP_ TPML_TAGGED_TPM_PROPERTY : public virtual TPMU_CAPABILITIES 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of properties
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 count;
    /// <summary>
    /// an array of tagged properties
    /// </summary>
    public: std::vector<TPMS_TAGGED_PROPERTY> tpmProperty;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPML_TAGGED_TPM_PROPERTY& operator=(const TPML_TAGGED_TPM_PROPERTY& rhs);
    public: TPML_TAGGED_TPM_PROPERTY(const TPML_TAGGED_TPM_PROPERTY& rhs);
    public:
    TPML_TAGGED_TPM_PROPERTY();
    virtual ~TPML_TAGGED_TPM_PROPERTY();
    /// <summary>
    /// This list is used to report on a list of properties that are TPMS_TAGGED_PROPERTY values. It is returned by a TPM2_GetCapability().
    /// </summary>
    ///<param name = "tpmProperty">an array of tagged properties</param>
    public: TPML_TAGGED_TPM_PROPERTY(
        const std::vector<TPMS_TAGGED_PROPERTY>& tpmProperty
    );
};
/// <summary>
/// This list is used to report on a list of properties that are TPMS_PCR_SELECT values. It is returned by a TPM2_GetCapability().
/// </summary>
class _DLLEXP_ TPML_TAGGED_PCR_PROPERTY : public virtual TPMU_CAPABILITIES 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of properties
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 count;
    /// <summary>
    /// a tagged PCR selection
    /// </summary>
    public: std::vector<TPMS_TAGGED_PCR_SELECT> pcrProperty;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPML_TAGGED_PCR_PROPERTY& operator=(const TPML_TAGGED_PCR_PROPERTY& rhs);
    public: TPML_TAGGED_PCR_PROPERTY(const TPML_TAGGED_PCR_PROPERTY& rhs);
    public:
    TPML_TAGGED_PCR_PROPERTY();
    virtual ~TPML_TAGGED_PCR_PROPERTY();
    /// <summary>
    /// This list is used to report on a list of properties that are TPMS_PCR_SELECT values. It is returned by a TPM2_GetCapability().
    /// </summary>
    ///<param name = "pcrProperty">a tagged PCR selection</param>
    public: TPML_TAGGED_PCR_PROPERTY(
        const std::vector<TPMS_TAGGED_PCR_SELECT>& pcrProperty
    );
};
/// <summary>
/// This list is used to report the ECC curve ID values supported by the TPM. It is returned by a TPM2_GetCapability().
/// </summary>
class _DLLEXP_ TPML_ECC_CURVE : public virtual TPMU_CAPABILITIES 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of curves
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 count;
    /// <summary>
    /// array of ECC curve identifiers
    /// </summary>
    public: std::vector<TPM_ECC_CURVE> eccCurves;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPML_ECC_CURVE& operator=(const TPML_ECC_CURVE& rhs);
    public: TPML_ECC_CURVE(const TPML_ECC_CURVE& rhs);
    public:
    TPML_ECC_CURVE();
    virtual ~TPML_ECC_CURVE();
    /// <summary>
    /// This list is used to report the ECC curve ID values supported by the TPM. It is returned by a TPM2_GetCapability().
    /// </summary>
    ///<param name = "eccCurves">array of ECC curve identifiers</param>
    public: TPML_ECC_CURVE(
        const std::vector<TPM_ECC_CURVE>& eccCurves
    );
};
/// <summary>
/// This list is used to report the authorization policy values for permanent handles. This is list may be generated by TPM2_GetCapabiltiy(). A permanent handle that cannot have a policy is not included in the list.
/// </summary>
class _DLLEXP_ TPML_TAGGED_POLICY : public virtual TPMU_CAPABILITIES 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of tagged policies
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 count;
    /// <summary>
    /// array of tagged policies
    /// </summary>
    public: std::vector<TPMS_TAGGED_POLICY> policies;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPML_TAGGED_POLICY& operator=(const TPML_TAGGED_POLICY& rhs);
    public: TPML_TAGGED_POLICY(const TPML_TAGGED_POLICY& rhs);
    public:
    TPML_TAGGED_POLICY();
    virtual ~TPML_TAGGED_POLICY();
    /// <summary>
    /// This list is used to report the authorization policy values for permanent handles. This is list may be generated by TPM2_GetCapabiltiy(). A permanent handle that cannot have a policy is not included in the list.
    /// </summary>
    ///<param name = "policies">array of tagged policies</param>
    public: TPML_TAGGED_POLICY(
        const std::vector<TPMS_TAGGED_POLICY>& policies
    );
};
/// <summary>
/// This data area is returned in response to a TPM2_GetCapability().
/// </summary>
class _DLLEXP_ TPMS_CAPABILITY_DATA : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the capability
    /// </summary>
    protected: mutable TPM_CAP capability;
    /// <summary>
    /// the capability data
    /// (One of [TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_CC, TPML_PCR_SELECTION, TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE, TPML_TAGGED_POLICY])
    /// </summary>
    public: TPMU_CAPABILITIES* data;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_CAPABILITY_DATA& operator=(const TPMS_CAPABILITY_DATA& rhs);
    public: TPMS_CAPABILITY_DATA(const TPMS_CAPABILITY_DATA& rhs);
    public:
    TPMS_CAPABILITY_DATA();
    virtual ~TPMS_CAPABILITY_DATA();
    /// <summary>
    /// This data area is returned in response to a TPM2_GetCapability().
    /// </summary>
    ///<param name = "data">the capability data(One of TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_CC, TPML_PCR_SELECTION, TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE, TPML_TAGGED_POLICY)</param>
    public: TPMS_CAPABILITY_DATA(
        const TPMU_CAPABILITIES& data
    );
};
/// <summary>
/// This structure is used in each of the attestation commands.
/// </summary>
class _DLLEXP_ TPMS_CLOCK_INFO : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// time value in milliseconds that advances while the TPM is powered
    /// NOTE The interpretation of the time-origin (clock=0) is out of the scope of this specification, although Coordinated Universal Time (UTC) is expected to be a common convention. This structure element is used to report on the TPM's Clock value.
    /// This value is reset to zero when the Storage Primary Seed is changed (TPM2_Clear()).
    /// This value may be advanced by TPM2_ClockSet().
    /// </summary>
    public: UINT64 clock;
    /// <summary>
    /// number of occurrences of TPM Reset since the last TPM2_Clear()
    /// </summary>
    public: UINT32 resetCount;
    /// <summary>
    /// number of times that TPM2_Shutdown() or _TPM_Hash_Start have occurred since the last TPM Reset or TPM2_Clear().
    /// </summary>
    public: UINT32 restartCount;
    /// <summary>
    /// no value of Clock greater than the current value of Clock has been previously reported by the TPM. Set to YES on TPM2_Clear().
    /// </summary>
    public: BYTE safe;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_CLOCK_INFO& operator=(const TPMS_CLOCK_INFO& rhs);
    public: TPMS_CLOCK_INFO(const TPMS_CLOCK_INFO& rhs);
    public:
    TPMS_CLOCK_INFO();
    virtual ~TPMS_CLOCK_INFO();
    /// <summary>
    /// This structure is used in each of the attestation commands.
    /// </summary>
    ///<param name = "clock">time value in milliseconds that advances while the TPM is powered NOTE The interpretation of the time-origin (clock=0) is out of the scope of this specification, although Coordinated Universal Time (UTC) is expected to be a common convention. This structure element is used to report on the TPM's Clock value. This value is reset to zero when the Storage Primary Seed is changed (TPM2_Clear()). This value may be advanced by TPM2_ClockSet().</param>
    ///<param name = "resetCount">number of occurrences of TPM Reset since the last TPM2_Clear()</param>
    ///<param name = "restartCount">number of times that TPM2_Shutdown() or _TPM_Hash_Start have occurred since the last TPM Reset or TPM2_Clear().</param>
    ///<param name = "safe">no value of Clock greater than the current value of Clock has been previously reported by the TPM. Set to YES on TPM2_Clear().</param>
    public: TPMS_CLOCK_INFO(
        const UINT64& clock,
        const UINT32& resetCount,
        const UINT32& restartCount,
        const BYTE& safe
    );
};
/// <summary>
/// This structure is used in, e.g., the TPM2_GetTime() attestation and TPM2_ReadClock().
/// </summary>
class _DLLEXP_ TPMS_TIME_INFO : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// time in milliseconds since the TIme circuit was last reset
    /// This structure element is used to report on the TPM's Time value.
    /// </summary>
    public: UINT64 time;
    /// <summary>
    /// a structure containing the clock information
    /// </summary>
    public: TPMS_CLOCK_INFO clockInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_TIME_INFO& operator=(const TPMS_TIME_INFO& rhs);
    public: TPMS_TIME_INFO(const TPMS_TIME_INFO& rhs);
    public:
    TPMS_TIME_INFO();
    virtual ~TPMS_TIME_INFO();
    /// <summary>
    /// This structure is used in, e.g., the TPM2_GetTime() attestation and TPM2_ReadClock().
    /// </summary>
    ///<param name = "time">time in milliseconds since the TIme circuit was last reset This structure element is used to report on the TPM's Time value.</param>
    ///<param name = "clockInfo">a structure containing the clock information</param>
    public: TPMS_TIME_INFO(
        const UINT64& time,
        const TPMS_CLOCK_INFO& clockInfo
    );
};
/// <summary>
/// This structure is used when the TPM performs TPM2_GetTime.
/// </summary>
class _DLLEXP_ TPMS_TIME_ATTEST_INFO : public virtual TPMU_ATTEST 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the Time, Clock, resetCount, restartCount, and Safe indicator
    /// </summary>
    public: TPMS_TIME_INFO time;
    /// <summary>
    /// a TPM vendor-specific value indicating the version number of the firmware
    /// </summary>
    public: UINT64 firmwareVersion;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_TIME_ATTEST_INFO& operator=(const TPMS_TIME_ATTEST_INFO& rhs);
    public: TPMS_TIME_ATTEST_INFO(const TPMS_TIME_ATTEST_INFO& rhs);
    public:
    TPMS_TIME_ATTEST_INFO();
    virtual ~TPMS_TIME_ATTEST_INFO();
    /// <summary>
    /// This structure is used when the TPM performs TPM2_GetTime.
    /// </summary>
    ///<param name = "time">the Time, Clock, resetCount, restartCount, and Safe indicator</param>
    ///<param name = "firmwareVersion">a TPM vendor-specific value indicating the version number of the firmware</param>
    public: TPMS_TIME_ATTEST_INFO(
        const TPMS_TIME_INFO& time,
        const UINT64& firmwareVersion
    );
};
/// <summary>
/// This is the attested data for TPM2_Certify().
/// </summary>
class _DLLEXP_ TPMS_CERTIFY_INFO : public virtual TPMU_ATTEST 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 nameSize;
    /// <summary>
    /// Name of the certified object
    /// </summary>
    public: std::vector<BYTE> name;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 qualifiedNameSize;
    /// <summary>
    /// Qualified Name of the certified object
    /// </summary>
    public: std::vector<BYTE> qualifiedName;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_CERTIFY_INFO& operator=(const TPMS_CERTIFY_INFO& rhs);
    public: TPMS_CERTIFY_INFO(const TPMS_CERTIFY_INFO& rhs);
    public:
    TPMS_CERTIFY_INFO();
    virtual ~TPMS_CERTIFY_INFO();
    /// <summary>
    /// This is the attested data for TPM2_Certify().
    /// </summary>
    ///<param name = "name">Name of the certified object</param>
    ///<param name = "qualifiedName">Qualified Name of the certified object</param>
    public: TPMS_CERTIFY_INFO(
        const std::vector<BYTE>& name,
        const std::vector<BYTE>& qualifiedName
    );
};
/// <summary>
/// This is the attested data for TPM2_Quote().
/// </summary>
class _DLLEXP_ TPMS_QUOTE_INFO : public virtual TPMU_ATTEST 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 pcrSelectCount;
    /// <summary>
    /// information on algID, PCR selected and digest
    /// </summary>
    public: std::vector<TPMS_PCR_SELECTION> pcrSelect;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 pcrDigestSize;
    /// <summary>
    /// digest of the selected PCR using the hash of the signing key
    /// </summary>
    public: std::vector<BYTE> pcrDigest;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_QUOTE_INFO& operator=(const TPMS_QUOTE_INFO& rhs);
    public: TPMS_QUOTE_INFO(const TPMS_QUOTE_INFO& rhs);
    public:
    TPMS_QUOTE_INFO();
    virtual ~TPMS_QUOTE_INFO();
    /// <summary>
    /// This is the attested data for TPM2_Quote().
    /// </summary>
    ///<param name = "pcrSelect">information on algID, PCR selected and digest</param>
    ///<param name = "pcrDigest">digest of the selected PCR using the hash of the signing key</param>
    public: TPMS_QUOTE_INFO(
        const std::vector<TPMS_PCR_SELECTION>& pcrSelect,
        const std::vector<BYTE>& pcrDigest
    );
};
/// <summary>
/// This is the attested data for TPM2_GetCommandAuditDigest().
/// </summary>
class _DLLEXP_ TPMS_COMMAND_AUDIT_INFO : public virtual TPMU_ATTEST 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the monotonic audit counter
    /// </summary>
    public: UINT64 auditCounter;
    /// <summary>
    /// hash algorithm used for the command audit
    /// </summary>
    public: TPM_ALG_ID digestAlg;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 auditDigestSize;
    /// <summary>
    /// the current value of the audit digest
    /// </summary>
    public: std::vector<BYTE> auditDigest;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 commandDigestSize;
    /// <summary>
    /// digest of the command codes being audited using digestAlg
    /// </summary>
    public: std::vector<BYTE> commandDigest;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_COMMAND_AUDIT_INFO& operator=(const TPMS_COMMAND_AUDIT_INFO& rhs);
    public: TPMS_COMMAND_AUDIT_INFO(const TPMS_COMMAND_AUDIT_INFO& rhs);
    public:
    TPMS_COMMAND_AUDIT_INFO();
    virtual ~TPMS_COMMAND_AUDIT_INFO();
    /// <summary>
    /// This is the attested data for TPM2_GetCommandAuditDigest().
    /// </summary>
    ///<param name = "auditCounter">the monotonic audit counter</param>
    ///<param name = "digestAlg">hash algorithm used for the command audit</param>
    ///<param name = "auditDigest">the current value of the audit digest</param>
    ///<param name = "commandDigest">digest of the command codes being audited using digestAlg</param>
    public: TPMS_COMMAND_AUDIT_INFO(
        const UINT64& auditCounter,
        const TPM_ALG_ID& digestAlg,
        const std::vector<BYTE>& auditDigest,
        const std::vector<BYTE>& commandDigest
    );
};
/// <summary>
/// This is the attested data for TPM2_GetSessionAuditDigest().
/// </summary>
class _DLLEXP_ TPMS_SESSION_AUDIT_INFO : public virtual TPMU_ATTEST 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// current exclusive status of the session TRUE if all of the commands recorded in the sessionDigest were executed without any intervening TPM command that did not use this audit session
    /// </summary>
    public: BYTE exclusiveSession;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 sessionDigestSize;
    /// <summary>
    /// the current value of the session audit digest
    /// </summary>
    public: std::vector<BYTE> sessionDigest;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SESSION_AUDIT_INFO& operator=(const TPMS_SESSION_AUDIT_INFO& rhs);
    public: TPMS_SESSION_AUDIT_INFO(const TPMS_SESSION_AUDIT_INFO& rhs);
    public:
    TPMS_SESSION_AUDIT_INFO();
    virtual ~TPMS_SESSION_AUDIT_INFO();
    /// <summary>
    /// This is the attested data for TPM2_GetSessionAuditDigest().
    /// </summary>
    ///<param name = "exclusiveSession">current exclusive status of the session TRUE if all of the commands recorded in the sessionDigest were executed without any intervening TPM command that did not use this audit session</param>
    ///<param name = "sessionDigest">the current value of the session audit digest</param>
    public: TPMS_SESSION_AUDIT_INFO(
        const BYTE& exclusiveSession,
        const std::vector<BYTE>& sessionDigest
    );
};
/// <summary>
/// This is the attested data for TPM2_CertifyCreation().
/// </summary>
class _DLLEXP_ TPMS_CREATION_INFO : public virtual TPMU_ATTEST 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 objectNameSize;
    /// <summary>
    /// Name of the object
    /// </summary>
    public: std::vector<BYTE> objectName;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 creationHashSize;
    /// <summary>
    /// creationHash
    /// </summary>
    public: std::vector<BYTE> creationHash;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_CREATION_INFO& operator=(const TPMS_CREATION_INFO& rhs);
    public: TPMS_CREATION_INFO(const TPMS_CREATION_INFO& rhs);
    public:
    TPMS_CREATION_INFO();
    virtual ~TPMS_CREATION_INFO();
    /// <summary>
    /// This is the attested data for TPM2_CertifyCreation().
    /// </summary>
    ///<param name = "objectName">Name of the object</param>
    ///<param name = "creationHash">creationHash</param>
    public: TPMS_CREATION_INFO(
        const std::vector<BYTE>& objectName,
        const std::vector<BYTE>& creationHash
    );
};
/// <summary>
/// This structure contains the Name and contents of the selected NV Index that is certified by TPM2_NV_Certify().
/// </summary>
class _DLLEXP_ TPMS_NV_CERTIFY_INFO : public virtual TPMU_ATTEST 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 indexNameSize;
    /// <summary>
    /// Name of the NV Index
    /// </summary>
    public: std::vector<BYTE> indexName;
    /// <summary>
    /// the offset parameter of TPM2_NV_Certify()
    /// </summary>
    public: UINT16 offset;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 nvContentsSize;
    /// <summary>
    /// contents of the NV Index
    /// </summary>
    public: std::vector<BYTE> nvContents;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_NV_CERTIFY_INFO& operator=(const TPMS_NV_CERTIFY_INFO& rhs);
    public: TPMS_NV_CERTIFY_INFO(const TPMS_NV_CERTIFY_INFO& rhs);
    public:
    TPMS_NV_CERTIFY_INFO();
    virtual ~TPMS_NV_CERTIFY_INFO();
    /// <summary>
    /// This structure contains the Name and contents of the selected NV Index that is certified by TPM2_NV_Certify().
    /// </summary>
    ///<param name = "indexName">Name of the NV Index</param>
    ///<param name = "offset">the offset parameter of TPM2_NV_Certify()</param>
    ///<param name = "nvContents">contents of the NV Index</param>
    public: TPMS_NV_CERTIFY_INFO(
        const std::vector<BYTE>& indexName,
        const UINT16& offset,
        const std::vector<BYTE>& nvContents
    );
};
/// <summary>
/// This structure contains the Name and hash of the contents of the selected NV Index that is certified by TPM2_NV_Certify(). The data is hashed using hash of the signing scheme.
/// </summary>
class _DLLEXP_ TPMS_NV_DIGEST_CERTIFY_INFO : public virtual TPMU_ATTEST 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 indexNameSize;
    /// <summary>
    /// Name of the NV Index
    /// </summary>
    public: std::vector<BYTE> indexName;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 nvDigestSize;
    /// <summary>
    /// hash of the contents of the index
    /// </summary>
    public: std::vector<BYTE> nvDigest;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_NV_DIGEST_CERTIFY_INFO& operator=(const TPMS_NV_DIGEST_CERTIFY_INFO& rhs);
    public: TPMS_NV_DIGEST_CERTIFY_INFO(const TPMS_NV_DIGEST_CERTIFY_INFO& rhs);
    public:
    TPMS_NV_DIGEST_CERTIFY_INFO();
    virtual ~TPMS_NV_DIGEST_CERTIFY_INFO();
    /// <summary>
    /// This structure contains the Name and hash of the contents of the selected NV Index that is certified by TPM2_NV_Certify(). The data is hashed using hash of the signing scheme.
    /// </summary>
    ///<param name = "indexName">Name of the NV Index</param>
    ///<param name = "nvDigest">hash of the contents of the index</param>
    public: TPMS_NV_DIGEST_CERTIFY_INFO(
        const std::vector<BYTE>& indexName,
        const std::vector<BYTE>& nvDigest
    );
};
/// <summary>
/// This structure is used on each TPM-generated signed structure. The signature is over this structure.
/// </summary>
class _DLLEXP_ TPMS_ATTEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the indication that this structure was created by a TPM (always TPM_GENERATED_VALUE)
    /// </summary>
    public: TPM_GENERATED magic;
    /// <summary>
    /// type of the attestation structure
    /// </summary>
    protected: mutable TPM_ST type;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 qualifiedSignerSize;
    /// <summary>
    /// Qualified Name of the signing key
    /// </summary>
    public: std::vector<BYTE> qualifiedSigner;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 extraDataSize;
    /// <summary>
    /// external information supplied by caller
    /// NOTE	A TPM2B_DATA structure provides room for a digest and a method indicator to indicate the components of the digest. The definition of this method indicator is outside the scope of this specification.
    /// </summary>
    public: std::vector<BYTE> extraData;
    /// <summary>
    /// Clock, resetCount, restartCount, and Safe
    /// </summary>
    public: TPMS_CLOCK_INFO clockInfo;
    /// <summary>
    /// TPM-vendor-specific value identifying the version number of the firmware
    /// </summary>
    public: UINT64 firmwareVersion;
    /// <summary>
    /// the type-specific attestation information
    /// (One of [TPMS_CERTIFY_INFO, TPMS_CREATION_INFO, TPMS_QUOTE_INFO, TPMS_COMMAND_AUDIT_INFO, TPMS_SESSION_AUDIT_INFO, TPMS_TIME_ATTEST_INFO, TPMS_NV_CERTIFY_INFO, TPMS_NV_DIGEST_CERTIFY_INFO])
    /// </summary>
    public: TPMU_ATTEST* attested;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_ATTEST& operator=(const TPMS_ATTEST& rhs);
    public: TPMS_ATTEST(const TPMS_ATTEST& rhs);
    public:
    TPMS_ATTEST();
    virtual ~TPMS_ATTEST();
    /// <summary>
    /// This structure is used on each TPM-generated signed structure. The signature is over this structure.
    /// </summary>
    ///<param name = "magic">the indication that this structure was created by a TPM (always TPM_GENERATED_VALUE)</param>
    ///<param name = "qualifiedSigner">Qualified Name of the signing key</param>
    ///<param name = "extraData">external information supplied by caller NOTE	A TPM2B_DATA structure provides room for a digest and a method indicator to indicate the components of the digest. The definition of this method indicator is outside the scope of this specification.</param>
    ///<param name = "clockInfo">Clock, resetCount, restartCount, and Safe</param>
    ///<param name = "firmwareVersion">TPM-vendor-specific value identifying the version number of the firmware</param>
    ///<param name = "attested">the type-specific attestation information(One of TPMS_CERTIFY_INFO, TPMS_CREATION_INFO, TPMS_QUOTE_INFO, TPMS_COMMAND_AUDIT_INFO, TPMS_SESSION_AUDIT_INFO, TPMS_TIME_ATTEST_INFO, TPMS_NV_CERTIFY_INFO, TPMS_NV_DIGEST_CERTIFY_INFO)</param>
    public: TPMS_ATTEST(
        const TPM_GENERATED& magic,
        const std::vector<BYTE>& qualifiedSigner,
        const std::vector<BYTE>& extraData,
        const TPMS_CLOCK_INFO& clockInfo,
        const UINT64& firmwareVersion,
        const TPMU_ATTEST& attested
    );
};
/// <summary>
/// This sized buffer to contain the signed structure. The attestationData is the signed portion of the structure. The size parameter is not signed.
/// </summary>
class _DLLEXP_ TPM2B_ATTEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the attestationData structure
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// the signed structure
    /// </summary>
    public: TPMS_ATTEST attestationData;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_ATTEST& operator=(const TPM2B_ATTEST& rhs);
    public: TPM2B_ATTEST(const TPM2B_ATTEST& rhs);
    public:
    TPM2B_ATTEST();
    virtual ~TPM2B_ATTEST();
    /// <summary>
    /// This sized buffer to contain the signed structure. The attestationData is the signed portion of the structure. The size parameter is not signed.
    /// </summary>
    ///<param name = "attestationData">the signed structure</param>
    public: TPM2B_ATTEST(
        const TPMS_ATTEST& attestationData
    );
};
/// <summary>
/// This is the format used for each of the authorizations in the session area of a command.
/// </summary>
class _DLLEXP_ TPMS_AUTH_COMMAND : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the session handle
    /// </summary>
    public: TPM_HANDLE sessionHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 nonceSize;
    /// <summary>
    /// the session nonce, may be the Empty Buffer
    /// </summary>
    public: std::vector<BYTE> nonce;
    /// <summary>
    /// the session attributes
    /// </summary>
    public: TPMA_SESSION sessionAttributes;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 hmacSize;
    /// <summary>
    /// either an HMAC, a password, or an EmptyAuth
    /// </summary>
    public: std::vector<BYTE> hmac;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_AUTH_COMMAND& operator=(const TPMS_AUTH_COMMAND& rhs);
    public: TPMS_AUTH_COMMAND(const TPMS_AUTH_COMMAND& rhs);
    public:
    TPMS_AUTH_COMMAND();
    virtual ~TPMS_AUTH_COMMAND();
    /// <summary>
    /// This is the format used for each of the authorizations in the session area of a command.
    /// </summary>
    ///<param name = "sessionHandle">the session handle</param>
    ///<param name = "nonce">the session nonce, may be the Empty Buffer</param>
    ///<param name = "sessionAttributes">the session attributes</param>
    ///<param name = "hmac">either an HMAC, a password, or an EmptyAuth</param>
    public: TPMS_AUTH_COMMAND(
        const TPM_HANDLE& sessionHandle,
        const std::vector<BYTE>& nonce,
        const TPMA_SESSION& sessionAttributes,
        const std::vector<BYTE>& hmac
    );
};
/// <summary>
/// This is the format for each of the authorizations in the session area of the response. If the TPM returns TPM_RC_SUCCESS, then the session area of the response contains the same number of authorizations as the command and the authorizations are in the same order.
/// </summary>
class _DLLEXP_ AUTHResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 nonceSize;
    /// <summary>
    /// the session nonce, may be the Empty Buffer
    /// </summary>
    public: std::vector<BYTE> nonce;
    /// <summary>
    /// the session attributes
    /// </summary>
    public: TPMA_SESSION sessionAttributes;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 hmacSize;
    /// <summary>
    /// either an HMAC or an EmptyAuth
    /// </summary>
    public: std::vector<BYTE> hmac;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: AUTHResponse& operator=(const AUTHResponse& rhs);
    public: AUTHResponse(const AUTHResponse& rhs);
    public:
    AUTHResponse();
    virtual ~AUTHResponse();
    /// <summary>
    /// This is the format for each of the authorizations in the session area of the response. If the TPM returns TPM_RC_SUCCESS, then the session area of the response contains the same number of authorizations as the command and the authorizations are in the same order.
    /// </summary>
    ///<param name = "nonce">the session nonce, may be the Empty Buffer</param>
    ///<param name = "sessionAttributes">the session attributes</param>
    ///<param name = "hmac">either an HMAC or an EmptyAuth</param>
    public: AUTHResponse(
        const std::vector<BYTE>& nonce,
        const TPMA_SESSION& sessionAttributes,
        const std::vector<BYTE>& hmac
    );
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymKeyBits
/// </summary>
class _DLLEXP_ TPMS_NULL_SYM_KEY_BITS : public virtual TPMS_NULL_UNION, public virtual TPMU_SYM_KEY_BITS 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_NULL_SYM_KEY_BITS& operator=(const TPMS_NULL_SYM_KEY_BITS& rhs);
    public: TPMS_NULL_SYM_KEY_BITS(const TPMS_NULL_SYM_KEY_BITS& rhs);
    public:
    TPMS_NULL_SYM_KEY_BITS();
    virtual ~TPMS_NULL_SYM_KEY_BITS();
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymMode
/// </summary>
class _DLLEXP_ TPMS_XOR_SYM_MODE : public virtual TPMS_NULL_UNION, public virtual TPMU_SYM_MODE 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_XOR_SYM_MODE& operator=(const TPMS_XOR_SYM_MODE& rhs);
    public: TPMS_XOR_SYM_MODE(const TPMS_XOR_SYM_MODE& rhs);
    public:
    TPMS_XOR_SYM_MODE();
    virtual ~TPMS_XOR_SYM_MODE();
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymMode
/// </summary>
class _DLLEXP_ TPMS_NULL_SYM_MODE : public virtual TPMS_NULL_UNION, public virtual TPMU_SYM_MODE 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_NULL_SYM_MODE& operator=(const TPMS_NULL_SYM_MODE& rhs);
    public: TPMS_NULL_SYM_MODE(const TPMS_NULL_SYM_MODE& rhs);
    public:
    TPMS_NULL_SYM_MODE();
    virtual ~TPMS_NULL_SYM_MODE();
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_TDES for the union TpmuSymDetails
/// </summary>
class _DLLEXP_ TPMS_TDES_SYM_DETAILS : public virtual TPMS_NULL_UNION, public virtual TPMU_SYM_DETAILS 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_TDES_SYM_DETAILS& operator=(const TPMS_TDES_SYM_DETAILS& rhs);
    public: TPMS_TDES_SYM_DETAILS(const TPMS_TDES_SYM_DETAILS& rhs);
    public:
    TPMS_TDES_SYM_DETAILS();
    virtual ~TPMS_TDES_SYM_DETAILS();
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_AES for the union TpmuSymDetails
/// </summary>
class _DLLEXP_ TPMS_AES_SYM_DETAILS : public virtual TPMS_NULL_UNION, public virtual TPMU_SYM_DETAILS 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_AES_SYM_DETAILS& operator=(const TPMS_AES_SYM_DETAILS& rhs);
    public: TPMS_AES_SYM_DETAILS(const TPMS_AES_SYM_DETAILS& rhs);
    public:
    TPMS_AES_SYM_DETAILS();
    virtual ~TPMS_AES_SYM_DETAILS();
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_SM4 for the union TpmuSymDetails
/// </summary>
class _DLLEXP_ TPMS_SM4_SYM_DETAILS : public virtual TPMS_NULL_UNION, public virtual TPMU_SYM_DETAILS 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SM4_SYM_DETAILS& operator=(const TPMS_SM4_SYM_DETAILS& rhs);
    public: TPMS_SM4_SYM_DETAILS(const TPMS_SM4_SYM_DETAILS& rhs);
    public:
    TPMS_SM4_SYM_DETAILS();
    virtual ~TPMS_SM4_SYM_DETAILS();
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_CAMELLIA for the union TpmuSymDetails
/// </summary>
class _DLLEXP_ TPMS_CAMELLIA_SYM_DETAILS : public virtual TPMS_NULL_UNION, public virtual TPMU_SYM_DETAILS 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_CAMELLIA_SYM_DETAILS& operator=(const TPMS_CAMELLIA_SYM_DETAILS& rhs);
    public: TPMS_CAMELLIA_SYM_DETAILS(const TPMS_CAMELLIA_SYM_DETAILS& rhs);
    public:
    TPMS_CAMELLIA_SYM_DETAILS();
    virtual ~TPMS_CAMELLIA_SYM_DETAILS();
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_ANY for the union TpmuSymDetails
/// </summary>
class _DLLEXP_ TPMS_ANY_SYM_DETAILS : public virtual TPMS_NULL_UNION, public virtual TPMU_SYM_DETAILS 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_ANY_SYM_DETAILS& operator=(const TPMS_ANY_SYM_DETAILS& rhs);
    public: TPMS_ANY_SYM_DETAILS(const TPMS_ANY_SYM_DETAILS& rhs);
    public:
    TPMS_ANY_SYM_DETAILS();
    virtual ~TPMS_ANY_SYM_DETAILS();
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymDetails
/// </summary>
class _DLLEXP_ TPMS_XOR_SYM_DETAILS : public virtual TPMS_NULL_UNION, public virtual TPMU_SYM_DETAILS 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_XOR_SYM_DETAILS& operator=(const TPMS_XOR_SYM_DETAILS& rhs);
    public: TPMS_XOR_SYM_DETAILS(const TPMS_XOR_SYM_DETAILS& rhs);
    public:
    TPMS_XOR_SYM_DETAILS();
    virtual ~TPMS_XOR_SYM_DETAILS();
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymDetails
/// </summary>
class _DLLEXP_ TPMS_NULL_SYM_DETAILS : public virtual TPMS_NULL_UNION, public virtual TPMU_SYM_DETAILS 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_NULL_SYM_DETAILS& operator=(const TPMS_NULL_SYM_DETAILS& rhs);
    public: TPMS_NULL_SYM_DETAILS(const TPMS_NULL_SYM_DETAILS& rhs);
    public:
    TPMS_NULL_SYM_DETAILS();
    virtual ~TPMS_NULL_SYM_DETAILS();
};
/// <summary>
/// The TPMT_SYM_DEF structure is used to select an algorithm to be used for parameter encryption in those cases when different symmetric algorithms may be selected.
/// </summary>
class _DLLEXP_ TPMT_SYM_DEF : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// symmetric algorithm
    /// </summary>
    public: TPM_ALG_ID algorithm;
    /// <summary>
    /// key size in bits
    /// </summary>
    public: UINT16 keyBits;
    /// <summary>
    /// encryption mode
    /// </summary>
    public: TPM_ALG_ID mode;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMT_SYM_DEF& operator=(const TPMT_SYM_DEF& rhs);
    public: TPMT_SYM_DEF(const TPMT_SYM_DEF& rhs);
    public:
    TPMT_SYM_DEF();
    virtual ~TPMT_SYM_DEF();
    /// <summary>
    /// The TPMT_SYM_DEF structure is used to select an algorithm to be used for parameter encryption in those cases when different symmetric algorithms may be selected.
    /// </summary>
    ///<param name = "algorithm">symmetric algorithm</param>
    ///<param name = "keyBits">key size in bits</param>
    ///<param name = "mode">encryption mode</param>
    public: TPMT_SYM_DEF(
        const TPM_ALG_ID& algorithm,
        const UINT16& keyBits,
        const TPM_ALG_ID& mode
    );
#include "Extensions/TPMT_SYM_DEF.h"
};
/// <summary>
/// This structure is used when different symmetric block cipher (not XOR) algorithms may be selected. If the Object can be an ordinary parent (not a derivation parent), this must be the first field in the Object's parameter (see 12.2.3.7) field.
/// </summary>
class _DLLEXP_ TPMT_SYM_DEF_OBJECT : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// symmetric algorithm
    /// </summary>
    public: TPM_ALG_ID algorithm;
    /// <summary>
    /// key size in bits
    /// </summary>
    public: UINT16 keyBits;
    /// <summary>
    /// encryption mode
    /// </summary>
    public: TPM_ALG_ID mode;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMT_SYM_DEF_OBJECT& operator=(const TPMT_SYM_DEF_OBJECT& rhs);
    public: TPMT_SYM_DEF_OBJECT(const TPMT_SYM_DEF_OBJECT& rhs);
    public:
    TPMT_SYM_DEF_OBJECT();
    virtual ~TPMT_SYM_DEF_OBJECT();
    /// <summary>
    /// This structure is used when different symmetric block cipher (not XOR) algorithms may be selected. If the Object can be an ordinary parent (not a derivation parent), this must be the first field in the Object's parameter (see 12.2.3.7) field.
    /// </summary>
    ///<param name = "algorithm">symmetric algorithm</param>
    ///<param name = "keyBits">key size in bits</param>
    ///<param name = "mode">encryption mode</param>
    public: TPMT_SYM_DEF_OBJECT(
        const TPM_ALG_ID& algorithm,
        const UINT16& keyBits,
        const TPM_ALG_ID& mode
    );
#include "Extensions/TPMT_SYM_DEF_OBJECT.h"
};
/// <summary>
/// This structure is used to hold a symmetric key in the sensitive area of an asymmetric object.
/// </summary>
class _DLLEXP_ TPM2B_SYM_KEY : public virtual TPMU_SENSITIVE_COMPOSITE 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size, in octets, of the buffer containing the key; may be zero
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// the key
    /// </summary>
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_SYM_KEY& operator=(const TPM2B_SYM_KEY& rhs);
    public: TPM2B_SYM_KEY(const TPM2B_SYM_KEY& rhs);
    public:
    TPM2B_SYM_KEY();
    virtual ~TPM2B_SYM_KEY();
    /// <summary>
    /// This structure is used to hold a symmetric key in the sensitive area of an asymmetric object.
    /// </summary>
    ///<param name = "buffer">the key</param>
    public: TPM2B_SYM_KEY(
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// This structure contains the parameters for a symmetric block cipher object.
/// </summary>
class _DLLEXP_ TPMS_SYMCIPHER_PARMS : public virtual TPMU_PUBLIC_PARMS 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// a symmetric block cipher
    /// </summary>
    public: TPMT_SYM_DEF_OBJECT sym;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SYMCIPHER_PARMS& operator=(const TPMS_SYMCIPHER_PARMS& rhs);
    public: TPMS_SYMCIPHER_PARMS(const TPMS_SYMCIPHER_PARMS& rhs);
    public:
    TPMS_SYMCIPHER_PARMS();
    virtual ~TPMS_SYMCIPHER_PARMS();
    /// <summary>
    /// This structure contains the parameters for a symmetric block cipher object.
    /// </summary>
    ///<param name = "sym">a symmetric block cipher</param>
    public: TPMS_SYMCIPHER_PARMS(
        const TPMT_SYM_DEF_OBJECT& sym
    );
};
/// <summary>
/// This buffer holds a label or context value. For interoperability and backwards compatibility, LABEL_MAX_BUFFER is the minimum of the largest digest on the device and the largest ECC parameter (MAX_ECC_KEY_BYTES) but no more than 32 bytes.
/// </summary>
class _DLLEXP_ TPM2B_LABEL : public TpmStructureBase
{
    friend class StructMarshallInfo;
    protected: mutable UINT16 size;
    /// <summary>
    /// symmetric data for a created object or the label and context for a derived object
    /// </summary>
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_LABEL& operator=(const TPM2B_LABEL& rhs);
    public: TPM2B_LABEL(const TPM2B_LABEL& rhs);
    public:
    TPM2B_LABEL();
    virtual ~TPM2B_LABEL();
    /// <summary>
    /// This buffer holds a label or context value. For interoperability and backwards compatibility, LABEL_MAX_BUFFER is the minimum of the largest digest on the device and the largest ECC parameter (MAX_ECC_KEY_BYTES) but no more than 32 bytes.
    /// </summary>
    ///<param name = "buffer">symmetric data for a created object or the label and context for a derived object</param>
    public: TPM2B_LABEL(
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// This structure contains the label and context fields for a derived object. These values are used in the derivation KDF. The values in the unique field of inPublic area template take precedence over the values in the inSensitive parameter.
/// </summary>
class _DLLEXP_ TPMS_DERIVE : public virtual TPMU_SENSITIVE_CREATE, public virtual TPMU_PUBLIC_ID 
{
    friend class StructMarshallInfo;
    protected: mutable UINT16 labelSize;
    public: std::vector<BYTE> label;
    protected: mutable UINT16 contextSize;
    public: std::vector<BYTE> context;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_DERIVE& operator=(const TPMS_DERIVE& rhs);
    public: TPMS_DERIVE(const TPMS_DERIVE& rhs);
    public:
    TPMS_DERIVE();
    virtual ~TPMS_DERIVE();
    /// <summary>
    /// This structure contains the label and context fields for a derived object. These values are used in the derivation KDF. The values in the unique field of inPublic area template take precedence over the values in the inSensitive parameter.
    /// </summary>
    ///<param name = "label"></param>
    ///<param name = "context"></param>
    public: TPMS_DERIVE(
        const std::vector<BYTE>& label,
        const std::vector<BYTE>& context
    );
};
/// <summary>
/// Table 142  Definition of TPM2B_DERIVE Structure
/// </summary>
class _DLLEXP_ TPM2B_DERIVE : public TpmStructureBase
{
    friend class StructMarshallInfo;
    protected: mutable UINT16 size;
    /// <summary>
    /// symmetric data for a created object or the label and context for a derived object
    /// </summary>
    public: TPMS_DERIVE buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_DERIVE& operator=(const TPM2B_DERIVE& rhs);
    public: TPM2B_DERIVE(const TPM2B_DERIVE& rhs);
    public:
    TPM2B_DERIVE();
    virtual ~TPM2B_DERIVE();
    /// <summary>
    /// Table 142  Definition of TPM2B_DERIVE Structure
    /// </summary>
    ///<param name = "buffer">symmetric data for a created object or the label and context for a derived object</param>
    public: TPM2B_DERIVE(
        const TPMS_DERIVE& buffer
    );
};
/// <summary>
/// This buffer wraps the TPMU_SENSITIVE_CREATE structure.
/// </summary>
class _DLLEXP_ TPM2B_SENSITIVE_DATA : public virtual TPMU_SENSITIVE_COMPOSITE 
{
    friend class StructMarshallInfo;
    protected: mutable UINT16 size;
    /// <summary>
    /// symmetric data for a created object or the label and context for a derived object
    /// </summary>
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_SENSITIVE_DATA& operator=(const TPM2B_SENSITIVE_DATA& rhs);
    public: TPM2B_SENSITIVE_DATA(const TPM2B_SENSITIVE_DATA& rhs);
    public:
    TPM2B_SENSITIVE_DATA();
    virtual ~TPM2B_SENSITIVE_DATA();
    /// <summary>
    /// This buffer wraps the TPMU_SENSITIVE_CREATE structure.
    /// </summary>
    ///<param name = "buffer">symmetric data for a created object or the label and context for a derived object</param>
    public: TPM2B_SENSITIVE_DATA(
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// This structure defines the values to be placed in the sensitive area of a created object. This structure is only used within a TPM2B_SENSITIVE_CREATE structure.
/// </summary>
class _DLLEXP_ TPMS_SENSITIVE_CREATE : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 userAuthSize;
    /// <summary>
    /// the USER auth secret value
    /// </summary>
    public: std::vector<BYTE> userAuth;
    protected: mutable UINT16 dataSize;
    /// <summary>
    /// data to be sealed, a key, or derivation values
    /// </summary>
    public: std::vector<BYTE> data;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SENSITIVE_CREATE& operator=(const TPMS_SENSITIVE_CREATE& rhs);
    public: TPMS_SENSITIVE_CREATE(const TPMS_SENSITIVE_CREATE& rhs);
    public:
    TPMS_SENSITIVE_CREATE();
    virtual ~TPMS_SENSITIVE_CREATE();
    /// <summary>
    /// This structure defines the values to be placed in the sensitive area of a created object. This structure is only used within a TPM2B_SENSITIVE_CREATE structure.
    /// </summary>
    ///<param name = "userAuth">the USER auth secret value</param>
    ///<param name = "data">data to be sealed, a key, or derivation values</param>
    public: TPMS_SENSITIVE_CREATE(
        const std::vector<BYTE>& userAuth,
        const std::vector<BYTE>& data
    );
};
/// <summary>
/// This structure contains the sensitive creation data in a sized buffer. This structure is defined so that both the userAuth and data values of the TPMS_SENSITIVE_CREATE may be passed as a single parameter for parameter encryption purposes.
/// </summary>
class _DLLEXP_ TPM2B_SENSITIVE_CREATE : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of sensitive in octets (may not be zero)
    /// NOTE	The userAuth and data parameters in this buffer may both be zero length but the minimum size of this parameter will be the sum of the size fields of the two parameters of the TPMS_SENSITIVE_CREATE.
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// data to be sealed or a symmetric key value.
    /// </summary>
    public: TPMS_SENSITIVE_CREATE sensitive;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_SENSITIVE_CREATE& operator=(const TPM2B_SENSITIVE_CREATE& rhs);
    public: TPM2B_SENSITIVE_CREATE(const TPM2B_SENSITIVE_CREATE& rhs);
    public:
    TPM2B_SENSITIVE_CREATE();
    virtual ~TPM2B_SENSITIVE_CREATE();
    /// <summary>
    /// This structure contains the sensitive creation data in a sized buffer. This structure is defined so that both the userAuth and data values of the TPMS_SENSITIVE_CREATE may be passed as a single parameter for parameter encryption purposes.
    /// </summary>
    ///<param name = "sensitive">data to be sealed or a symmetric key value.</param>
    public: TPM2B_SENSITIVE_CREATE(
        const TPMS_SENSITIVE_CREATE& sensitive
    );
};
/// <summary>
/// This structure is the scheme data for schemes that only require a hash to complete their definition.
/// </summary>
class _DLLEXP_ TPMS_SCHEME_HASH : public virtual TPMU_SCHEME_KEYEDHASH, public virtual TPMU_SIG_SCHEME, public virtual TPMU_KDF_SCHEME, public virtual TPMU_ASYM_SCHEME, public virtual TPMU_SIGNATURE 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the hash algorithm used to digest the message
    /// </summary>
    public: TPM_ALG_ID hashAlg;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SCHEME_HASH& operator=(const TPMS_SCHEME_HASH& rhs);
    public: TPMS_SCHEME_HASH(const TPMS_SCHEME_HASH& rhs);
    public:
    TPMS_SCHEME_HASH();
    virtual ~TPMS_SCHEME_HASH();
    /// <summary>
    /// This structure is the scheme data for schemes that only require a hash to complete their definition.
    /// </summary>
    ///<param name = "hashAlg">the hash algorithm used to digest the message</param>
    public: TPMS_SCHEME_HASH(
        const TPM_ALG_ID& hashAlg
    );
};
/// <summary>
/// This definition is for split signing schemes that require a commit count.
/// </summary>
class _DLLEXP_ TPMS_SCHEME_ECDAA : public virtual TPMU_SIG_SCHEME, public virtual TPMU_ASYM_SCHEME 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the hash algorithm used to digest the message
    /// </summary>
    public: TPM_ALG_ID hashAlg;
    /// <summary>
    /// the counter value that is used between TPM2_Commit() and the sign operation
    /// </summary>
    public: UINT16 count;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SCHEME_ECDAA& operator=(const TPMS_SCHEME_ECDAA& rhs);
    public: TPMS_SCHEME_ECDAA(const TPMS_SCHEME_ECDAA& rhs);
    public:
    TPMS_SCHEME_ECDAA();
    virtual ~TPMS_SCHEME_ECDAA();
    /// <summary>
    /// This definition is for split signing schemes that require a commit count.
    /// </summary>
    ///<param name = "hashAlg">the hash algorithm used to digest the message</param>
    ///<param name = "count">the counter value that is used between TPM2_Commit() and the sign operation</param>
    public: TPMS_SCHEME_ECDAA(
        const TPM_ALG_ID& hashAlg,
        const UINT16& count
    );
};
/// <summary>
/// Table 150  Definition of Types for HMAC_SIG_SCHEME
/// </summary>
class _DLLEXP_ TPMS_SCHEME_HMAC : public virtual TPMS_SCHEME_HASH, public virtual TPMU_SCHEME_KEYEDHASH, public virtual TPMU_SIG_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SCHEME_HMAC& operator=(const TPMS_SCHEME_HMAC& rhs);
    public: TPMS_SCHEME_HMAC(const TPMS_SCHEME_HMAC& rhs);
    public:
    TPMS_SCHEME_HMAC();
    virtual ~TPMS_SCHEME_HMAC();
    /// <summary>
    /// Table 150  Definition of Types for HMAC_SIG_SCHEME
    /// </summary>
    ///<param name = "hashAlg">the hash algorithm used to digest the message</param>
    public: TPMS_SCHEME_HMAC(
        const TPM_ALG_ID& hashAlg
    );
};
/// <summary>
/// This structure is for the XOR encryption scheme.
/// </summary>
class _DLLEXP_ TPMS_SCHEME_XOR : public virtual TPMU_SCHEME_KEYEDHASH 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the hash algorithm used to digest the message
    /// </summary>
    public: TPM_ALG_ID hashAlg;
    /// <summary>
    /// the key derivation function
    /// </summary>
    public: TPM_ALG_ID kdf;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SCHEME_XOR& operator=(const TPMS_SCHEME_XOR& rhs);
    public: TPMS_SCHEME_XOR(const TPMS_SCHEME_XOR& rhs);
    public:
    TPMS_SCHEME_XOR();
    virtual ~TPMS_SCHEME_XOR();
    /// <summary>
    /// This structure is for the XOR encryption scheme.
    /// </summary>
    ///<param name = "hashAlg">the hash algorithm used to digest the message</param>
    ///<param name = "kdf">the key derivation function</param>
    public: TPMS_SCHEME_XOR(
        const TPM_ALG_ID& hashAlg,
        const TPM_ALG_ID& kdf
    );
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSchemeKeyedhash
/// </summary>
class _DLLEXP_ TPMS_NULL_SCHEME_KEYEDHASH : public virtual TPMS_NULL_UNION, public virtual TPMU_SCHEME_KEYEDHASH 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_NULL_SCHEME_KEYEDHASH& operator=(const TPMS_NULL_SCHEME_KEYEDHASH& rhs);
    public: TPMS_NULL_SCHEME_KEYEDHASH(const TPMS_NULL_SCHEME_KEYEDHASH& rhs);
    public:
    TPMS_NULL_SCHEME_KEYEDHASH();
    virtual ~TPMS_NULL_SCHEME_KEYEDHASH();
};
/// <summary>
/// This structure is used for a hash signing object.
/// </summary>
class _DLLEXP_ TPMT_KEYEDHASH_SCHEME : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// selects the scheme
    /// </summary>
    protected: mutable TPM_ALG_ID scheme;
    /// <summary>
    /// the scheme parameters
    /// (One of [TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH])
    /// </summary>
    public: TPMU_SCHEME_KEYEDHASH* details;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMT_KEYEDHASH_SCHEME& operator=(const TPMT_KEYEDHASH_SCHEME& rhs);
    public: TPMT_KEYEDHASH_SCHEME(const TPMT_KEYEDHASH_SCHEME& rhs);
    public:
    TPMT_KEYEDHASH_SCHEME();
    virtual ~TPMT_KEYEDHASH_SCHEME();
    /// <summary>
    /// This structure is used for a hash signing object.
    /// </summary>
    ///<param name = "details">the scheme parameters(One of TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH)</param>
    public: TPMT_KEYEDHASH_SCHEME(
        const TPMU_SCHEME_KEYEDHASH& details
    );
};
/// <summary>
/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
/// </summary>
class _DLLEXP_ TPMS_SIG_SCHEME_RSASSA : public virtual TPMS_SCHEME_HASH, public virtual TPMU_SIG_SCHEME, public virtual TPMU_ASYM_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SIG_SCHEME_RSASSA& operator=(const TPMS_SIG_SCHEME_RSASSA& rhs);
    public: TPMS_SIG_SCHEME_RSASSA(const TPMS_SIG_SCHEME_RSASSA& rhs);
    public:
    TPMS_SIG_SCHEME_RSASSA();
    virtual ~TPMS_SIG_SCHEME_RSASSA();
    /// <summary>
    /// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
    /// </summary>
    ///<param name = "hashAlg">the hash algorithm used to digest the message</param>
    public: TPMS_SIG_SCHEME_RSASSA(
        const TPM_ALG_ID& hashAlg
    );
};
/// <summary>
/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
/// </summary>
class _DLLEXP_ TPMS_SIG_SCHEME_RSAPSS : public virtual TPMS_SCHEME_HASH, public virtual TPMU_SIG_SCHEME, public virtual TPMU_ASYM_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SIG_SCHEME_RSAPSS& operator=(const TPMS_SIG_SCHEME_RSAPSS& rhs);
    public: TPMS_SIG_SCHEME_RSAPSS(const TPMS_SIG_SCHEME_RSAPSS& rhs);
    public:
    TPMS_SIG_SCHEME_RSAPSS();
    virtual ~TPMS_SIG_SCHEME_RSAPSS();
    /// <summary>
    /// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
    /// </summary>
    ///<param name = "hashAlg">the hash algorithm used to digest the message</param>
    public: TPMS_SIG_SCHEME_RSAPSS(
        const TPM_ALG_ID& hashAlg
    );
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
class _DLLEXP_ TPMS_SIG_SCHEME_ECDSA : public virtual TPMS_SCHEME_HASH, public virtual TPMU_SIG_SCHEME, public virtual TPMU_ASYM_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SIG_SCHEME_ECDSA& operator=(const TPMS_SIG_SCHEME_ECDSA& rhs);
    public: TPMS_SIG_SCHEME_ECDSA(const TPMS_SIG_SCHEME_ECDSA& rhs);
    public:
    TPMS_SIG_SCHEME_ECDSA();
    virtual ~TPMS_SIG_SCHEME_ECDSA();
    /// <summary>
    /// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
    /// </summary>
    ///<param name = "hashAlg">the hash algorithm used to digest the message</param>
    public: TPMS_SIG_SCHEME_ECDSA(
        const TPM_ALG_ID& hashAlg
    );
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
class _DLLEXP_ TPMS_SIG_SCHEME_SM2 : public virtual TPMS_SCHEME_HASH, public virtual TPMU_SIG_SCHEME, public virtual TPMU_ASYM_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SIG_SCHEME_SM2& operator=(const TPMS_SIG_SCHEME_SM2& rhs);
    public: TPMS_SIG_SCHEME_SM2(const TPMS_SIG_SCHEME_SM2& rhs);
    public:
    TPMS_SIG_SCHEME_SM2();
    virtual ~TPMS_SIG_SCHEME_SM2();
    /// <summary>
    /// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
    /// </summary>
    ///<param name = "hashAlg">the hash algorithm used to digest the message</param>
    public: TPMS_SIG_SCHEME_SM2(
        const TPM_ALG_ID& hashAlg
    );
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
class _DLLEXP_ TPMS_SIG_SCHEME_ECSCHNORR : public virtual TPMS_SCHEME_HASH, public virtual TPMU_SIG_SCHEME, public virtual TPMU_ASYM_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SIG_SCHEME_ECSCHNORR& operator=(const TPMS_SIG_SCHEME_ECSCHNORR& rhs);
    public: TPMS_SIG_SCHEME_ECSCHNORR(const TPMS_SIG_SCHEME_ECSCHNORR& rhs);
    public:
    TPMS_SIG_SCHEME_ECSCHNORR();
    virtual ~TPMS_SIG_SCHEME_ECSCHNORR();
    /// <summary>
    /// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
    /// </summary>
    ///<param name = "hashAlg">the hash algorithm used to digest the message</param>
    public: TPMS_SIG_SCHEME_ECSCHNORR(
        const TPM_ALG_ID& hashAlg
    );
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
class _DLLEXP_ TPMS_SIG_SCHEME_ECDAA : public virtual TPMS_SCHEME_ECDAA, public virtual TPMU_SIG_SCHEME, public virtual TPMU_ASYM_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SIG_SCHEME_ECDAA& operator=(const TPMS_SIG_SCHEME_ECDAA& rhs);
    public: TPMS_SIG_SCHEME_ECDAA(const TPMS_SIG_SCHEME_ECDAA& rhs);
    public:
    TPMS_SIG_SCHEME_ECDAA();
    virtual ~TPMS_SIG_SCHEME_ECDAA();
    /// <summary>
    /// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
    /// </summary>
    ///<param name = "hashAlg">the hash algorithm used to digest the message</param>
    ///<param name = "count">the counter value that is used between TPM2_Commit() and the sign operation</param>
    public: TPMS_SIG_SCHEME_ECDAA(
        const TPM_ALG_ID& hashAlg,
        const UINT16& count
    );
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSigScheme
/// </summary>
class _DLLEXP_ TPMS_NULL_SIG_SCHEME : public virtual TPMS_NULL_UNION, public virtual TPMU_SIG_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_NULL_SIG_SCHEME& operator=(const TPMS_NULL_SIG_SCHEME& rhs);
    public: TPMS_NULL_SIG_SCHEME(const TPMS_NULL_SIG_SCHEME& rhs);
    public:
    TPMS_NULL_SIG_SCHEME();
    virtual ~TPMS_NULL_SIG_SCHEME();
};
/// <summary>
/// Table 157  Definition of TPMT_SIG_SCHEME Structure
/// </summary>
class _DLLEXP_ TPMT_SIG_SCHEME : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID scheme;
    /// <summary>
    /// scheme parameters
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: TPMU_SIG_SCHEME* details;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMT_SIG_SCHEME& operator=(const TPMT_SIG_SCHEME& rhs);
    public: TPMT_SIG_SCHEME(const TPMT_SIG_SCHEME& rhs);
    public:
    TPMT_SIG_SCHEME();
    virtual ~TPMT_SIG_SCHEME();
    /// <summary>
    /// Table 157  Definition of TPMT_SIG_SCHEME Structure
    /// </summary>
    ///<param name = "details">scheme parameters(One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)</param>
    public: TPMT_SIG_SCHEME(
        const TPMU_SIG_SCHEME& details
    );
};
/// <summary>
/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
class _DLLEXP_ TPMS_ENC_SCHEME_OAEP : public virtual TPMS_SCHEME_HASH, public virtual TPMU_ASYM_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_ENC_SCHEME_OAEP& operator=(const TPMS_ENC_SCHEME_OAEP& rhs);
    public: TPMS_ENC_SCHEME_OAEP(const TPMS_ENC_SCHEME_OAEP& rhs);
    public:
    TPMS_ENC_SCHEME_OAEP();
    virtual ~TPMS_ENC_SCHEME_OAEP();
    /// <summary>
    /// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
    /// </summary>
    ///<param name = "hashAlg">the hash algorithm used to digest the message</param>
    public: TPMS_ENC_SCHEME_OAEP(
        const TPM_ALG_ID& hashAlg
    );
};
/// <summary>
/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
class _DLLEXP_ TPMS_ENC_SCHEME_RSAES : public virtual TPMS_EMPTY, public virtual TPMU_ASYM_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_ENC_SCHEME_RSAES& operator=(const TPMS_ENC_SCHEME_RSAES& rhs);
    public: TPMS_ENC_SCHEME_RSAES(const TPMS_ENC_SCHEME_RSAES& rhs);
    public:
    TPMS_ENC_SCHEME_RSAES();
    virtual ~TPMS_ENC_SCHEME_RSAES();
};
/// <summary>
/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
class _DLLEXP_ TPMS_KEY_SCHEME_ECDH : public virtual TPMS_SCHEME_HASH, public virtual TPMU_ASYM_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_KEY_SCHEME_ECDH& operator=(const TPMS_KEY_SCHEME_ECDH& rhs);
    public: TPMS_KEY_SCHEME_ECDH(const TPMS_KEY_SCHEME_ECDH& rhs);
    public:
    TPMS_KEY_SCHEME_ECDH();
    virtual ~TPMS_KEY_SCHEME_ECDH();
    /// <summary>
    /// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
    /// </summary>
    ///<param name = "hashAlg">the hash algorithm used to digest the message</param>
    public: TPMS_KEY_SCHEME_ECDH(
        const TPM_ALG_ID& hashAlg
    );
};
/// <summary>
/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
class _DLLEXP_ TPMS_KEY_SCHEME_ECMQV : public virtual TPMS_SCHEME_HASH, public virtual TPMU_ASYM_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_KEY_SCHEME_ECMQV& operator=(const TPMS_KEY_SCHEME_ECMQV& rhs);
    public: TPMS_KEY_SCHEME_ECMQV(const TPMS_KEY_SCHEME_ECMQV& rhs);
    public:
    TPMS_KEY_SCHEME_ECMQV();
    virtual ~TPMS_KEY_SCHEME_ECMQV();
    /// <summary>
    /// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
    /// </summary>
    ///<param name = "hashAlg">the hash algorithm used to digest the message</param>
    public: TPMS_KEY_SCHEME_ECMQV(
        const TPM_ALG_ID& hashAlg
    );
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
class _DLLEXP_ TPMS_SCHEME_MGF1 : public virtual TPMS_SCHEME_HASH, public virtual TPMU_KDF_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SCHEME_MGF1& operator=(const TPMS_SCHEME_MGF1& rhs);
    public: TPMS_SCHEME_MGF1(const TPMS_SCHEME_MGF1& rhs);
    public:
    TPMS_SCHEME_MGF1();
    virtual ~TPMS_SCHEME_MGF1();
    /// <summary>
    /// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
    /// </summary>
    ///<param name = "hashAlg">the hash algorithm used to digest the message</param>
    public: TPMS_SCHEME_MGF1(
        const TPM_ALG_ID& hashAlg
    );
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
class _DLLEXP_ TPMS_SCHEME_KDF1_SP800_56A : public virtual TPMS_SCHEME_HASH, public virtual TPMU_KDF_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SCHEME_KDF1_SP800_56A& operator=(const TPMS_SCHEME_KDF1_SP800_56A& rhs);
    public: TPMS_SCHEME_KDF1_SP800_56A(const TPMS_SCHEME_KDF1_SP800_56A& rhs);
    public:
    TPMS_SCHEME_KDF1_SP800_56A();
    virtual ~TPMS_SCHEME_KDF1_SP800_56A();
    /// <summary>
    /// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
    /// </summary>
    ///<param name = "hashAlg">the hash algorithm used to digest the message</param>
    public: TPMS_SCHEME_KDF1_SP800_56A(
        const TPM_ALG_ID& hashAlg
    );
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
class _DLLEXP_ TPMS_SCHEME_KDF2 : public virtual TPMS_SCHEME_HASH, public virtual TPMU_KDF_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SCHEME_KDF2& operator=(const TPMS_SCHEME_KDF2& rhs);
    public: TPMS_SCHEME_KDF2(const TPMS_SCHEME_KDF2& rhs);
    public:
    TPMS_SCHEME_KDF2();
    virtual ~TPMS_SCHEME_KDF2();
    /// <summary>
    /// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
    /// </summary>
    ///<param name = "hashAlg">the hash algorithm used to digest the message</param>
    public: TPMS_SCHEME_KDF2(
        const TPM_ALG_ID& hashAlg
    );
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
class _DLLEXP_ TPMS_SCHEME_KDF1_SP800_108 : public virtual TPMS_SCHEME_HASH, public virtual TPMU_KDF_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SCHEME_KDF1_SP800_108& operator=(const TPMS_SCHEME_KDF1_SP800_108& rhs);
    public: TPMS_SCHEME_KDF1_SP800_108(const TPMS_SCHEME_KDF1_SP800_108& rhs);
    public:
    TPMS_SCHEME_KDF1_SP800_108();
    virtual ~TPMS_SCHEME_KDF1_SP800_108();
    /// <summary>
    /// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
    /// </summary>
    ///<param name = "hashAlg">the hash algorithm used to digest the message</param>
    public: TPMS_SCHEME_KDF1_SP800_108(
        const TPM_ALG_ID& hashAlg
    );
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuKdfScheme
/// </summary>
class _DLLEXP_ TPMS_NULL_KDF_SCHEME : public virtual TPMS_NULL_UNION, public virtual TPMU_KDF_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_NULL_KDF_SCHEME& operator=(const TPMS_NULL_KDF_SCHEME& rhs);
    public: TPMS_NULL_KDF_SCHEME(const TPMS_NULL_KDF_SCHEME& rhs);
    public:
    TPMS_NULL_KDF_SCHEME();
    virtual ~TPMS_NULL_KDF_SCHEME();
};
/// <summary>
/// Table 162  Definition of TPMT_KDF_SCHEME Structure
/// </summary>
class _DLLEXP_ TPMT_KDF_SCHEME : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID scheme;
    /// <summary>
    /// scheme parameters
    /// (One of [TPMS_SCHEME_MGF1, TPMS_SCHEME_KDF1_SP800_56A, TPMS_SCHEME_KDF2, TPMS_SCHEME_KDF1_SP800_108, TPMS_NULL_KDF_SCHEME])
    /// </summary>
    public: TPMU_KDF_SCHEME* details;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMT_KDF_SCHEME& operator=(const TPMT_KDF_SCHEME& rhs);
    public: TPMT_KDF_SCHEME(const TPMT_KDF_SCHEME& rhs);
    public:
    TPMT_KDF_SCHEME();
    virtual ~TPMT_KDF_SCHEME();
    /// <summary>
    /// Table 162  Definition of TPMT_KDF_SCHEME Structure
    /// </summary>
    ///<param name = "details">scheme parameters(One of TPMS_SCHEME_MGF1, TPMS_SCHEME_KDF1_SP800_56A, TPMS_SCHEME_KDF2, TPMS_SCHEME_KDF1_SP800_108, TPMS_NULL_KDF_SCHEME)</param>
    public: TPMT_KDF_SCHEME(
        const TPMU_KDF_SCHEME& details
    );
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuAsymScheme
/// </summary>
class _DLLEXP_ TPMS_NULL_ASYM_SCHEME : public virtual TPMS_NULL_UNION, public virtual TPMU_ASYM_SCHEME 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_NULL_ASYM_SCHEME& operator=(const TPMS_NULL_ASYM_SCHEME& rhs);
    public: TPMS_NULL_ASYM_SCHEME(const TPMS_NULL_ASYM_SCHEME& rhs);
    public:
    TPMS_NULL_ASYM_SCHEME();
    virtual ~TPMS_NULL_ASYM_SCHEME();
};
/// <summary>
/// This structure is defined to allow overlay of all of the schemes for any asymmetric object. This structure is not sent on the interface. It is defined so that common functions may operate on any similar scheme structure.
/// </summary>
class _DLLEXP_ TPMT_ASYM_SCHEME : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID scheme;
    /// <summary>
    /// scheme parameters
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: TPMU_ASYM_SCHEME* details;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMT_ASYM_SCHEME& operator=(const TPMT_ASYM_SCHEME& rhs);
    public: TPMT_ASYM_SCHEME(const TPMT_ASYM_SCHEME& rhs);
    public:
    TPMT_ASYM_SCHEME();
    virtual ~TPMT_ASYM_SCHEME();
    /// <summary>
    /// This structure is defined to allow overlay of all of the schemes for any asymmetric object. This structure is not sent on the interface. It is defined so that common functions may operate on any similar scheme structure.
    /// </summary>
    ///<param name = "details">scheme parameters(One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)</param>
    public: TPMT_ASYM_SCHEME(
        const TPMU_ASYM_SCHEME& details
    );
};
/// <summary>
/// Table 167  Definition of {RSA} TPMT_RSA_SCHEME Structure
/// </summary>
class _DLLEXP_ TPMT_RSA_SCHEME : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID scheme;
    /// <summary>
    /// scheme parameters
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: TPMU_ASYM_SCHEME* details;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMT_RSA_SCHEME& operator=(const TPMT_RSA_SCHEME& rhs);
    public: TPMT_RSA_SCHEME(const TPMT_RSA_SCHEME& rhs);
    public:
    TPMT_RSA_SCHEME();
    virtual ~TPMT_RSA_SCHEME();
    /// <summary>
    /// Table 167  Definition of {RSA} TPMT_RSA_SCHEME Structure
    /// </summary>
    ///<param name = "details">scheme parameters(One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)</param>
    public: TPMT_RSA_SCHEME(
        const TPMU_ASYM_SCHEME& details
    );
};
/// <summary>
/// Table 169  Definition of {RSA} TPMT_RSA_DECRYPT Structure
/// </summary>
class _DLLEXP_ TPMT_RSA_DECRYPT : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID scheme;
    /// <summary>
    /// scheme parameters
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: TPMU_ASYM_SCHEME* details;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMT_RSA_DECRYPT& operator=(const TPMT_RSA_DECRYPT& rhs);
    public: TPMT_RSA_DECRYPT(const TPMT_RSA_DECRYPT& rhs);
    public:
    TPMT_RSA_DECRYPT();
    virtual ~TPMT_RSA_DECRYPT();
    /// <summary>
    /// Table 169  Definition of {RSA} TPMT_RSA_DECRYPT Structure
    /// </summary>
    ///<param name = "details">scheme parameters(One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)</param>
    public: TPMT_RSA_DECRYPT(
        const TPMU_ASYM_SCHEME& details
    );
};
/// <summary>
/// This sized buffer holds the largest RSA public key supported by the TPM.
/// </summary>
class _DLLEXP_ TPM2B_PUBLIC_KEY_RSA : public virtual TPMU_PUBLIC_ID 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the buffer
    /// The value of zero is only valid for create.
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// Value
    /// </summary>
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_PUBLIC_KEY_RSA& operator=(const TPM2B_PUBLIC_KEY_RSA& rhs);
    public: TPM2B_PUBLIC_KEY_RSA(const TPM2B_PUBLIC_KEY_RSA& rhs);
    public:
    TPM2B_PUBLIC_KEY_RSA();
    virtual ~TPM2B_PUBLIC_KEY_RSA();
    /// <summary>
    /// This sized buffer holds the largest RSA public key supported by the TPM.
    /// </summary>
    ///<param name = "buffer">Value</param>
    public: TPM2B_PUBLIC_KEY_RSA(
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// This sized buffer holds the largest RSA prime number supported by the TPM.
/// </summary>
class _DLLEXP_ TPM2B_PRIVATE_KEY_RSA : public virtual TPMU_SENSITIVE_COMPOSITE 
{
    friend class StructMarshallInfo;
    protected: mutable UINT16 size;
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_PRIVATE_KEY_RSA& operator=(const TPM2B_PRIVATE_KEY_RSA& rhs);
    public: TPM2B_PRIVATE_KEY_RSA(const TPM2B_PRIVATE_KEY_RSA& rhs);
    public:
    TPM2B_PRIVATE_KEY_RSA();
    virtual ~TPM2B_PRIVATE_KEY_RSA();
    /// <summary>
    /// This sized buffer holds the largest RSA prime number supported by the TPM.
    /// </summary>
    ///<param name = "buffer"></param>
    public: TPM2B_PRIVATE_KEY_RSA(
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// This sized buffer holds the largest ECC parameter (coordinate) supported by the TPM.
/// </summary>
class _DLLEXP_ TPM2B_ECC_PARAMETER : public virtual TPMU_SENSITIVE_COMPOSITE 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of buffer
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// the parameter data
    /// </summary>
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_ECC_PARAMETER& operator=(const TPM2B_ECC_PARAMETER& rhs);
    public: TPM2B_ECC_PARAMETER(const TPM2B_ECC_PARAMETER& rhs);
    public:
    TPM2B_ECC_PARAMETER();
    virtual ~TPM2B_ECC_PARAMETER();
    /// <summary>
    /// This sized buffer holds the largest ECC parameter (coordinate) supported by the TPM.
    /// </summary>
    ///<param name = "buffer">the parameter data</param>
    public: TPM2B_ECC_PARAMETER(
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// This structure holds two ECC coordinates that, together, make up an ECC point.
/// </summary>
class _DLLEXP_ TPMS_ECC_POINT : public virtual TPMU_PUBLIC_ID 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of buffer
    /// </summary>
    protected: mutable UINT16 xSize;
    /// <summary>
    /// X coordinate
    /// </summary>
    public: std::vector<BYTE> x;
    /// <summary>
    /// size of buffer
    /// </summary>
    protected: mutable UINT16 ySize;
    /// <summary>
    /// Y coordinate
    /// </summary>
    public: std::vector<BYTE> y;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_ECC_POINT& operator=(const TPMS_ECC_POINT& rhs);
    public: TPMS_ECC_POINT(const TPMS_ECC_POINT& rhs);
    public:
    TPMS_ECC_POINT();
    virtual ~TPMS_ECC_POINT();
    /// <summary>
    /// This structure holds two ECC coordinates that, together, make up an ECC point.
    /// </summary>
    ///<param name = "x">X coordinate</param>
    ///<param name = "y">Y coordinate</param>
    public: TPMS_ECC_POINT(
        const std::vector<BYTE>& x,
        const std::vector<BYTE>& y
    );
};
/// <summary>
/// This structure is defined to allow a point to be a single sized parameter so that it may be encrypted.
/// </summary>
class _DLLEXP_ TPM2B_ECC_POINT : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the remainder of this structure
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// coordinates
    /// </summary>
    public: TPMS_ECC_POINT point;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_ECC_POINT& operator=(const TPM2B_ECC_POINT& rhs);
    public: TPM2B_ECC_POINT(const TPM2B_ECC_POINT& rhs);
    public:
    TPM2B_ECC_POINT();
    virtual ~TPM2B_ECC_POINT();
    /// <summary>
    /// This structure is defined to allow a point to be a single sized parameter so that it may be encrypted.
    /// </summary>
    ///<param name = "point">coordinates</param>
    public: TPM2B_ECC_POINT(
        const TPMS_ECC_POINT& point
    );
};
/// <summary>
/// Table 178  Definition of (TPMT_SIG_SCHEME) {ECC} TPMT_ECC_SCHEME Structure
/// </summary>
class _DLLEXP_ TPMT_ECC_SCHEME : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID scheme;
    /// <summary>
    /// scheme parameters
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: TPMU_ASYM_SCHEME* details;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMT_ECC_SCHEME& operator=(const TPMT_ECC_SCHEME& rhs);
    public: TPMT_ECC_SCHEME(const TPMT_ECC_SCHEME& rhs);
    public:
    TPMT_ECC_SCHEME();
    virtual ~TPMT_ECC_SCHEME();
    /// <summary>
    /// Table 178  Definition of (TPMT_SIG_SCHEME) {ECC} TPMT_ECC_SCHEME Structure
    /// </summary>
    ///<param name = "details">scheme parameters(One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)</param>
    public: TPMT_ECC_SCHEME(
        const TPMU_ASYM_SCHEME& details
    );
};
/// <summary>
/// This structure is used to report on the curve parameters of an ECC curve. It is returned by TPM2_ECC_Parameters().
/// </summary>
class _DLLEXP_ TPMS_ALGORITHM_DETAIL_ECC : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// identifier for the curve
    /// </summary>
    public: TPM_ECC_CURVE curveID;
    /// <summary>
    /// Size in bits of the key
    /// </summary>
    public: UINT16 keySize;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID kdfScheme;
    /// <summary>
    /// if not TPM_ALG_NULL, the required KDF and hash algorithm used in secret sharing operations
    /// (One of [TPMS_SCHEME_MGF1, TPMS_SCHEME_KDF1_SP800_56A, TPMS_SCHEME_KDF2, TPMS_SCHEME_KDF1_SP800_108, TPMS_NULL_KDF_SCHEME])
    /// </summary>
    public: TPMU_KDF_SCHEME* kdf;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID signScheme;
    /// <summary>
    /// If not TPM_ALG_NULL, this is the mandatory signature scheme that is required to be used with this curve.
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: TPMU_ASYM_SCHEME* sign;
    /// <summary>
    /// size of buffer
    /// </summary>
    protected: mutable UINT16 pSize;
    /// <summary>
    /// Fp (the modulus)
    /// </summary>
    public: std::vector<BYTE> p;
    /// <summary>
    /// size of buffer
    /// </summary>
    protected: mutable UINT16 aSize;
    /// <summary>
    /// coefficient of the linear term in the curve equation
    /// </summary>
    public: std::vector<BYTE> a;
    /// <summary>
    /// size of buffer
    /// </summary>
    protected: mutable UINT16 bSize;
    /// <summary>
    /// constant term for curve equation
    /// </summary>
    public: std::vector<BYTE> b;
    /// <summary>
    /// size of buffer
    /// </summary>
    protected: mutable UINT16 gXSize;
    /// <summary>
    /// x coordinate of base point G
    /// </summary>
    public: std::vector<BYTE> gX;
    /// <summary>
    /// size of buffer
    /// </summary>
    protected: mutable UINT16 gYSize;
    /// <summary>
    /// y coordinate of base point G
    /// </summary>
    public: std::vector<BYTE> gY;
    /// <summary>
    /// size of buffer
    /// </summary>
    protected: mutable UINT16 nSize;
    /// <summary>
    /// order of G
    /// </summary>
    public: std::vector<BYTE> n;
    /// <summary>
    /// size of buffer
    /// </summary>
    protected: mutable UINT16 hSize;
    /// <summary>
    /// cofactor (a size of zero indicates a cofactor of 1)
    /// </summary>
    public: std::vector<BYTE> h;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_ALGORITHM_DETAIL_ECC& operator=(const TPMS_ALGORITHM_DETAIL_ECC& rhs);
    public: TPMS_ALGORITHM_DETAIL_ECC(const TPMS_ALGORITHM_DETAIL_ECC& rhs);
    public:
    TPMS_ALGORITHM_DETAIL_ECC();
    virtual ~TPMS_ALGORITHM_DETAIL_ECC();
    /// <summary>
    /// This structure is used to report on the curve parameters of an ECC curve. It is returned by TPM2_ECC_Parameters().
    /// </summary>
    ///<param name = "curveID">identifier for the curve</param>
    ///<param name = "keySize">Size in bits of the key</param>
    ///<param name = "kdf">if not TPM_ALG_NULL, the required KDF and hash algorithm used in secret sharing operations(One of TPMS_SCHEME_MGF1, TPMS_SCHEME_KDF1_SP800_56A, TPMS_SCHEME_KDF2, TPMS_SCHEME_KDF1_SP800_108, TPMS_NULL_KDF_SCHEME)</param>
    ///<param name = "sign">If not TPM_ALG_NULL, this is the mandatory signature scheme that is required to be used with this curve.(One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)</param>
    ///<param name = "p">Fp (the modulus)</param>
    ///<param name = "a">coefficient of the linear term in the curve equation</param>
    ///<param name = "b">constant term for curve equation</param>
    ///<param name = "gX">x coordinate of base point G</param>
    ///<param name = "gY">y coordinate of base point G</param>
    ///<param name = "n">order of G</param>
    ///<param name = "h">cofactor (a size of zero indicates a cofactor of 1)</param>
    public: TPMS_ALGORITHM_DETAIL_ECC(
        const TPM_ECC_CURVE& curveID,
        const UINT16& keySize,
        const TPMU_KDF_SCHEME& kdf,
        const TPMU_ASYM_SCHEME& sign,
        const std::vector<BYTE>& p,
        const std::vector<BYTE>& a,
        const std::vector<BYTE>& b,
        const std::vector<BYTE>& gX,
        const std::vector<BYTE>& gY,
        const std::vector<BYTE>& n,
        const std::vector<BYTE>& h
    );
};
/// <summary>
/// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
/// </summary>
class _DLLEXP_ TPMS_SIGNATURE_RSA : public virtual TPMU_SIGNATURE 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the hash algorithm used to digest the message
    /// TPM_ALG_NULL is not allowed.
    /// </summary>
    public: TPM_ALG_ID hash;
    /// <summary>
    /// size of the buffer
    /// The value of zero is only valid for create.
    /// </summary>
    protected: mutable UINT16 sigSize;
    /// <summary>
    /// The signature is the size of a public key.
    /// </summary>
    public: std::vector<BYTE> sig;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SIGNATURE_RSA& operator=(const TPMS_SIGNATURE_RSA& rhs);
    public: TPMS_SIGNATURE_RSA(const TPMS_SIGNATURE_RSA& rhs);
    public:
    TPMS_SIGNATURE_RSA();
    virtual ~TPMS_SIGNATURE_RSA();
    /// <summary>
    /// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
    /// </summary>
    ///<param name = "hash">the hash algorithm used to digest the message TPM_ALG_NULL is not allowed.</param>
    ///<param name = "sig">The signature is the size of a public key.</param>
    public: TPMS_SIGNATURE_RSA(
        const TPM_ALG_ID& hash,
        const std::vector<BYTE>& sig
    );
};
/// <summary>
/// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
/// </summary>
class _DLLEXP_ TPMS_SIGNATURE_RSASSA : public virtual TPMS_SIGNATURE_RSA, public virtual TPMU_SIGNATURE 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SIGNATURE_RSASSA& operator=(const TPMS_SIGNATURE_RSASSA& rhs);
    public: TPMS_SIGNATURE_RSASSA(const TPMS_SIGNATURE_RSASSA& rhs);
    public:
    TPMS_SIGNATURE_RSASSA();
    virtual ~TPMS_SIGNATURE_RSASSA();
    /// <summary>
    /// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
    /// </summary>
    ///<param name = "hash">the hash algorithm used to digest the message TPM_ALG_NULL is not allowed.</param>
    ///<param name = "sig">The signature is the size of a public key.</param>
    public: TPMS_SIGNATURE_RSASSA(
        const TPM_ALG_ID& hash,
        const std::vector<BYTE>& sig
    );
};
/// <summary>
/// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
/// </summary>
class _DLLEXP_ TPMS_SIGNATURE_RSAPSS : public virtual TPMS_SIGNATURE_RSA, public virtual TPMU_SIGNATURE 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SIGNATURE_RSAPSS& operator=(const TPMS_SIGNATURE_RSAPSS& rhs);
    public: TPMS_SIGNATURE_RSAPSS(const TPMS_SIGNATURE_RSAPSS& rhs);
    public:
    TPMS_SIGNATURE_RSAPSS();
    virtual ~TPMS_SIGNATURE_RSAPSS();
    /// <summary>
    /// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
    /// </summary>
    ///<param name = "hash">the hash algorithm used to digest the message TPM_ALG_NULL is not allowed.</param>
    ///<param name = "sig">The signature is the size of a public key.</param>
    public: TPMS_SIGNATURE_RSAPSS(
        const TPM_ALG_ID& hash,
        const std::vector<BYTE>& sig
    );
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
class _DLLEXP_ TPMS_SIGNATURE_ECC : public virtual TPMU_SIGNATURE 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the hash algorithm used in the signature process
    /// TPM_ALG_NULL is not allowed.
    /// </summary>
    public: TPM_ALG_ID hash;
    /// <summary>
    /// size of buffer
    /// </summary>
    protected: mutable UINT16 signatureRSize;
    public: std::vector<BYTE> signatureR;
    /// <summary>
    /// size of buffer
    /// </summary>
    protected: mutable UINT16 signatureSSize;
    public: std::vector<BYTE> signatureS;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SIGNATURE_ECC& operator=(const TPMS_SIGNATURE_ECC& rhs);
    public: TPMS_SIGNATURE_ECC(const TPMS_SIGNATURE_ECC& rhs);
    public:
    TPMS_SIGNATURE_ECC();
    virtual ~TPMS_SIGNATURE_ECC();
    /// <summary>
    /// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
    /// </summary>
    ///<param name = "hash">the hash algorithm used in the signature process TPM_ALG_NULL is not allowed.</param>
    ///<param name = "signatureR"></param>
    ///<param name = "signatureS"></param>
    public: TPMS_SIGNATURE_ECC(
        const TPM_ALG_ID& hash,
        const std::vector<BYTE>& signatureR,
        const std::vector<BYTE>& signatureS
    );
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
class _DLLEXP_ TPMS_SIGNATURE_ECDSA : public virtual TPMS_SIGNATURE_ECC, public virtual TPMU_SIGNATURE 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SIGNATURE_ECDSA& operator=(const TPMS_SIGNATURE_ECDSA& rhs);
    public: TPMS_SIGNATURE_ECDSA(const TPMS_SIGNATURE_ECDSA& rhs);
    public:
    TPMS_SIGNATURE_ECDSA();
    virtual ~TPMS_SIGNATURE_ECDSA();
    /// <summary>
    /// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
    /// </summary>
    ///<param name = "hash">the hash algorithm used in the signature process TPM_ALG_NULL is not allowed.</param>
    ///<param name = "signatureR"></param>
    ///<param name = "signatureS"></param>
    public: TPMS_SIGNATURE_ECDSA(
        const TPM_ALG_ID& hash,
        const std::vector<BYTE>& signatureR,
        const std::vector<BYTE>& signatureS
    );
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
class _DLLEXP_ TPMS_SIGNATURE_ECDAA : public virtual TPMS_SIGNATURE_ECC, public virtual TPMU_SIGNATURE 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SIGNATURE_ECDAA& operator=(const TPMS_SIGNATURE_ECDAA& rhs);
    public: TPMS_SIGNATURE_ECDAA(const TPMS_SIGNATURE_ECDAA& rhs);
    public:
    TPMS_SIGNATURE_ECDAA();
    virtual ~TPMS_SIGNATURE_ECDAA();
    /// <summary>
    /// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
    /// </summary>
    ///<param name = "hash">the hash algorithm used in the signature process TPM_ALG_NULL is not allowed.</param>
    ///<param name = "signatureR"></param>
    ///<param name = "signatureS"></param>
    public: TPMS_SIGNATURE_ECDAA(
        const TPM_ALG_ID& hash,
        const std::vector<BYTE>& signatureR,
        const std::vector<BYTE>& signatureS
    );
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
class _DLLEXP_ TPMS_SIGNATURE_SM2 : public virtual TPMS_SIGNATURE_ECC, public virtual TPMU_SIGNATURE 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SIGNATURE_SM2& operator=(const TPMS_SIGNATURE_SM2& rhs);
    public: TPMS_SIGNATURE_SM2(const TPMS_SIGNATURE_SM2& rhs);
    public:
    TPMS_SIGNATURE_SM2();
    virtual ~TPMS_SIGNATURE_SM2();
    /// <summary>
    /// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
    /// </summary>
    ///<param name = "hash">the hash algorithm used in the signature process TPM_ALG_NULL is not allowed.</param>
    ///<param name = "signatureR"></param>
    ///<param name = "signatureS"></param>
    public: TPMS_SIGNATURE_SM2(
        const TPM_ALG_ID& hash,
        const std::vector<BYTE>& signatureR,
        const std::vector<BYTE>& signatureS
    );
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
class _DLLEXP_ TPMS_SIGNATURE_ECSCHNORR : public virtual TPMS_SIGNATURE_ECC, public virtual TPMU_SIGNATURE 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_SIGNATURE_ECSCHNORR& operator=(const TPMS_SIGNATURE_ECSCHNORR& rhs);
    public: TPMS_SIGNATURE_ECSCHNORR(const TPMS_SIGNATURE_ECSCHNORR& rhs);
    public:
    TPMS_SIGNATURE_ECSCHNORR();
    virtual ~TPMS_SIGNATURE_ECSCHNORR();
    /// <summary>
    /// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
    /// </summary>
    ///<param name = "hash">the hash algorithm used in the signature process TPM_ALG_NULL is not allowed.</param>
    ///<param name = "signatureR"></param>
    ///<param name = "signatureS"></param>
    public: TPMS_SIGNATURE_ECSCHNORR(
        const TPM_ALG_ID& hash,
        const std::vector<BYTE>& signatureR,
        const std::vector<BYTE>& signatureS
    );
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSignature
/// </summary>
class _DLLEXP_ TPMS_NULL_SIGNATURE : public virtual TPMS_NULL_UNION, public virtual TPMU_SIGNATURE 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_NULL_SIGNATURE& operator=(const TPMS_NULL_SIGNATURE& rhs);
    public: TPMS_NULL_SIGNATURE(const TPMS_NULL_SIGNATURE& rhs);
    public:
    TPMS_NULL_SIGNATURE();
    virtual ~TPMS_NULL_SIGNATURE();
};
/// <summary>
/// Table 185 shows the basic algorithm-agile structure when a symmetric or asymmetric signature is indicated. The sigAlg parameter indicates the algorithm used for the signature. This structure is output from commands such as the attestation commands and TPM2_Sign, and is an input to commands such as TPM2_VerifySignature(), TPM2_PolicySigned(), and TPM2_FieldUpgradeStart().
/// </summary>
class _DLLEXP_ TPMT_SIGNATURE : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// selector of the algorithm used to construct the signature
    /// </summary>
    protected: mutable TPM_ALG_ID sigAlg;
    /// <summary>
    /// This shall be the actual signature information.
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: TPMU_SIGNATURE* signature;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMT_SIGNATURE& operator=(const TPMT_SIGNATURE& rhs);
    public: TPMT_SIGNATURE(const TPMT_SIGNATURE& rhs);
    public:
    TPMT_SIGNATURE();
    virtual ~TPMT_SIGNATURE();
    /// <summary>
    /// Table 185 shows the basic algorithm-agile structure when a symmetric or asymmetric signature is indicated. The sigAlg parameter indicates the algorithm used for the signature. This structure is output from commands such as the attestation commands and TPM2_Sign, and is an input to commands such as TPM2_VerifySignature(), TPM2_PolicySigned(), and TPM2_FieldUpgradeStart().
    /// </summary>
    ///<param name = "signature">This shall be the actual signature information.(One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)</param>
    public: TPMT_SIGNATURE(
        const TPMU_SIGNATURE& signature
    );
};
/// <summary>
/// Table 187  Definition of TPM2B_ENCRYPTED_SECRET Structure
/// </summary>
class _DLLEXP_ TPM2B_ENCRYPTED_SECRET : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the secret value
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// secret
    /// </summary>
    public: std::vector<BYTE> secret;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_ENCRYPTED_SECRET& operator=(const TPM2B_ENCRYPTED_SECRET& rhs);
    public: TPM2B_ENCRYPTED_SECRET(const TPM2B_ENCRYPTED_SECRET& rhs);
    public:
    TPM2B_ENCRYPTED_SECRET();
    virtual ~TPM2B_ENCRYPTED_SECRET();
    /// <summary>
    /// Table 187  Definition of TPM2B_ENCRYPTED_SECRET Structure
    /// </summary>
    ///<param name = "secret">secret</param>
    public: TPM2B_ENCRYPTED_SECRET(
        const std::vector<BYTE>& secret
    );
};
/// <summary>
/// This structure describes the parameters that would appear in the public area of a KEYEDHASH object.
/// </summary>
class _DLLEXP_ TPMS_KEYEDHASH_PARMS : public virtual TPMU_PUBLIC_PARMS 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// selects the scheme
    /// </summary>
    protected: mutable TPM_ALG_ID schemeScheme;
    /// <summary>
    /// Indicates the signing method used for a keyedHash signing object. This field also determines the size of the data field for a data object created with TPM2_Create() or TPM2_CreatePrimary().
    /// (One of [TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH])
    /// </summary>
    public: TPMU_SCHEME_KEYEDHASH* scheme;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_KEYEDHASH_PARMS& operator=(const TPMS_KEYEDHASH_PARMS& rhs);
    public: TPMS_KEYEDHASH_PARMS(const TPMS_KEYEDHASH_PARMS& rhs);
    public:
    TPMS_KEYEDHASH_PARMS();
    virtual ~TPMS_KEYEDHASH_PARMS();
    /// <summary>
    /// This structure describes the parameters that would appear in the public area of a KEYEDHASH object.
    /// </summary>
    ///<param name = "scheme">Indicates the signing method used for a keyedHash signing object. This field also determines the size of the data field for a data object created with TPM2_Create() or TPM2_CreatePrimary().(One of TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH)</param>
    public: TPMS_KEYEDHASH_PARMS(
        const TPMU_SCHEME_KEYEDHASH& scheme
    );
};
/// <summary>
/// This structure contains the common public area parameters for an asymmetric key. The first two parameters of the parameter definition structures of an asymmetric key shall have the same two first components.
/// </summary>
class _DLLEXP_ TPMS_ASYM_PARMS : public virtual TPMU_PUBLIC_PARMS 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the companion symmetric algorithm for a restricted decryption key and shall be set to a supported symmetric algorithm
    /// This field is optional for keys that are not decryption keys and shall be set to TPM_ALG_NULL if not used.
    /// </summary>
    public: TPMT_SYM_DEF_OBJECT symmetric;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID schemeScheme;
    /// <summary>
    /// for a key with the sign attribute SET, a valid signing scheme for the key type
    /// for a key with the decrypt attribute SET, a valid key exchange protocol
    /// for a key with sign and decrypt attributes, shall be TPM_ALG_NULL
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: TPMU_ASYM_SCHEME* scheme;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_ASYM_PARMS& operator=(const TPMS_ASYM_PARMS& rhs);
    public: TPMS_ASYM_PARMS(const TPMS_ASYM_PARMS& rhs);
    public:
    TPMS_ASYM_PARMS();
    virtual ~TPMS_ASYM_PARMS();
    /// <summary>
    /// This structure contains the common public area parameters for an asymmetric key. The first two parameters of the parameter definition structures of an asymmetric key shall have the same two first components.
    /// </summary>
    ///<param name = "symmetric">the companion symmetric algorithm for a restricted decryption key and shall be set to a supported symmetric algorithm This field is optional for keys that are not decryption keys and shall be set to TPM_ALG_NULL if not used.</param>
    ///<param name = "scheme">for a key with the sign attribute SET, a valid signing scheme for the key type for a key with the decrypt attribute SET, a valid key exchange protocol for a key with sign and decrypt attributes, shall be TPM_ALG_NULL(One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)</param>
    public: TPMS_ASYM_PARMS(
        const TPMT_SYM_DEF_OBJECT& symmetric,
        const TPMU_ASYM_SCHEME& scheme
    );
};
/// <summary>
/// A TPM compatible with this specification and supporting RSA shall support two primes and an exponent of zero. An exponent of zero indicates that the exponent is the default of 216 + 1. Support for other values is optional. Use of other exponents in duplicated keys is not recommended because the resulting keys would not be interoperable with other TPMs.
/// </summary>
class _DLLEXP_ TPMS_RSA_PARMS : public virtual TPMU_PUBLIC_PARMS 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// for a restricted decryption key, shall be set to a supported symmetric algorithm, key size, and mode.
    /// if the key is not a restricted decryption key, this field shall be set to TPM_ALG_NULL.
    /// </summary>
    public: TPMT_SYM_DEF_OBJECT symmetric;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID schemeScheme;
    /// <summary>
    /// scheme.scheme shall be:
    /// for an unrestricted signing key, either TPM_ALG_RSAPSS TPM_ALG_RSASSA or TPM_ALG_NULL
    /// for a restricted signing key, either TPM_ALG_RSAPSS or TPM_ALG_RSASSA
    /// for an unrestricted decryption key, TPM_ALG_RSAES, TPM_ALG_OAEP, or TPM_ALG_NULL unless the object also has the sign attribute
    /// for a restricted decryption key, TPM_ALG_NULL
    /// NOTE	When both sign and decrypt are SET, restricted shall be CLEAR and scheme shall be TPM_ALG_NULL.
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: TPMU_ASYM_SCHEME* scheme;
    /// <summary>
    /// number of bits in the public modulus
    /// </summary>
    public: UINT16 keyBits;
    /// <summary>
    /// the public exponent A prime number greater than 2.
    /// </summary>
    public: UINT32 exponent;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_RSA_PARMS& operator=(const TPMS_RSA_PARMS& rhs);
    public: TPMS_RSA_PARMS(const TPMS_RSA_PARMS& rhs);
    public:
    TPMS_RSA_PARMS();
    virtual ~TPMS_RSA_PARMS();
    /// <summary>
    /// A TPM compatible with this specification and supporting RSA shall support two primes and an exponent of zero. An exponent of zero indicates that the exponent is the default of 216 + 1. Support for other values is optional. Use of other exponents in duplicated keys is not recommended because the resulting keys would not be interoperable with other TPMs.
    /// </summary>
    ///<param name = "symmetric">for a restricted decryption key, shall be set to a supported symmetric algorithm, key size, and mode. if the key is not a restricted decryption key, this field shall be set to TPM_ALG_NULL.</param>
    ///<param name = "scheme">scheme.scheme shall be: for an unrestricted signing key, either TPM_ALG_RSAPSS TPM_ALG_RSASSA or TPM_ALG_NULL for a restricted signing key, either TPM_ALG_RSAPSS or TPM_ALG_RSASSA for an unrestricted decryption key, TPM_ALG_RSAES, TPM_ALG_OAEP, or TPM_ALG_NULL unless the object also has the sign attribute for a restricted decryption key, TPM_ALG_NULL NOTE	When both sign and decrypt are SET, restricted shall be CLEAR and scheme shall be TPM_ALG_NULL.(One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)</param>
    ///<param name = "keyBits">number of bits in the public modulus</param>
    ///<param name = "exponent">the public exponent A prime number greater than 2.</param>
    public: TPMS_RSA_PARMS(
        const TPMT_SYM_DEF_OBJECT& symmetric,
        const TPMU_ASYM_SCHEME& scheme,
        const UINT16& keyBits,
        const UINT32& exponent
    );
};
/// <summary>
/// This structure contains the parameters for prime modulus ECC.
/// </summary>
class _DLLEXP_ TPMS_ECC_PARMS : public virtual TPMU_PUBLIC_PARMS 
{
    friend class StructMarshallInfo;
    /// <summary>
    /// for a restricted decryption key, shall be set to a supported symmetric algorithm, key size. and mode.
    /// if the key is not a restricted decryption key, this field shall be set to TPM_ALG_NULL.
    /// </summary>
    public: TPMT_SYM_DEF_OBJECT symmetric;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID schemeScheme;
    /// <summary>
    /// If the sign attribute of the key is SET, then this shall be a valid signing scheme.
    /// NOTE	If the sign parameter in curveID indicates a mandatory scheme, then this field shall have the same value.
    /// If the decrypt attribute of the key is SET, then this shall be a valid key exchange scheme or TPM_ALG_NULL.
    /// If the key is a Storage Key, then this field shall be TPM_ALG_NULL.
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: TPMU_ASYM_SCHEME* scheme;
    /// <summary>
    /// ECC curve ID
    /// </summary>
    public: TPM_ECC_CURVE curveID;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID kdfScheme;
    /// <summary>
    /// an optional key derivation scheme for generating a symmetric key from a Z value
    /// If the kdf parameter associated with curveID is not TPM_ALG_NULL then this is required to be NULL.
    /// NOTE	There are currently no commands where this parameter has effect and, in the reference code, this field needs to be set to TPM_ALG_NULL.
    /// (One of [TPMS_SCHEME_MGF1, TPMS_SCHEME_KDF1_SP800_56A, TPMS_SCHEME_KDF2, TPMS_SCHEME_KDF1_SP800_108, TPMS_NULL_KDF_SCHEME])
    /// </summary>
    public: TPMU_KDF_SCHEME* kdf;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_ECC_PARMS& operator=(const TPMS_ECC_PARMS& rhs);
    public: TPMS_ECC_PARMS(const TPMS_ECC_PARMS& rhs);
    public:
    TPMS_ECC_PARMS();
    virtual ~TPMS_ECC_PARMS();
    /// <summary>
    /// This structure contains the parameters for prime modulus ECC.
    /// </summary>
    ///<param name = "symmetric">for a restricted decryption key, shall be set to a supported symmetric algorithm, key size. and mode. if the key is not a restricted decryption key, this field shall be set to TPM_ALG_NULL.</param>
    ///<param name = "scheme">If the sign attribute of the key is SET, then this shall be a valid signing scheme. NOTE	If the sign parameter in curveID indicates a mandatory scheme, then this field shall have the same value. If the decrypt attribute of the key is SET, then this shall be a valid key exchange scheme or TPM_ALG_NULL. If the key is a Storage Key, then this field shall be TPM_ALG_NULL.(One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)</param>
    ///<param name = "curveID">ECC curve ID</param>
    ///<param name = "kdf">an optional key derivation scheme for generating a symmetric key from a Z value If the kdf parameter associated with curveID is not TPM_ALG_NULL then this is required to be NULL. NOTE	There are currently no commands where this parameter has effect and, in the reference code, this field needs to be set to TPM_ALG_NULL.(One of TPMS_SCHEME_MGF1, TPMS_SCHEME_KDF1_SP800_56A, TPMS_SCHEME_KDF2, TPMS_SCHEME_KDF1_SP800_108, TPMS_NULL_KDF_SCHEME)</param>
    public: TPMS_ECC_PARMS(
        const TPMT_SYM_DEF_OBJECT& symmetric,
        const TPMU_ASYM_SCHEME& scheme,
        const TPM_ECC_CURVE& curveID,
        const TPMU_KDF_SCHEME& kdf
    );
};
/// <summary>
/// This structure is used in TPM2_TestParms() to validate that a set of algorithm parameters is supported by the TPM.
/// </summary>
class _DLLEXP_ TPMT_PUBLIC_PARMS : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the algorithm to be tested
    /// </summary>
    protected: mutable TPM_ALG_ID type;
    /// <summary>
    /// the algorithm details
    /// (One of [TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS, TPMS_ASYM_PARMS])
    /// </summary>
    public: TPMU_PUBLIC_PARMS* parameters;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMT_PUBLIC_PARMS& operator=(const TPMT_PUBLIC_PARMS& rhs);
    public: TPMT_PUBLIC_PARMS(const TPMT_PUBLIC_PARMS& rhs);
    public:
    TPMT_PUBLIC_PARMS();
    virtual ~TPMT_PUBLIC_PARMS();
    /// <summary>
    /// This structure is used in TPM2_TestParms() to validate that a set of algorithm parameters is supported by the TPM.
    /// </summary>
    ///<param name = "parameters">the algorithm details(One of TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS, TPMS_ASYM_PARMS)</param>
    public: TPMT_PUBLIC_PARMS(
        const TPMU_PUBLIC_PARMS& parameters
    );
};
/// <summary>
/// Table 196 defines the public area structure. The Name of the object is nameAlg concatenated with the digest of this structure using nameAlg.
/// </summary>
class _DLLEXP_ TPMT_PUBLIC : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// algorithm associated with this object
    /// </summary>
    protected: mutable TPM_ALG_ID type;
    /// <summary>
    /// algorithm used for computing the Name of the object
    /// NOTE	The "+" indicates that the instance of a TPMT_PUBLIC may have a "+" to indicate that the nameAlg may be TPM_ALG_NULL.
    /// </summary>
    public: TPM_ALG_ID nameAlg;
    /// <summary>
    /// attributes that, along with type, determine the manipulations of this object
    /// </summary>
    public: TPMA_OBJECT objectAttributes;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 authPolicySize;
    /// <summary>
    /// optional policy for using this key
    /// The policy is computed using the nameAlg of the object.
    /// NOTE Shall be the Empty Policy if no authorization policy is present.
    /// </summary>
    public: std::vector<BYTE> authPolicy;
    /// <summary>
    /// the algorithm or structure details
    /// (One of [TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS, TPMS_ASYM_PARMS])
    /// </summary>
    public: TPMU_PUBLIC_PARMS* parameters;
    /// <summary>
    /// the unique identifier of the structure
    /// For an asymmetric key, this would be the public key.
    /// (One of [TPM2B_DIGEST_Keyedhash, TPM2B_DIGEST_Symcipher, TPM2B_PUBLIC_KEY_RSA, TPMS_ECC_POINT, TPMS_DERIVE])
    /// </summary>
    public: TPMU_PUBLIC_ID* unique;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMT_PUBLIC& operator=(const TPMT_PUBLIC& rhs);
    public: TPMT_PUBLIC(const TPMT_PUBLIC& rhs);
    public:
    TPMT_PUBLIC();
    virtual ~TPMT_PUBLIC();
    /// <summary>
    /// Table 196 defines the public area structure. The Name of the object is nameAlg concatenated with the digest of this structure using nameAlg.
    /// </summary>
    ///<param name = "nameAlg">algorithm used for computing the Name of the object NOTE	The "+" indicates that the instance of a TPMT_PUBLIC may have a "+" to indicate that the nameAlg may be TPM_ALG_NULL.</param>
    ///<param name = "objectAttributes">attributes that, along with type, determine the manipulations of this object</param>
    ///<param name = "authPolicy">optional policy for using this key The policy is computed using the nameAlg of the object. NOTE Shall be the Empty Policy if no authorization policy is present.</param>
    ///<param name = "parameters">the algorithm or structure details(One of TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS, TPMS_ASYM_PARMS)</param>
    ///<param name = "unique">the unique identifier of the structure For an asymmetric key, this would be the public key.(One of TPM2B_DIGEST_Keyedhash, TPM2B_DIGEST_Symcipher, TPM2B_PUBLIC_KEY_RSA, TPMS_ECC_POINT, TPMS_DERIVE)</param>
    public: TPMT_PUBLIC(
        const TPM_ALG_ID& nameAlg,
        const TPMA_OBJECT& objectAttributes,
        const std::vector<BYTE>& authPolicy,
        const TPMU_PUBLIC_PARMS& parameters,
        const TPMU_PUBLIC_ID& unique
    );
#include "Extensions/TPMT_PUBLIC.h"
};
/// <summary>
/// This sized buffer is used to embed a TPMT_PUBLIC in a load command and in any response that returns a public area.
/// </summary>
class _DLLEXP_ TPM2B_PUBLIC : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of publicArea
    /// NOTE	The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// the public area NOTE	The + indicates that the caller may specify that use of TPM_ALG_NULL is allowed for nameAlg.
    /// </summary>
    public: TPMT_PUBLIC publicArea;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_PUBLIC& operator=(const TPM2B_PUBLIC& rhs);
    public: TPM2B_PUBLIC(const TPM2B_PUBLIC& rhs);
    public:
    TPM2B_PUBLIC();
    virtual ~TPM2B_PUBLIC();
    /// <summary>
    /// This sized buffer is used to embed a TPMT_PUBLIC in a load command and in any response that returns a public area.
    /// </summary>
    ///<param name = "publicArea">the public area NOTE	The + indicates that the caller may specify that use of TPM_ALG_NULL is allowed for nameAlg.</param>
    public: TPM2B_PUBLIC(
        const TPMT_PUBLIC& publicArea
    );
};
/// <summary>
/// This sized buffer is used to embed a TPMT_TEMPLATE for TPM2_CreateLoaded().
/// </summary>
class _DLLEXP_ TPM2B_TEMPLATE : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of publicArea
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// the public area
    /// </summary>
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_TEMPLATE& operator=(const TPM2B_TEMPLATE& rhs);
    public: TPM2B_TEMPLATE(const TPM2B_TEMPLATE& rhs);
    public:
    TPM2B_TEMPLATE();
    virtual ~TPM2B_TEMPLATE();
    /// <summary>
    /// This sized buffer is used to embed a TPMT_TEMPLATE for TPM2_CreateLoaded().
    /// </summary>
    ///<param name = "buffer">the public area</param>
    public: TPM2B_TEMPLATE(
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// This structure is defined for coding purposes. For IO to the TPM, the sensitive portion of the key will be in a canonical form. For an RSA key, this will be one of the prime factors of the public modulus. After loading, it is typical that other values will be computed so that computations using the private key will not need to start with just one prime factor. This structure can be used to store the results of such vendor-specific calculations.
/// </summary>
class _DLLEXP_ TPM2B_PRIVATE_VENDOR_SPECIFIC : public virtual TPMU_SENSITIVE_COMPOSITE 
{
    friend class StructMarshallInfo;
    protected: mutable UINT16 size;
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_PRIVATE_VENDOR_SPECIFIC& operator=(const TPM2B_PRIVATE_VENDOR_SPECIFIC& rhs);
    public: TPM2B_PRIVATE_VENDOR_SPECIFIC(const TPM2B_PRIVATE_VENDOR_SPECIFIC& rhs);
    public:
    TPM2B_PRIVATE_VENDOR_SPECIFIC();
    virtual ~TPM2B_PRIVATE_VENDOR_SPECIFIC();
    /// <summary>
    /// This structure is defined for coding purposes. For IO to the TPM, the sensitive portion of the key will be in a canonical form. For an RSA key, this will be one of the prime factors of the public modulus. After loading, it is typical that other values will be computed so that computations using the private key will not need to start with just one prime factor. This structure can be used to store the results of such vendor-specific calculations.
    /// </summary>
    ///<param name = "buffer"></param>
    public: TPM2B_PRIVATE_VENDOR_SPECIFIC(
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// authValue shall not be larger than the size of the digest produced by the nameAlg of the object. seedValue shall be the size of the digest produced by the nameAlg of the object.
/// </summary>
class _DLLEXP_ TPMT_SENSITIVE : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// identifier for the sensitive area This shall be the same as the type parameter of the associated public area.
    /// </summary>
    protected: mutable TPM_ALG_ID sensitiveType;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 authValueSize;
    /// <summary>
    /// user authorization data
    /// The authValue may be a zero-length string.
    /// </summary>
    public: std::vector<BYTE> authValue;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 seedValueSize;
    /// <summary>
    /// for a parent object, the optional protection seed; for other objects, the obfuscation value
    /// </summary>
    public: std::vector<BYTE> seedValue;
    /// <summary>
    /// the type-specific private data
    /// (One of [TPM2B_PRIVATE_KEY_RSA, TPM2B_ECC_PARAMETER, TPM2B_SENSITIVE_DATA, TPM2B_SYM_KEY, TPM2B_PRIVATE_VENDOR_SPECIFIC])
    /// </summary>
    public: TPMU_SENSITIVE_COMPOSITE* sensitive;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMT_SENSITIVE& operator=(const TPMT_SENSITIVE& rhs);
    public: TPMT_SENSITIVE(const TPMT_SENSITIVE& rhs);
    public:
    TPMT_SENSITIVE();
    virtual ~TPMT_SENSITIVE();
    /// <summary>
    /// authValue shall not be larger than the size of the digest produced by the nameAlg of the object. seedValue shall be the size of the digest produced by the nameAlg of the object.
    /// </summary>
    ///<param name = "authValue">user authorization data The authValue may be a zero-length string.</param>
    ///<param name = "seedValue">for a parent object, the optional protection seed; for other objects, the obfuscation value</param>
    ///<param name = "sensitive">the type-specific private data(One of TPM2B_PRIVATE_KEY_RSA, TPM2B_ECC_PARAMETER, TPM2B_SENSITIVE_DATA, TPM2B_SYM_KEY, TPM2B_PRIVATE_VENDOR_SPECIFIC)</param>
    public: TPMT_SENSITIVE(
        const std::vector<BYTE>& authValue,
        const std::vector<BYTE>& seedValue,
        const TPMU_SENSITIVE_COMPOSITE& sensitive
    );
#include "Extensions/TPMT_SENSITIVE.h"
};
/// <summary>
/// The TPM2B_SENSITIVE structure is used as a parameter in TPM2_LoadExternal(). It is an unencrypted sensitive area but it may be encrypted using parameter encryption.
/// </summary>
class _DLLEXP_ TPM2B_SENSITIVE : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the private structure
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// an unencrypted sensitive area
    /// </summary>
    public: TPMT_SENSITIVE sensitiveArea;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_SENSITIVE& operator=(const TPM2B_SENSITIVE& rhs);
    public: TPM2B_SENSITIVE(const TPM2B_SENSITIVE& rhs);
    public:
    TPM2B_SENSITIVE();
    virtual ~TPM2B_SENSITIVE();
    /// <summary>
    /// The TPM2B_SENSITIVE structure is used as a parameter in TPM2_LoadExternal(). It is an unencrypted sensitive area but it may be encrypted using parameter encryption.
    /// </summary>
    ///<param name = "sensitiveArea">an unencrypted sensitive area</param>
    public: TPM2B_SENSITIVE(
        const TPMT_SENSITIVE& sensitiveArea
    );
};
/// <summary>
/// This structure is defined to size the contents of a TPM2B_PRIVATE. This structure is not directly marshaled or unmarshaled.
/// </summary>
class _DLLEXP_ _PRIVATE : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 integrityOuterSize;
    public: std::vector<BYTE> integrityOuter;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 integrityInnerSize;
    /// <summary>
    /// could also be a TPM2B_IV
    /// </summary>
    public: std::vector<BYTE> integrityInner;
    /// <summary>
    /// size of the private structure
    /// </summary>
    protected: mutable UINT16 sensitiveSize;
    /// <summary>
    /// the sensitive area
    /// </summary>
    public: TPMT_SENSITIVE sensitive;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: _PRIVATE& operator=(const _PRIVATE& rhs);
    public: _PRIVATE(const _PRIVATE& rhs);
    public:
    _PRIVATE();
    virtual ~_PRIVATE();
    /// <summary>
    /// This structure is defined to size the contents of a TPM2B_PRIVATE. This structure is not directly marshaled or unmarshaled.
    /// </summary>
    ///<param name = "integrityOuter"></param>
    ///<param name = "integrityInner">could also be a TPM2B_IV</param>
    ///<param name = "sensitive">the sensitive area</param>
    public: _PRIVATE(
        const std::vector<BYTE>& integrityOuter,
        const std::vector<BYTE>& integrityInner,
        const TPMT_SENSITIVE& sensitive
    );
};
/// <summary>
/// The TPM2B_PRIVATE structure is used as a parameter in multiple commands that create, load, and modify the sensitive area of an object.
/// </summary>
class _DLLEXP_ TPM2B_PRIVATE : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the private structure
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// an encrypted private area
    /// </summary>
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_PRIVATE& operator=(const TPM2B_PRIVATE& rhs);
    public: TPM2B_PRIVATE(const TPM2B_PRIVATE& rhs);
    public:
    TPM2B_PRIVATE();
    virtual ~TPM2B_PRIVATE();
    /// <summary>
    /// The TPM2B_PRIVATE structure is used as a parameter in multiple commands that create, load, and modify the sensitive area of an object.
    /// </summary>
    ///<param name = "buffer">an encrypted private area</param>
    public: TPM2B_PRIVATE(
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// This structure is used for sizing the TPM2B_ID_OBJECT.
/// </summary>
class _DLLEXP_ TPMS_ID_OBJECT : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 integrityHMACSize;
    /// <summary>
    /// HMAC using the nameAlg of the storage key on the target TPM
    /// </summary>
    public: std::vector<BYTE> integrityHMAC;
    /// <summary>
    /// credential protector information returned if name matches the referenced object
    /// All of the encIdentity is encrypted, including the size field.
    /// NOTE	The TPM is not required to check that the size is not larger than the digest of the nameAlg. However, if the size is larger, the ID object may not be usable on a TPM that has no digest larger than produced by nameAlg.
    /// </summary>
    public: std::vector<BYTE> encIdentity;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_ID_OBJECT& operator=(const TPMS_ID_OBJECT& rhs);
    public: TPMS_ID_OBJECT(const TPMS_ID_OBJECT& rhs);
    public:
    TPMS_ID_OBJECT();
    virtual ~TPMS_ID_OBJECT();
    /// <summary>
    /// This structure is used for sizing the TPM2B_ID_OBJECT.
    /// </summary>
    ///<param name = "integrityHMAC">HMAC using the nameAlg of the storage key on the target TPM</param>
    ///<param name = "encIdentity">credential protector information returned if name matches the referenced object All of the encIdentity is encrypted, including the size field. NOTE	The TPM is not required to check that the size is not larger than the digest of the nameAlg. However, if the size is larger, the ID object may not be usable on a TPM that has no digest larger than produced by nameAlg.</param>
    public: TPMS_ID_OBJECT(
        const std::vector<BYTE>& integrityHMAC,
        const std::vector<BYTE>& encIdentity
    );
};
/// <summary>
/// This structure is an output from TPM2_MakeCredential() and is an input to TPM2_ActivateCredential().
/// </summary>
class _DLLEXP_ TPM2B_ID_OBJECT : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the credential structure
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// an encrypted credential area
    /// </summary>
    public: TPMS_ID_OBJECT credential;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_ID_OBJECT& operator=(const TPM2B_ID_OBJECT& rhs);
    public: TPM2B_ID_OBJECT(const TPM2B_ID_OBJECT& rhs);
    public:
    TPM2B_ID_OBJECT();
    virtual ~TPM2B_ID_OBJECT();
    /// <summary>
    /// This structure is an output from TPM2_MakeCredential() and is an input to TPM2_ActivateCredential().
    /// </summary>
    ///<param name = "credential">an encrypted credential area</param>
    public: TPM2B_ID_OBJECT(
        const TPMS_ID_OBJECT& credential
    );
};
/// <summary>
/// This is the data that can be written to and read from a TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL non-volatile index. pinCount is the most significant octets. pinLimit is the least significant octets.
/// </summary>
class _DLLEXP_ TPMS_NV_PIN_COUNTER_PARAMETERS : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// This counter shows the current number of successful authValue authorization attempts to access a TPM_NT_PIN_PASS index or the current number of unsuccessful authValue authorization attempts to access a TPM_NT_PIN_FAIL index.
    /// </summary>
    public: UINT32 pinCount;
    /// <summary>
    /// This threshold is the value of pinCount at which the authValue authorization of the host TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL index is locked out.
    /// </summary>
    public: UINT32 pinLimit;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_NV_PIN_COUNTER_PARAMETERS& operator=(const TPMS_NV_PIN_COUNTER_PARAMETERS& rhs);
    public: TPMS_NV_PIN_COUNTER_PARAMETERS(const TPMS_NV_PIN_COUNTER_PARAMETERS& rhs);
    public:
    TPMS_NV_PIN_COUNTER_PARAMETERS();
    virtual ~TPMS_NV_PIN_COUNTER_PARAMETERS();
    /// <summary>
    /// This is the data that can be written to and read from a TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL non-volatile index. pinCount is the most significant octets. pinLimit is the least significant octets.
    /// </summary>
    ///<param name = "pinCount">This counter shows the current number of successful authValue authorization attempts to access a TPM_NT_PIN_PASS index or the current number of unsuccessful authValue authorization attempts to access a TPM_NT_PIN_FAIL index.</param>
    ///<param name = "pinLimit">This threshold is the value of pinCount at which the authValue authorization of the host TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL index is locked out.</param>
    public: TPMS_NV_PIN_COUNTER_PARAMETERS(
        const UINT32& pinCount,
        const UINT32& pinLimit
    );
};
/// <summary>
/// This structure describes an NV Index.
/// </summary>
class _DLLEXP_ TPMS_NV_PUBLIC : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the handle of the data area
    /// </summary>
    public: TPM_HANDLE nvIndex;
    /// <summary>
    /// hash algorithm used to compute the name of the Index and used for the authPolicy. For an extend index, the hash algorithm used for the extend.
    /// </summary>
    public: TPM_ALG_ID nameAlg;
    /// <summary>
    /// the Index attributes
    /// </summary>
    public: TPMA_NV attributes;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 authPolicySize;
    /// <summary>
    /// optional access policy for the Index The policy is computed using the nameAlg NOTE Shall be the Empty Policy if no authorization policy is present.
    /// </summary>
    public: std::vector<BYTE> authPolicy;
    /// <summary>
    /// the size of the data area
    /// The maximum size is implementation-dependent. The minimum maximum size is platform-specific.
    /// </summary>
    public: UINT16 dataSize;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_NV_PUBLIC& operator=(const TPMS_NV_PUBLIC& rhs);
    public: TPMS_NV_PUBLIC(const TPMS_NV_PUBLIC& rhs);
    public:
    TPMS_NV_PUBLIC();
    virtual ~TPMS_NV_PUBLIC();
    /// <summary>
    /// This structure describes an NV Index.
    /// </summary>
    ///<param name = "nvIndex">the handle of the data area</param>
    ///<param name = "nameAlg">hash algorithm used to compute the name of the Index and used for the authPolicy. For an extend index, the hash algorithm used for the extend.</param>
    ///<param name = "attributes">the Index attributes</param>
    ///<param name = "authPolicy">optional access policy for the Index The policy is computed using the nameAlg NOTE Shall be the Empty Policy if no authorization policy is present.</param>
    ///<param name = "dataSize">the size of the data area The maximum size is implementation-dependent. The minimum maximum size is platform-specific.</param>
    public: TPMS_NV_PUBLIC(
        const TPM_HANDLE& nvIndex,
        const TPM_ALG_ID& nameAlg,
        const TPMA_NV& attributes,
        const std::vector<BYTE>& authPolicy,
        const UINT16& dataSize
    );
};
/// <summary>
/// This structure is used when a TPMS_NV_PUBLIC is sent on the TPM interface.
/// </summary>
class _DLLEXP_ TPM2B_NV_PUBLIC : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of nvPublic
    /// </summary>
    protected: mutable UINT16 size;
    /// <summary>
    /// the public area
    /// </summary>
    public: TPMS_NV_PUBLIC nvPublic;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_NV_PUBLIC& operator=(const TPM2B_NV_PUBLIC& rhs);
    public: TPM2B_NV_PUBLIC(const TPM2B_NV_PUBLIC& rhs);
    public:
    TPM2B_NV_PUBLIC();
    virtual ~TPM2B_NV_PUBLIC();
    /// <summary>
    /// This structure is used when a TPMS_NV_PUBLIC is sent on the TPM interface.
    /// </summary>
    ///<param name = "nvPublic">the public area</param>
    public: TPM2B_NV_PUBLIC(
        const TPMS_NV_PUBLIC& nvPublic
    );
};
/// <summary>
/// This structure holds the object or session context data. When saved, the full structure is encrypted.
/// </summary>
class _DLLEXP_ TPM2B_CONTEXT_SENSITIVE : public TpmStructureBase
{
    friend class StructMarshallInfo;
    protected: mutable UINT16 size;
    /// <summary>
    /// the sensitive data
    /// </summary>
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_CONTEXT_SENSITIVE& operator=(const TPM2B_CONTEXT_SENSITIVE& rhs);
    public: TPM2B_CONTEXT_SENSITIVE(const TPM2B_CONTEXT_SENSITIVE& rhs);
    public:
    TPM2B_CONTEXT_SENSITIVE();
    virtual ~TPM2B_CONTEXT_SENSITIVE();
    /// <summary>
    /// This structure holds the object or session context data. When saved, the full structure is encrypted.
    /// </summary>
    ///<param name = "buffer">the sensitive data</param>
    public: TPM2B_CONTEXT_SENSITIVE(
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// This structure holds the integrity value and the encrypted data for a context.
/// </summary>
class _DLLEXP_ TPMS_CONTEXT_DATA : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 integritySize;
    /// <summary>
    /// the integrity value
    /// </summary>
    public: std::vector<BYTE> integrity;
    /// <summary>
    /// the sensitive area
    /// </summary>
    public: std::vector<BYTE> encrypted;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_CONTEXT_DATA& operator=(const TPMS_CONTEXT_DATA& rhs);
    public: TPMS_CONTEXT_DATA(const TPMS_CONTEXT_DATA& rhs);
    public:
    TPMS_CONTEXT_DATA();
    virtual ~TPMS_CONTEXT_DATA();
    /// <summary>
    /// This structure holds the integrity value and the encrypted data for a context.
    /// </summary>
    ///<param name = "integrity">the integrity value</param>
    ///<param name = "encrypted">the sensitive area</param>
    public: TPMS_CONTEXT_DATA(
        const std::vector<BYTE>& integrity,
        const std::vector<BYTE>& encrypted
    );
};
/// <summary>
/// This structure is used in a TPMS_CONTEXT.
/// </summary>
class _DLLEXP_ TPM2B_CONTEXT_DATA : public TpmStructureBase
{
    friend class StructMarshallInfo;
    protected: mutable UINT16 size;
    public: TPMS_CONTEXT_DATA buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_CONTEXT_DATA& operator=(const TPM2B_CONTEXT_DATA& rhs);
    public: TPM2B_CONTEXT_DATA(const TPM2B_CONTEXT_DATA& rhs);
    public:
    TPM2B_CONTEXT_DATA();
    virtual ~TPM2B_CONTEXT_DATA();
    /// <summary>
    /// This structure is used in a TPMS_CONTEXT.
    /// </summary>
    ///<param name = "buffer"></param>
    public: TPM2B_CONTEXT_DATA(
        const TPMS_CONTEXT_DATA& buffer
    );
};
/// <summary>
/// This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when the context was saved (TPM2_ContextSave()), then the TPM shall not load the context.
/// </summary>
class _DLLEXP_ TPMS_CONTEXT : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the sequence number of the context
    /// NOTE	Transient object contexts and session contexts used different counters.
    /// </summary>
    public: UINT64 sequence;
    /// <summary>
    /// a handle indicating if the context is a session, object, or sequence object (see Table 217  Context Handle Values
    /// </summary>
    public: TPM_HANDLE savedHandle;
    /// <summary>
    /// the hierarchy of the context
    /// </summary>
    public: TPM_HANDLE hierarchy;
    protected: mutable UINT16 contextBlobSize;
    /// <summary>
    /// the context data and integrity HMAC
    /// </summary>
    public: TPMS_CONTEXT_DATA contextBlob;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_CONTEXT& operator=(const TPMS_CONTEXT& rhs);
    public: TPMS_CONTEXT(const TPMS_CONTEXT& rhs);
    public:
    TPMS_CONTEXT();
    virtual ~TPMS_CONTEXT();
    /// <summary>
    /// This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when the context was saved (TPM2_ContextSave()), then the TPM shall not load the context.
    /// </summary>
    ///<param name = "sequence">the sequence number of the context NOTE	Transient object contexts and session contexts used different counters.</param>
    ///<param name = "savedHandle">a handle indicating if the context is a session, object, or sequence object (see Table 217  Context Handle Values</param>
    ///<param name = "hierarchy">the hierarchy of the context</param>
    ///<param name = "contextBlob">the context data and integrity HMAC</param>
    public: TPMS_CONTEXT(
        const UINT64& sequence,
        const TPM_HANDLE& savedHandle,
        const TPM_HANDLE& hierarchy,
        const TPMS_CONTEXT_DATA& contextBlob
    );
};
/// <summary>
/// This structure provides information relating to the creation environment for the object. The creation data includes the parent Name, parent Qualified Name, and the digest of selected PCR. These values represent the environment in which the object was created. Creation data allows a relying party to determine if an object was created when some appropriate protections were present.
/// </summary>
class _DLLEXP_ TPMS_CREATION_DATA : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 pcrSelectCount;
    /// <summary>
    /// list indicating the PCR included in pcrDigest
    /// </summary>
    public: std::vector<TPMS_PCR_SELECTION> pcrSelect;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 pcrDigestSize;
    /// <summary>
    /// digest of the selected PCR using nameAlg of the object for which this structure is being created
    /// pcrDigest.size shall be zero if the pcrSelect list is empty.
    /// </summary>
    public: std::vector<BYTE> pcrDigest;
    /// <summary>
    /// the locality at which the object was created
    /// </summary>
    public: TPMA_LOCALITY locality;
    /// <summary>
    /// nameAlg of the parent
    /// </summary>
    public: TPM_ALG_ID parentNameAlg;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 parentNameSize;
    /// <summary>
    /// Name of the parent at time of creation
    /// The size will match digest size associated with parentNameAlg unless it is TPM_ALG_NULL, in which case the size will be 4 and parentName will be the hierarchy handle.
    /// </summary>
    public: std::vector<BYTE> parentName;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 parentQualifiedNameSize;
    /// <summary>
    /// Qualified Name of the parent at the time of creation
    /// Size is the same as parentName.
    /// </summary>
    public: std::vector<BYTE> parentQualifiedName;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 outsideInfoSize;
    /// <summary>
    /// association with additional information added by the key creator
    /// This will be the contents of the outsideInfo parameter in TPM2_Create() or TPM2_CreatePrimary().
    /// </summary>
    public: std::vector<BYTE> outsideInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_CREATION_DATA& operator=(const TPMS_CREATION_DATA& rhs);
    public: TPMS_CREATION_DATA(const TPMS_CREATION_DATA& rhs);
    public:
    TPMS_CREATION_DATA();
    virtual ~TPMS_CREATION_DATA();
    /// <summary>
    /// This structure provides information relating to the creation environment for the object. The creation data includes the parent Name, parent Qualified Name, and the digest of selected PCR. These values represent the environment in which the object was created. Creation data allows a relying party to determine if an object was created when some appropriate protections were present.
    /// </summary>
    ///<param name = "pcrSelect">list indicating the PCR included in pcrDigest</param>
    ///<param name = "pcrDigest">digest of the selected PCR using nameAlg of the object for which this structure is being created pcrDigest.size shall be zero if the pcrSelect list is empty.</param>
    ///<param name = "locality">the locality at which the object was created</param>
    ///<param name = "parentNameAlg">nameAlg of the parent</param>
    ///<param name = "parentName">Name of the parent at time of creation The size will match digest size associated with parentNameAlg unless it is TPM_ALG_NULL, in which case the size will be 4 and parentName will be the hierarchy handle.</param>
    ///<param name = "parentQualifiedName">Qualified Name of the parent at the time of creation Size is the same as parentName.</param>
    ///<param name = "outsideInfo">association with additional information added by the key creator This will be the contents of the outsideInfo parameter in TPM2_Create() or TPM2_CreatePrimary().</param>
    public: TPMS_CREATION_DATA(
        const std::vector<TPMS_PCR_SELECTION>& pcrSelect,
        const std::vector<BYTE>& pcrDigest,
        const TPMA_LOCALITY& locality,
        const TPM_ALG_ID& parentNameAlg,
        const std::vector<BYTE>& parentName,
        const std::vector<BYTE>& parentQualifiedName,
        const std::vector<BYTE>& outsideInfo
    );
};
/// <summary>
/// This structure is created by TPM2_Create() and TPM2_CreatePrimary(). It is never entered into the TPM and never has a size of zero.
/// </summary>
class _DLLEXP_ TPM2B_CREATION_DATA : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the creation data
    /// </summary>
    protected: mutable UINT16 size;
    public: TPMS_CREATION_DATA creationData;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_CREATION_DATA& operator=(const TPM2B_CREATION_DATA& rhs);
    public: TPM2B_CREATION_DATA(const TPM2B_CREATION_DATA& rhs);
    public:
    TPM2B_CREATION_DATA();
    virtual ~TPM2B_CREATION_DATA();
    /// <summary>
    /// This structure is created by TPM2_Create() and TPM2_CreatePrimary(). It is never entered into the TPM and never has a size of zero.
    /// </summary>
    ///<param name = "creationData"></param>
    public: TPM2B_CREATION_DATA(
        const TPMS_CREATION_DATA& creationData
    );
};
/// <summary>
/// TPMS_AC_OUTPUT is used to return information about an AC. The tag structure parameter indicates the type of the data value.
/// </summary>
class _DLLEXP_ TPMS_AC_OUTPUT : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// tag indicating the contents of data
    /// </summary>
    public: TPM_AT tag;
    /// <summary>
    /// the data returned from the AC
    /// </summary>
    public: UINT32 data;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPMS_AC_OUTPUT& operator=(const TPMS_AC_OUTPUT& rhs);
    public: TPMS_AC_OUTPUT(const TPMS_AC_OUTPUT& rhs);
    public:
    TPMS_AC_OUTPUT();
    virtual ~TPMS_AC_OUTPUT();
    /// <summary>
    /// TPMS_AC_OUTPUT is used to return information about an AC. The tag structure parameter indicates the type of the data value.
    /// </summary>
    ///<param name = "tag">tag indicating the contents of data</param>
    ///<param name = "data">the data returned from the AC</param>
    public: TPMS_AC_OUTPUT(
        const TPM_AT& tag,
        const UINT32& data
    );
};
/// <summary>
/// This list is only used in TPM2_AC_GetCapability().
/// </summary>
class _DLLEXP_ TPML_AC_CAPABILITIES : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of values in the acCapabilities list; may be 0
    /// </summary>
    protected: mutable UINT32 count;
    /// <summary>
    /// a list of AC values
    /// </summary>
    public: std::vector<TPMS_AC_OUTPUT> acCapabilities;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPML_AC_CAPABILITIES& operator=(const TPML_AC_CAPABILITIES& rhs);
    public: TPML_AC_CAPABILITIES(const TPML_AC_CAPABILITIES& rhs);
    public:
    TPML_AC_CAPABILITIES();
    virtual ~TPML_AC_CAPABILITIES();
    /// <summary>
    /// This list is only used in TPM2_AC_GetCapability().
    /// </summary>
    ///<param name = "acCapabilities">a list of AC values</param>
    public: TPML_AC_CAPABILITIES(
        const std::vector<TPMS_AC_OUTPUT>& acCapabilities
    );
};
/// <summary>
/// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
/// </summary>
class _DLLEXP_ TPM2_Startup_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_SU_CLEAR or TPM_SU_STATE
    /// </summary>
    public: TPM_SU startupType;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_Startup_REQUEST& operator=(const TPM2_Startup_REQUEST& rhs);
    public: TPM2_Startup_REQUEST(const TPM2_Startup_REQUEST& rhs);
    public:
    TPM2_Startup_REQUEST();
    virtual ~TPM2_Startup_REQUEST();
    /// <summary>
    /// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
    /// </summary>
    ///<param name = "startupType">TPM_SU_CLEAR or TPM_SU_STATE</param>
    public: TPM2_Startup_REQUEST(
        const TPM_SU& startupType
    );
};
/// <summary>
/// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
/// </summary>
class _DLLEXP_ StartupResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: StartupResponse& operator=(const StartupResponse& rhs);
    public: StartupResponse(const StartupResponse& rhs);
    public:
    StartupResponse();
    virtual ~StartupResponse();
};
/// <summary>
/// This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
/// </summary>
class _DLLEXP_ TPM2_Shutdown_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_SU_CLEAR or TPM_SU_STATE
    /// </summary>
    public: TPM_SU shutdownType;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_Shutdown_REQUEST& operator=(const TPM2_Shutdown_REQUEST& rhs);
    public: TPM2_Shutdown_REQUEST(const TPM2_Shutdown_REQUEST& rhs);
    public:
    TPM2_Shutdown_REQUEST();
    virtual ~TPM2_Shutdown_REQUEST();
    /// <summary>
    /// This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
    /// </summary>
    ///<param name = "shutdownType">TPM_SU_CLEAR or TPM_SU_STATE</param>
    public: TPM2_Shutdown_REQUEST(
        const TPM_SU& shutdownType
    );
};
/// <summary>
/// This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
/// </summary>
class _DLLEXP_ ShutdownResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: ShutdownResponse& operator=(const ShutdownResponse& rhs);
    public: ShutdownResponse(const ShutdownResponse& rhs);
    public:
    ShutdownResponse();
    virtual ~ShutdownResponse();
};
/// <summary>
/// This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
/// </summary>
class _DLLEXP_ TPM2_SelfTest_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// YES if full test to be performed
    /// NO if only test of untested functions required
    /// </summary>
    public: BYTE fullTest;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_SelfTest_REQUEST& operator=(const TPM2_SelfTest_REQUEST& rhs);
    public: TPM2_SelfTest_REQUEST(const TPM2_SelfTest_REQUEST& rhs);
    public:
    TPM2_SelfTest_REQUEST();
    virtual ~TPM2_SelfTest_REQUEST();
    /// <summary>
    /// This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
    /// </summary>
    ///<param name = "fullTest">YES if full test to be performed NO if only test of untested functions required</param>
    public: TPM2_SelfTest_REQUEST(
        const BYTE& fullTest
    );
};
/// <summary>
/// This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
/// </summary>
class _DLLEXP_ SelfTestResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: SelfTestResponse& operator=(const SelfTestResponse& rhs);
    public: SelfTestResponse(const SelfTestResponse& rhs);
    public:
    SelfTestResponse();
    virtual ~SelfTestResponse();
};
/// <summary>
/// This command causes the TPM to perform a test of the selected algorithms.
/// </summary>
class _DLLEXP_ TPM2_IncrementalSelfTest_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of algorithms in the algorithms list; may be 0
    /// </summary>
    protected: mutable UINT32 toTestCount;
    /// <summary>
    /// list of algorithms that should be tested
    /// </summary>
    public: std::vector<TPM_ALG_ID> toTest;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_IncrementalSelfTest_REQUEST& operator=(const TPM2_IncrementalSelfTest_REQUEST& rhs);
    public: TPM2_IncrementalSelfTest_REQUEST(const TPM2_IncrementalSelfTest_REQUEST& rhs);
    public:
    TPM2_IncrementalSelfTest_REQUEST();
    virtual ~TPM2_IncrementalSelfTest_REQUEST();
    /// <summary>
    /// This command causes the TPM to perform a test of the selected algorithms.
    /// </summary>
    ///<param name = "toTest">list of algorithms that should be tested</param>
    public: TPM2_IncrementalSelfTest_REQUEST(
        const std::vector<TPM_ALG_ID>& toTest
    );
};
/// <summary>
/// This command causes the TPM to perform a test of the selected algorithms.
/// </summary>
class _DLLEXP_ IncrementalSelfTestResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of algorithms in the algorithms list; may be 0
    /// </summary>
    protected: mutable UINT32 toDoListCount;
    /// <summary>
    /// list of algorithms that need testing
    /// </summary>
    public: std::vector<TPM_ALG_ID> toDoList;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: IncrementalSelfTestResponse& operator=(const IncrementalSelfTestResponse& rhs);
    public: IncrementalSelfTestResponse(const IncrementalSelfTestResponse& rhs);
    public:
    IncrementalSelfTestResponse();
    virtual ~IncrementalSelfTestResponse();
    /// <summary>
    /// This command causes the TPM to perform a test of the selected algorithms.
    /// </summary>
    ///<param name = "toDoList">list of algorithms that need testing</param>
    public: IncrementalSelfTestResponse(
        const std::vector<TPM_ALG_ID>& toDoList
    );
};
/// <summary>
/// This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
/// </summary>
class _DLLEXP_ TPM2_GetTestResult_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_GetTestResult_REQUEST& operator=(const TPM2_GetTestResult_REQUEST& rhs);
    public: TPM2_GetTestResult_REQUEST(const TPM2_GetTestResult_REQUEST& rhs);
    public:
    TPM2_GetTestResult_REQUEST();
    virtual ~TPM2_GetTestResult_REQUEST();
};
/// <summary>
/// This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
/// </summary>
class _DLLEXP_ GetTestResultResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 outDataSize;
    /// <summary>
    /// test result data
    /// contains manufacturer-specific information
    /// </summary>
    public: std::vector<BYTE> outData;
    public: TPM_RC testResult;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: GetTestResultResponse& operator=(const GetTestResultResponse& rhs);
    public: GetTestResultResponse(const GetTestResultResponse& rhs);
    public:
    GetTestResultResponse();
    virtual ~GetTestResultResponse();
    /// <summary>
    /// This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
    /// </summary>
    ///<param name = "outData">test result data contains manufacturer-specific information</param>
    ///<param name = "testResult"></param>
    public: GetTestResultResponse(
        const std::vector<BYTE>& outData,
        const TPM_RC& testResult
    );
};
/// <summary>
/// This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
/// </summary>
class _DLLEXP_ TPM2_StartAuthSession_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of a loaded decrypt key used to encrypt salt
    /// may be TPM_RH_NULL
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE tpmKey;
    /// <summary>
    /// entity providing the authValue
    /// may be TPM_RH_NULL
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE bind;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 nonceCallerSize;
    /// <summary>
    /// initial nonceCaller, sets nonceTPM size for the session
    /// shall be at least 16 octets
    /// </summary>
    public: std::vector<BYTE> nonceCaller;
    /// <summary>
    /// size of the secret value
    /// </summary>
    protected: mutable UINT16 encryptedSaltSize;
    /// <summary>
    /// value encrypted according to the type of tpmKey
    /// If tpmKey is TPM_RH_NULL, this shall be the Empty Buffer.
    /// </summary>
    public: std::vector<BYTE> encryptedSalt;
    /// <summary>
    /// indicates the type of the session; simple HMAC or policy (including a trial policy)
    /// </summary>
    public: TPM_SE sessionType;
    /// <summary>
    /// the algorithm and key size for parameter encryption
    /// may select TPM_ALG_NULL
    /// </summary>
    public: TPMT_SYM_DEF symmetric;
    /// <summary>
    /// hash algorithm to use for the session
    /// Shall be a hash algorithm supported by the TPM and not TPM_ALG_NULL
    /// </summary>
    public: TPM_ALG_ID authHash;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_StartAuthSession_REQUEST& operator=(const TPM2_StartAuthSession_REQUEST& rhs);
    public: TPM2_StartAuthSession_REQUEST(const TPM2_StartAuthSession_REQUEST& rhs);
    public:
    TPM2_StartAuthSession_REQUEST();
    virtual ~TPM2_StartAuthSession_REQUEST();
    /// <summary>
    /// This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
    /// </summary>
    ///<param name = "tpmKey">handle of a loaded decrypt key used to encrypt salt may be TPM_RH_NULL Auth Index: None</param>
    ///<param name = "bind">entity providing the authValue may be TPM_RH_NULL Auth Index: None</param>
    ///<param name = "nonceCaller">initial nonceCaller, sets nonceTPM size for the session shall be at least 16 octets</param>
    ///<param name = "encryptedSalt">value encrypted according to the type of tpmKey If tpmKey is TPM_RH_NULL, this shall be the Empty Buffer.</param>
    ///<param name = "sessionType">indicates the type of the session; simple HMAC or policy (including a trial policy)</param>
    ///<param name = "symmetric">the algorithm and key size for parameter encryption may select TPM_ALG_NULL</param>
    ///<param name = "authHash">hash algorithm to use for the session Shall be a hash algorithm supported by the TPM and not TPM_ALG_NULL</param>
    public: TPM2_StartAuthSession_REQUEST(
        const TPM_HANDLE& tpmKey,
        const TPM_HANDLE& bind,
        const std::vector<BYTE>& nonceCaller,
        const std::vector<BYTE>& encryptedSalt,
        const TPM_SE& sessionType,
        const TPMT_SYM_DEF& symmetric,
        const TPM_ALG_ID& authHash
    );
};
/// <summary>
/// This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
/// </summary>
class _DLLEXP_ StartAuthSessionResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the newly created session
    /// </summary>
    public: TPM_HANDLE handle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 nonceTPMSize;
    /// <summary>
    /// the initial nonce from the TPM, used in the computation of the sessionKey
    /// </summary>
    public: std::vector<BYTE> nonceTPM;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: StartAuthSessionResponse& operator=(const StartAuthSessionResponse& rhs);
    public: StartAuthSessionResponse(const StartAuthSessionResponse& rhs);
    public:
    StartAuthSessionResponse();
    virtual ~StartAuthSessionResponse();
    /// <summary>
    /// This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
    /// </summary>
    ///<param name = "handle">handle for the newly created session</param>
    ///<param name = "nonceTPM">the initial nonce from the TPM, used in the computation of the sessionKey</param>
    public: StartAuthSessionResponse(
        const TPM_HANDLE& handle,
        const std::vector<BYTE>& nonceTPM
    );
};
/// <summary>
/// This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
/// </summary>
class _DLLEXP_ TPM2_PolicyRestart_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the handle for the policy session
    /// </summary>
    public: TPM_HANDLE sessionHandle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyRestart_REQUEST& operator=(const TPM2_PolicyRestart_REQUEST& rhs);
    public: TPM2_PolicyRestart_REQUEST(const TPM2_PolicyRestart_REQUEST& rhs);
    public:
    TPM2_PolicyRestart_REQUEST();
    virtual ~TPM2_PolicyRestart_REQUEST();
    /// <summary>
    /// This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
    /// </summary>
    ///<param name = "sessionHandle">the handle for the policy session</param>
    public: TPM2_PolicyRestart_REQUEST(
        const TPM_HANDLE& sessionHandle
    );
};
/// <summary>
/// This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
/// </summary>
class _DLLEXP_ PolicyRestartResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyRestartResponse& operator=(const PolicyRestartResponse& rhs);
    public: PolicyRestartResponse(const PolicyRestartResponse& rhs);
    public:
    PolicyRestartResponse();
    virtual ~PolicyRestartResponse();
};
/// <summary>
/// This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
/// </summary>
class _DLLEXP_ TPM2_Create_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of parent for new object
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE parentHandle;
    /// <summary>
    /// size of sensitive in octets (may not be zero)
    /// NOTE	The userAuth and data parameters in this buffer may both be zero length but the minimum size of this parameter will be the sum of the size fields of the two parameters of the TPMS_SENSITIVE_CREATE.
    /// </summary>
    protected: mutable UINT16 inSensitiveSize;
    /// <summary>
    /// the sensitive data
    /// </summary>
    public: TPMS_SENSITIVE_CREATE inSensitive;
    /// <summary>
    /// size of publicArea
    /// NOTE	The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 inPublicSize;
    /// <summary>
    /// the public template
    /// </summary>
    public: TPMT_PUBLIC inPublic;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 outsideInfoSize;
    /// <summary>
    /// data that will be included in the creation data for this object to provide permanent, verifiable linkage between this object and some object owner data
    /// </summary>
    public: std::vector<BYTE> outsideInfo;
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 creationPCRCount;
    /// <summary>
    /// PCR that will be used in creation data
    /// </summary>
    public: std::vector<TPMS_PCR_SELECTION> creationPCR;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_Create_REQUEST& operator=(const TPM2_Create_REQUEST& rhs);
    public: TPM2_Create_REQUEST(const TPM2_Create_REQUEST& rhs);
    public:
    TPM2_Create_REQUEST();
    virtual ~TPM2_Create_REQUEST();
    /// <summary>
    /// This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
    /// </summary>
    ///<param name = "parentHandle">handle of parent for new object Auth Index: 1 Auth Role: USER</param>
    ///<param name = "inSensitive">the sensitive data</param>
    ///<param name = "inPublic">the public template</param>
    ///<param name = "outsideInfo">data that will be included in the creation data for this object to provide permanent, verifiable linkage between this object and some object owner data</param>
    ///<param name = "creationPCR">PCR that will be used in creation data</param>
    public: TPM2_Create_REQUEST(
        const TPM_HANDLE& parentHandle,
        const TPMS_SENSITIVE_CREATE& inSensitive,
        const TPMT_PUBLIC& inPublic,
        const std::vector<BYTE>& outsideInfo,
        const std::vector<TPMS_PCR_SELECTION>& creationPCR
    );
};
/// <summary>
/// This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
/// </summary>
class _DLLEXP_ CreateResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the private portion of the object
    /// </summary>
    public: TPM2B_PRIVATE outPrivate;
    /// <summary>
    /// size of publicArea
    /// NOTE	The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 outPublicSize;
    /// <summary>
    /// the public portion of the created object
    /// </summary>
    public: TPMT_PUBLIC outPublic;
    /// <summary>
    /// size of the creation data
    /// </summary>
    protected: mutable UINT16 creationDataSize;
    /// <summary>
    /// contains a TPMS_CREATION_DATA
    /// </summary>
    public: TPMS_CREATION_DATA creationData;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 creationHashSize;
    /// <summary>
    /// digest of creationData using nameAlg of outPublic
    /// </summary>
    public: std::vector<BYTE> creationHash;
    /// <summary>
    /// ticket used by TPM2_CertifyCreation() to validate that the creation data was produced by the TPM
    /// </summary>
    public: TPMT_TK_CREATION creationTicket;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: CreateResponse& operator=(const CreateResponse& rhs);
    public: CreateResponse(const CreateResponse& rhs);
    public:
    CreateResponse();
    virtual ~CreateResponse();
    /// <summary>
    /// This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
    /// </summary>
    ///<param name = "outPrivate">the private portion of the object</param>
    ///<param name = "outPublic">the public portion of the created object</param>
    ///<param name = "creationData">contains a TPMS_CREATION_DATA</param>
    ///<param name = "creationHash">digest of creationData using nameAlg of outPublic</param>
    ///<param name = "creationTicket">ticket used by TPM2_CertifyCreation() to validate that the creation data was produced by the TPM</param>
    public: CreateResponse(
        const TPM2B_PRIVATE& outPrivate,
        const TPMT_PUBLIC& outPublic,
        const TPMS_CREATION_DATA& creationData,
        const std::vector<BYTE>& creationHash,
        const TPMT_TK_CREATION& creationTicket
    );
};
/// <summary>
/// This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
/// </summary>
class _DLLEXP_ TPM2_Load_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM handle of parent key; shall not be a reserved handle
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE parentHandle;
    /// <summary>
    /// the private portion of the object
    /// </summary>
    public: TPM2B_PRIVATE inPrivate;
    /// <summary>
    /// size of publicArea
    /// NOTE	The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 inPublicSize;
    /// <summary>
    /// the public portion of the object
    /// </summary>
    public: TPMT_PUBLIC inPublic;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_Load_REQUEST& operator=(const TPM2_Load_REQUEST& rhs);
    public: TPM2_Load_REQUEST(const TPM2_Load_REQUEST& rhs);
    public:
    TPM2_Load_REQUEST();
    virtual ~TPM2_Load_REQUEST();
    /// <summary>
    /// This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
    /// </summary>
    ///<param name = "parentHandle">TPM handle of parent key; shall not be a reserved handle Auth Index: 1 Auth Role: USER</param>
    ///<param name = "inPrivate">the private portion of the object</param>
    ///<param name = "inPublic">the public portion of the object</param>
    public: TPM2_Load_REQUEST(
        const TPM_HANDLE& parentHandle,
        const TPM2B_PRIVATE& inPrivate,
        const TPMT_PUBLIC& inPublic
    );
};
/// <summary>
/// This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
/// </summary>
class _DLLEXP_ LoadResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of type TPM_HT_TRANSIENT for the loaded object
    /// </summary>
    public: TPM_HANDLE handle;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 nameSize;
    /// <summary>
    /// Name of the loaded object
    /// </summary>
    public: std::vector<BYTE> name;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: LoadResponse& operator=(const LoadResponse& rhs);
    public: LoadResponse(const LoadResponse& rhs);
    public:
    LoadResponse();
    virtual ~LoadResponse();
    /// <summary>
    /// This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
    /// </summary>
    ///<param name = "handle">handle of type TPM_HT_TRANSIENT for the loaded object</param>
    ///<param name = "name">Name of the loaded object</param>
    public: LoadResponse(
        const TPM_HANDLE& handle,
        const std::vector<BYTE>& name
    );
};
/// <summary>
/// This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
/// </summary>
class _DLLEXP_ TPM2_LoadExternal_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the private structure
    /// </summary>
    protected: mutable UINT16 inPrivateSize;
    /// <summary>
    /// the sensitive portion of the object (optional)
    /// </summary>
    public: TPMT_SENSITIVE inPrivate;
    /// <summary>
    /// size of publicArea
    /// NOTE	The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 inPublicSize;
    /// <summary>
    /// the public portion of the object
    /// </summary>
    public: TPMT_PUBLIC inPublic;
    /// <summary>
    /// hierarchy with which the object area is associated
    /// </summary>
    public: TPM_HANDLE hierarchy;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_LoadExternal_REQUEST& operator=(const TPM2_LoadExternal_REQUEST& rhs);
    public: TPM2_LoadExternal_REQUEST(const TPM2_LoadExternal_REQUEST& rhs);
    public:
    TPM2_LoadExternal_REQUEST();
    virtual ~TPM2_LoadExternal_REQUEST();
    /// <summary>
    /// This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
    /// </summary>
    ///<param name = "inPrivate">the sensitive portion of the object (optional)</param>
    ///<param name = "inPublic">the public portion of the object</param>
    ///<param name = "hierarchy">hierarchy with which the object area is associated</param>
    public: TPM2_LoadExternal_REQUEST(
        const TPMT_SENSITIVE& inPrivate,
        const TPMT_PUBLIC& inPublic,
        const TPM_HANDLE& hierarchy
    );
};
/// <summary>
/// This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
/// </summary>
class _DLLEXP_ LoadExternalResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of type TPM_HT_TRANSIENT for the loaded object
    /// </summary>
    public: TPM_HANDLE handle;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 nameSize;
    /// <summary>
    /// name of the loaded object
    /// </summary>
    public: std::vector<BYTE> name;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: LoadExternalResponse& operator=(const LoadExternalResponse& rhs);
    public: LoadExternalResponse(const LoadExternalResponse& rhs);
    public:
    LoadExternalResponse();
    virtual ~LoadExternalResponse();
    /// <summary>
    /// This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
    /// </summary>
    ///<param name = "handle">handle of type TPM_HT_TRANSIENT for the loaded object</param>
    ///<param name = "name">name of the loaded object</param>
    public: LoadExternalResponse(
        const TPM_HANDLE& handle,
        const std::vector<BYTE>& name
    );
};
/// <summary>
/// This command allows access to the public area of a loaded object.
/// </summary>
class _DLLEXP_ TPM2_ReadPublic_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM handle of an object
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE objectHandle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_ReadPublic_REQUEST& operator=(const TPM2_ReadPublic_REQUEST& rhs);
    public: TPM2_ReadPublic_REQUEST(const TPM2_ReadPublic_REQUEST& rhs);
    public:
    TPM2_ReadPublic_REQUEST();
    virtual ~TPM2_ReadPublic_REQUEST();
    /// <summary>
    /// This command allows access to the public area of a loaded object.
    /// </summary>
    ///<param name = "objectHandle">TPM handle of an object Auth Index: None</param>
    public: TPM2_ReadPublic_REQUEST(
        const TPM_HANDLE& objectHandle
    );
};
/// <summary>
/// This command allows access to the public area of a loaded object.
/// </summary>
class _DLLEXP_ ReadPublicResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of publicArea
    /// NOTE	The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 outPublicSize;
    /// <summary>
    /// structure containing the public area of an object
    /// </summary>
    public: TPMT_PUBLIC outPublic;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 nameSize;
    /// <summary>
    /// name of the object
    /// </summary>
    public: std::vector<BYTE> name;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 qualifiedNameSize;
    /// <summary>
    /// the Qualified Name of the object
    /// </summary>
    public: std::vector<BYTE> qualifiedName;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: ReadPublicResponse& operator=(const ReadPublicResponse& rhs);
    public: ReadPublicResponse(const ReadPublicResponse& rhs);
    public:
    ReadPublicResponse();
    virtual ~ReadPublicResponse();
    /// <summary>
    /// This command allows access to the public area of a loaded object.
    /// </summary>
    ///<param name = "outPublic">structure containing the public area of an object</param>
    ///<param name = "name">name of the object</param>
    ///<param name = "qualifiedName">the Qualified Name of the object</param>
    public: ReadPublicResponse(
        const TPMT_PUBLIC& outPublic,
        const std::vector<BYTE>& name,
        const std::vector<BYTE>& qualifiedName
    );
};
/// <summary>
/// This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
/// </summary>
class _DLLEXP_ TPM2_ActivateCredential_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of the object associated with certificate in credentialBlob
    /// Auth Index: 1
    /// Auth Role: ADMIN
    /// </summary>
    public: TPM_HANDLE activateHandle;
    /// <summary>
    /// loaded key used to decrypt the TPMS_SENSITIVE in credentialBlob
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE keyHandle;
    /// <summary>
    /// size of the credential structure
    /// </summary>
    protected: mutable UINT16 credentialBlobSize;
    /// <summary>
    /// the credential
    /// </summary>
    public: TPMS_ID_OBJECT credentialBlob;
    /// <summary>
    /// size of the secret value
    /// </summary>
    protected: mutable UINT16 secretSize;
    /// <summary>
    /// keyHandle algorithm-dependent encrypted seed that protects credentialBlob
    /// </summary>
    public: std::vector<BYTE> secret;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_ActivateCredential_REQUEST& operator=(const TPM2_ActivateCredential_REQUEST& rhs);
    public: TPM2_ActivateCredential_REQUEST(const TPM2_ActivateCredential_REQUEST& rhs);
    public:
    TPM2_ActivateCredential_REQUEST();
    virtual ~TPM2_ActivateCredential_REQUEST();
    /// <summary>
    /// This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
    /// </summary>
    ///<param name = "activateHandle">handle of the object associated with certificate in credentialBlob Auth Index: 1 Auth Role: ADMIN</param>
    ///<param name = "keyHandle">loaded key used to decrypt the TPMS_SENSITIVE in credentialBlob Auth Index: 2 Auth Role: USER</param>
    ///<param name = "credentialBlob">the credential</param>
    ///<param name = "secret">keyHandle algorithm-dependent encrypted seed that protects credentialBlob</param>
    public: TPM2_ActivateCredential_REQUEST(
        const TPM_HANDLE& activateHandle,
        const TPM_HANDLE& keyHandle,
        const TPMS_ID_OBJECT& credentialBlob,
        const std::vector<BYTE>& secret
    );
};
/// <summary>
/// This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
/// </summary>
class _DLLEXP_ ActivateCredentialResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 certInfoSize;
    /// <summary>
    /// the decrypted certificate information
    /// the data should be no larger than the size of the digest of the nameAlg associated with keyHandle
    /// </summary>
    public: std::vector<BYTE> certInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: ActivateCredentialResponse& operator=(const ActivateCredentialResponse& rhs);
    public: ActivateCredentialResponse(const ActivateCredentialResponse& rhs);
    public:
    ActivateCredentialResponse();
    virtual ~ActivateCredentialResponse();
    /// <summary>
    /// This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
    /// </summary>
    ///<param name = "certInfo">the decrypted certificate information the data should be no larger than the size of the digest of the nameAlg associated with keyHandle</param>
    public: ActivateCredentialResponse(
        const std::vector<BYTE>& certInfo
    );
};
/// <summary>
/// This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
/// </summary>
class _DLLEXP_ TPM2_MakeCredential_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// loaded public area, used to encrypt the sensitive area containing the credential key
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE handle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 credentialSize;
    /// <summary>
    /// the credential information
    /// </summary>
    public: std::vector<BYTE> credential;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 objectNameSize;
    /// <summary>
    /// Name of the object to which the credential applies
    /// </summary>
    public: std::vector<BYTE> objectName;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_MakeCredential_REQUEST& operator=(const TPM2_MakeCredential_REQUEST& rhs);
    public: TPM2_MakeCredential_REQUEST(const TPM2_MakeCredential_REQUEST& rhs);
    public:
    TPM2_MakeCredential_REQUEST();
    virtual ~TPM2_MakeCredential_REQUEST();
    /// <summary>
    /// This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
    /// </summary>
    ///<param name = "handle">loaded public area, used to encrypt the sensitive area containing the credential key Auth Index: None</param>
    ///<param name = "credential">the credential information</param>
    ///<param name = "objectName">Name of the object to which the credential applies</param>
    public: TPM2_MakeCredential_REQUEST(
        const TPM_HANDLE& handle,
        const std::vector<BYTE>& credential,
        const std::vector<BYTE>& objectName
    );
};
/// <summary>
/// This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
/// </summary>
class _DLLEXP_ MakeCredentialResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the credential structure
    /// </summary>
    protected: mutable UINT16 credentialBlobSize;
    /// <summary>
    /// the credential
    /// </summary>
    public: TPMS_ID_OBJECT credentialBlob;
    /// <summary>
    /// size of the secret value
    /// </summary>
    protected: mutable UINT16 secretSize;
    /// <summary>
    /// handle algorithm-dependent data that wraps the key that encrypts credentialBlob
    /// </summary>
    public: std::vector<BYTE> secret;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: MakeCredentialResponse& operator=(const MakeCredentialResponse& rhs);
    public: MakeCredentialResponse(const MakeCredentialResponse& rhs);
    public:
    MakeCredentialResponse();
    virtual ~MakeCredentialResponse();
    /// <summary>
    /// This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
    /// </summary>
    ///<param name = "credentialBlob">the credential</param>
    ///<param name = "secret">handle algorithm-dependent data that wraps the key that encrypts credentialBlob</param>
    public: MakeCredentialResponse(
        const TPMS_ID_OBJECT& credentialBlob,
        const std::vector<BYTE>& secret
    );
};
/// <summary>
/// This command returns the data in a loaded Sealed Data Object.
/// </summary>
class _DLLEXP_ TPM2_Unseal_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of a loaded data object
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE itemHandle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_Unseal_REQUEST& operator=(const TPM2_Unseal_REQUEST& rhs);
    public: TPM2_Unseal_REQUEST(const TPM2_Unseal_REQUEST& rhs);
    public:
    TPM2_Unseal_REQUEST();
    virtual ~TPM2_Unseal_REQUEST();
    /// <summary>
    /// This command returns the data in a loaded Sealed Data Object.
    /// </summary>
    ///<param name = "itemHandle">handle of a loaded data object Auth Index: 1 Auth Role: USER</param>
    public: TPM2_Unseal_REQUEST(
        const TPM_HANDLE& itemHandle
    );
};
/// <summary>
/// This command returns the data in a loaded Sealed Data Object.
/// </summary>
class _DLLEXP_ UnsealResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    protected: mutable UINT16 outDataSize;
    /// <summary>
    /// unsealed data
    /// Size of outData is limited to be no more than 128 octets.
    /// </summary>
    public: std::vector<BYTE> outData;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: UnsealResponse& operator=(const UnsealResponse& rhs);
    public: UnsealResponse(const UnsealResponse& rhs);
    public:
    UnsealResponse();
    virtual ~UnsealResponse();
    /// <summary>
    /// This command returns the data in a loaded Sealed Data Object.
    /// </summary>
    ///<param name = "outData">unsealed data Size of outData is limited to be no more than 128 octets.</param>
    public: UnsealResponse(
        const std::vector<BYTE>& outData
    );
};
/// <summary>
/// This command is used to change the authorization secret for a TPM-resident object.
/// </summary>
class _DLLEXP_ TPM2_ObjectChangeAuth_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of the object
    /// Auth Index: 1
    /// Auth Role: ADMIN
    /// </summary>
    public: TPM_HANDLE objectHandle;
    /// <summary>
    /// handle of the parent
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE parentHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 newAuthSize;
    /// <summary>
    /// new authorization value
    /// </summary>
    public: std::vector<BYTE> newAuth;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_ObjectChangeAuth_REQUEST& operator=(const TPM2_ObjectChangeAuth_REQUEST& rhs);
    public: TPM2_ObjectChangeAuth_REQUEST(const TPM2_ObjectChangeAuth_REQUEST& rhs);
    public:
    TPM2_ObjectChangeAuth_REQUEST();
    virtual ~TPM2_ObjectChangeAuth_REQUEST();
    /// <summary>
    /// This command is used to change the authorization secret for a TPM-resident object.
    /// </summary>
    ///<param name = "objectHandle">handle of the object Auth Index: 1 Auth Role: ADMIN</param>
    ///<param name = "parentHandle">handle of the parent Auth Index: None</param>
    ///<param name = "newAuth">new authorization value</param>
    public: TPM2_ObjectChangeAuth_REQUEST(
        const TPM_HANDLE& objectHandle,
        const TPM_HANDLE& parentHandle,
        const std::vector<BYTE>& newAuth
    );
};
/// <summary>
/// This command is used to change the authorization secret for a TPM-resident object.
/// </summary>
class _DLLEXP_ ObjectChangeAuthResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// private area containing the new authorization value
    /// </summary>
    public: TPM2B_PRIVATE outPrivate;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: ObjectChangeAuthResponse& operator=(const ObjectChangeAuthResponse& rhs);
    public: ObjectChangeAuthResponse(const ObjectChangeAuthResponse& rhs);
    public:
    ObjectChangeAuthResponse();
    virtual ~ObjectChangeAuthResponse();
    /// <summary>
    /// This command is used to change the authorization secret for a TPM-resident object.
    /// </summary>
    ///<param name = "outPrivate">private area containing the new authorization value</param>
    public: ObjectChangeAuthResponse(
        const TPM2B_PRIVATE& outPrivate
    );
};
/// <summary>
/// This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
/// </summary>
class _DLLEXP_ TPM2_CreateLoaded_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// Handle of a transient storage key, a persistent storage key, TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE parentHandle;
    /// <summary>
    /// size of sensitive in octets (may not be zero)
    /// NOTE	The userAuth and data parameters in this buffer may both be zero length but the minimum size of this parameter will be the sum of the size fields of the two parameters of the TPMS_SENSITIVE_CREATE.
    /// </summary>
    protected: mutable UINT16 inSensitiveSize;
    /// <summary>
    /// the sensitive data, see TPM 2.0 Part 1 Sensitive Values
    /// </summary>
    public: TPMS_SENSITIVE_CREATE inSensitive;
    /// <summary>
    /// size of publicArea
    /// </summary>
    protected: mutable UINT16 inPublicSize;
    /// <summary>
    /// the public template
    /// </summary>
    public: std::vector<BYTE> inPublic;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_CreateLoaded_REQUEST& operator=(const TPM2_CreateLoaded_REQUEST& rhs);
    public: TPM2_CreateLoaded_REQUEST(const TPM2_CreateLoaded_REQUEST& rhs);
    public:
    TPM2_CreateLoaded_REQUEST();
    virtual ~TPM2_CreateLoaded_REQUEST();
    /// <summary>
    /// This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
    /// </summary>
    ///<param name = "parentHandle">Handle of a transient storage key, a persistent storage key, TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL Auth Index: 1 Auth Role: USER</param>
    ///<param name = "inSensitive">the sensitive data, see TPM 2.0 Part 1 Sensitive Values</param>
    ///<param name = "inPublic">the public template</param>
    public: TPM2_CreateLoaded_REQUEST(
        const TPM_HANDLE& parentHandle,
        const TPMS_SENSITIVE_CREATE& inSensitive,
        const std::vector<BYTE>& inPublic
    );
};
/// <summary>
/// This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
/// </summary>
class _DLLEXP_ CreateLoadedResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of type TPM_HT_TRANSIENT for created object
    /// </summary>
    public: TPM_HANDLE handle;
    /// <summary>
    /// the sensitive area of the object (optional)
    /// </summary>
    public: TPM2B_PRIVATE outPrivate;
    /// <summary>
    /// size of publicArea
    /// NOTE	The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 outPublicSize;
    /// <summary>
    /// the public portion of the created object
    /// </summary>
    public: TPMT_PUBLIC outPublic;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 nameSize;
    /// <summary>
    /// the name of the created object
    /// </summary>
    public: std::vector<BYTE> name;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: CreateLoadedResponse& operator=(const CreateLoadedResponse& rhs);
    public: CreateLoadedResponse(const CreateLoadedResponse& rhs);
    public:
    CreateLoadedResponse();
    virtual ~CreateLoadedResponse();
    /// <summary>
    /// This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
    /// </summary>
    ///<param name = "handle">handle of type TPM_HT_TRANSIENT for created object</param>
    ///<param name = "outPrivate">the sensitive area of the object (optional)</param>
    ///<param name = "outPublic">the public portion of the created object</param>
    ///<param name = "name">the name of the created object</param>
    public: CreateLoadedResponse(
        const TPM_HANDLE& handle,
        const TPM2B_PRIVATE& outPrivate,
        const TPMT_PUBLIC& outPublic,
        const std::vector<BYTE>& name
    );
};
/// <summary>
/// This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
/// </summary>
class _DLLEXP_ TPM2_Duplicate_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// loaded object to duplicate
    /// Auth Index: 1
    /// Auth Role: DUP
    /// </summary>
    public: TPM_HANDLE objectHandle;
    /// <summary>
    /// shall reference the public area of an asymmetric key
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE newParentHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 encryptionKeyInSize;
    /// <summary>
    /// optional symmetric encryption key
    /// The size for this key is set to zero when the TPM is to generate the key. This parameter may be encrypted.
    /// </summary>
    public: std::vector<BYTE> encryptionKeyIn;
    /// <summary>
    /// definition for the symmetric algorithm to be used for the inner wrapper
    /// may be TPM_ALG_NULL if no inner wrapper is applied
    /// </summary>
    public: TPMT_SYM_DEF_OBJECT symmetricAlg;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_Duplicate_REQUEST& operator=(const TPM2_Duplicate_REQUEST& rhs);
    public: TPM2_Duplicate_REQUEST(const TPM2_Duplicate_REQUEST& rhs);
    public:
    TPM2_Duplicate_REQUEST();
    virtual ~TPM2_Duplicate_REQUEST();
    /// <summary>
    /// This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
    /// </summary>
    ///<param name = "objectHandle">loaded object to duplicate Auth Index: 1 Auth Role: DUP</param>
    ///<param name = "newParentHandle">shall reference the public area of an asymmetric key Auth Index: None</param>
    ///<param name = "encryptionKeyIn">optional symmetric encryption key The size for this key is set to zero when the TPM is to generate the key. This parameter may be encrypted.</param>
    ///<param name = "symmetricAlg">definition for the symmetric algorithm to be used for the inner wrapper may be TPM_ALG_NULL if no inner wrapper is applied</param>
    public: TPM2_Duplicate_REQUEST(
        const TPM_HANDLE& objectHandle,
        const TPM_HANDLE& newParentHandle,
        const std::vector<BYTE>& encryptionKeyIn,
        const TPMT_SYM_DEF_OBJECT& symmetricAlg
    );
};
/// <summary>
/// This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
/// </summary>
class _DLLEXP_ DuplicateResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 encryptionKeyOutSize;
    /// <summary>
    /// If the caller provided an encryption key or if symmetricAlg was TPM_ALG_NULL, then this will be the Empty Buffer; otherwise, it shall contain the TPM-generated, symmetric encryption key for the inner wrapper.
    /// </summary>
    public: std::vector<BYTE> encryptionKeyOut;
    /// <summary>
    /// private area that may be encrypted by encryptionKeyIn; and may be doubly encrypted
    /// </summary>
    public: TPM2B_PRIVATE duplicate;
    /// <summary>
    /// size of the secret value
    /// </summary>
    protected: mutable UINT16 outSymSeedSize;
    /// <summary>
    /// seed protected by the asymmetric algorithms of new parent (NP)
    /// </summary>
    public: std::vector<BYTE> outSymSeed;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: DuplicateResponse& operator=(const DuplicateResponse& rhs);
    public: DuplicateResponse(const DuplicateResponse& rhs);
    public:
    DuplicateResponse();
    virtual ~DuplicateResponse();
    /// <summary>
    /// This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
    /// </summary>
    ///<param name = "encryptionKeyOut">If the caller provided an encryption key or if symmetricAlg was TPM_ALG_NULL, then this will be the Empty Buffer; otherwise, it shall contain the TPM-generated, symmetric encryption key for the inner wrapper.</param>
    ///<param name = "duplicate">private area that may be encrypted by encryptionKeyIn; and may be doubly encrypted</param>
    ///<param name = "outSymSeed">seed protected by the asymmetric algorithms of new parent (NP)</param>
    public: DuplicateResponse(
        const std::vector<BYTE>& encryptionKeyOut,
        const TPM2B_PRIVATE& duplicate,
        const std::vector<BYTE>& outSymSeed
    );
};
/// <summary>
/// This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
/// </summary>
class _DLLEXP_ TPM2_Rewrap_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// parent of object
    /// Auth Index: 1
    /// Auth Role: User
    /// </summary>
    public: TPM_HANDLE oldParent;
    /// <summary>
    /// new parent of the object
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE newParent;
    /// <summary>
    /// an object encrypted using symmetric key derived from inSymSeed
    /// </summary>
    public: TPM2B_PRIVATE inDuplicate;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 nameSize;
    /// <summary>
    /// the Name of the object being rewrapped
    /// </summary>
    public: std::vector<BYTE> name;
    /// <summary>
    /// size of the secret value
    /// </summary>
    protected: mutable UINT16 inSymSeedSize;
    /// <summary>
    /// the seed for the symmetric key and HMAC key
    /// needs oldParent private key to recover the seed and generate the symmetric key
    /// </summary>
    public: std::vector<BYTE> inSymSeed;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_Rewrap_REQUEST& operator=(const TPM2_Rewrap_REQUEST& rhs);
    public: TPM2_Rewrap_REQUEST(const TPM2_Rewrap_REQUEST& rhs);
    public:
    TPM2_Rewrap_REQUEST();
    virtual ~TPM2_Rewrap_REQUEST();
    /// <summary>
    /// This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
    /// </summary>
    ///<param name = "oldParent">parent of object Auth Index: 1 Auth Role: User</param>
    ///<param name = "newParent">new parent of the object Auth Index: None</param>
    ///<param name = "inDuplicate">an object encrypted using symmetric key derived from inSymSeed</param>
    ///<param name = "name">the Name of the object being rewrapped</param>
    ///<param name = "inSymSeed">the seed for the symmetric key and HMAC key needs oldParent private key to recover the seed and generate the symmetric key</param>
    public: TPM2_Rewrap_REQUEST(
        const TPM_HANDLE& oldParent,
        const TPM_HANDLE& newParent,
        const TPM2B_PRIVATE& inDuplicate,
        const std::vector<BYTE>& name,
        const std::vector<BYTE>& inSymSeed
    );
};
/// <summary>
/// This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
/// </summary>
class _DLLEXP_ RewrapResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// an object encrypted using symmetric key derived from outSymSeed
    /// </summary>
    public: TPM2B_PRIVATE outDuplicate;
    /// <summary>
    /// size of the secret value
    /// </summary>
    protected: mutable UINT16 outSymSeedSize;
    /// <summary>
    /// seed for a symmetric key protected by newParent asymmetric key
    /// </summary>
    public: std::vector<BYTE> outSymSeed;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: RewrapResponse& operator=(const RewrapResponse& rhs);
    public: RewrapResponse(const RewrapResponse& rhs);
    public:
    RewrapResponse();
    virtual ~RewrapResponse();
    /// <summary>
    /// This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
    /// </summary>
    ///<param name = "outDuplicate">an object encrypted using symmetric key derived from outSymSeed</param>
    ///<param name = "outSymSeed">seed for a symmetric key protected by newParent asymmetric key</param>
    public: RewrapResponse(
        const TPM2B_PRIVATE& outDuplicate,
        const std::vector<BYTE>& outSymSeed
    );
};
/// <summary>
/// This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
/// </summary>
class _DLLEXP_ TPM2_Import_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the handle of the new parent for the object
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE parentHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 encryptionKeySize;
    /// <summary>
    /// the optional symmetric encryption key used as the inner wrapper for duplicate
    /// If symmetricAlg is TPM_ALG_NULL, then this parameter shall be the Empty Buffer.
    /// </summary>
    public: std::vector<BYTE> encryptionKey;
    /// <summary>
    /// size of publicArea
    /// NOTE	The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 objectPublicSize;
    /// <summary>
    /// the public area of the object to be imported
    /// This is provided so that the integrity value for duplicate and the object attributes can be checked.
    /// NOTE	Even if the integrity value of the object is not checked on input, the object Name is required to create the integrity value for the imported object.
    /// </summary>
    public: TPMT_PUBLIC objectPublic;
    /// <summary>
    /// the symmetrically encrypted duplicate object that may contain an inner symmetric wrapper
    /// </summary>
    public: TPM2B_PRIVATE duplicate;
    /// <summary>
    /// size of the secret value
    /// </summary>
    protected: mutable UINT16 inSymSeedSize;
    /// <summary>
    /// the seed for the symmetric key and HMAC key
    /// inSymSeed is encrypted/encoded using the algorithms of newParent.
    /// </summary>
    public: std::vector<BYTE> inSymSeed;
    /// <summary>
    /// definition for the symmetric algorithm to use for the inner wrapper
    /// If this algorithm is TPM_ALG_NULL, no inner wrapper is present and encryptionKey shall be the Empty Buffer.
    /// </summary>
    public: TPMT_SYM_DEF_OBJECT symmetricAlg;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_Import_REQUEST& operator=(const TPM2_Import_REQUEST& rhs);
    public: TPM2_Import_REQUEST(const TPM2_Import_REQUEST& rhs);
    public:
    TPM2_Import_REQUEST();
    virtual ~TPM2_Import_REQUEST();
    /// <summary>
    /// This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
    /// </summary>
    ///<param name = "parentHandle">the handle of the new parent for the object Auth Index: 1 Auth Role: USER</param>
    ///<param name = "encryptionKey">the optional symmetric encryption key used as the inner wrapper for duplicate If symmetricAlg is TPM_ALG_NULL, then this parameter shall be the Empty Buffer.</param>
    ///<param name = "objectPublic">the public area of the object to be imported This is provided so that the integrity value for duplicate and the object attributes can be checked. NOTE	Even if the integrity value of the object is not checked on input, the object Name is required to create the integrity value for the imported object.</param>
    ///<param name = "duplicate">the symmetrically encrypted duplicate object that may contain an inner symmetric wrapper</param>
    ///<param name = "inSymSeed">the seed for the symmetric key and HMAC key inSymSeed is encrypted/encoded using the algorithms of newParent.</param>
    ///<param name = "symmetricAlg">definition for the symmetric algorithm to use for the inner wrapper If this algorithm is TPM_ALG_NULL, no inner wrapper is present and encryptionKey shall be the Empty Buffer.</param>
    public: TPM2_Import_REQUEST(
        const TPM_HANDLE& parentHandle,
        const std::vector<BYTE>& encryptionKey,
        const TPMT_PUBLIC& objectPublic,
        const TPM2B_PRIVATE& duplicate,
        const std::vector<BYTE>& inSymSeed,
        const TPMT_SYM_DEF_OBJECT& symmetricAlg
    );
};
/// <summary>
/// This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
/// </summary>
class _DLLEXP_ ImportResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the sensitive area encrypted with the symmetric key of parentHandle
    /// </summary>
    public: TPM2B_PRIVATE outPrivate;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: ImportResponse& operator=(const ImportResponse& rhs);
    public: ImportResponse(const ImportResponse& rhs);
    public:
    ImportResponse();
    virtual ~ImportResponse();
    /// <summary>
    /// This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
    /// </summary>
    ///<param name = "outPrivate">the sensitive area encrypted with the symmetric key of parentHandle</param>
    public: ImportResponse(
        const TPM2B_PRIVATE& outPrivate
    );
};
/// <summary>
/// This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
/// </summary>
class _DLLEXP_ TPM2_RSA_Encrypt_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// reference to public portion of RSA key to use for encryption
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE keyHandle;
    /// <summary>
    /// size of the buffer
    /// The value of zero is only valid for create.
    /// </summary>
    protected: mutable UINT16 messageSize;
    /// <summary>
    /// message to be encrypted
    /// NOTE 1	The data type was chosen because it limits the overall size of the input to no greater than the size of the largest RSA public key. This may be larger than allowed for keyHandle.
    /// </summary>
    public: std::vector<BYTE> message;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    /// <summary>
    /// the padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: TPMU_ASYM_SCHEME* inScheme;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 labelSize;
    /// <summary>
    /// optional label L to be associated with the message
    /// Size of the buffer is zero if no label is present
    /// NOTE 2	See description of label above.
    /// </summary>
    public: std::vector<BYTE> label;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_RSA_Encrypt_REQUEST& operator=(const TPM2_RSA_Encrypt_REQUEST& rhs);
    public: TPM2_RSA_Encrypt_REQUEST(const TPM2_RSA_Encrypt_REQUEST& rhs);
    public:
    TPM2_RSA_Encrypt_REQUEST();
    virtual ~TPM2_RSA_Encrypt_REQUEST();
    /// <summary>
    /// This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
    /// </summary>
    ///<param name = "keyHandle">reference to public portion of RSA key to use for encryption Auth Index: None</param>
    ///<param name = "message">message to be encrypted NOTE 1	The data type was chosen because it limits the overall size of the input to no greater than the size of the largest RSA public key. This may be larger than allowed for keyHandle.</param>
    ///<param name = "inScheme">the padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL(One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)</param>
    ///<param name = "label">optional label L to be associated with the message Size of the buffer is zero if no label is present NOTE 2	See description of label above.</param>
    public: TPM2_RSA_Encrypt_REQUEST(
        const TPM_HANDLE& keyHandle,
        const std::vector<BYTE>& message,
        const TPMU_ASYM_SCHEME& inScheme,
        const std::vector<BYTE>& label
    );
};
/// <summary>
/// This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
/// </summary>
class _DLLEXP_ RSA_EncryptResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the buffer
    /// The value of zero is only valid for create.
    /// </summary>
    protected: mutable UINT16 outDataSize;
    /// <summary>
    /// encrypted output
    /// </summary>
    public: std::vector<BYTE> outData;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: RSA_EncryptResponse& operator=(const RSA_EncryptResponse& rhs);
    public: RSA_EncryptResponse(const RSA_EncryptResponse& rhs);
    public:
    RSA_EncryptResponse();
    virtual ~RSA_EncryptResponse();
    /// <summary>
    /// This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
    /// </summary>
    ///<param name = "outData">encrypted output</param>
    public: RSA_EncryptResponse(
        const std::vector<BYTE>& outData
    );
};
/// <summary>
/// This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
/// </summary>
class _DLLEXP_ TPM2_RSA_Decrypt_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// RSA key to use for decryption
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE keyHandle;
    /// <summary>
    /// size of the buffer
    /// The value of zero is only valid for create.
    /// </summary>
    protected: mutable UINT16 cipherTextSize;
    /// <summary>
    /// cipher text to be decrypted
    /// NOTE	An encrypted RSA data block is the size of the public modulus.
    /// </summary>
    public: std::vector<BYTE> cipherText;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    /// <summary>
    /// the padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: TPMU_ASYM_SCHEME* inScheme;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 labelSize;
    /// <summary>
    /// label whose association with the message is to be verified
    /// </summary>
    public: std::vector<BYTE> label;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_RSA_Decrypt_REQUEST& operator=(const TPM2_RSA_Decrypt_REQUEST& rhs);
    public: TPM2_RSA_Decrypt_REQUEST(const TPM2_RSA_Decrypt_REQUEST& rhs);
    public:
    TPM2_RSA_Decrypt_REQUEST();
    virtual ~TPM2_RSA_Decrypt_REQUEST();
    /// <summary>
    /// This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
    /// </summary>
    ///<param name = "keyHandle">RSA key to use for decryption Auth Index: 1 Auth Role: USER</param>
    ///<param name = "cipherText">cipher text to be decrypted NOTE	An encrypted RSA data block is the size of the public modulus.</param>
    ///<param name = "inScheme">the padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL(One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)</param>
    ///<param name = "label">label whose association with the message is to be verified</param>
    public: TPM2_RSA_Decrypt_REQUEST(
        const TPM_HANDLE& keyHandle,
        const std::vector<BYTE>& cipherText,
        const TPMU_ASYM_SCHEME& inScheme,
        const std::vector<BYTE>& label
    );
};
/// <summary>
/// This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
/// </summary>
class _DLLEXP_ RSA_DecryptResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the buffer
    /// The value of zero is only valid for create.
    /// </summary>
    protected: mutable UINT16 messageSize;
    /// <summary>
    /// decrypted output
    /// </summary>
    public: std::vector<BYTE> message;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: RSA_DecryptResponse& operator=(const RSA_DecryptResponse& rhs);
    public: RSA_DecryptResponse(const RSA_DecryptResponse& rhs);
    public:
    RSA_DecryptResponse();
    virtual ~RSA_DecryptResponse();
    /// <summary>
    /// This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
    /// </summary>
    ///<param name = "message">decrypted output</param>
    public: RSA_DecryptResponse(
        const std::vector<BYTE>& message
    );
};
/// <summary>
/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS).
/// </summary>
class _DLLEXP_ TPM2_ECDH_KeyGen_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// Handle of a loaded ECC key public area.
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE keyHandle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_ECDH_KeyGen_REQUEST& operator=(const TPM2_ECDH_KeyGen_REQUEST& rhs);
    public: TPM2_ECDH_KeyGen_REQUEST(const TPM2_ECDH_KeyGen_REQUEST& rhs);
    public:
    TPM2_ECDH_KeyGen_REQUEST();
    virtual ~TPM2_ECDH_KeyGen_REQUEST();
    /// <summary>
    /// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS).
    /// </summary>
    ///<param name = "keyHandle">Handle of a loaded ECC key public area. Auth Index: None</param>
    public: TPM2_ECDH_KeyGen_REQUEST(
        const TPM_HANDLE& keyHandle
    );
};
/// <summary>
/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS).
/// </summary>
class _DLLEXP_ ECDH_KeyGenResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the remainder of this structure
    /// </summary>
    protected: mutable UINT16 zPointSize;
    /// <summary>
    /// results of P  h[de]Qs
    /// </summary>
    public: TPMS_ECC_POINT zPoint;
    /// <summary>
    /// size of the remainder of this structure
    /// </summary>
    protected: mutable UINT16 pubPointSize;
    /// <summary>
    /// generated ephemeral public point (Qe)
    /// </summary>
    public: TPMS_ECC_POINT pubPoint;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: ECDH_KeyGenResponse& operator=(const ECDH_KeyGenResponse& rhs);
    public: ECDH_KeyGenResponse(const ECDH_KeyGenResponse& rhs);
    public:
    ECDH_KeyGenResponse();
    virtual ~ECDH_KeyGenResponse();
    /// <summary>
    /// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS).
    /// </summary>
    ///<param name = "zPoint">results of P  h[de]Qs</param>
    ///<param name = "pubPoint">generated ephemeral public point (Qe)</param>
    public: ECDH_KeyGenResponse(
        const TPMS_ECC_POINT& zPoint,
        const TPMS_ECC_POINT& pubPoint
    );
};
/// <summary>
/// This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve).
/// </summary>
class _DLLEXP_ TPM2_ECDH_ZGen_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of a loaded ECC key
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE keyHandle;
    /// <summary>
    /// size of the remainder of this structure
    /// </summary>
    protected: mutable UINT16 inPointSize;
    /// <summary>
    /// a public key
    /// </summary>
    public: TPMS_ECC_POINT inPoint;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_ECDH_ZGen_REQUEST& operator=(const TPM2_ECDH_ZGen_REQUEST& rhs);
    public: TPM2_ECDH_ZGen_REQUEST(const TPM2_ECDH_ZGen_REQUEST& rhs);
    public:
    TPM2_ECDH_ZGen_REQUEST();
    virtual ~TPM2_ECDH_ZGen_REQUEST();
    /// <summary>
    /// This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve).
    /// </summary>
    ///<param name = "keyHandle">handle of a loaded ECC key Auth Index: 1 Auth Role: USER</param>
    ///<param name = "inPoint">a public key</param>
    public: TPM2_ECDH_ZGen_REQUEST(
        const TPM_HANDLE& keyHandle,
        const TPMS_ECC_POINT& inPoint
    );
};
/// <summary>
/// This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve).
/// </summary>
class _DLLEXP_ ECDH_ZGenResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the remainder of this structure
    /// </summary>
    protected: mutable UINT16 outPointSize;
    /// <summary>
    /// X and Y coordinates of the product of the multiplication Z = (xZ , yZ)  [hdS]QB
    /// </summary>
    public: TPMS_ECC_POINT outPoint;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: ECDH_ZGenResponse& operator=(const ECDH_ZGenResponse& rhs);
    public: ECDH_ZGenResponse(const ECDH_ZGenResponse& rhs);
    public:
    ECDH_ZGenResponse();
    virtual ~ECDH_ZGenResponse();
    /// <summary>
    /// This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve).
    /// </summary>
    ///<param name = "outPoint">X and Y coordinates of the product of the multiplication Z = (xZ , yZ)  [hdS]QB</param>
    public: ECDH_ZGenResponse(
        const TPMS_ECC_POINT& outPoint
    );
};
/// <summary>
/// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
/// </summary>
class _DLLEXP_ TPM2_ECC_Parameters_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// parameter set selector
    /// </summary>
    public: TPM_ECC_CURVE curveID;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_ECC_Parameters_REQUEST& operator=(const TPM2_ECC_Parameters_REQUEST& rhs);
    public: TPM2_ECC_Parameters_REQUEST(const TPM2_ECC_Parameters_REQUEST& rhs);
    public:
    TPM2_ECC_Parameters_REQUEST();
    virtual ~TPM2_ECC_Parameters_REQUEST();
    /// <summary>
    /// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
    /// </summary>
    ///<param name = "curveID">parameter set selector</param>
    public: TPM2_ECC_Parameters_REQUEST(
        const TPM_ECC_CURVE& curveID
    );
};
/// <summary>
/// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
/// </summary>
class _DLLEXP_ ECC_ParametersResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// ECC parameters for the selected curve
    /// </summary>
    public: TPMS_ALGORITHM_DETAIL_ECC parameters;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: ECC_ParametersResponse& operator=(const ECC_ParametersResponse& rhs);
    public: ECC_ParametersResponse(const ECC_ParametersResponse& rhs);
    public:
    ECC_ParametersResponse();
    virtual ~ECC_ParametersResponse();
    /// <summary>
    /// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
    /// </summary>
    ///<param name = "parameters">ECC parameters for the selected curve</param>
    public: ECC_ParametersResponse(
        const TPMS_ALGORITHM_DETAIL_ECC& parameters
    );
};
/// <summary>
/// This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
/// </summary>
class _DLLEXP_ TPM2_ZGen_2Phase_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of an unrestricted decryption key ECC
    /// The private key referenced by this handle is used as dS,A
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE keyA;
    /// <summary>
    /// size of the remainder of this structure
    /// </summary>
    protected: mutable UINT16 inQsBSize;
    /// <summary>
    /// other partys static public key (Qs,B = (Xs,B, Ys,B))
    /// </summary>
    public: TPMS_ECC_POINT inQsB;
    /// <summary>
    /// size of the remainder of this structure
    /// </summary>
    protected: mutable UINT16 inQeBSize;
    /// <summary>
    /// other party's ephemeral public key (Qe,B = (Xe,B, Ye,B))
    /// </summary>
    public: TPMS_ECC_POINT inQeB;
    /// <summary>
    /// the key exchange scheme
    /// </summary>
    public: TPM_ALG_ID inScheme;
    /// <summary>
    /// value returned by TPM2_EC_Ephemeral()
    /// </summary>
    public: UINT16 counter;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_ZGen_2Phase_REQUEST& operator=(const TPM2_ZGen_2Phase_REQUEST& rhs);
    public: TPM2_ZGen_2Phase_REQUEST(const TPM2_ZGen_2Phase_REQUEST& rhs);
    public:
    TPM2_ZGen_2Phase_REQUEST();
    virtual ~TPM2_ZGen_2Phase_REQUEST();
    /// <summary>
    /// This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
    /// </summary>
    ///<param name = "keyA">handle of an unrestricted decryption key ECC The private key referenced by this handle is used as dS,A Auth Index: 1 Auth Role: USER</param>
    ///<param name = "inQsB">other partys static public key (Qs,B = (Xs,B, Ys,B))</param>
    ///<param name = "inQeB">other party's ephemeral public key (Qe,B = (Xe,B, Ye,B))</param>
    ///<param name = "inScheme">the key exchange scheme</param>
    ///<param name = "counter">value returned by TPM2_EC_Ephemeral()</param>
    public: TPM2_ZGen_2Phase_REQUEST(
        const TPM_HANDLE& keyA,
        const TPMS_ECC_POINT& inQsB,
        const TPMS_ECC_POINT& inQeB,
        const TPM_ALG_ID& inScheme,
        const UINT16& counter
    );
};
/// <summary>
/// This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
/// </summary>
class _DLLEXP_ ZGen_2PhaseResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the remainder of this structure
    /// </summary>
    protected: mutable UINT16 outZ1Size;
    /// <summary>
    /// X and Y coordinates of the computed value (scheme dependent)
    /// </summary>
    public: TPMS_ECC_POINT outZ1;
    /// <summary>
    /// size of the remainder of this structure
    /// </summary>
    protected: mutable UINT16 outZ2Size;
    /// <summary>
    /// X and Y coordinates of the second computed value (scheme dependent)
    /// </summary>
    public: TPMS_ECC_POINT outZ2;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: ZGen_2PhaseResponse& operator=(const ZGen_2PhaseResponse& rhs);
    public: ZGen_2PhaseResponse(const ZGen_2PhaseResponse& rhs);
    public:
    ZGen_2PhaseResponse();
    virtual ~ZGen_2PhaseResponse();
    /// <summary>
    /// This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
    /// </summary>
    ///<param name = "outZ1">X and Y coordinates of the computed value (scheme dependent)</param>
    ///<param name = "outZ2">X and Y coordinates of the second computed value (scheme dependent)</param>
    public: ZGen_2PhaseResponse(
        const TPMS_ECC_POINT& outZ1,
        const TPMS_ECC_POINT& outZ2
    );
};
/// <summary>
/// NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
/// </summary>
class _DLLEXP_ TPM2_EncryptDecrypt_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the symmetric key used for the operation
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE keyHandle;
    /// <summary>
    /// if YES, then the operation is decryption; if NO, the operation is encryption
    /// </summary>
    public: BYTE decrypt;
    /// <summary>
    /// symmetric encryption/decryption mode
    /// this field shall match the default mode of the key or be TPM_ALG_NULL.
    /// </summary>
    public: TPM_ALG_ID mode;
    /// <summary>
    /// size of the IV value
    /// This value is fixed for a TPM implementation.
    /// </summary>
    protected: mutable UINT16 ivInSize;
    /// <summary>
    /// an initial value as required by the algorithm
    /// </summary>
    public: std::vector<BYTE> ivIn;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 inDataSize;
    /// <summary>
    /// the data to be encrypted/decrypted
    /// </summary>
    public: std::vector<BYTE> inData;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_EncryptDecrypt_REQUEST& operator=(const TPM2_EncryptDecrypt_REQUEST& rhs);
    public: TPM2_EncryptDecrypt_REQUEST(const TPM2_EncryptDecrypt_REQUEST& rhs);
    public:
    TPM2_EncryptDecrypt_REQUEST();
    virtual ~TPM2_EncryptDecrypt_REQUEST();
    /// <summary>
    /// NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
    /// </summary>
    ///<param name = "keyHandle">the symmetric key used for the operation Auth Index: 1 Auth Role: USER</param>
    ///<param name = "decrypt">if YES, then the operation is decryption; if NO, the operation is encryption</param>
    ///<param name = "mode">symmetric encryption/decryption mode this field shall match the default mode of the key or be TPM_ALG_NULL.</param>
    ///<param name = "ivIn">an initial value as required by the algorithm</param>
    ///<param name = "inData">the data to be encrypted/decrypted</param>
    public: TPM2_EncryptDecrypt_REQUEST(
        const TPM_HANDLE& keyHandle,
        const BYTE& decrypt,
        const TPM_ALG_ID& mode,
        const std::vector<BYTE>& ivIn,
        const std::vector<BYTE>& inData
    );
};
/// <summary>
/// NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
/// </summary>
class _DLLEXP_ EncryptDecryptResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 outDataSize;
    /// <summary>
    /// encrypted or decrypted output
    /// </summary>
    public: std::vector<BYTE> outData;
    /// <summary>
    /// size of the IV value
    /// This value is fixed for a TPM implementation.
    /// </summary>
    protected: mutable UINT16 ivOutSize;
    /// <summary>
    /// chaining value to use for IV in next round
    /// </summary>
    public: std::vector<BYTE> ivOut;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: EncryptDecryptResponse& operator=(const EncryptDecryptResponse& rhs);
    public: EncryptDecryptResponse(const EncryptDecryptResponse& rhs);
    public:
    EncryptDecryptResponse();
    virtual ~EncryptDecryptResponse();
    /// <summary>
    /// NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
    /// </summary>
    ///<param name = "outData">encrypted or decrypted output</param>
    ///<param name = "ivOut">chaining value to use for IV in next round</param>
    public: EncryptDecryptResponse(
        const std::vector<BYTE>& outData,
        const std::vector<BYTE>& ivOut
    );
};
/// <summary>
/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
/// </summary>
class _DLLEXP_ TPM2_EncryptDecrypt2_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the symmetric key used for the operation
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE keyHandle;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 inDataSize;
    /// <summary>
    /// the data to be encrypted/decrypted
    /// </summary>
    public: std::vector<BYTE> inData;
    /// <summary>
    /// if YES, then the operation is decryption; if NO, the operation is encryption
    /// </summary>
    public: BYTE decrypt;
    /// <summary>
    /// symmetric mode
    /// this field shall match the default mode of the key or be TPM_ALG_NULL.
    /// </summary>
    public: TPM_ALG_ID mode;
    /// <summary>
    /// size of the IV value
    /// This value is fixed for a TPM implementation.
    /// </summary>
    protected: mutable UINT16 ivInSize;
    /// <summary>
    /// an initial value as required by the algorithm
    /// </summary>
    public: std::vector<BYTE> ivIn;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_EncryptDecrypt2_REQUEST& operator=(const TPM2_EncryptDecrypt2_REQUEST& rhs);
    public: TPM2_EncryptDecrypt2_REQUEST(const TPM2_EncryptDecrypt2_REQUEST& rhs);
    public:
    TPM2_EncryptDecrypt2_REQUEST();
    virtual ~TPM2_EncryptDecrypt2_REQUEST();
    /// <summary>
    /// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
    /// </summary>
    ///<param name = "keyHandle">the symmetric key used for the operation Auth Index: 1 Auth Role: USER</param>
    ///<param name = "inData">the data to be encrypted/decrypted</param>
    ///<param name = "decrypt">if YES, then the operation is decryption; if NO, the operation is encryption</param>
    ///<param name = "mode">symmetric mode this field shall match the default mode of the key or be TPM_ALG_NULL.</param>
    ///<param name = "ivIn">an initial value as required by the algorithm</param>
    public: TPM2_EncryptDecrypt2_REQUEST(
        const TPM_HANDLE& keyHandle,
        const std::vector<BYTE>& inData,
        const BYTE& decrypt,
        const TPM_ALG_ID& mode,
        const std::vector<BYTE>& ivIn
    );
};
/// <summary>
/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
/// </summary>
class _DLLEXP_ EncryptDecrypt2Response : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 outDataSize;
    /// <summary>
    /// encrypted or decrypted output
    /// </summary>
    public: std::vector<BYTE> outData;
    /// <summary>
    /// size of the IV value
    /// This value is fixed for a TPM implementation.
    /// </summary>
    protected: mutable UINT16 ivOutSize;
    /// <summary>
    /// chaining value to use for IV in next round
    /// </summary>
    public: std::vector<BYTE> ivOut;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: EncryptDecrypt2Response& operator=(const EncryptDecrypt2Response& rhs);
    public: EncryptDecrypt2Response(const EncryptDecrypt2Response& rhs);
    public:
    EncryptDecrypt2Response();
    virtual ~EncryptDecrypt2Response();
    /// <summary>
    /// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
    /// </summary>
    ///<param name = "outData">encrypted or decrypted output</param>
    ///<param name = "ivOut">chaining value to use for IV in next round</param>
    public: EncryptDecrypt2Response(
        const std::vector<BYTE>& outData,
        const std::vector<BYTE>& ivOut
    );
};
/// <summary>
/// This command performs a hash operation on a data buffer and returns the results.
/// </summary>
class _DLLEXP_ TPM2_Hash_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 dataSize;
    /// <summary>
    /// data to be hashed
    /// </summary>
    public: std::vector<BYTE> data;
    /// <summary>
    /// algorithm for the hash being computed  shall not be TPM_ALG_NULL
    /// </summary>
    public: TPM_ALG_ID hashAlg;
    /// <summary>
    /// hierarchy to use for the ticket (TPM_RH_NULL allowed)
    /// </summary>
    public: TPM_HANDLE hierarchy;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_Hash_REQUEST& operator=(const TPM2_Hash_REQUEST& rhs);
    public: TPM2_Hash_REQUEST(const TPM2_Hash_REQUEST& rhs);
    public:
    TPM2_Hash_REQUEST();
    virtual ~TPM2_Hash_REQUEST();
    /// <summary>
    /// This command performs a hash operation on a data buffer and returns the results.
    /// </summary>
    ///<param name = "data">data to be hashed</param>
    ///<param name = "hashAlg">algorithm for the hash being computed  shall not be TPM_ALG_NULL</param>
    ///<param name = "hierarchy">hierarchy to use for the ticket (TPM_RH_NULL allowed)</param>
    public: TPM2_Hash_REQUEST(
        const std::vector<BYTE>& data,
        const TPM_ALG_ID& hashAlg,
        const TPM_HANDLE& hierarchy
    );
};
/// <summary>
/// This command performs a hash operation on a data buffer and returns the results.
/// </summary>
class _DLLEXP_ HashResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 outHashSize;
    /// <summary>
    /// results
    /// </summary>
    public: std::vector<BYTE> outHash;
    /// <summary>
    /// ticket indicating that the sequence of octets used to compute outDigest did not start with TPM_GENERATED_VALUE
    /// will be a NULL ticket if the digest may not be signed with a restricted key
    /// </summary>
    public: TPMT_TK_HASHCHECK validation;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: HashResponse& operator=(const HashResponse& rhs);
    public: HashResponse(const HashResponse& rhs);
    public:
    HashResponse();
    virtual ~HashResponse();
    /// <summary>
    /// This command performs a hash operation on a data buffer and returns the results.
    /// </summary>
    ///<param name = "outHash">results</param>
    ///<param name = "validation">ticket indicating that the sequence of octets used to compute outDigest did not start with TPM_GENERATED_VALUE will be a NULL ticket if the digest may not be signed with a restricted key</param>
    public: HashResponse(
        const std::vector<BYTE>& outHash,
        const TPMT_TK_HASHCHECK& validation
    );
};
/// <summary>
/// This command performs an HMAC on the supplied data using the indicated hash algorithm.
/// </summary>
class _DLLEXP_ TPM2_HMAC_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the symmetric signing key providing the HMAC key
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE handle;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 bufferSize;
    /// <summary>
    /// HMAC data
    /// </summary>
    public: std::vector<BYTE> buffer;
    /// <summary>
    /// algorithm to use for HMAC
    /// </summary>
    public: TPM_ALG_ID hashAlg;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_HMAC_REQUEST& operator=(const TPM2_HMAC_REQUEST& rhs);
    public: TPM2_HMAC_REQUEST(const TPM2_HMAC_REQUEST& rhs);
    public:
    TPM2_HMAC_REQUEST();
    virtual ~TPM2_HMAC_REQUEST();
    /// <summary>
    /// This command performs an HMAC on the supplied data using the indicated hash algorithm.
    /// </summary>
    ///<param name = "handle">handle for the symmetric signing key providing the HMAC key Auth Index: 1 Auth Role: USER</param>
    ///<param name = "buffer">HMAC data</param>
    ///<param name = "hashAlg">algorithm to use for HMAC</param>
    public: TPM2_HMAC_REQUEST(
        const TPM_HANDLE& handle,
        const std::vector<BYTE>& buffer,
        const TPM_ALG_ID& hashAlg
    );
};
/// <summary>
/// This command performs an HMAC on the supplied data using the indicated hash algorithm.
/// </summary>
class _DLLEXP_ HMACResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 outHMACSize;
    /// <summary>
    /// the returned HMAC in a sized buffer
    /// </summary>
    public: std::vector<BYTE> outHMAC;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: HMACResponse& operator=(const HMACResponse& rhs);
    public: HMACResponse(const HMACResponse& rhs);
    public:
    HMACResponse();
    virtual ~HMACResponse();
    /// <summary>
    /// This command performs an HMAC on the supplied data using the indicated hash algorithm.
    /// </summary>
    ///<param name = "outHMAC">the returned HMAC in a sized buffer</param>
    public: HMACResponse(
        const std::vector<BYTE>& outHMAC
    );
};
/// <summary>
/// This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
/// </summary>
class _DLLEXP_ TPM2_MAC_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the symmetric signing key providing the MAC key
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE handle;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 bufferSize;
    /// <summary>
    /// MAC data
    /// </summary>
    public: std::vector<BYTE> buffer;
    /// <summary>
    /// algorithm to use for MAC
    /// </summary>
    public: TPM_ALG_ID inScheme;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_MAC_REQUEST& operator=(const TPM2_MAC_REQUEST& rhs);
    public: TPM2_MAC_REQUEST(const TPM2_MAC_REQUEST& rhs);
    public:
    TPM2_MAC_REQUEST();
    virtual ~TPM2_MAC_REQUEST();
    /// <summary>
    /// This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
    /// </summary>
    ///<param name = "handle">handle for the symmetric signing key providing the MAC key Auth Index: 1 Auth Role: USER</param>
    ///<param name = "buffer">MAC data</param>
    ///<param name = "inScheme">algorithm to use for MAC</param>
    public: TPM2_MAC_REQUEST(
        const TPM_HANDLE& handle,
        const std::vector<BYTE>& buffer,
        const TPM_ALG_ID& inScheme
    );
};
/// <summary>
/// This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
/// </summary>
class _DLLEXP_ MACResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 outMACSize;
    /// <summary>
    /// the returned MAC in a sized buffer
    /// </summary>
    public: std::vector<BYTE> outMAC;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: MACResponse& operator=(const MACResponse& rhs);
    public: MACResponse(const MACResponse& rhs);
    public:
    MACResponse();
    virtual ~MACResponse();
    /// <summary>
    /// This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
    /// </summary>
    ///<param name = "outMAC">the returned MAC in a sized buffer</param>
    public: MACResponse(
        const std::vector<BYTE>& outMAC
    );
};
/// <summary>
/// This command returns the next bytesRequested octets from the random number generator (RNG).
/// </summary>
class _DLLEXP_ TPM2_GetRandom_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of octets to return
    /// </summary>
    public: UINT16 bytesRequested;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_GetRandom_REQUEST& operator=(const TPM2_GetRandom_REQUEST& rhs);
    public: TPM2_GetRandom_REQUEST(const TPM2_GetRandom_REQUEST& rhs);
    public:
    TPM2_GetRandom_REQUEST();
    virtual ~TPM2_GetRandom_REQUEST();
    /// <summary>
    /// This command returns the next bytesRequested octets from the random number generator (RNG).
    /// </summary>
    ///<param name = "bytesRequested">number of octets to return</param>
    public: TPM2_GetRandom_REQUEST(
        const UINT16& bytesRequested
    );
};
/// <summary>
/// This command returns the next bytesRequested octets from the random number generator (RNG).
/// </summary>
class _DLLEXP_ GetRandomResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 randomBytesSize;
    /// <summary>
    /// the random octets
    /// </summary>
    public: std::vector<BYTE> randomBytes;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: GetRandomResponse& operator=(const GetRandomResponse& rhs);
    public: GetRandomResponse(const GetRandomResponse& rhs);
    public:
    GetRandomResponse();
    virtual ~GetRandomResponse();
    /// <summary>
    /// This command returns the next bytesRequested octets from the random number generator (RNG).
    /// </summary>
    ///<param name = "randomBytes">the random octets</param>
    public: GetRandomResponse(
        const std::vector<BYTE>& randomBytes
    );
};
/// <summary>
/// This command is used to add "additional information" to the RNG state.
/// </summary>
class _DLLEXP_ TPM2_StirRandom_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    protected: mutable UINT16 inDataSize;
    /// <summary>
    /// additional information
    /// </summary>
    public: std::vector<BYTE> inData;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_StirRandom_REQUEST& operator=(const TPM2_StirRandom_REQUEST& rhs);
    public: TPM2_StirRandom_REQUEST(const TPM2_StirRandom_REQUEST& rhs);
    public:
    TPM2_StirRandom_REQUEST();
    virtual ~TPM2_StirRandom_REQUEST();
    /// <summary>
    /// This command is used to add "additional information" to the RNG state.
    /// </summary>
    ///<param name = "inData">additional information</param>
    public: TPM2_StirRandom_REQUEST(
        const std::vector<BYTE>& inData
    );
};
/// <summary>
/// This command is used to add "additional information" to the RNG state.
/// </summary>
class _DLLEXP_ StirRandomResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: StirRandomResponse& operator=(const StirRandomResponse& rhs);
    public: StirRandomResponse(const StirRandomResponse& rhs);
    public:
    StirRandomResponse();
    virtual ~StirRandomResponse();
};
/// <summary>
/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
class _DLLEXP_ TPM2_HMAC_Start_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of an HMAC key
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE handle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 authSize;
    /// <summary>
    /// authorization value for subsequent use of the sequence
    /// </summary>
    public: std::vector<BYTE> auth;
    /// <summary>
    /// the hash algorithm to use for the HMAC
    /// </summary>
    public: TPM_ALG_ID hashAlg;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_HMAC_Start_REQUEST& operator=(const TPM2_HMAC_Start_REQUEST& rhs);
    public: TPM2_HMAC_Start_REQUEST(const TPM2_HMAC_Start_REQUEST& rhs);
    public:
    TPM2_HMAC_Start_REQUEST();
    virtual ~TPM2_HMAC_Start_REQUEST();
    /// <summary>
    /// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
    /// </summary>
    ///<param name = "handle">handle of an HMAC key Auth Index: 1 Auth Role: USER</param>
    ///<param name = "auth">authorization value for subsequent use of the sequence</param>
    ///<param name = "hashAlg">the hash algorithm to use for the HMAC</param>
    public: TPM2_HMAC_Start_REQUEST(
        const TPM_HANDLE& handle,
        const std::vector<BYTE>& auth,
        const TPM_ALG_ID& hashAlg
    );
};
/// <summary>
/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
class _DLLEXP_ HMAC_StartResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// a handle to reference the sequence
    /// </summary>
    public: TPM_HANDLE handle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: HMAC_StartResponse& operator=(const HMAC_StartResponse& rhs);
    public: HMAC_StartResponse(const HMAC_StartResponse& rhs);
    public:
    HMAC_StartResponse();
    virtual ~HMAC_StartResponse();
    /// <summary>
    /// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
    /// </summary>
    ///<param name = "handle">a handle to reference the sequence</param>
    public: HMAC_StartResponse(
        const TPM_HANDLE& handle
    );
};
/// <summary>
/// This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
class _DLLEXP_ TPM2_MAC_Start_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of a MAC key
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE handle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 authSize;
    /// <summary>
    /// authorization value for subsequent use of the sequence
    /// </summary>
    public: std::vector<BYTE> auth;
    /// <summary>
    /// the algorithm to use for the MAC
    /// </summary>
    public: TPM_ALG_ID inScheme;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_MAC_Start_REQUEST& operator=(const TPM2_MAC_Start_REQUEST& rhs);
    public: TPM2_MAC_Start_REQUEST(const TPM2_MAC_Start_REQUEST& rhs);
    public:
    TPM2_MAC_Start_REQUEST();
    virtual ~TPM2_MAC_Start_REQUEST();
    /// <summary>
    /// This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
    /// </summary>
    ///<param name = "handle">handle of a MAC key Auth Index: 1 Auth Role: USER</param>
    ///<param name = "auth">authorization value for subsequent use of the sequence</param>
    ///<param name = "inScheme">the algorithm to use for the MAC</param>
    public: TPM2_MAC_Start_REQUEST(
        const TPM_HANDLE& handle,
        const std::vector<BYTE>& auth,
        const TPM_ALG_ID& inScheme
    );
};
/// <summary>
/// This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
class _DLLEXP_ MAC_StartResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// a handle to reference the sequence
    /// </summary>
    public: TPM_HANDLE handle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: MAC_StartResponse& operator=(const MAC_StartResponse& rhs);
    public: MAC_StartResponse(const MAC_StartResponse& rhs);
    public:
    MAC_StartResponse();
    virtual ~MAC_StartResponse();
    /// <summary>
    /// This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
    /// </summary>
    ///<param name = "handle">a handle to reference the sequence</param>
    public: MAC_StartResponse(
        const TPM_HANDLE& handle
    );
};
/// <summary>
/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
/// </summary>
class _DLLEXP_ TPM2_HashSequenceStart_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 authSize;
    /// <summary>
    /// authorization value for subsequent use of the sequence
    /// </summary>
    public: std::vector<BYTE> auth;
    /// <summary>
    /// the hash algorithm to use for the hash sequence
    /// An Event Sequence starts if this is TPM_ALG_NULL.
    /// </summary>
    public: TPM_ALG_ID hashAlg;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_HashSequenceStart_REQUEST& operator=(const TPM2_HashSequenceStart_REQUEST& rhs);
    public: TPM2_HashSequenceStart_REQUEST(const TPM2_HashSequenceStart_REQUEST& rhs);
    public:
    TPM2_HashSequenceStart_REQUEST();
    virtual ~TPM2_HashSequenceStart_REQUEST();
    /// <summary>
    /// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
    /// </summary>
    ///<param name = "auth">authorization value for subsequent use of the sequence</param>
    ///<param name = "hashAlg">the hash algorithm to use for the hash sequence An Event Sequence starts if this is TPM_ALG_NULL.</param>
    public: TPM2_HashSequenceStart_REQUEST(
        const std::vector<BYTE>& auth,
        const TPM_ALG_ID& hashAlg
    );
};
/// <summary>
/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
/// </summary>
class _DLLEXP_ HashSequenceStartResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// a handle to reference the sequence
    /// </summary>
    public: TPM_HANDLE handle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: HashSequenceStartResponse& operator=(const HashSequenceStartResponse& rhs);
    public: HashSequenceStartResponse(const HashSequenceStartResponse& rhs);
    public:
    HashSequenceStartResponse();
    virtual ~HashSequenceStartResponse();
    /// <summary>
    /// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
    /// </summary>
    ///<param name = "handle">a handle to reference the sequence</param>
    public: HashSequenceStartResponse(
        const TPM_HANDLE& handle
    );
};
/// <summary>
/// This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
/// </summary>
class _DLLEXP_ TPM2_SequenceUpdate_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the sequence object
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE sequenceHandle;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 bufferSize;
    /// <summary>
    /// data to be added to hash
    /// </summary>
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_SequenceUpdate_REQUEST& operator=(const TPM2_SequenceUpdate_REQUEST& rhs);
    public: TPM2_SequenceUpdate_REQUEST(const TPM2_SequenceUpdate_REQUEST& rhs);
    public:
    TPM2_SequenceUpdate_REQUEST();
    virtual ~TPM2_SequenceUpdate_REQUEST();
    /// <summary>
    /// This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
    /// </summary>
    ///<param name = "sequenceHandle">handle for the sequence object Auth Index: 1 Auth Role: USER</param>
    ///<param name = "buffer">data to be added to hash</param>
    public: TPM2_SequenceUpdate_REQUEST(
        const TPM_HANDLE& sequenceHandle,
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
/// </summary>
class _DLLEXP_ SequenceUpdateResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: SequenceUpdateResponse& operator=(const SequenceUpdateResponse& rhs);
    public: SequenceUpdateResponse(const SequenceUpdateResponse& rhs);
    public:
    SequenceUpdateResponse();
    virtual ~SequenceUpdateResponse();
};
/// <summary>
/// This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
/// </summary>
class _DLLEXP_ TPM2_SequenceComplete_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// authorization for the sequence
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE sequenceHandle;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 bufferSize;
    /// <summary>
    /// data to be added to the hash/HMAC
    /// </summary>
    public: std::vector<BYTE> buffer;
    /// <summary>
    /// hierarchy of the ticket for a hash
    /// </summary>
    public: TPM_HANDLE hierarchy;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_SequenceComplete_REQUEST& operator=(const TPM2_SequenceComplete_REQUEST& rhs);
    public: TPM2_SequenceComplete_REQUEST(const TPM2_SequenceComplete_REQUEST& rhs);
    public:
    TPM2_SequenceComplete_REQUEST();
    virtual ~TPM2_SequenceComplete_REQUEST();
    /// <summary>
    /// This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
    /// </summary>
    ///<param name = "sequenceHandle">authorization for the sequence Auth Index: 1 Auth Role: USER</param>
    ///<param name = "buffer">data to be added to the hash/HMAC</param>
    ///<param name = "hierarchy">hierarchy of the ticket for a hash</param>
    public: TPM2_SequenceComplete_REQUEST(
        const TPM_HANDLE& sequenceHandle,
        const std::vector<BYTE>& buffer,
        const TPM_HANDLE& hierarchy
    );
};
/// <summary>
/// This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
/// </summary>
class _DLLEXP_ SequenceCompleteResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 resultSize;
    /// <summary>
    /// the returned HMAC or digest in a sized buffer
    /// </summary>
    public: std::vector<BYTE> result;
    /// <summary>
    /// ticket indicating that the sequence of octets used to compute outDigest did not start with TPM_GENERATED_VALUE
    /// This is a NULL Ticket when the sequence is HMAC.
    /// </summary>
    public: TPMT_TK_HASHCHECK validation;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: SequenceCompleteResponse& operator=(const SequenceCompleteResponse& rhs);
    public: SequenceCompleteResponse(const SequenceCompleteResponse& rhs);
    public:
    SequenceCompleteResponse();
    virtual ~SequenceCompleteResponse();
    /// <summary>
    /// This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
    /// </summary>
    ///<param name = "result">the returned HMAC or digest in a sized buffer</param>
    ///<param name = "validation">ticket indicating that the sequence of octets used to compute outDigest did not start with TPM_GENERATED_VALUE This is a NULL Ticket when the sequence is HMAC.</param>
    public: SequenceCompleteResponse(
        const std::vector<BYTE>& result,
        const TPMT_TK_HASHCHECK& validation
    );
};
/// <summary>
/// This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
/// </summary>
class _DLLEXP_ TPM2_EventSequenceComplete_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// PCR to be extended with the Event data
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE pcrHandle;
    /// <summary>
    /// authorization for the sequence
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE sequenceHandle;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 bufferSize;
    /// <summary>
    /// data to be added to the Event
    /// </summary>
    public: std::vector<BYTE> buffer;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_EventSequenceComplete_REQUEST& operator=(const TPM2_EventSequenceComplete_REQUEST& rhs);
    public: TPM2_EventSequenceComplete_REQUEST(const TPM2_EventSequenceComplete_REQUEST& rhs);
    public:
    TPM2_EventSequenceComplete_REQUEST();
    virtual ~TPM2_EventSequenceComplete_REQUEST();
    /// <summary>
    /// This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
    /// </summary>
    ///<param name = "pcrHandle">PCR to be extended with the Event data Auth Index: 1 Auth Role: USER</param>
    ///<param name = "sequenceHandle">authorization for the sequence Auth Index: 2 Auth Role: USER</param>
    ///<param name = "buffer">data to be added to the Event</param>
    public: TPM2_EventSequenceComplete_REQUEST(
        const TPM_HANDLE& pcrHandle,
        const TPM_HANDLE& sequenceHandle,
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
/// </summary>
class _DLLEXP_ EventSequenceCompleteResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of digests in the list
    /// </summary>
    protected: mutable UINT32 resultsCount;
    /// <summary>
    /// list of digests computed for the PCR
    /// </summary>
    public: std::vector<TPMT_HA> results;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: EventSequenceCompleteResponse& operator=(const EventSequenceCompleteResponse& rhs);
    public: EventSequenceCompleteResponse(const EventSequenceCompleteResponse& rhs);
    public:
    EventSequenceCompleteResponse();
    virtual ~EventSequenceCompleteResponse();
    /// <summary>
    /// This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
    /// </summary>
    ///<param name = "results">list of digests computed for the PCR</param>
    public: EventSequenceCompleteResponse(
        const std::vector<TPMT_HA>& results
    );
};
/// <summary>
/// The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
/// </summary>
class _DLLEXP_ TPM2_Certify_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of the object to be certified
    /// Auth Index: 1
    /// Auth Role: ADMIN
    /// </summary>
    public: TPM_HANDLE objectHandle;
    /// <summary>
    /// handle of the key used to sign the attestation structure
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE signHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 qualifyingDataSize;
    /// <summary>
    /// user provided qualifying data
    /// </summary>
    public: std::vector<BYTE> qualifyingData;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    /// <summary>
    /// signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: TPMU_SIG_SCHEME* inScheme;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_Certify_REQUEST& operator=(const TPM2_Certify_REQUEST& rhs);
    public: TPM2_Certify_REQUEST(const TPM2_Certify_REQUEST& rhs);
    public:
    TPM2_Certify_REQUEST();
    virtual ~TPM2_Certify_REQUEST();
    /// <summary>
    /// The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
    /// </summary>
    ///<param name = "objectHandle">handle of the object to be certified Auth Index: 1 Auth Role: ADMIN</param>
    ///<param name = "signHandle">handle of the key used to sign the attestation structure Auth Index: 2 Auth Role: USER</param>
    ///<param name = "qualifyingData">user provided qualifying data</param>
    ///<param name = "inScheme">signing scheme to use if the scheme for signHandle is TPM_ALG_NULL(One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)</param>
    public: TPM2_Certify_REQUEST(
        const TPM_HANDLE& objectHandle,
        const TPM_HANDLE& signHandle,
        const std::vector<BYTE>& qualifyingData,
        const TPMU_SIG_SCHEME& inScheme
    );
};
/// <summary>
/// The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
/// </summary>
class _DLLEXP_ CertifyResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the attestationData structure
    /// </summary>
    protected: mutable UINT16 certifyInfoSize;
    /// <summary>
    /// the structure that was signed
    /// </summary>
    public: TPMS_ATTEST certifyInfo;
    /// <summary>
    /// selector of the algorithm used to construct the signature
    /// </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    /// <summary>
    /// the asymmetric signature over certifyInfo using the key referenced by signHandle
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: TPMU_SIGNATURE* signature;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: CertifyResponse& operator=(const CertifyResponse& rhs);
    public: CertifyResponse(const CertifyResponse& rhs);
    public:
    CertifyResponse();
    virtual ~CertifyResponse();
    /// <summary>
    /// The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
    /// </summary>
    ///<param name = "certifyInfo">the structure that was signed</param>
    ///<param name = "signature">the asymmetric signature over certifyInfo using the key referenced by signHandle(One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)</param>
    public: CertifyResponse(
        const TPMS_ATTEST& certifyInfo,
        const TPMU_SIGNATURE& signature
    );
};
/// <summary>
/// This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
/// </summary>
class _DLLEXP_ TPM2_CertifyCreation_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of the key that will sign the attestation block
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE signHandle;
    /// <summary>
    /// the object associated with the creation data
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE objectHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 qualifyingDataSize;
    /// <summary>
    /// user-provided qualifying data
    /// </summary>
    public: std::vector<BYTE> qualifyingData;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 creationHashSize;
    /// <summary>
    /// hash of the creation data produced by TPM2_Create() or TPM2_CreatePrimary()
    /// </summary>
    public: std::vector<BYTE> creationHash;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    /// <summary>
    /// signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: TPMU_SIG_SCHEME* inScheme;
    /// <summary>
    /// ticket produced by TPM2_Create() or TPM2_CreatePrimary()
    /// </summary>
    public: TPMT_TK_CREATION creationTicket;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_CertifyCreation_REQUEST& operator=(const TPM2_CertifyCreation_REQUEST& rhs);
    public: TPM2_CertifyCreation_REQUEST(const TPM2_CertifyCreation_REQUEST& rhs);
    public:
    TPM2_CertifyCreation_REQUEST();
    virtual ~TPM2_CertifyCreation_REQUEST();
    /// <summary>
    /// This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
    /// </summary>
    ///<param name = "signHandle">handle of the key that will sign the attestation block Auth Index: 1 Auth Role: USER</param>
    ///<param name = "objectHandle">the object associated with the creation data Auth Index: None</param>
    ///<param name = "qualifyingData">user-provided qualifying data</param>
    ///<param name = "creationHash">hash of the creation data produced by TPM2_Create() or TPM2_CreatePrimary()</param>
    ///<param name = "inScheme">signing scheme to use if the scheme for signHandle is TPM_ALG_NULL(One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)</param>
    ///<param name = "creationTicket">ticket produced by TPM2_Create() or TPM2_CreatePrimary()</param>
    public: TPM2_CertifyCreation_REQUEST(
        const TPM_HANDLE& signHandle,
        const TPM_HANDLE& objectHandle,
        const std::vector<BYTE>& qualifyingData,
        const std::vector<BYTE>& creationHash,
        const TPMU_SIG_SCHEME& inScheme,
        const TPMT_TK_CREATION& creationTicket
    );
};
/// <summary>
/// This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
/// </summary>
class _DLLEXP_ CertifyCreationResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the attestationData structure
    /// </summary>
    protected: mutable UINT16 certifyInfoSize;
    /// <summary>
    /// the structure that was signed
    /// </summary>
    public: TPMS_ATTEST certifyInfo;
    /// <summary>
    /// selector of the algorithm used to construct the signature
    /// </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    /// <summary>
    /// the signature over certifyInfo
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: TPMU_SIGNATURE* signature;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: CertifyCreationResponse& operator=(const CertifyCreationResponse& rhs);
    public: CertifyCreationResponse(const CertifyCreationResponse& rhs);
    public:
    CertifyCreationResponse();
    virtual ~CertifyCreationResponse();
    /// <summary>
    /// This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
    /// </summary>
    ///<param name = "certifyInfo">the structure that was signed</param>
    ///<param name = "signature">the signature over certifyInfo(One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)</param>
    public: CertifyCreationResponse(
        const TPMS_ATTEST& certifyInfo,
        const TPMU_SIGNATURE& signature
    );
};
/// <summary>
/// This command is used to quote PCR values.
/// </summary>
class _DLLEXP_ TPM2_Quote_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of key that will perform signature
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE signHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 qualifyingDataSize;
    /// <summary>
    /// data supplied by the caller
    /// </summary>
    public: std::vector<BYTE> qualifyingData;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    /// <summary>
    /// signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: TPMU_SIG_SCHEME* inScheme;
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 PCRselectCount;
    /// <summary>
    /// PCR set to quote
    /// </summary>
    public: std::vector<TPMS_PCR_SELECTION> PCRselect;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_Quote_REQUEST& operator=(const TPM2_Quote_REQUEST& rhs);
    public: TPM2_Quote_REQUEST(const TPM2_Quote_REQUEST& rhs);
    public:
    TPM2_Quote_REQUEST();
    virtual ~TPM2_Quote_REQUEST();
    /// <summary>
    /// This command is used to quote PCR values.
    /// </summary>
    ///<param name = "signHandle">handle of key that will perform signature Auth Index: 1 Auth Role: USER</param>
    ///<param name = "qualifyingData">data supplied by the caller</param>
    ///<param name = "inScheme">signing scheme to use if the scheme for signHandle is TPM_ALG_NULL(One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)</param>
    ///<param name = "PCRselect">PCR set to quote</param>
    public: TPM2_Quote_REQUEST(
        const TPM_HANDLE& signHandle,
        const std::vector<BYTE>& qualifyingData,
        const TPMU_SIG_SCHEME& inScheme,
        const std::vector<TPMS_PCR_SELECTION>& PCRselect
    );
};
/// <summary>
/// This command is used to quote PCR values.
/// </summary>
class _DLLEXP_ QuoteResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the attestationData structure
    /// </summary>
    protected: mutable UINT16 quotedSize;
    /// <summary>
    /// the quoted information
    /// </summary>
    public: TPMS_ATTEST quoted;
    /// <summary>
    /// selector of the algorithm used to construct the signature
    /// </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    /// <summary>
    /// the signature over quoted
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: TPMU_SIGNATURE* signature;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: QuoteResponse& operator=(const QuoteResponse& rhs);
    public: QuoteResponse(const QuoteResponse& rhs);
    public:
    QuoteResponse();
    virtual ~QuoteResponse();
    /// <summary>
    /// This command is used to quote PCR values.
    /// </summary>
    ///<param name = "quoted">the quoted information</param>
    ///<param name = "signature">the signature over quoted(One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)</param>
    public: QuoteResponse(
        const TPMS_ATTEST& quoted,
        const TPMU_SIGNATURE& signature
    );
};
/// <summary>
/// This command returns a digital signature of the audit session digest.
/// </summary>
class _DLLEXP_ TPM2_GetSessionAuditDigest_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE privacyAdminHandle;
    /// <summary>
    /// handle of the signing key
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE signHandle;
    /// <summary>
    /// handle of the audit session
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE sessionHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 qualifyingDataSize;
    /// <summary>
    /// user-provided qualifying data  may be zero-length
    /// </summary>
    public: std::vector<BYTE> qualifyingData;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    /// <summary>
    /// signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: TPMU_SIG_SCHEME* inScheme;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_GetSessionAuditDigest_REQUEST& operator=(const TPM2_GetSessionAuditDigest_REQUEST& rhs);
    public: TPM2_GetSessionAuditDigest_REQUEST(const TPM2_GetSessionAuditDigest_REQUEST& rhs);
    public:
    TPM2_GetSessionAuditDigest_REQUEST();
    virtual ~TPM2_GetSessionAuditDigest_REQUEST();
    /// <summary>
    /// This command returns a digital signature of the audit session digest.
    /// </summary>
    ///<param name = "privacyAdminHandle">handle of the privacy administrator (TPM_RH_ENDORSEMENT) Auth Index: 1 Auth Role: USER</param>
    ///<param name = "signHandle">handle of the signing key Auth Index: 2 Auth Role: USER</param>
    ///<param name = "sessionHandle">handle of the audit session Auth Index: None</param>
    ///<param name = "qualifyingData">user-provided qualifying data  may be zero-length</param>
    ///<param name = "inScheme">signing scheme to use if the scheme for signHandle is TPM_ALG_NULL(One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)</param>
    public: TPM2_GetSessionAuditDigest_REQUEST(
        const TPM_HANDLE& privacyAdminHandle,
        const TPM_HANDLE& signHandle,
        const TPM_HANDLE& sessionHandle,
        const std::vector<BYTE>& qualifyingData,
        const TPMU_SIG_SCHEME& inScheme
    );
};
/// <summary>
/// This command returns a digital signature of the audit session digest.
/// </summary>
class _DLLEXP_ GetSessionAuditDigestResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the attestationData structure
    /// </summary>
    protected: mutable UINT16 auditInfoSize;
    /// <summary>
    /// the audit information that was signed
    /// </summary>
    public: TPMS_ATTEST auditInfo;
    /// <summary>
    /// selector of the algorithm used to construct the signature
    /// </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    /// <summary>
    /// the signature over auditInfo
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: TPMU_SIGNATURE* signature;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: GetSessionAuditDigestResponse& operator=(const GetSessionAuditDigestResponse& rhs);
    public: GetSessionAuditDigestResponse(const GetSessionAuditDigestResponse& rhs);
    public:
    GetSessionAuditDigestResponse();
    virtual ~GetSessionAuditDigestResponse();
    /// <summary>
    /// This command returns a digital signature of the audit session digest.
    /// </summary>
    ///<param name = "auditInfo">the audit information that was signed</param>
    ///<param name = "signature">the signature over auditInfo(One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)</param>
    public: GetSessionAuditDigestResponse(
        const TPMS_ATTEST& auditInfo,
        const TPMU_SIGNATURE& signature
    );
};
/// <summary>
/// This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
/// </summary>
class _DLLEXP_ TPM2_GetCommandAuditDigest_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE privacyHandle;
    /// <summary>
    /// the handle of the signing key
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE signHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 qualifyingDataSize;
    /// <summary>
    /// other data to associate with this audit digest
    /// </summary>
    public: std::vector<BYTE> qualifyingData;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    /// <summary>
    /// signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: TPMU_SIG_SCHEME* inScheme;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_GetCommandAuditDigest_REQUEST& operator=(const TPM2_GetCommandAuditDigest_REQUEST& rhs);
    public: TPM2_GetCommandAuditDigest_REQUEST(const TPM2_GetCommandAuditDigest_REQUEST& rhs);
    public:
    TPM2_GetCommandAuditDigest_REQUEST();
    virtual ~TPM2_GetCommandAuditDigest_REQUEST();
    /// <summary>
    /// This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
    /// </summary>
    ///<param name = "privacyHandle">handle of the privacy administrator (TPM_RH_ENDORSEMENT) Auth Index: 1 Auth Role: USER</param>
    ///<param name = "signHandle">the handle of the signing key Auth Index: 2 Auth Role: USER</param>
    ///<param name = "qualifyingData">other data to associate with this audit digest</param>
    ///<param name = "inScheme">signing scheme to use if the scheme for signHandle is TPM_ALG_NULL(One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)</param>
    public: TPM2_GetCommandAuditDigest_REQUEST(
        const TPM_HANDLE& privacyHandle,
        const TPM_HANDLE& signHandle,
        const std::vector<BYTE>& qualifyingData,
        const TPMU_SIG_SCHEME& inScheme
    );
};
/// <summary>
/// This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
/// </summary>
class _DLLEXP_ GetCommandAuditDigestResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the attestationData structure
    /// </summary>
    protected: mutable UINT16 auditInfoSize;
    /// <summary>
    /// the auditInfo that was signed
    /// </summary>
    public: TPMS_ATTEST auditInfo;
    /// <summary>
    /// selector of the algorithm used to construct the signature
    /// </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    /// <summary>
    /// the signature over auditInfo
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: TPMU_SIGNATURE* signature;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: GetCommandAuditDigestResponse& operator=(const GetCommandAuditDigestResponse& rhs);
    public: GetCommandAuditDigestResponse(const GetCommandAuditDigestResponse& rhs);
    public:
    GetCommandAuditDigestResponse();
    virtual ~GetCommandAuditDigestResponse();
    /// <summary>
    /// This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
    /// </summary>
    ///<param name = "auditInfo">the auditInfo that was signed</param>
    ///<param name = "signature">the signature over auditInfo(One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)</param>
    public: GetCommandAuditDigestResponse(
        const TPMS_ATTEST& auditInfo,
        const TPMU_SIGNATURE& signature
    );
};
/// <summary>
/// This command returns the current values of Time and Clock.
/// </summary>
class _DLLEXP_ TPM2_GetTime_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE privacyAdminHandle;
    /// <summary>
    /// the keyHandle identifier of a loaded key that can perform digital signatures
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE signHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 qualifyingDataSize;
    /// <summary>
    /// data to tick stamp
    /// </summary>
    public: std::vector<BYTE> qualifyingData;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    /// <summary>
    /// signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: TPMU_SIG_SCHEME* inScheme;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_GetTime_REQUEST& operator=(const TPM2_GetTime_REQUEST& rhs);
    public: TPM2_GetTime_REQUEST(const TPM2_GetTime_REQUEST& rhs);
    public:
    TPM2_GetTime_REQUEST();
    virtual ~TPM2_GetTime_REQUEST();
    /// <summary>
    /// This command returns the current values of Time and Clock.
    /// </summary>
    ///<param name = "privacyAdminHandle">handle of the privacy administrator (TPM_RH_ENDORSEMENT) Auth Index: 1 Auth Role: USER</param>
    ///<param name = "signHandle">the keyHandle identifier of a loaded key that can perform digital signatures Auth Index: 2 Auth Role: USER</param>
    ///<param name = "qualifyingData">data to tick stamp</param>
    ///<param name = "inScheme">signing scheme to use if the scheme for signHandle is TPM_ALG_NULL(One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)</param>
    public: TPM2_GetTime_REQUEST(
        const TPM_HANDLE& privacyAdminHandle,
        const TPM_HANDLE& signHandle,
        const std::vector<BYTE>& qualifyingData,
        const TPMU_SIG_SCHEME& inScheme
    );
};
/// <summary>
/// This command returns the current values of Time and Clock.
/// </summary>
class _DLLEXP_ GetTimeResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the attestationData structure
    /// </summary>
    protected: mutable UINT16 timeInfoSize;
    /// <summary>
    /// standard TPM-generated attestation block
    /// </summary>
    public: TPMS_ATTEST timeInfo;
    /// <summary>
    /// selector of the algorithm used to construct the signature
    /// </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    /// <summary>
    /// the signature over timeInfo
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: TPMU_SIGNATURE* signature;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: GetTimeResponse& operator=(const GetTimeResponse& rhs);
    public: GetTimeResponse(const GetTimeResponse& rhs);
    public:
    GetTimeResponse();
    virtual ~GetTimeResponse();
    /// <summary>
    /// This command returns the current values of Time and Clock.
    /// </summary>
    ///<param name = "timeInfo">standard TPM-generated attestation block</param>
    ///<param name = "signature">the signature over timeInfo(One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)</param>
    public: GetTimeResponse(
        const TPMS_ATTEST& timeInfo,
        const TPMU_SIGNATURE& signature
    );
};
/// <summary>
/// The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
/// </summary>
class _DLLEXP_ TPM2_CertifyX509_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of the object to be certified
    /// Auth Index: 1
    /// Auth Role: ADMIN
    /// </summary>
    public: TPM_HANDLE objectHandle;
    /// <summary>
    /// handle of the key used to sign the attestation structure
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE signHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 qualifyingDataSize;
    /// <summary>
    /// user provided qualifying data
    /// </summary>
    public: std::vector<BYTE> qualifyingData;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    /// <summary>
    /// signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: TPMU_SIG_SCHEME* inScheme;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 partialCertificateSize;
    /// <summary>
    /// a DER encoded partial certificate
    /// </summary>
    public: std::vector<BYTE> partialCertificate;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_CertifyX509_REQUEST& operator=(const TPM2_CertifyX509_REQUEST& rhs);
    public: TPM2_CertifyX509_REQUEST(const TPM2_CertifyX509_REQUEST& rhs);
    public:
    TPM2_CertifyX509_REQUEST();
    virtual ~TPM2_CertifyX509_REQUEST();
    /// <summary>
    /// The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
    /// </summary>
    ///<param name = "objectHandle">handle of the object to be certified Auth Index: 1 Auth Role: ADMIN</param>
    ///<param name = "signHandle">handle of the key used to sign the attestation structure Auth Index: 2 Auth Role: USER</param>
    ///<param name = "qualifyingData">user provided qualifying data</param>
    ///<param name = "inScheme">signing scheme to use if the scheme for signHandle is TPM_ALG_NULL(One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)</param>
    ///<param name = "partialCertificate">a DER encoded partial certificate</param>
    public: TPM2_CertifyX509_REQUEST(
        const TPM_HANDLE& objectHandle,
        const TPM_HANDLE& signHandle,
        const std::vector<BYTE>& qualifyingData,
        const TPMU_SIG_SCHEME& inScheme,
        const std::vector<BYTE>& partialCertificate
    );
};
/// <summary>
/// The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
/// </summary>
class _DLLEXP_ CertifyX509Response : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 addedToCertificateSize;
    /// <summary>
    /// the DER encoded fields added to partialCertificate to make it a complete RFC5280 TBSCertificate.
    /// </summary>
    public: std::vector<BYTE> addedToCertificate;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 tbsDigestSize;
    /// <summary>
    /// the digest that was signed
    /// </summary>
    public: std::vector<BYTE> tbsDigest;
    /// <summary>
    /// selector of the algorithm used to construct the signature
    /// </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    /// <summary>
    /// The signature over tbsDigest
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: TPMU_SIGNATURE* signature;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: CertifyX509Response& operator=(const CertifyX509Response& rhs);
    public: CertifyX509Response(const CertifyX509Response& rhs);
    public:
    CertifyX509Response();
    virtual ~CertifyX509Response();
    /// <summary>
    /// The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
    /// </summary>
    ///<param name = "addedToCertificate">the DER encoded fields added to partialCertificate to make it a complete RFC5280 TBSCertificate.</param>
    ///<param name = "tbsDigest">the digest that was signed</param>
    ///<param name = "signature">The signature over tbsDigest(One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)</param>
    public: CertifyX509Response(
        const std::vector<BYTE>& addedToCertificate,
        const std::vector<BYTE>& tbsDigest,
        const TPMU_SIGNATURE& signature
    );
};
/// <summary>
/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
/// </summary>
class _DLLEXP_ TPM2_Commit_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of the key that will be used in the signing operation
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE signHandle;
    /// <summary>
    /// size of the remainder of this structure
    /// </summary>
    protected: mutable UINT16 P1Size;
    /// <summary>
    /// a point (M) on the curve used by signHandle
    /// </summary>
    public: TPMS_ECC_POINT P1;
    protected: mutable UINT16 s2Size;
    /// <summary>
    /// octet array used to derive x-coordinate of a base point
    /// </summary>
    public: std::vector<BYTE> s2;
    /// <summary>
    /// size of buffer
    /// </summary>
    protected: mutable UINT16 y2Size;
    /// <summary>
    /// y coordinate of the point associated with s2
    /// </summary>
    public: std::vector<BYTE> y2;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_Commit_REQUEST& operator=(const TPM2_Commit_REQUEST& rhs);
    public: TPM2_Commit_REQUEST(const TPM2_Commit_REQUEST& rhs);
    public:
    TPM2_Commit_REQUEST();
    virtual ~TPM2_Commit_REQUEST();
    /// <summary>
    /// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
    /// </summary>
    ///<param name = "signHandle">handle of the key that will be used in the signing operation Auth Index: 1 Auth Role: USER</param>
    ///<param name = "P1">a point (M) on the curve used by signHandle</param>
    ///<param name = "s2">octet array used to derive x-coordinate of a base point</param>
    ///<param name = "y2">y coordinate of the point associated with s2</param>
    public: TPM2_Commit_REQUEST(
        const TPM_HANDLE& signHandle,
        const TPMS_ECC_POINT& P1,
        const std::vector<BYTE>& s2,
        const std::vector<BYTE>& y2
    );
};
/// <summary>
/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
/// </summary>
class _DLLEXP_ CommitResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the remainder of this structure
    /// </summary>
    protected: mutable UINT16 KSize;
    /// <summary>
    /// ECC point K  [ds](x2, y2)
    /// </summary>
    public: TPMS_ECC_POINT K;
    /// <summary>
    /// size of the remainder of this structure
    /// </summary>
    protected: mutable UINT16 LSize;
    /// <summary>
    /// ECC point L  [r](x2, y2)
    /// </summary>
    public: TPMS_ECC_POINT L;
    /// <summary>
    /// size of the remainder of this structure
    /// </summary>
    protected: mutable UINT16 ESize;
    /// <summary>
    /// ECC point E  [r]P1
    /// </summary>
    public: TPMS_ECC_POINT E;
    /// <summary>
    /// least-significant 16 bits of commitCount
    /// </summary>
    public: UINT16 counter;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: CommitResponse& operator=(const CommitResponse& rhs);
    public: CommitResponse(const CommitResponse& rhs);
    public:
    CommitResponse();
    virtual ~CommitResponse();
    /// <summary>
    /// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
    /// </summary>
    ///<param name = "K">ECC point K  [ds](x2, y2)</param>
    ///<param name = "L">ECC point L  [r](x2, y2)</param>
    ///<param name = "E">ECC point E  [r]P1</param>
    ///<param name = "counter">least-significant 16 bits of commitCount</param>
    public: CommitResponse(
        const TPMS_ECC_POINT& K,
        const TPMS_ECC_POINT& L,
        const TPMS_ECC_POINT& E,
        const UINT16& counter
    );
};
/// <summary>
/// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
/// </summary>
class _DLLEXP_ TPM2_EC_Ephemeral_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// The curve for the computed ephemeral point
    /// </summary>
    public: TPM_ECC_CURVE curveID;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_EC_Ephemeral_REQUEST& operator=(const TPM2_EC_Ephemeral_REQUEST& rhs);
    public: TPM2_EC_Ephemeral_REQUEST(const TPM2_EC_Ephemeral_REQUEST& rhs);
    public:
    TPM2_EC_Ephemeral_REQUEST();
    virtual ~TPM2_EC_Ephemeral_REQUEST();
    /// <summary>
    /// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
    /// </summary>
    ///<param name = "curveID">The curve for the computed ephemeral point</param>
    public: TPM2_EC_Ephemeral_REQUEST(
        const TPM_ECC_CURVE& curveID
    );
};
/// <summary>
/// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
/// </summary>
class _DLLEXP_ EC_EphemeralResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the remainder of this structure
    /// </summary>
    protected: mutable UINT16 QSize;
    /// <summary>
    /// ephemeral public key Q  [r]G
    /// </summary>
    public: TPMS_ECC_POINT Q;
    /// <summary>
    /// least-significant 16 bits of commitCount
    /// </summary>
    public: UINT16 counter;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: EC_EphemeralResponse& operator=(const EC_EphemeralResponse& rhs);
    public: EC_EphemeralResponse(const EC_EphemeralResponse& rhs);
    public:
    EC_EphemeralResponse();
    virtual ~EC_EphemeralResponse();
    /// <summary>
    /// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
    /// </summary>
    ///<param name = "Q">ephemeral public key Q  [r]G</param>
    ///<param name = "counter">least-significant 16 bits of commitCount</param>
    public: EC_EphemeralResponse(
        const TPMS_ECC_POINT& Q,
        const UINT16& counter
    );
};
/// <summary>
/// This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
/// </summary>
class _DLLEXP_ TPM2_VerifySignature_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of public key that will be used in the validation
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE keyHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 digestSize;
    /// <summary>
    /// digest of the signed message
    /// </summary>
    public: std::vector<BYTE> digest;
    /// <summary>
    /// selector of the algorithm used to construct the signature
    /// </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    /// <summary>
    /// signature to be tested
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: TPMU_SIGNATURE* signature;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_VerifySignature_REQUEST& operator=(const TPM2_VerifySignature_REQUEST& rhs);
    public: TPM2_VerifySignature_REQUEST(const TPM2_VerifySignature_REQUEST& rhs);
    public:
    TPM2_VerifySignature_REQUEST();
    virtual ~TPM2_VerifySignature_REQUEST();
    /// <summary>
    /// This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
    /// </summary>
    ///<param name = "keyHandle">handle of public key that will be used in the validation Auth Index: None</param>
    ///<param name = "digest">digest of the signed message</param>
    ///<param name = "signature">signature to be tested(One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)</param>
    public: TPM2_VerifySignature_REQUEST(
        const TPM_HANDLE& keyHandle,
        const std::vector<BYTE>& digest,
        const TPMU_SIGNATURE& signature
    );
};
/// <summary>
/// This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
/// </summary>
class _DLLEXP_ VerifySignatureResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: TPMT_TK_VERIFIED validation;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: VerifySignatureResponse& operator=(const VerifySignatureResponse& rhs);
    public: VerifySignatureResponse(const VerifySignatureResponse& rhs);
    public:
    VerifySignatureResponse();
    virtual ~VerifySignatureResponse();
    /// <summary>
    /// This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
    /// </summary>
    ///<param name = "validation"></param>
    public: VerifySignatureResponse(
        const TPMT_TK_VERIFIED& validation
    );
};
/// <summary>
/// This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
/// </summary>
class _DLLEXP_ TPM2_Sign_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// Handle of key that will perform signing
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE keyHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 digestSize;
    /// <summary>
    /// digest to be signed
    /// </summary>
    public: std::vector<BYTE> digest;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    /// <summary>
    /// signing scheme to use if the scheme for keyHandle is TPM_ALG_NULL
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: TPMU_SIG_SCHEME* inScheme;
    /// <summary>
    /// proof that digest was created by the TPM
    /// If keyHandle is not a restricted signing key, then this may be a NULL Ticket with tag = TPM_ST_CHECKHASH.
    /// </summary>
    public: TPMT_TK_HASHCHECK validation;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_Sign_REQUEST& operator=(const TPM2_Sign_REQUEST& rhs);
    public: TPM2_Sign_REQUEST(const TPM2_Sign_REQUEST& rhs);
    public:
    TPM2_Sign_REQUEST();
    virtual ~TPM2_Sign_REQUEST();
    /// <summary>
    /// This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
    /// </summary>
    ///<param name = "keyHandle">Handle of key that will perform signing Auth Index: 1 Auth Role: USER</param>
    ///<param name = "digest">digest to be signed</param>
    ///<param name = "inScheme">signing scheme to use if the scheme for keyHandle is TPM_ALG_NULL(One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)</param>
    ///<param name = "validation">proof that digest was created by the TPM If keyHandle is not a restricted signing key, then this may be a NULL Ticket with tag = TPM_ST_CHECKHASH.</param>
    public: TPM2_Sign_REQUEST(
        const TPM_HANDLE& keyHandle,
        const std::vector<BYTE>& digest,
        const TPMU_SIG_SCHEME& inScheme,
        const TPMT_TK_HASHCHECK& validation
    );
};
/// <summary>
/// This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
/// </summary>
class _DLLEXP_ SignResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// selector of the algorithm used to construct the signature
    /// </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    /// <summary>
    /// the signature
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: TPMU_SIGNATURE* signature;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: SignResponse& operator=(const SignResponse& rhs);
    public: SignResponse(const SignResponse& rhs);
    public:
    SignResponse();
    virtual ~SignResponse();
    /// <summary>
    /// This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
    /// </summary>
    ///<param name = "signature">the signature(One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)</param>
    public: SignResponse(
        const TPMU_SIGNATURE& signature
    );
};
/// <summary>
/// This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
/// </summary>
class _DLLEXP_ TPM2_SetCommandCodeAuditStatus_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE auth;
    /// <summary>
    /// hash algorithm for the audit digest; if TPM_ALG_NULL, then the hash is not changed
    /// </summary>
    public: TPM_ALG_ID auditAlg;
    /// <summary>
    /// number of commands in the commandCode list; may be 0
    /// </summary>
    protected: mutable UINT32 setListCount;
    /// <summary>
    /// list of commands that will be added to those that will be audited
    /// </summary>
    public: std::vector<TPM_CC> setList;
    /// <summary>
    /// number of commands in the commandCode list; may be 0
    /// </summary>
    protected: mutable UINT32 clearListCount;
    /// <summary>
    /// list of commands that will no longer be audited
    /// </summary>
    public: std::vector<TPM_CC> clearList;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_SetCommandCodeAuditStatus_REQUEST& operator=(const TPM2_SetCommandCodeAuditStatus_REQUEST& rhs);
    public: TPM2_SetCommandCodeAuditStatus_REQUEST(const TPM2_SetCommandCodeAuditStatus_REQUEST& rhs);
    public:
    TPM2_SetCommandCodeAuditStatus_REQUEST();
    virtual ~TPM2_SetCommandCodeAuditStatus_REQUEST();
    /// <summary>
    /// This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
    /// </summary>
    ///<param name = "auth">TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER</param>
    ///<param name = "auditAlg">hash algorithm for the audit digest; if TPM_ALG_NULL, then the hash is not changed</param>
    ///<param name = "setList">list of commands that will be added to those that will be audited</param>
    ///<param name = "clearList">list of commands that will no longer be audited</param>
    public: TPM2_SetCommandCodeAuditStatus_REQUEST(
        const TPM_HANDLE& auth,
        const TPM_ALG_ID& auditAlg,
        const std::vector<TPM_CC>& setList,
        const std::vector<TPM_CC>& clearList
    );
};
/// <summary>
/// This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
/// </summary>
class _DLLEXP_ SetCommandCodeAuditStatusResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: SetCommandCodeAuditStatusResponse& operator=(const SetCommandCodeAuditStatusResponse& rhs);
    public: SetCommandCodeAuditStatusResponse(const SetCommandCodeAuditStatusResponse& rhs);
    public:
    SetCommandCodeAuditStatusResponse();
    virtual ~SetCommandCodeAuditStatusResponse();
};
/// <summary>
/// This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
/// </summary>
class _DLLEXP_ TPM2_PCR_Extend_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of the PCR
    /// Auth Handle: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE pcrHandle;
    /// <summary>
    /// number of digests in the list
    /// </summary>
    protected: mutable UINT32 digestsCount;
    /// <summary>
    /// list of tagged digest values to be extended
    /// </summary>
    public: std::vector<TPMT_HA> digests;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PCR_Extend_REQUEST& operator=(const TPM2_PCR_Extend_REQUEST& rhs);
    public: TPM2_PCR_Extend_REQUEST(const TPM2_PCR_Extend_REQUEST& rhs);
    public:
    TPM2_PCR_Extend_REQUEST();
    virtual ~TPM2_PCR_Extend_REQUEST();
    /// <summary>
    /// This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
    /// </summary>
    ///<param name = "pcrHandle">handle of the PCR Auth Handle: 1 Auth Role: USER</param>
    ///<param name = "digests">list of tagged digest values to be extended</param>
    public: TPM2_PCR_Extend_REQUEST(
        const TPM_HANDLE& pcrHandle,
        const std::vector<TPMT_HA>& digests
    );
};
/// <summary>
/// This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
/// </summary>
class _DLLEXP_ PCR_ExtendResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PCR_ExtendResponse& operator=(const PCR_ExtendResponse& rhs);
    public: PCR_ExtendResponse(const PCR_ExtendResponse& rhs);
    public:
    PCR_ExtendResponse();
    virtual ~PCR_ExtendResponse();
};
/// <summary>
/// This command is used to cause an update to the indicated PCR.
/// </summary>
class _DLLEXP_ TPM2_PCR_Event_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// Handle of the PCR
    /// Auth Handle: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE pcrHandle;
    /// <summary>
    /// size of the operand buffer
    /// </summary>
    protected: mutable UINT16 eventDataSize;
    /// <summary>
    /// Event data in sized buffer
    /// </summary>
    public: std::vector<BYTE> eventData;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PCR_Event_REQUEST& operator=(const TPM2_PCR_Event_REQUEST& rhs);
    public: TPM2_PCR_Event_REQUEST(const TPM2_PCR_Event_REQUEST& rhs);
    public:
    TPM2_PCR_Event_REQUEST();
    virtual ~TPM2_PCR_Event_REQUEST();
    /// <summary>
    /// This command is used to cause an update to the indicated PCR.
    /// </summary>
    ///<param name = "pcrHandle">Handle of the PCR Auth Handle: 1 Auth Role: USER</param>
    ///<param name = "eventData">Event data in sized buffer</param>
    public: TPM2_PCR_Event_REQUEST(
        const TPM_HANDLE& pcrHandle,
        const std::vector<BYTE>& eventData
    );
};
/// <summary>
/// This command is used to cause an update to the indicated PCR.
/// </summary>
class _DLLEXP_ PCR_EventResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of digests in the list
    /// </summary>
    protected: mutable UINT32 digestsCount;
    public: std::vector<TPMT_HA> digests;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PCR_EventResponse& operator=(const PCR_EventResponse& rhs);
    public: PCR_EventResponse(const PCR_EventResponse& rhs);
    public:
    PCR_EventResponse();
    virtual ~PCR_EventResponse();
    /// <summary>
    /// This command is used to cause an update to the indicated PCR.
    /// </summary>
    ///<param name = "digests"></param>
    public: PCR_EventResponse(
        const std::vector<TPMT_HA>& digests
    );
};
/// <summary>
/// This command returns the values of all PCR specified in pcrSelectionIn.
/// </summary>
class _DLLEXP_ TPM2_PCR_Read_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 pcrSelectionInCount;
    /// <summary>
    /// The selection of PCR to read
    /// </summary>
    public: std::vector<TPMS_PCR_SELECTION> pcrSelectionIn;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PCR_Read_REQUEST& operator=(const TPM2_PCR_Read_REQUEST& rhs);
    public: TPM2_PCR_Read_REQUEST(const TPM2_PCR_Read_REQUEST& rhs);
    public:
    TPM2_PCR_Read_REQUEST();
    virtual ~TPM2_PCR_Read_REQUEST();
    /// <summary>
    /// This command returns the values of all PCR specified in pcrSelectionIn.
    /// </summary>
    ///<param name = "pcrSelectionIn">The selection of PCR to read</param>
    public: TPM2_PCR_Read_REQUEST(
        const std::vector<TPMS_PCR_SELECTION>& pcrSelectionIn
    );
};
/// <summary>
/// This command returns the values of all PCR specified in pcrSelectionIn.
/// </summary>
class _DLLEXP_ PCR_ReadResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the current value of the PCR update counter
    /// </summary>
    public: UINT32 pcrUpdateCounter;
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 pcrSelectionOutCount;
    /// <summary>
    /// the PCR in the returned list
    /// </summary>
    public: std::vector<TPMS_PCR_SELECTION> pcrSelectionOut;
    /// <summary>
    /// number of digests in the list, minimum is two for TPM2_PolicyOR().
    /// </summary>
    protected: mutable UINT32 pcrValuesCount;
    /// <summary>
    /// the contents of the PCR indicated in pcrSelectOut-> pcrSelection[] as tagged digests
    /// </summary>
    public: std::vector<TPM2B_DIGEST> pcrValues;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PCR_ReadResponse& operator=(const PCR_ReadResponse& rhs);
    public: PCR_ReadResponse(const PCR_ReadResponse& rhs);
    public:
    PCR_ReadResponse();
    virtual ~PCR_ReadResponse();
    /// <summary>
    /// This command returns the values of all PCR specified in pcrSelectionIn.
    /// </summary>
    ///<param name = "pcrUpdateCounter">the current value of the PCR update counter</param>
    ///<param name = "pcrSelectionOut">the PCR in the returned list</param>
    ///<param name = "pcrValues">the contents of the PCR indicated in pcrSelectOut-> pcrSelection[] as tagged digests</param>
    public: PCR_ReadResponse(
        const UINT32& pcrUpdateCounter,
        const std::vector<TPMS_PCR_SELECTION>& pcrSelectionOut,
        const std::vector<TPM2B_DIGEST>& pcrValues
    );
};
/// <summary>
/// This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
/// </summary>
class _DLLEXP_ TPM2_PCR_Allocate_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 pcrAllocationCount;
    /// <summary>
    /// the requested allocation
    /// </summary>
    public: std::vector<TPMS_PCR_SELECTION> pcrAllocation;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PCR_Allocate_REQUEST& operator=(const TPM2_PCR_Allocate_REQUEST& rhs);
    public: TPM2_PCR_Allocate_REQUEST(const TPM2_PCR_Allocate_REQUEST& rhs);
    public:
    TPM2_PCR_Allocate_REQUEST();
    virtual ~TPM2_PCR_Allocate_REQUEST();
    /// <summary>
    /// This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
    /// </summary>
    ///<param name = "authHandle">TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER</param>
    ///<param name = "pcrAllocation">the requested allocation</param>
    public: TPM2_PCR_Allocate_REQUEST(
        const TPM_HANDLE& authHandle,
        const std::vector<TPMS_PCR_SELECTION>& pcrAllocation
    );
};
/// <summary>
/// This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
/// </summary>
class _DLLEXP_ PCR_AllocateResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// YES if the allocation succeeded
    /// </summary>
    public: BYTE allocationSuccess;
    /// <summary>
    /// maximum number of PCR that may be in a bank
    /// </summary>
    public: UINT32 maxPCR;
    /// <summary>
    /// number of octets required to satisfy the request
    /// </summary>
    public: UINT32 sizeNeeded;
    /// <summary>
    /// Number of octets available. Computed before the allocation.
    /// </summary>
    public: UINT32 sizeAvailable;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PCR_AllocateResponse& operator=(const PCR_AllocateResponse& rhs);
    public: PCR_AllocateResponse(const PCR_AllocateResponse& rhs);
    public:
    PCR_AllocateResponse();
    virtual ~PCR_AllocateResponse();
    /// <summary>
    /// This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
    /// </summary>
    ///<param name = "allocationSuccess">YES if the allocation succeeded</param>
    ///<param name = "maxPCR">maximum number of PCR that may be in a bank</param>
    ///<param name = "sizeNeeded">number of octets required to satisfy the request</param>
    ///<param name = "sizeAvailable">Number of octets available. Computed before the allocation.</param>
    public: PCR_AllocateResponse(
        const BYTE& allocationSuccess,
        const UINT32& maxPCR,
        const UINT32& sizeNeeded,
        const UINT32& sizeAvailable
    );
};
/// <summary>
/// This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
/// </summary>
class _DLLEXP_ TPM2_PCR_SetAuthPolicy_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 authPolicySize;
    /// <summary>
    /// the desired authPolicy
    /// </summary>
    public: std::vector<BYTE> authPolicy;
    /// <summary>
    /// the hash algorithm of the policy
    /// </summary>
    public: TPM_ALG_ID hashAlg;
    /// <summary>
    /// the PCR for which the policy is to be set
    /// </summary>
    public: TPM_HANDLE pcrNum;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PCR_SetAuthPolicy_REQUEST& operator=(const TPM2_PCR_SetAuthPolicy_REQUEST& rhs);
    public: TPM2_PCR_SetAuthPolicy_REQUEST(const TPM2_PCR_SetAuthPolicy_REQUEST& rhs);
    public:
    TPM2_PCR_SetAuthPolicy_REQUEST();
    virtual ~TPM2_PCR_SetAuthPolicy_REQUEST();
    /// <summary>
    /// This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
    /// </summary>
    ///<param name = "authHandle">TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER</param>
    ///<param name = "authPolicy">the desired authPolicy</param>
    ///<param name = "hashAlg">the hash algorithm of the policy</param>
    ///<param name = "pcrNum">the PCR for which the policy is to be set</param>
    public: TPM2_PCR_SetAuthPolicy_REQUEST(
        const TPM_HANDLE& authHandle,
        const std::vector<BYTE>& authPolicy,
        const TPM_ALG_ID& hashAlg,
        const TPM_HANDLE& pcrNum
    );
};
/// <summary>
/// This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
/// </summary>
class _DLLEXP_ PCR_SetAuthPolicyResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PCR_SetAuthPolicyResponse& operator=(const PCR_SetAuthPolicyResponse& rhs);
    public: PCR_SetAuthPolicyResponse(const PCR_SetAuthPolicyResponse& rhs);
    public:
    PCR_SetAuthPolicyResponse();
    virtual ~PCR_SetAuthPolicyResponse();
};
/// <summary>
/// This command changes the authValue of a PCR or group of PCR.
/// </summary>
class _DLLEXP_ TPM2_PCR_SetAuthValue_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for a PCR that may have an authorization value set
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE pcrHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 authSize;
    /// <summary>
    /// the desired authorization value
    /// </summary>
    public: std::vector<BYTE> auth;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PCR_SetAuthValue_REQUEST& operator=(const TPM2_PCR_SetAuthValue_REQUEST& rhs);
    public: TPM2_PCR_SetAuthValue_REQUEST(const TPM2_PCR_SetAuthValue_REQUEST& rhs);
    public:
    TPM2_PCR_SetAuthValue_REQUEST();
    virtual ~TPM2_PCR_SetAuthValue_REQUEST();
    /// <summary>
    /// This command changes the authValue of a PCR or group of PCR.
    /// </summary>
    ///<param name = "pcrHandle">handle for a PCR that may have an authorization value set Auth Index: 1 Auth Role: USER</param>
    ///<param name = "auth">the desired authorization value</param>
    public: TPM2_PCR_SetAuthValue_REQUEST(
        const TPM_HANDLE& pcrHandle,
        const std::vector<BYTE>& auth
    );
};
/// <summary>
/// This command changes the authValue of a PCR or group of PCR.
/// </summary>
class _DLLEXP_ PCR_SetAuthValueResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PCR_SetAuthValueResponse& operator=(const PCR_SetAuthValueResponse& rhs);
    public: PCR_SetAuthValueResponse(const PCR_SetAuthValueResponse& rhs);
    public:
    PCR_SetAuthValueResponse();
    virtual ~PCR_SetAuthValueResponse();
};
/// <summary>
/// If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
/// </summary>
class _DLLEXP_ TPM2_PCR_Reset_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the PCR to reset
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE pcrHandle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PCR_Reset_REQUEST& operator=(const TPM2_PCR_Reset_REQUEST& rhs);
    public: TPM2_PCR_Reset_REQUEST(const TPM2_PCR_Reset_REQUEST& rhs);
    public:
    TPM2_PCR_Reset_REQUEST();
    virtual ~TPM2_PCR_Reset_REQUEST();
    /// <summary>
    /// If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
    /// </summary>
    ///<param name = "pcrHandle">the PCR to reset Auth Index: 1 Auth Role: USER</param>
    public: TPM2_PCR_Reset_REQUEST(
        const TPM_HANDLE& pcrHandle
    );
};
/// <summary>
/// If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
/// </summary>
class _DLLEXP_ PCR_ResetResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PCR_ResetResponse& operator=(const PCR_ResetResponse& rhs);
    public: PCR_ResetResponse(const PCR_ResetResponse& rhs);
    public:
    PCR_ResetResponse();
    virtual ~PCR_ResetResponse();
};
/// <summary>
/// This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
/// </summary>
class _DLLEXP_ TPM2_PolicySigned_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for a key that will validate the signature
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE authObject;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 nonceTPMSize;
    /// <summary>
    /// the policy nonce for the session
    /// This can be the Empty Buffer.
    /// </summary>
    public: std::vector<BYTE> nonceTPM;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 cpHashASize;
    /// <summary>
    /// digest of the command parameters to which this authorization is limited
    /// This is not the cpHash for this command but the cpHash for the command to which this policy session will be applied. If it is not limited, the parameter will be the Empty Buffer.
    /// </summary>
    public: std::vector<BYTE> cpHashA;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 policyRefSize;
    /// <summary>
    /// a reference to a policy relating to the authorization  may be the Empty Buffer
    /// Size is limited to be no larger than the nonce size supported on the TPM.
    /// </summary>
    public: std::vector<BYTE> policyRef;
    /// <summary>
    /// time when authorization will expire, measured in seconds from the time that nonceTPM was generated
    /// If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
    /// </summary>
    public: INT32 expiration;
    /// <summary>
    /// selector of the algorithm used to construct the signature
    /// </summary>
    protected: mutable TPM_ALG_ID authSigAlg;
    /// <summary>
    /// signed authorization (not optional)
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: TPMU_SIGNATURE* auth;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicySigned_REQUEST& operator=(const TPM2_PolicySigned_REQUEST& rhs);
    public: TPM2_PolicySigned_REQUEST(const TPM2_PolicySigned_REQUEST& rhs);
    public:
    TPM2_PolicySigned_REQUEST();
    virtual ~TPM2_PolicySigned_REQUEST();
    /// <summary>
    /// This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
    /// </summary>
    ///<param name = "authObject">handle for a key that will validate the signature Auth Index: None</param>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    ///<param name = "nonceTPM">the policy nonce for the session This can be the Empty Buffer.</param>
    ///<param name = "cpHashA">digest of the command parameters to which this authorization is limited This is not the cpHash for this command but the cpHash for the command to which this policy session will be applied. If it is not limited, the parameter will be the Empty Buffer.</param>
    ///<param name = "policyRef">a reference to a policy relating to the authorization  may be the Empty Buffer Size is limited to be no larger than the nonce size supported on the TPM.</param>
    ///<param name = "expiration">time when authorization will expire, measured in seconds from the time that nonceTPM was generated If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.</param>
    ///<param name = "auth">signed authorization (not optional)(One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)</param>
    public: TPM2_PolicySigned_REQUEST(
        const TPM_HANDLE& authObject,
        const TPM_HANDLE& policySession,
        const std::vector<BYTE>& nonceTPM,
        const std::vector<BYTE>& cpHashA,
        const std::vector<BYTE>& policyRef,
        const INT32& expiration,
        const TPMU_SIGNATURE& auth
    );
};
/// <summary>
/// This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
/// </summary>
class _DLLEXP_ PolicySignedResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the timeout value
    /// </summary>
    protected: mutable UINT16 timeoutSize;
    /// <summary>
    /// implementation-specific time value, used to indicate to the TPM when the ticket expires
    /// NOTE	If policyTicket is a NULL Ticket, then this shall be the Empty Buffer.
    /// </summary>
    public: std::vector<BYTE> timeout;
    /// <summary>
    /// produced if the command succeeds and expiration in the command was non-zero; this ticket will use the TPMT_ST_AUTH_SIGNED structure tag. See 23.2.5
    /// </summary>
    public: TPMT_TK_AUTH policyTicket;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicySignedResponse& operator=(const PolicySignedResponse& rhs);
    public: PolicySignedResponse(const PolicySignedResponse& rhs);
    public:
    PolicySignedResponse();
    virtual ~PolicySignedResponse();
    /// <summary>
    /// This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
    /// </summary>
    ///<param name = "timeout">implementation-specific time value, used to indicate to the TPM when the ticket expires NOTE	If policyTicket is a NULL Ticket, then this shall be the Empty Buffer.</param>
    ///<param name = "policyTicket">produced if the command succeeds and expiration in the command was non-zero; this ticket will use the TPMT_ST_AUTH_SIGNED structure tag. See 23.2.5</param>
    public: PolicySignedResponse(
        const std::vector<BYTE>& timeout,
        const TPMT_TK_AUTH& policyTicket
    );
};
/// <summary>
/// This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
/// </summary>
class _DLLEXP_ TPM2_PolicySecret_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for an entity providing the authorization
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 nonceTPMSize;
    /// <summary>
    /// the policy nonce for the session
    /// This can be the Empty Buffer.
    /// </summary>
    public: std::vector<BYTE> nonceTPM;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 cpHashASize;
    /// <summary>
    /// digest of the command parameters to which this authorization is limited
    /// This not the cpHash for this command but the cpHash for the command to which this policy session will be applied. If it is not limited, the parameter will be the Empty Buffer.
    /// </summary>
    public: std::vector<BYTE> cpHashA;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 policyRefSize;
    /// <summary>
    /// a reference to a policy relating to the authorization  may be the Empty Buffer
    /// Size is limited to be no larger than the nonce size supported on the TPM.
    /// </summary>
    public: std::vector<BYTE> policyRef;
    /// <summary>
    /// time when authorization will expire, measured in seconds from the time that nonceTPM was generated
    /// If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
    /// </summary>
    public: INT32 expiration;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicySecret_REQUEST& operator=(const TPM2_PolicySecret_REQUEST& rhs);
    public: TPM2_PolicySecret_REQUEST(const TPM2_PolicySecret_REQUEST& rhs);
    public:
    TPM2_PolicySecret_REQUEST();
    virtual ~TPM2_PolicySecret_REQUEST();
    /// <summary>
    /// This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
    /// </summary>
    ///<param name = "authHandle">handle for an entity providing the authorization Auth Index: 1 Auth Role: USER</param>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    ///<param name = "nonceTPM">the policy nonce for the session This can be the Empty Buffer.</param>
    ///<param name = "cpHashA">digest of the command parameters to which this authorization is limited This not the cpHash for this command but the cpHash for the command to which this policy session will be applied. If it is not limited, the parameter will be the Empty Buffer.</param>
    ///<param name = "policyRef">a reference to a policy relating to the authorization  may be the Empty Buffer Size is limited to be no larger than the nonce size supported on the TPM.</param>
    ///<param name = "expiration">time when authorization will expire, measured in seconds from the time that nonceTPM was generated If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.</param>
    public: TPM2_PolicySecret_REQUEST(
        const TPM_HANDLE& authHandle,
        const TPM_HANDLE& policySession,
        const std::vector<BYTE>& nonceTPM,
        const std::vector<BYTE>& cpHashA,
        const std::vector<BYTE>& policyRef,
        const INT32& expiration
    );
};
/// <summary>
/// This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
/// </summary>
class _DLLEXP_ PolicySecretResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the timeout value
    /// </summary>
    protected: mutable UINT16 timeoutSize;
    /// <summary>
    /// implementation-specific time value used to indicate to the TPM when the ticket expires
    /// </summary>
    public: std::vector<BYTE> timeout;
    /// <summary>
    /// produced if the command succeeds and expiration in the command was non-zero ( See 23.2.5). This ticket will use the TPMT_ST_AUTH_SECRET structure tag
    /// </summary>
    public: TPMT_TK_AUTH policyTicket;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicySecretResponse& operator=(const PolicySecretResponse& rhs);
    public: PolicySecretResponse(const PolicySecretResponse& rhs);
    public:
    PolicySecretResponse();
    virtual ~PolicySecretResponse();
    /// <summary>
    /// This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
    /// </summary>
    ///<param name = "timeout">implementation-specific time value used to indicate to the TPM when the ticket expires</param>
    ///<param name = "policyTicket">produced if the command succeeds and expiration in the command was non-zero ( See 23.2.5). This ticket will use the TPMT_ST_AUTH_SECRET structure tag</param>
    public: PolicySecretResponse(
        const std::vector<BYTE>& timeout,
        const TPMT_TK_AUTH& policyTicket
    );
};
/// <summary>
/// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
/// </summary>
class _DLLEXP_ TPM2_PolicyTicket_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    /// <summary>
    /// size of the timeout value
    /// </summary>
    protected: mutable UINT16 timeoutSize;
    /// <summary>
    /// time when authorization will expire
    /// The contents are TPM specific. This shall be the value returned when ticket was produced.
    /// </summary>
    public: std::vector<BYTE> timeout;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 cpHashASize;
    /// <summary>
    /// digest of the command parameters to which this authorization is limited
    /// If it is not limited, the parameter will be the Empty Buffer.
    /// </summary>
    public: std::vector<BYTE> cpHashA;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 policyRefSize;
    /// <summary>
    /// reference to a qualifier for the policy  may be the Empty Buffer
    /// </summary>
    public: std::vector<BYTE> policyRef;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 authNameSize;
    /// <summary>
    /// name of the object that provided the authorization
    /// </summary>
    public: std::vector<BYTE> authName;
    /// <summary>
    /// an authorization ticket returned by the TPM in response to a TPM2_PolicySigned() or TPM2_PolicySecret()
    /// </summary>
    public: TPMT_TK_AUTH ticket;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyTicket_REQUEST& operator=(const TPM2_PolicyTicket_REQUEST& rhs);
    public: TPM2_PolicyTicket_REQUEST(const TPM2_PolicyTicket_REQUEST& rhs);
    public:
    TPM2_PolicyTicket_REQUEST();
    virtual ~TPM2_PolicyTicket_REQUEST();
    /// <summary>
    /// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
    /// </summary>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    ///<param name = "timeout">time when authorization will expire The contents are TPM specific. This shall be the value returned when ticket was produced.</param>
    ///<param name = "cpHashA">digest of the command parameters to which this authorization is limited If it is not limited, the parameter will be the Empty Buffer.</param>
    ///<param name = "policyRef">reference to a qualifier for the policy  may be the Empty Buffer</param>
    ///<param name = "authName">name of the object that provided the authorization</param>
    ///<param name = "ticket">an authorization ticket returned by the TPM in response to a TPM2_PolicySigned() or TPM2_PolicySecret()</param>
    public: TPM2_PolicyTicket_REQUEST(
        const TPM_HANDLE& policySession,
        const std::vector<BYTE>& timeout,
        const std::vector<BYTE>& cpHashA,
        const std::vector<BYTE>& policyRef,
        const std::vector<BYTE>& authName,
        const TPMT_TK_AUTH& ticket
    );
};
/// <summary>
/// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
/// </summary>
class _DLLEXP_ PolicyTicketResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyTicketResponse& operator=(const PolicyTicketResponse& rhs);
    public: PolicyTicketResponse(const PolicyTicketResponse& rhs);
    public:
    PolicyTicketResponse();
    virtual ~PolicyTicketResponse();
};
/// <summary>
/// This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
/// </summary>
class _DLLEXP_ TPM2_PolicyOR_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    /// <summary>
    /// number of digests in the list, minimum is two for TPM2_PolicyOR().
    /// </summary>
    protected: mutable UINT32 pHashListCount;
    /// <summary>
    /// the list of hashes to check for a match
    /// </summary>
    public: std::vector<TPM2B_DIGEST> pHashList;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyOR_REQUEST& operator=(const TPM2_PolicyOR_REQUEST& rhs);
    public: TPM2_PolicyOR_REQUEST(const TPM2_PolicyOR_REQUEST& rhs);
    public:
    TPM2_PolicyOR_REQUEST();
    virtual ~TPM2_PolicyOR_REQUEST();
    /// <summary>
    /// This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
    /// </summary>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    ///<param name = "pHashList">the list of hashes to check for a match</param>
    public: TPM2_PolicyOR_REQUEST(
        const TPM_HANDLE& policySession,
        const std::vector<TPM2B_DIGEST>& pHashList
    );
};
/// <summary>
/// This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
/// </summary>
class _DLLEXP_ PolicyORResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyORResponse& operator=(const PolicyORResponse& rhs);
    public: PolicyORResponse(const PolicyORResponse& rhs);
    public:
    PolicyORResponse();
    virtual ~PolicyORResponse();
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
/// </summary>
class _DLLEXP_ TPM2_PolicyPCR_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 pcrDigestSize;
    /// <summary>
    /// expected digest value of the selected PCR using the hash algorithm of the session; may be zero length
    /// </summary>
    public: std::vector<BYTE> pcrDigest;
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 pcrsCount;
    /// <summary>
    /// the PCR to include in the check digest
    /// </summary>
    public: std::vector<TPMS_PCR_SELECTION> pcrs;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyPCR_REQUEST& operator=(const TPM2_PolicyPCR_REQUEST& rhs);
    public: TPM2_PolicyPCR_REQUEST(const TPM2_PolicyPCR_REQUEST& rhs);
    public:
    TPM2_PolicyPCR_REQUEST();
    virtual ~TPM2_PolicyPCR_REQUEST();
    /// <summary>
    /// This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
    /// </summary>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    ///<param name = "pcrDigest">expected digest value of the selected PCR using the hash algorithm of the session; may be zero length</param>
    ///<param name = "pcrs">the PCR to include in the check digest</param>
    public: TPM2_PolicyPCR_REQUEST(
        const TPM_HANDLE& policySession,
        const std::vector<BYTE>& pcrDigest,
        const std::vector<TPMS_PCR_SELECTION>& pcrs
    );
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
/// </summary>
class _DLLEXP_ PolicyPCRResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyPCRResponse& operator=(const PolicyPCRResponse& rhs);
    public: PolicyPCRResponse(const PolicyPCRResponse& rhs);
    public:
    PolicyPCRResponse();
    virtual ~PolicyPCRResponse();
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific locality.
/// </summary>
class _DLLEXP_ TPM2_PolicyLocality_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    /// <summary>
    /// the allowed localities for the policy
    /// </summary>
    public: TPMA_LOCALITY locality;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyLocality_REQUEST& operator=(const TPM2_PolicyLocality_REQUEST& rhs);
    public: TPM2_PolicyLocality_REQUEST(const TPM2_PolicyLocality_REQUEST& rhs);
    public:
    TPM2_PolicyLocality_REQUEST();
    virtual ~TPM2_PolicyLocality_REQUEST();
    /// <summary>
    /// This command indicates that the authorization will be limited to a specific locality.
    /// </summary>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    ///<param name = "locality">the allowed localities for the policy</param>
    public: TPM2_PolicyLocality_REQUEST(
        const TPM_HANDLE& policySession,
        const TPMA_LOCALITY& locality
    );
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific locality.
/// </summary>
class _DLLEXP_ PolicyLocalityResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyLocalityResponse& operator=(const PolicyLocalityResponse& rhs);
    public: PolicyLocalityResponse(const PolicyLocalityResponse& rhs);
    public:
    PolicyLocalityResponse();
    virtual ~PolicyLocalityResponse();
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
/// </summary>
class _DLLEXP_ TPM2_PolicyNV_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// the NV Index of the area to read
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 operandBSize;
    /// <summary>
    /// the second operand
    /// </summary>
    public: std::vector<BYTE> operandB;
    /// <summary>
    /// the octet offset in the NV Index for the start of operand A
    /// </summary>
    public: UINT16 offset;
    /// <summary>
    /// the comparison to make
    /// </summary>
    public: TPM_EO operation;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyNV_REQUEST& operator=(const TPM2_PolicyNV_REQUEST& rhs);
    public: TPM2_PolicyNV_REQUEST(const TPM2_PolicyNV_REQUEST& rhs);
    public:
    TPM2_PolicyNV_REQUEST();
    virtual ~TPM2_PolicyNV_REQUEST();
    /// <summary>
    /// This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
    /// </summary>
    ///<param name = "authHandle">handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER</param>
    ///<param name = "nvIndex">the NV Index of the area to read Auth Index: None</param>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    ///<param name = "operandB">the second operand</param>
    ///<param name = "offset">the octet offset in the NV Index for the start of operand A</param>
    ///<param name = "operation">the comparison to make</param>
    public: TPM2_PolicyNV_REQUEST(
        const TPM_HANDLE& authHandle,
        const TPM_HANDLE& nvIndex,
        const TPM_HANDLE& policySession,
        const std::vector<BYTE>& operandB,
        const UINT16& offset,
        const TPM_EO& operation
    );
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
/// </summary>
class _DLLEXP_ PolicyNVResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyNVResponse& operator=(const PolicyNVResponse& rhs);
    public: PolicyNVResponse(const PolicyNVResponse& rhs);
    public:
    PolicyNVResponse();
    virtual ~PolicyNVResponse();
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
/// </summary>
class _DLLEXP_ TPM2_PolicyCounterTimer_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 operandBSize;
    /// <summary>
    /// the second operand
    /// </summary>
    public: std::vector<BYTE> operandB;
    /// <summary>
    /// the octet offset in the TPMS_TIME_INFO structure for the start of operand A
    /// </summary>
    public: UINT16 offset;
    /// <summary>
    /// the comparison to make
    /// </summary>
    public: TPM_EO operation;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyCounterTimer_REQUEST& operator=(const TPM2_PolicyCounterTimer_REQUEST& rhs);
    public: TPM2_PolicyCounterTimer_REQUEST(const TPM2_PolicyCounterTimer_REQUEST& rhs);
    public:
    TPM2_PolicyCounterTimer_REQUEST();
    virtual ~TPM2_PolicyCounterTimer_REQUEST();
    /// <summary>
    /// This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
    /// </summary>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    ///<param name = "operandB">the second operand</param>
    ///<param name = "offset">the octet offset in the TPMS_TIME_INFO structure for the start of operand A</param>
    ///<param name = "operation">the comparison to make</param>
    public: TPM2_PolicyCounterTimer_REQUEST(
        const TPM_HANDLE& policySession,
        const std::vector<BYTE>& operandB,
        const UINT16& offset,
        const TPM_EO& operation
    );
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
/// </summary>
class _DLLEXP_ PolicyCounterTimerResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyCounterTimerResponse& operator=(const PolicyCounterTimerResponse& rhs);
    public: PolicyCounterTimerResponse(const PolicyCounterTimerResponse& rhs);
    public:
    PolicyCounterTimerResponse();
    virtual ~PolicyCounterTimerResponse();
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific command code.
/// </summary>
class _DLLEXP_ TPM2_PolicyCommandCode_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    /// <summary>
    /// the allowed commandCode
    /// </summary>
    public: TPM_CC code;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyCommandCode_REQUEST& operator=(const TPM2_PolicyCommandCode_REQUEST& rhs);
    public: TPM2_PolicyCommandCode_REQUEST(const TPM2_PolicyCommandCode_REQUEST& rhs);
    public:
    TPM2_PolicyCommandCode_REQUEST();
    virtual ~TPM2_PolicyCommandCode_REQUEST();
    /// <summary>
    /// This command indicates that the authorization will be limited to a specific command code.
    /// </summary>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    ///<param name = "code">the allowed commandCode</param>
    public: TPM2_PolicyCommandCode_REQUEST(
        const TPM_HANDLE& policySession,
        const TPM_CC& code
    );
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific command code.
/// </summary>
class _DLLEXP_ PolicyCommandCodeResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyCommandCodeResponse& operator=(const PolicyCommandCodeResponse& rhs);
    public: PolicyCommandCodeResponse(const PolicyCommandCodeResponse& rhs);
    public:
    PolicyCommandCodeResponse();
    virtual ~PolicyCommandCodeResponse();
};
/// <summary>
/// This command indicates that physical presence will need to be asserted at the time the authorization is performed.
/// </summary>
class _DLLEXP_ TPM2_PolicyPhysicalPresence_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyPhysicalPresence_REQUEST& operator=(const TPM2_PolicyPhysicalPresence_REQUEST& rhs);
    public: TPM2_PolicyPhysicalPresence_REQUEST(const TPM2_PolicyPhysicalPresence_REQUEST& rhs);
    public:
    TPM2_PolicyPhysicalPresence_REQUEST();
    virtual ~TPM2_PolicyPhysicalPresence_REQUEST();
    /// <summary>
    /// This command indicates that physical presence will need to be asserted at the time the authorization is performed.
    /// </summary>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    public: TPM2_PolicyPhysicalPresence_REQUEST(
        const TPM_HANDLE& policySession
    );
};
/// <summary>
/// This command indicates that physical presence will need to be asserted at the time the authorization is performed.
/// </summary>
class _DLLEXP_ PolicyPhysicalPresenceResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyPhysicalPresenceResponse& operator=(const PolicyPhysicalPresenceResponse& rhs);
    public: PolicyPhysicalPresenceResponse(const PolicyPhysicalPresenceResponse& rhs);
    public:
    PolicyPhysicalPresenceResponse();
    virtual ~PolicyPhysicalPresenceResponse();
};
/// <summary>
/// This command is used to allow a policy to be bound to a specific command and command parameters.
/// </summary>
class _DLLEXP_ TPM2_PolicyCpHash_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 cpHashASize;
    /// <summary>
    /// the cpHash added to the policy
    /// </summary>
    public: std::vector<BYTE> cpHashA;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyCpHash_REQUEST& operator=(const TPM2_PolicyCpHash_REQUEST& rhs);
    public: TPM2_PolicyCpHash_REQUEST(const TPM2_PolicyCpHash_REQUEST& rhs);
    public:
    TPM2_PolicyCpHash_REQUEST();
    virtual ~TPM2_PolicyCpHash_REQUEST();
    /// <summary>
    /// This command is used to allow a policy to be bound to a specific command and command parameters.
    /// </summary>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    ///<param name = "cpHashA">the cpHash added to the policy</param>
    public: TPM2_PolicyCpHash_REQUEST(
        const TPM_HANDLE& policySession,
        const std::vector<BYTE>& cpHashA
    );
};
/// <summary>
/// This command is used to allow a policy to be bound to a specific command and command parameters.
/// </summary>
class _DLLEXP_ PolicyCpHashResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyCpHashResponse& operator=(const PolicyCpHashResponse& rhs);
    public: PolicyCpHashResponse(const PolicyCpHashResponse& rhs);
    public:
    PolicyCpHashResponse();
    virtual ~PolicyCpHashResponse();
};
/// <summary>
/// This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
/// </summary>
class _DLLEXP_ TPM2_PolicyNameHash_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 nameHashSize;
    /// <summary>
    /// the digest to be added to the policy
    /// </summary>
    public: std::vector<BYTE> nameHash;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyNameHash_REQUEST& operator=(const TPM2_PolicyNameHash_REQUEST& rhs);
    public: TPM2_PolicyNameHash_REQUEST(const TPM2_PolicyNameHash_REQUEST& rhs);
    public:
    TPM2_PolicyNameHash_REQUEST();
    virtual ~TPM2_PolicyNameHash_REQUEST();
    /// <summary>
    /// This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
    /// </summary>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    ///<param name = "nameHash">the digest to be added to the policy</param>
    public: TPM2_PolicyNameHash_REQUEST(
        const TPM_HANDLE& policySession,
        const std::vector<BYTE>& nameHash
    );
};
/// <summary>
/// This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
/// </summary>
class _DLLEXP_ PolicyNameHashResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyNameHashResponse& operator=(const PolicyNameHashResponse& rhs);
    public: PolicyNameHashResponse(const PolicyNameHashResponse& rhs);
    public:
    PolicyNameHashResponse();
    virtual ~PolicyNameHashResponse();
};
/// <summary>
/// This command allows qualification of duplication to allow duplication to a selected new parent.
/// </summary>
class _DLLEXP_ TPM2_PolicyDuplicationSelect_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 objectNameSize;
    /// <summary>
    /// the Name of the object to be duplicated
    /// </summary>
    public: std::vector<BYTE> objectName;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 newParentNameSize;
    /// <summary>
    /// the Name of the new parent
    /// </summary>
    public: std::vector<BYTE> newParentName;
    /// <summary>
    /// if YES, the objectName will be included in the value in policySessionpolicyDigest
    /// </summary>
    public: BYTE includeObject;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyDuplicationSelect_REQUEST& operator=(const TPM2_PolicyDuplicationSelect_REQUEST& rhs);
    public: TPM2_PolicyDuplicationSelect_REQUEST(const TPM2_PolicyDuplicationSelect_REQUEST& rhs);
    public:
    TPM2_PolicyDuplicationSelect_REQUEST();
    virtual ~TPM2_PolicyDuplicationSelect_REQUEST();
    /// <summary>
    /// This command allows qualification of duplication to allow duplication to a selected new parent.
    /// </summary>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    ///<param name = "objectName">the Name of the object to be duplicated</param>
    ///<param name = "newParentName">the Name of the new parent</param>
    ///<param name = "includeObject">if YES, the objectName will be included in the value in policySessionpolicyDigest</param>
    public: TPM2_PolicyDuplicationSelect_REQUEST(
        const TPM_HANDLE& policySession,
        const std::vector<BYTE>& objectName,
        const std::vector<BYTE>& newParentName,
        const BYTE& includeObject
    );
};
/// <summary>
/// This command allows qualification of duplication to allow duplication to a selected new parent.
/// </summary>
class _DLLEXP_ PolicyDuplicationSelectResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyDuplicationSelectResponse& operator=(const PolicyDuplicationSelectResponse& rhs);
    public: PolicyDuplicationSelectResponse(const PolicyDuplicationSelectResponse& rhs);
    public:
    PolicyDuplicationSelectResponse();
    virtual ~PolicyDuplicationSelectResponse();
};
/// <summary>
/// This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
/// </summary>
class _DLLEXP_ TPM2_PolicyAuthorize_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 approvedPolicySize;
    /// <summary>
    /// digest of the policy being approved
    /// </summary>
    public: std::vector<BYTE> approvedPolicy;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 policyRefSize;
    /// <summary>
    /// a policy qualifier
    /// </summary>
    public: std::vector<BYTE> policyRef;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 keySignSize;
    /// <summary>
    /// Name of a key that can sign a policy addition
    /// </summary>
    public: std::vector<BYTE> keySign;
    /// <summary>
    /// ticket validating that approvedPolicy and policyRef were signed by keySign
    /// </summary>
    public: TPMT_TK_VERIFIED checkTicket;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyAuthorize_REQUEST& operator=(const TPM2_PolicyAuthorize_REQUEST& rhs);
    public: TPM2_PolicyAuthorize_REQUEST(const TPM2_PolicyAuthorize_REQUEST& rhs);
    public:
    TPM2_PolicyAuthorize_REQUEST();
    virtual ~TPM2_PolicyAuthorize_REQUEST();
    /// <summary>
    /// This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
    /// </summary>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    ///<param name = "approvedPolicy">digest of the policy being approved</param>
    ///<param name = "policyRef">a policy qualifier</param>
    ///<param name = "keySign">Name of a key that can sign a policy addition</param>
    ///<param name = "checkTicket">ticket validating that approvedPolicy and policyRef were signed by keySign</param>
    public: TPM2_PolicyAuthorize_REQUEST(
        const TPM_HANDLE& policySession,
        const std::vector<BYTE>& approvedPolicy,
        const std::vector<BYTE>& policyRef,
        const std::vector<BYTE>& keySign,
        const TPMT_TK_VERIFIED& checkTicket
    );
};
/// <summary>
/// This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
/// </summary>
class _DLLEXP_ PolicyAuthorizeResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyAuthorizeResponse& operator=(const PolicyAuthorizeResponse& rhs);
    public: PolicyAuthorizeResponse(const PolicyAuthorizeResponse& rhs);
    public:
    PolicyAuthorizeResponse();
    virtual ~PolicyAuthorizeResponse();
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized entity.
/// </summary>
class _DLLEXP_ TPM2_PolicyAuthValue_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyAuthValue_REQUEST& operator=(const TPM2_PolicyAuthValue_REQUEST& rhs);
    public: TPM2_PolicyAuthValue_REQUEST(const TPM2_PolicyAuthValue_REQUEST& rhs);
    public:
    TPM2_PolicyAuthValue_REQUEST();
    virtual ~TPM2_PolicyAuthValue_REQUEST();
    /// <summary>
    /// This command allows a policy to be bound to the authorization value of the authorized entity.
    /// </summary>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    public: TPM2_PolicyAuthValue_REQUEST(
        const TPM_HANDLE& policySession
    );
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized entity.
/// </summary>
class _DLLEXP_ PolicyAuthValueResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyAuthValueResponse& operator=(const PolicyAuthValueResponse& rhs);
    public: PolicyAuthValueResponse(const PolicyAuthValueResponse& rhs);
    public:
    PolicyAuthValueResponse();
    virtual ~PolicyAuthValueResponse();
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized object.
/// </summary>
class _DLLEXP_ TPM2_PolicyPassword_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyPassword_REQUEST& operator=(const TPM2_PolicyPassword_REQUEST& rhs);
    public: TPM2_PolicyPassword_REQUEST(const TPM2_PolicyPassword_REQUEST& rhs);
    public:
    TPM2_PolicyPassword_REQUEST();
    virtual ~TPM2_PolicyPassword_REQUEST();
    /// <summary>
    /// This command allows a policy to be bound to the authorization value of the authorized object.
    /// </summary>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    public: TPM2_PolicyPassword_REQUEST(
        const TPM_HANDLE& policySession
    );
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized object.
/// </summary>
class _DLLEXP_ PolicyPasswordResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyPasswordResponse& operator=(const PolicyPasswordResponse& rhs);
    public: PolicyPasswordResponse(const PolicyPasswordResponse& rhs);
    public:
    PolicyPasswordResponse();
    virtual ~PolicyPasswordResponse();
};
/// <summary>
/// This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
/// </summary>
class _DLLEXP_ TPM2_PolicyGetDigest_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the policy session
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyGetDigest_REQUEST& operator=(const TPM2_PolicyGetDigest_REQUEST& rhs);
    public: TPM2_PolicyGetDigest_REQUEST(const TPM2_PolicyGetDigest_REQUEST& rhs);
    public:
    TPM2_PolicyGetDigest_REQUEST();
    virtual ~TPM2_PolicyGetDigest_REQUEST();
    /// <summary>
    /// This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
    /// </summary>
    ///<param name = "policySession">handle for the policy session Auth Index: None</param>
    public: TPM2_PolicyGetDigest_REQUEST(
        const TPM_HANDLE& policySession
    );
};
/// <summary>
/// This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
/// </summary>
class _DLLEXP_ PolicyGetDigestResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 policyDigestSize;
    /// <summary>
    /// the current value of the policySessionpolicyDigest
    /// </summary>
    public: std::vector<BYTE> policyDigest;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyGetDigestResponse& operator=(const PolicyGetDigestResponse& rhs);
    public: PolicyGetDigestResponse(const PolicyGetDigestResponse& rhs);
    public:
    PolicyGetDigestResponse();
    virtual ~PolicyGetDigestResponse();
    /// <summary>
    /// This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
    /// </summary>
    ///<param name = "policyDigest">the current value of the policySessionpolicyDigest</param>
    public: PolicyGetDigestResponse(
        const std::vector<BYTE>& policyDigest
    );
};
/// <summary>
/// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
/// </summary>
class _DLLEXP_ TPM2_PolicyNvWritten_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    /// <summary>
    /// YES if NV Index is required to have been written
    /// NO if NV Index is required not to have been written
    /// </summary>
    public: BYTE writtenSet;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyNvWritten_REQUEST& operator=(const TPM2_PolicyNvWritten_REQUEST& rhs);
    public: TPM2_PolicyNvWritten_REQUEST(const TPM2_PolicyNvWritten_REQUEST& rhs);
    public:
    TPM2_PolicyNvWritten_REQUEST();
    virtual ~TPM2_PolicyNvWritten_REQUEST();
    /// <summary>
    /// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
    /// </summary>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    ///<param name = "writtenSet">YES if NV Index is required to have been written NO if NV Index is required not to have been written</param>
    public: TPM2_PolicyNvWritten_REQUEST(
        const TPM_HANDLE& policySession,
        const BYTE& writtenSet
    );
};
/// <summary>
/// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
/// </summary>
class _DLLEXP_ PolicyNvWrittenResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyNvWrittenResponse& operator=(const PolicyNvWrittenResponse& rhs);
    public: PolicyNvWrittenResponse(const PolicyNvWrittenResponse& rhs);
    public:
    PolicyNvWrittenResponse();
    virtual ~PolicyNvWrittenResponse();
};
/// <summary>
/// This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
/// </summary>
class _DLLEXP_ TPM2_PolicyTemplate_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 templateHashSize;
    /// <summary>
    /// the digest to be added to the policy
    /// </summary>
    public: std::vector<BYTE> templateHash;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyTemplate_REQUEST& operator=(const TPM2_PolicyTemplate_REQUEST& rhs);
    public: TPM2_PolicyTemplate_REQUEST(const TPM2_PolicyTemplate_REQUEST& rhs);
    public:
    TPM2_PolicyTemplate_REQUEST();
    virtual ~TPM2_PolicyTemplate_REQUEST();
    /// <summary>
    /// This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
    /// </summary>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    ///<param name = "templateHash">the digest to be added to the policy</param>
    public: TPM2_PolicyTemplate_REQUEST(
        const TPM_HANDLE& policySession,
        const std::vector<BYTE>& templateHash
    );
};
/// <summary>
/// This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
/// </summary>
class _DLLEXP_ PolicyTemplateResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyTemplateResponse& operator=(const PolicyTemplateResponse& rhs);
    public: PolicyTemplateResponse(const PolicyTemplateResponse& rhs);
    public:
    PolicyTemplateResponse();
    virtual ~PolicyTemplateResponse();
};
/// <summary>
/// This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
/// </summary>
class _DLLEXP_ TPM2_PolicyAuthorizeNV_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// the NV Index of the area to read
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PolicyAuthorizeNV_REQUEST& operator=(const TPM2_PolicyAuthorizeNV_REQUEST& rhs);
    public: TPM2_PolicyAuthorizeNV_REQUEST(const TPM2_PolicyAuthorizeNV_REQUEST& rhs);
    public:
    TPM2_PolicyAuthorizeNV_REQUEST();
    virtual ~TPM2_PolicyAuthorizeNV_REQUEST();
    /// <summary>
    /// This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
    /// </summary>
    ///<param name = "authHandle">handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER</param>
    ///<param name = "nvIndex">the NV Index of the area to read Auth Index: None</param>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    public: TPM2_PolicyAuthorizeNV_REQUEST(
        const TPM_HANDLE& authHandle,
        const TPM_HANDLE& nvIndex,
        const TPM_HANDLE& policySession
    );
};
/// <summary>
/// This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
/// </summary>
class _DLLEXP_ PolicyAuthorizeNVResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PolicyAuthorizeNVResponse& operator=(const PolicyAuthorizeNVResponse& rhs);
    public: PolicyAuthorizeNVResponse(const PolicyAuthorizeNVResponse& rhs);
    public:
    PolicyAuthorizeNVResponse();
    virtual ~PolicyAuthorizeNVResponse();
};
/// <summary>
/// This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
/// </summary>
class _DLLEXP_ TPM2_CreatePrimary_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE primaryHandle;
    /// <summary>
    /// size of sensitive in octets (may not be zero)
    /// NOTE	The userAuth and data parameters in this buffer may both be zero length but the minimum size of this parameter will be the sum of the size fields of the two parameters of the TPMS_SENSITIVE_CREATE.
    /// </summary>
    protected: mutable UINT16 inSensitiveSize;
    /// <summary>
    /// the sensitive data, see TPM 2.0 Part 1 Sensitive Values
    /// </summary>
    public: TPMS_SENSITIVE_CREATE inSensitive;
    /// <summary>
    /// size of publicArea
    /// NOTE	The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 inPublicSize;
    /// <summary>
    /// the public template
    /// </summary>
    public: TPMT_PUBLIC inPublic;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 outsideInfoSize;
    /// <summary>
    /// data that will be included in the creation data for this object to provide permanent, verifiable linkage between this object and some object owner data
    /// </summary>
    public: std::vector<BYTE> outsideInfo;
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 creationPCRCount;
    /// <summary>
    /// PCR that will be used in creation data
    /// </summary>
    public: std::vector<TPMS_PCR_SELECTION> creationPCR;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_CreatePrimary_REQUEST& operator=(const TPM2_CreatePrimary_REQUEST& rhs);
    public: TPM2_CreatePrimary_REQUEST(const TPM2_CreatePrimary_REQUEST& rhs);
    public:
    TPM2_CreatePrimary_REQUEST();
    virtual ~TPM2_CreatePrimary_REQUEST();
    /// <summary>
    /// This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
    /// </summary>
    ///<param name = "primaryHandle">TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL Auth Index: 1 Auth Role: USER</param>
    ///<param name = "inSensitive">the sensitive data, see TPM 2.0 Part 1 Sensitive Values</param>
    ///<param name = "inPublic">the public template</param>
    ///<param name = "outsideInfo">data that will be included in the creation data for this object to provide permanent, verifiable linkage between this object and some object owner data</param>
    ///<param name = "creationPCR">PCR that will be used in creation data</param>
    public: TPM2_CreatePrimary_REQUEST(
        const TPM_HANDLE& primaryHandle,
        const TPMS_SENSITIVE_CREATE& inSensitive,
        const TPMT_PUBLIC& inPublic,
        const std::vector<BYTE>& outsideInfo,
        const std::vector<TPMS_PCR_SELECTION>& creationPCR
    );
};
/// <summary>
/// This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
/// </summary>
class _DLLEXP_ CreatePrimaryResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of type TPM_HT_TRANSIENT for created Primary Object
    /// </summary>
    public: TPM_HANDLE handle;
    /// <summary>
    /// size of publicArea
    /// NOTE	The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 outPublicSize;
    /// <summary>
    /// the public portion of the created object
    /// </summary>
    public: TPMT_PUBLIC outPublic;
    /// <summary>
    /// size of the creation data
    /// </summary>
    protected: mutable UINT16 creationDataSize;
    /// <summary>
    /// contains a TPMT_CREATION_DATA
    /// </summary>
    public: TPMS_CREATION_DATA creationData;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 creationHashSize;
    /// <summary>
    /// digest of creationData using nameAlg of outPublic
    /// </summary>
    public: std::vector<BYTE> creationHash;
    /// <summary>
    /// ticket used by TPM2_CertifyCreation() to validate that the creation data was produced by the TPM
    /// </summary>
    public: TPMT_TK_CREATION creationTicket;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 nameSize;
    /// <summary>
    /// the name of the created object
    /// </summary>
    public: std::vector<BYTE> name;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: CreatePrimaryResponse& operator=(const CreatePrimaryResponse& rhs);
    public: CreatePrimaryResponse(const CreatePrimaryResponse& rhs);
    public:
    CreatePrimaryResponse();
    virtual ~CreatePrimaryResponse();
    /// <summary>
    /// This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
    /// </summary>
    ///<param name = "handle">handle of type TPM_HT_TRANSIENT for created Primary Object</param>
    ///<param name = "outPublic">the public portion of the created object</param>
    ///<param name = "creationData">contains a TPMT_CREATION_DATA</param>
    ///<param name = "creationHash">digest of creationData using nameAlg of outPublic</param>
    ///<param name = "creationTicket">ticket used by TPM2_CertifyCreation() to validate that the creation data was produced by the TPM</param>
    ///<param name = "name">the name of the created object</param>
    public: CreatePrimaryResponse(
        const TPM_HANDLE& handle,
        const TPMT_PUBLIC& outPublic,
        const TPMS_CREATION_DATA& creationData,
        const std::vector<BYTE>& creationHash,
        const TPMT_TK_CREATION& creationTicket,
        const std::vector<BYTE>& name
    );
};
/// <summary>
/// This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
/// </summary>
class _DLLEXP_ TPM2_HierarchyControl_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// the enable being modified
    /// TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM, or TPM_RH_PLATFORM_NV
    /// </summary>
    public: TPM_HANDLE enable;
    /// <summary>
    /// YES if the enable should be SET, NO if the enable should be CLEAR
    /// </summary>
    public: BYTE state;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_HierarchyControl_REQUEST& operator=(const TPM2_HierarchyControl_REQUEST& rhs);
    public: TPM2_HierarchyControl_REQUEST(const TPM2_HierarchyControl_REQUEST& rhs);
    public:
    TPM2_HierarchyControl_REQUEST();
    virtual ~TPM2_HierarchyControl_REQUEST();
    /// <summary>
    /// This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
    /// </summary>
    ///<param name = "authHandle">TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER</param>
    ///<param name = "enable">the enable being modified TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM, or TPM_RH_PLATFORM_NV</param>
    ///<param name = "state">YES if the enable should be SET, NO if the enable should be CLEAR</param>
    public: TPM2_HierarchyControl_REQUEST(
        const TPM_HANDLE& authHandle,
        const TPM_HANDLE& enable,
        const BYTE& state
    );
};
/// <summary>
/// This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
/// </summary>
class _DLLEXP_ HierarchyControlResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: HierarchyControlResponse& operator=(const HierarchyControlResponse& rhs);
    public: HierarchyControlResponse(const HierarchyControlResponse& rhs);
    public:
    HierarchyControlResponse();
    virtual ~HierarchyControlResponse();
};
/// <summary>
/// This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
/// </summary>
class _DLLEXP_ TPM2_SetPrimaryPolicy_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 authPolicySize;
    /// <summary>
    /// an authorization policy digest; may be the Empty Buffer
    /// If hashAlg is TPM_ALG_NULL, then this shall be an Empty Buffer.
    /// </summary>
    public: std::vector<BYTE> authPolicy;
    /// <summary>
    /// the hash algorithm to use for the policy
    /// If the authPolicy is an Empty Buffer, then this field shall be TPM_ALG_NULL.
    /// </summary>
    public: TPM_ALG_ID hashAlg;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_SetPrimaryPolicy_REQUEST& operator=(const TPM2_SetPrimaryPolicy_REQUEST& rhs);
    public: TPM2_SetPrimaryPolicy_REQUEST(const TPM2_SetPrimaryPolicy_REQUEST& rhs);
    public:
    TPM2_SetPrimaryPolicy_REQUEST();
    virtual ~TPM2_SetPrimaryPolicy_REQUEST();
    /// <summary>
    /// This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
    /// </summary>
    ///<param name = "authHandle">TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER</param>
    ///<param name = "authPolicy">an authorization policy digest; may be the Empty Buffer If hashAlg is TPM_ALG_NULL, then this shall be an Empty Buffer.</param>
    ///<param name = "hashAlg">the hash algorithm to use for the policy If the authPolicy is an Empty Buffer, then this field shall be TPM_ALG_NULL.</param>
    public: TPM2_SetPrimaryPolicy_REQUEST(
        const TPM_HANDLE& authHandle,
        const std::vector<BYTE>& authPolicy,
        const TPM_ALG_ID& hashAlg
    );
};
/// <summary>
/// This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
/// </summary>
class _DLLEXP_ SetPrimaryPolicyResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: SetPrimaryPolicyResponse& operator=(const SetPrimaryPolicyResponse& rhs);
    public: SetPrimaryPolicyResponse(const SetPrimaryPolicyResponse& rhs);
    public:
    SetPrimaryPolicyResponse();
    virtual ~SetPrimaryPolicyResponse();
};
/// <summary>
/// This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
/// </summary>
class _DLLEXP_ TPM2_ChangePPS_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_ChangePPS_REQUEST& operator=(const TPM2_ChangePPS_REQUEST& rhs);
    public: TPM2_ChangePPS_REQUEST(const TPM2_ChangePPS_REQUEST& rhs);
    public:
    TPM2_ChangePPS_REQUEST();
    virtual ~TPM2_ChangePPS_REQUEST();
    /// <summary>
    /// This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
    /// </summary>
    ///<param name = "authHandle">TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER</param>
    public: TPM2_ChangePPS_REQUEST(
        const TPM_HANDLE& authHandle
    );
};
/// <summary>
/// This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
/// </summary>
class _DLLEXP_ ChangePPSResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: ChangePPSResponse& operator=(const ChangePPSResponse& rhs);
    public: ChangePPSResponse(const ChangePPSResponse& rhs);
    public:
    ChangePPSResponse();
    virtual ~ChangePPSResponse();
};
/// <summary>
/// This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
/// </summary>
class _DLLEXP_ TPM2_ChangeEPS_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_ChangeEPS_REQUEST& operator=(const TPM2_ChangeEPS_REQUEST& rhs);
    public: TPM2_ChangeEPS_REQUEST(const TPM2_ChangeEPS_REQUEST& rhs);
    public:
    TPM2_ChangeEPS_REQUEST();
    virtual ~TPM2_ChangeEPS_REQUEST();
    /// <summary>
    /// This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
    /// </summary>
    ///<param name = "authHandle">TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER</param>
    public: TPM2_ChangeEPS_REQUEST(
        const TPM_HANDLE& authHandle
    );
};
/// <summary>
/// This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
/// </summary>
class _DLLEXP_ ChangeEPSResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: ChangeEPSResponse& operator=(const ChangeEPSResponse& rhs);
    public: ChangeEPSResponse(const ChangeEPSResponse& rhs);
    public:
    ChangeEPSResponse();
    virtual ~ChangeEPSResponse();
};
/// <summary>
/// This command removes all TPM context associated with a specific Owner.
/// </summary>
class _DLLEXP_ TPM2_Clear_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_Clear_REQUEST& operator=(const TPM2_Clear_REQUEST& rhs);
    public: TPM2_Clear_REQUEST(const TPM2_Clear_REQUEST& rhs);
    public:
    TPM2_Clear_REQUEST();
    virtual ~TPM2_Clear_REQUEST();
    /// <summary>
    /// This command removes all TPM context associated with a specific Owner.
    /// </summary>
    ///<param name = "authHandle">TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER</param>
    public: TPM2_Clear_REQUEST(
        const TPM_HANDLE& authHandle
    );
};
/// <summary>
/// This command removes all TPM context associated with a specific Owner.
/// </summary>
class _DLLEXP_ ClearResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: ClearResponse& operator=(const ClearResponse& rhs);
    public: ClearResponse(const ClearResponse& rhs);
    public:
    ClearResponse();
    virtual ~ClearResponse();
};
/// <summary>
/// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
/// </summary>
class _DLLEXP_ TPM2_ClearControl_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE auth;
    /// <summary>
    /// YES if the disableOwnerClear flag is to be SET, NO if the flag is to be CLEAR.
    /// </summary>
    public: BYTE disable;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_ClearControl_REQUEST& operator=(const TPM2_ClearControl_REQUEST& rhs);
    public: TPM2_ClearControl_REQUEST(const TPM2_ClearControl_REQUEST& rhs);
    public:
    TPM2_ClearControl_REQUEST();
    virtual ~TPM2_ClearControl_REQUEST();
    /// <summary>
    /// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
    /// </summary>
    ///<param name = "auth">TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER</param>
    ///<param name = "disable">YES if the disableOwnerClear flag is to be SET, NO if the flag is to be CLEAR.</param>
    public: TPM2_ClearControl_REQUEST(
        const TPM_HANDLE& auth,
        const BYTE& disable
    );
};
/// <summary>
/// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
/// </summary>
class _DLLEXP_ ClearControlResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: ClearControlResponse& operator=(const ClearControlResponse& rhs);
    public: ClearControlResponse(const ClearControlResponse& rhs);
    public:
    ClearControlResponse();
    virtual ~ClearControlResponse();
};
/// <summary>
/// This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
/// </summary>
class _DLLEXP_ TPM2_HierarchyChangeAuth_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 newAuthSize;
    /// <summary>
    /// new authorization value
    /// </summary>
    public: std::vector<BYTE> newAuth;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_HierarchyChangeAuth_REQUEST& operator=(const TPM2_HierarchyChangeAuth_REQUEST& rhs);
    public: TPM2_HierarchyChangeAuth_REQUEST(const TPM2_HierarchyChangeAuth_REQUEST& rhs);
    public:
    TPM2_HierarchyChangeAuth_REQUEST();
    virtual ~TPM2_HierarchyChangeAuth_REQUEST();
    /// <summary>
    /// This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
    /// </summary>
    ///<param name = "authHandle">TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER</param>
    ///<param name = "newAuth">new authorization value</param>
    public: TPM2_HierarchyChangeAuth_REQUEST(
        const TPM_HANDLE& authHandle,
        const std::vector<BYTE>& newAuth
    );
};
/// <summary>
/// This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
/// </summary>
class _DLLEXP_ HierarchyChangeAuthResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: HierarchyChangeAuthResponse& operator=(const HierarchyChangeAuthResponse& rhs);
    public: HierarchyChangeAuthResponse(const HierarchyChangeAuthResponse& rhs);
    public:
    HierarchyChangeAuthResponse();
    virtual ~HierarchyChangeAuthResponse();
};
/// <summary>
/// This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
/// </summary>
class _DLLEXP_ TPM2_DictionaryAttackLockReset_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_LOCKOUT
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE lockHandle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_DictionaryAttackLockReset_REQUEST& operator=(const TPM2_DictionaryAttackLockReset_REQUEST& rhs);
    public: TPM2_DictionaryAttackLockReset_REQUEST(const TPM2_DictionaryAttackLockReset_REQUEST& rhs);
    public:
    TPM2_DictionaryAttackLockReset_REQUEST();
    virtual ~TPM2_DictionaryAttackLockReset_REQUEST();
    /// <summary>
    /// This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
    /// </summary>
    ///<param name = "lockHandle">TPM_RH_LOCKOUT Auth Index: 1 Auth Role: USER</param>
    public: TPM2_DictionaryAttackLockReset_REQUEST(
        const TPM_HANDLE& lockHandle
    );
};
/// <summary>
/// This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
/// </summary>
class _DLLEXP_ DictionaryAttackLockResetResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: DictionaryAttackLockResetResponse& operator=(const DictionaryAttackLockResetResponse& rhs);
    public: DictionaryAttackLockResetResponse(const DictionaryAttackLockResetResponse& rhs);
    public:
    DictionaryAttackLockResetResponse();
    virtual ~DictionaryAttackLockResetResponse();
};
/// <summary>
/// This command changes the lockout parameters.
/// </summary>
class _DLLEXP_ TPM2_DictionaryAttackParameters_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_LOCKOUT
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE lockHandle;
    /// <summary>
    /// count of authorization failures before the lockout is imposed
    /// </summary>
    public: UINT32 newMaxTries;
    /// <summary>
    /// time in seconds before the authorization failure count is automatically decremented
    /// A value of zero indicates that DA protection is disabled.
    /// </summary>
    public: UINT32 newRecoveryTime;
    /// <summary>
    /// time in seconds after a lockoutAuth failure before use of lockoutAuth is allowed
    /// A value of zero indicates that a reboot is required.
    /// </summary>
    public: UINT32 lockoutRecovery;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_DictionaryAttackParameters_REQUEST& operator=(const TPM2_DictionaryAttackParameters_REQUEST& rhs);
    public: TPM2_DictionaryAttackParameters_REQUEST(const TPM2_DictionaryAttackParameters_REQUEST& rhs);
    public:
    TPM2_DictionaryAttackParameters_REQUEST();
    virtual ~TPM2_DictionaryAttackParameters_REQUEST();
    /// <summary>
    /// This command changes the lockout parameters.
    /// </summary>
    ///<param name = "lockHandle">TPM_RH_LOCKOUT Auth Index: 1 Auth Role: USER</param>
    ///<param name = "newMaxTries">count of authorization failures before the lockout is imposed</param>
    ///<param name = "newRecoveryTime">time in seconds before the authorization failure count is automatically decremented A value of zero indicates that DA protection is disabled.</param>
    ///<param name = "lockoutRecovery">time in seconds after a lockoutAuth failure before use of lockoutAuth is allowed A value of zero indicates that a reboot is required.</param>
    public: TPM2_DictionaryAttackParameters_REQUEST(
        const TPM_HANDLE& lockHandle,
        const UINT32& newMaxTries,
        const UINT32& newRecoveryTime,
        const UINT32& lockoutRecovery
    );
};
/// <summary>
/// This command changes the lockout parameters.
/// </summary>
class _DLLEXP_ DictionaryAttackParametersResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: DictionaryAttackParametersResponse& operator=(const DictionaryAttackParametersResponse& rhs);
    public: DictionaryAttackParametersResponse(const DictionaryAttackParametersResponse& rhs);
    public:
    DictionaryAttackParametersResponse();
    virtual ~DictionaryAttackParametersResponse();
};
/// <summary>
/// This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
/// </summary>
class _DLLEXP_ TPM2_PP_Commands_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_PLATFORM+PP
    /// Auth Index: 1
    /// Auth Role: USER + Physical Presence
    /// </summary>
    public: TPM_HANDLE auth;
    /// <summary>
    /// number of commands in the commandCode list; may be 0
    /// </summary>
    protected: mutable UINT32 setListCount;
    /// <summary>
    /// list of commands to be added to those that will require that Physical Presence be asserted
    /// </summary>
    public: std::vector<TPM_CC> setList;
    /// <summary>
    /// number of commands in the commandCode list; may be 0
    /// </summary>
    protected: mutable UINT32 clearListCount;
    /// <summary>
    /// list of commands that will no longer require that Physical Presence be asserted
    /// </summary>
    public: std::vector<TPM_CC> clearList;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_PP_Commands_REQUEST& operator=(const TPM2_PP_Commands_REQUEST& rhs);
    public: TPM2_PP_Commands_REQUEST(const TPM2_PP_Commands_REQUEST& rhs);
    public:
    TPM2_PP_Commands_REQUEST();
    virtual ~TPM2_PP_Commands_REQUEST();
    /// <summary>
    /// This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
    /// </summary>
    ///<param name = "auth">TPM_RH_PLATFORM+PP Auth Index: 1 Auth Role: USER + Physical Presence</param>
    ///<param name = "setList">list of commands to be added to those that will require that Physical Presence be asserted</param>
    ///<param name = "clearList">list of commands that will no longer require that Physical Presence be asserted</param>
    public: TPM2_PP_Commands_REQUEST(
        const TPM_HANDLE& auth,
        const std::vector<TPM_CC>& setList,
        const std::vector<TPM_CC>& clearList
    );
};
/// <summary>
/// This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
/// </summary>
class _DLLEXP_ PP_CommandsResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PP_CommandsResponse& operator=(const PP_CommandsResponse& rhs);
    public: PP_CommandsResponse(const PP_CommandsResponse& rhs);
    public:
    PP_CommandsResponse();
    virtual ~PP_CommandsResponse();
};
/// <summary>
/// This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
/// </summary>
class _DLLEXP_ TPM2_SetAlgorithmSet_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_PLATFORM
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// a TPM vendor-dependent value indicating the algorithm set selection
    /// </summary>
    public: UINT32 algorithmSet;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_SetAlgorithmSet_REQUEST& operator=(const TPM2_SetAlgorithmSet_REQUEST& rhs);
    public: TPM2_SetAlgorithmSet_REQUEST(const TPM2_SetAlgorithmSet_REQUEST& rhs);
    public:
    TPM2_SetAlgorithmSet_REQUEST();
    virtual ~TPM2_SetAlgorithmSet_REQUEST();
    /// <summary>
    /// This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
    /// </summary>
    ///<param name = "authHandle">TPM_RH_PLATFORM Auth Index: 1 Auth Role: USER</param>
    ///<param name = "algorithmSet">a TPM vendor-dependent value indicating the algorithm set selection</param>
    public: TPM2_SetAlgorithmSet_REQUEST(
        const TPM_HANDLE& authHandle,
        const UINT32& algorithmSet
    );
};
/// <summary>
/// This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
/// </summary>
class _DLLEXP_ SetAlgorithmSetResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: SetAlgorithmSetResponse& operator=(const SetAlgorithmSetResponse& rhs);
    public: SetAlgorithmSetResponse(const SetAlgorithmSetResponse& rhs);
    public:
    SetAlgorithmSetResponse();
    virtual ~SetAlgorithmSetResponse();
};
/// <summary>
/// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
/// </summary>
class _DLLEXP_ TPM2_FieldUpgradeStart_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index:1
    /// Auth Role: ADMIN
    /// </summary>
    public: TPM_HANDLE authorization;
    /// <summary>
    /// handle of a public area that contains the TPM Vendor Authorization Key that will be used to validate manifestSignature
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE keyHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 fuDigestSize;
    /// <summary>
    /// digest of the first block in the field upgrade sequence
    /// </summary>
    public: std::vector<BYTE> fuDigest;
    /// <summary>
    /// selector of the algorithm used to construct the signature
    /// </summary>
    protected: mutable TPM_ALG_ID manifestSignatureSigAlg;
    /// <summary>
    /// signature over fuDigest using the key associated with keyHandle (not optional)
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: TPMU_SIGNATURE* manifestSignature;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_FieldUpgradeStart_REQUEST& operator=(const TPM2_FieldUpgradeStart_REQUEST& rhs);
    public: TPM2_FieldUpgradeStart_REQUEST(const TPM2_FieldUpgradeStart_REQUEST& rhs);
    public:
    TPM2_FieldUpgradeStart_REQUEST();
    virtual ~TPM2_FieldUpgradeStart_REQUEST();
    /// <summary>
    /// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
    /// </summary>
    ///<param name = "authorization">TPM_RH_PLATFORM+{PP} Auth Index:1 Auth Role: ADMIN</param>
    ///<param name = "keyHandle">handle of a public area that contains the TPM Vendor Authorization Key that will be used to validate manifestSignature Auth Index: None</param>
    ///<param name = "fuDigest">digest of the first block in the field upgrade sequence</param>
    ///<param name = "manifestSignature">signature over fuDigest using the key associated with keyHandle (not optional)(One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)</param>
    public: TPM2_FieldUpgradeStart_REQUEST(
        const TPM_HANDLE& authorization,
        const TPM_HANDLE& keyHandle,
        const std::vector<BYTE>& fuDigest,
        const TPMU_SIGNATURE& manifestSignature
    );
};
/// <summary>
/// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
/// </summary>
class _DLLEXP_ FieldUpgradeStartResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: FieldUpgradeStartResponse& operator=(const FieldUpgradeStartResponse& rhs);
    public: FieldUpgradeStartResponse(const FieldUpgradeStartResponse& rhs);
    public:
    FieldUpgradeStartResponse();
    virtual ~FieldUpgradeStartResponse();
};
/// <summary>
/// This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
/// </summary>
class _DLLEXP_ TPM2_FieldUpgradeData_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 fuDataSize;
    /// <summary>
    /// field upgrade image data
    /// </summary>
    public: std::vector<BYTE> fuData;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_FieldUpgradeData_REQUEST& operator=(const TPM2_FieldUpgradeData_REQUEST& rhs);
    public: TPM2_FieldUpgradeData_REQUEST(const TPM2_FieldUpgradeData_REQUEST& rhs);
    public:
    TPM2_FieldUpgradeData_REQUEST();
    virtual ~TPM2_FieldUpgradeData_REQUEST();
    /// <summary>
    /// This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
    /// </summary>
    ///<param name = "fuData">field upgrade image data</param>
    public: TPM2_FieldUpgradeData_REQUEST(
        const std::vector<BYTE>& fuData
    );
};
/// <summary>
/// This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
/// </summary>
class _DLLEXP_ FieldUpgradeDataResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// tagged digest of the next block
    /// TPM_ALG_NULL if field update is complete
    /// </summary>
    public: TPMT_HA nextDigest;
    /// <summary>
    /// tagged digest of the first block of the sequence
    /// </summary>
    public: TPMT_HA firstDigest;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: FieldUpgradeDataResponse& operator=(const FieldUpgradeDataResponse& rhs);
    public: FieldUpgradeDataResponse(const FieldUpgradeDataResponse& rhs);
    public:
    FieldUpgradeDataResponse();
    virtual ~FieldUpgradeDataResponse();
    /// <summary>
    /// This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
    /// </summary>
    ///<param name = "nextDigest">tagged digest of the next block TPM_ALG_NULL if field update is complete</param>
    ///<param name = "firstDigest">tagged digest of the first block of the sequence</param>
    public: FieldUpgradeDataResponse(
        const TPMT_HA& nextDigest,
        const TPMT_HA& firstDigest
    );
};
/// <summary>
/// This command is used to read a copy of the current firmware installed in the TPM.
/// </summary>
class _DLLEXP_ TPM2_FirmwareRead_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the number of previous calls to this command in this sequence
    /// set to 0 on the first call
    /// </summary>
    public: UINT32 sequenceNumber;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_FirmwareRead_REQUEST& operator=(const TPM2_FirmwareRead_REQUEST& rhs);
    public: TPM2_FirmwareRead_REQUEST(const TPM2_FirmwareRead_REQUEST& rhs);
    public:
    TPM2_FirmwareRead_REQUEST();
    virtual ~TPM2_FirmwareRead_REQUEST();
    /// <summary>
    /// This command is used to read a copy of the current firmware installed in the TPM.
    /// </summary>
    ///<param name = "sequenceNumber">the number of previous calls to this command in this sequence set to 0 on the first call</param>
    public: TPM2_FirmwareRead_REQUEST(
        const UINT32& sequenceNumber
    );
};
/// <summary>
/// This command is used to read a copy of the current firmware installed in the TPM.
/// </summary>
class _DLLEXP_ FirmwareReadResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 fuDataSize;
    /// <summary>
    /// field upgrade image data
    /// </summary>
    public: std::vector<BYTE> fuData;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: FirmwareReadResponse& operator=(const FirmwareReadResponse& rhs);
    public: FirmwareReadResponse(const FirmwareReadResponse& rhs);
    public:
    FirmwareReadResponse();
    virtual ~FirmwareReadResponse();
    /// <summary>
    /// This command is used to read a copy of the current firmware installed in the TPM.
    /// </summary>
    ///<param name = "fuData">field upgrade image data</param>
    public: FirmwareReadResponse(
        const std::vector<BYTE>& fuData
    );
};
/// <summary>
/// This command saves a session context, object context, or sequence object context outside the TPM.
/// </summary>
class _DLLEXP_ TPM2_ContextSave_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of the resource to save
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE saveHandle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_ContextSave_REQUEST& operator=(const TPM2_ContextSave_REQUEST& rhs);
    public: TPM2_ContextSave_REQUEST(const TPM2_ContextSave_REQUEST& rhs);
    public:
    TPM2_ContextSave_REQUEST();
    virtual ~TPM2_ContextSave_REQUEST();
    /// <summary>
    /// This command saves a session context, object context, or sequence object context outside the TPM.
    /// </summary>
    ///<param name = "saveHandle">handle of the resource to save Auth Index: None</param>
    public: TPM2_ContextSave_REQUEST(
        const TPM_HANDLE& saveHandle
    );
};
/// <summary>
/// This command saves a session context, object context, or sequence object context outside the TPM.
/// </summary>
class _DLLEXP_ ContextSaveResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: TPMS_CONTEXT context;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: ContextSaveResponse& operator=(const ContextSaveResponse& rhs);
    public: ContextSaveResponse(const ContextSaveResponse& rhs);
    public:
    ContextSaveResponse();
    virtual ~ContextSaveResponse();
    /// <summary>
    /// This command saves a session context, object context, or sequence object context outside the TPM.
    /// </summary>
    ///<param name = "context"></param>
    public: ContextSaveResponse(
        const TPMS_CONTEXT& context
    );
};
/// <summary>
/// This command is used to reload a context that has been saved by TPM2_ContextSave().
/// </summary>
class _DLLEXP_ TPM2_ContextLoad_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the context blob
    /// </summary>
    public: TPMS_CONTEXT context;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_ContextLoad_REQUEST& operator=(const TPM2_ContextLoad_REQUEST& rhs);
    public: TPM2_ContextLoad_REQUEST(const TPM2_ContextLoad_REQUEST& rhs);
    public:
    TPM2_ContextLoad_REQUEST();
    virtual ~TPM2_ContextLoad_REQUEST();
    /// <summary>
    /// This command is used to reload a context that has been saved by TPM2_ContextSave().
    /// </summary>
    ///<param name = "context">the context blob</param>
    public: TPM2_ContextLoad_REQUEST(
        const TPMS_CONTEXT& context
    );
};
/// <summary>
/// This command is used to reload a context that has been saved by TPM2_ContextSave().
/// </summary>
class _DLLEXP_ ContextLoadResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the handle assigned to the resource after it has been successfully loaded
    /// </summary>
    public: TPM_HANDLE handle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: ContextLoadResponse& operator=(const ContextLoadResponse& rhs);
    public: ContextLoadResponse(const ContextLoadResponse& rhs);
    public:
    ContextLoadResponse();
    virtual ~ContextLoadResponse();
    /// <summary>
    /// This command is used to reload a context that has been saved by TPM2_ContextSave().
    /// </summary>
    ///<param name = "handle">the handle assigned to the resource after it has been successfully loaded</param>
    public: ContextLoadResponse(
        const TPM_HANDLE& handle
    );
};
/// <summary>
/// This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
/// </summary>
class _DLLEXP_ TPM2_FlushContext_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the handle of the item to flush
    /// NOTE	This is a use of a handle as a parameter.
    /// </summary>
    public: TPM_HANDLE flushHandle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_FlushContext_REQUEST& operator=(const TPM2_FlushContext_REQUEST& rhs);
    public: TPM2_FlushContext_REQUEST(const TPM2_FlushContext_REQUEST& rhs);
    public:
    TPM2_FlushContext_REQUEST();
    virtual ~TPM2_FlushContext_REQUEST();
    /// <summary>
    /// This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
    /// </summary>
    ///<param name = "flushHandle">the handle of the item to flush NOTE	This is a use of a handle as a parameter.</param>
    public: TPM2_FlushContext_REQUEST(
        const TPM_HANDLE& flushHandle
    );
};
/// <summary>
/// This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
/// </summary>
class _DLLEXP_ FlushContextResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: FlushContextResponse& operator=(const FlushContextResponse& rhs);
    public: FlushContextResponse(const FlushContextResponse& rhs);
    public:
    FlushContextResponse();
    virtual ~FlushContextResponse();
};
/// <summary>
/// This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
/// </summary>
class _DLLEXP_ TPM2_EvictControl_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE auth;
    /// <summary>
    /// the handle of a loaded object
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE objectHandle;
    /// <summary>
    /// if objectHandle is a transient object handle, then this is the persistent handle for the object
    /// if objectHandle is a persistent object handle, then it shall be the same value as persistentHandle
    /// </summary>
    public: TPM_HANDLE persistentHandle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_EvictControl_REQUEST& operator=(const TPM2_EvictControl_REQUEST& rhs);
    public: TPM2_EvictControl_REQUEST(const TPM2_EvictControl_REQUEST& rhs);
    public:
    TPM2_EvictControl_REQUEST();
    virtual ~TPM2_EvictControl_REQUEST();
    /// <summary>
    /// This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
    /// </summary>
    ///<param name = "auth">TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER</param>
    ///<param name = "objectHandle">the handle of a loaded object Auth Index: None</param>
    ///<param name = "persistentHandle">if objectHandle is a transient object handle, then this is the persistent handle for the object if objectHandle is a persistent object handle, then it shall be the same value as persistentHandle</param>
    public: TPM2_EvictControl_REQUEST(
        const TPM_HANDLE& auth,
        const TPM_HANDLE& objectHandle,
        const TPM_HANDLE& persistentHandle
    );
};
/// <summary>
/// This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
/// </summary>
class _DLLEXP_ EvictControlResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: EvictControlResponse& operator=(const EvictControlResponse& rhs);
    public: EvictControlResponse(const EvictControlResponse& rhs);
    public:
    EvictControlResponse();
    virtual ~EvictControlResponse();
};
/// <summary>
/// This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
/// </summary>
class _DLLEXP_ TPM2_ReadClock_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_ReadClock_REQUEST& operator=(const TPM2_ReadClock_REQUEST& rhs);
    public: TPM2_ReadClock_REQUEST(const TPM2_ReadClock_REQUEST& rhs);
    public:
    TPM2_ReadClock_REQUEST();
    virtual ~TPM2_ReadClock_REQUEST();
};
/// <summary>
/// This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
/// </summary>
class _DLLEXP_ ReadClockResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: TPMS_TIME_INFO currentTime;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: ReadClockResponse& operator=(const ReadClockResponse& rhs);
    public: ReadClockResponse(const ReadClockResponse& rhs);
    public:
    ReadClockResponse();
    virtual ~ReadClockResponse();
    /// <summary>
    /// This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
    /// </summary>
    ///<param name = "currentTime"></param>
    public: ReadClockResponse(
        const TPMS_TIME_INFO& currentTime
    );
};
/// <summary>
/// This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
/// </summary>
class _DLLEXP_ TPM2_ClockSet_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE auth;
    /// <summary>
    /// new Clock setting in milliseconds
    /// </summary>
    public: UINT64 newTime;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_ClockSet_REQUEST& operator=(const TPM2_ClockSet_REQUEST& rhs);
    public: TPM2_ClockSet_REQUEST(const TPM2_ClockSet_REQUEST& rhs);
    public:
    TPM2_ClockSet_REQUEST();
    virtual ~TPM2_ClockSet_REQUEST();
    /// <summary>
    /// This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
    /// </summary>
    ///<param name = "auth">TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER</param>
    ///<param name = "newTime">new Clock setting in milliseconds</param>
    public: TPM2_ClockSet_REQUEST(
        const TPM_HANDLE& auth,
        const UINT64& newTime
    );
};
/// <summary>
/// This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
/// </summary>
class _DLLEXP_ ClockSetResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: ClockSetResponse& operator=(const ClockSetResponse& rhs);
    public: ClockSetResponse(const ClockSetResponse& rhs);
    public:
    ClockSetResponse();
    virtual ~ClockSetResponse();
};
/// <summary>
/// This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
/// </summary>
class _DLLEXP_ TPM2_ClockRateAdjust_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE auth;
    /// <summary>
    /// Adjustment to current Clock update rate
    /// </summary>
    public: TPM_CLOCK_ADJUST rateAdjust;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_ClockRateAdjust_REQUEST& operator=(const TPM2_ClockRateAdjust_REQUEST& rhs);
    public: TPM2_ClockRateAdjust_REQUEST(const TPM2_ClockRateAdjust_REQUEST& rhs);
    public:
    TPM2_ClockRateAdjust_REQUEST();
    virtual ~TPM2_ClockRateAdjust_REQUEST();
    /// <summary>
    /// This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
    /// </summary>
    ///<param name = "auth">TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER</param>
    ///<param name = "rateAdjust">Adjustment to current Clock update rate</param>
    public: TPM2_ClockRateAdjust_REQUEST(
        const TPM_HANDLE& auth,
        const TPM_CLOCK_ADJUST& rateAdjust
    );
};
/// <summary>
/// This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
/// </summary>
class _DLLEXP_ ClockRateAdjustResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: ClockRateAdjustResponse& operator=(const ClockRateAdjustResponse& rhs);
    public: ClockRateAdjustResponse(const ClockRateAdjustResponse& rhs);
    public:
    ClockRateAdjustResponse();
    virtual ~ClockRateAdjustResponse();
};
/// <summary>
/// This command returns various information regarding the TPM and its current state.
/// </summary>
class _DLLEXP_ TPM2_GetCapability_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// group selection; determines the format of the response
    /// </summary>
    public: TPM_CAP capability;
    /// <summary>
    /// further definition of information
    /// </summary>
    public: UINT32 property;
    /// <summary>
    /// number of properties of the indicated type to return
    /// </summary>
    public: UINT32 propertyCount;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_GetCapability_REQUEST& operator=(const TPM2_GetCapability_REQUEST& rhs);
    public: TPM2_GetCapability_REQUEST(const TPM2_GetCapability_REQUEST& rhs);
    public:
    TPM2_GetCapability_REQUEST();
    virtual ~TPM2_GetCapability_REQUEST();
    /// <summary>
    /// This command returns various information regarding the TPM and its current state.
    /// </summary>
    ///<param name = "capability">group selection; determines the format of the response</param>
    ///<param name = "property">further definition of information</param>
    ///<param name = "propertyCount">number of properties of the indicated type to return</param>
    public: TPM2_GetCapability_REQUEST(
        const TPM_CAP& capability,
        const UINT32& property,
        const UINT32& propertyCount
    );
};
/// <summary>
/// This command returns various information regarding the TPM and its current state.
/// </summary>
class _DLLEXP_ GetCapabilityResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// flag to indicate if there are more values of this type
    /// </summary>
    public: BYTE moreData;
    /// <summary>
    /// the capability
    /// </summary>
    protected: mutable TPM_CAP capabilityDataCapability;
    /// <summary>
    /// the capability data
    /// (One of [TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_CC, TPML_PCR_SELECTION, TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE, TPML_TAGGED_POLICY])
    /// </summary>
    public: TPMU_CAPABILITIES* capabilityData;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: GetCapabilityResponse& operator=(const GetCapabilityResponse& rhs);
    public: GetCapabilityResponse(const GetCapabilityResponse& rhs);
    public:
    GetCapabilityResponse();
    virtual ~GetCapabilityResponse();
    /// <summary>
    /// This command returns various information regarding the TPM and its current state.
    /// </summary>
    ///<param name = "moreData">flag to indicate if there are more values of this type</param>
    ///<param name = "capabilityData">the capability data(One of TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_CC, TPML_PCR_SELECTION, TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE, TPML_TAGGED_POLICY)</param>
    public: GetCapabilityResponse(
        const BYTE& moreData,
        const TPMU_CAPABILITIES& capabilityData
    );
};
/// <summary>
/// This command is used to check to see if specific combinations of algorithm parameters are supported.
/// </summary>
class _DLLEXP_ TPM2_TestParms_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the algorithm to be tested
    /// </summary>
    protected: mutable TPM_ALG_ID parametersType;
    /// <summary>
    /// algorithm parameters to be validated
    /// (One of [TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS, TPMS_ASYM_PARMS])
    /// </summary>
    public: TPMU_PUBLIC_PARMS* parameters;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_TestParms_REQUEST& operator=(const TPM2_TestParms_REQUEST& rhs);
    public: TPM2_TestParms_REQUEST(const TPM2_TestParms_REQUEST& rhs);
    public:
    TPM2_TestParms_REQUEST();
    virtual ~TPM2_TestParms_REQUEST();
    /// <summary>
    /// This command is used to check to see if specific combinations of algorithm parameters are supported.
    /// </summary>
    ///<param name = "parameters">algorithm parameters to be validated(One of TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS, TPMS_ASYM_PARMS)</param>
    public: TPM2_TestParms_REQUEST(
        const TPMU_PUBLIC_PARMS& parameters
    );
};
/// <summary>
/// This command is used to check to see if specific combinations of algorithm parameters are supported.
/// </summary>
class _DLLEXP_ TestParmsResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TestParmsResponse& operator=(const TestParmsResponse& rhs);
    public: TestParmsResponse(const TestParmsResponse& rhs);
    public:
    TestParmsResponse();
    virtual ~TestParmsResponse();
};
/// <summary>
/// This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
/// </summary>
class _DLLEXP_ TPM2_NV_DefineSpace_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 authSize;
    /// <summary>
    /// the authorization value
    /// </summary>
    public: std::vector<BYTE> auth;
    /// <summary>
    /// size of nvPublic
    /// </summary>
    protected: mutable UINT16 publicInfoSize;
    /// <summary>
    /// the public parameters of the NV area
    /// </summary>
    public: TPMS_NV_PUBLIC publicInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_NV_DefineSpace_REQUEST& operator=(const TPM2_NV_DefineSpace_REQUEST& rhs);
    public: TPM2_NV_DefineSpace_REQUEST(const TPM2_NV_DefineSpace_REQUEST& rhs);
    public:
    TPM2_NV_DefineSpace_REQUEST();
    virtual ~TPM2_NV_DefineSpace_REQUEST();
    /// <summary>
    /// This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
    /// </summary>
    ///<param name = "authHandle">TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER</param>
    ///<param name = "auth">the authorization value</param>
    ///<param name = "publicInfo">the public parameters of the NV area</param>
    public: TPM2_NV_DefineSpace_REQUEST(
        const TPM_HANDLE& authHandle,
        const std::vector<BYTE>& auth,
        const TPMS_NV_PUBLIC& publicInfo
    );
};
/// <summary>
/// This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
/// </summary>
class _DLLEXP_ NV_DefineSpaceResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: NV_DefineSpaceResponse& operator=(const NV_DefineSpaceResponse& rhs);
    public: NV_DefineSpaceResponse(const NV_DefineSpaceResponse& rhs);
    public:
    NV_DefineSpaceResponse();
    virtual ~NV_DefineSpaceResponse();
};
/// <summary>
/// This command removes an Index from the TPM.
/// </summary>
class _DLLEXP_ TPM2_NV_UndefineSpace_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// the NV Index to remove from NV space
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_NV_UndefineSpace_REQUEST& operator=(const TPM2_NV_UndefineSpace_REQUEST& rhs);
    public: TPM2_NV_UndefineSpace_REQUEST(const TPM2_NV_UndefineSpace_REQUEST& rhs);
    public:
    TPM2_NV_UndefineSpace_REQUEST();
    virtual ~TPM2_NV_UndefineSpace_REQUEST();
    /// <summary>
    /// This command removes an Index from the TPM.
    /// </summary>
    ///<param name = "authHandle">TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER</param>
    ///<param name = "nvIndex">the NV Index to remove from NV space Auth Index: None</param>
    public: TPM2_NV_UndefineSpace_REQUEST(
        const TPM_HANDLE& authHandle,
        const TPM_HANDLE& nvIndex
    );
};
/// <summary>
/// This command removes an Index from the TPM.
/// </summary>
class _DLLEXP_ NV_UndefineSpaceResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: NV_UndefineSpaceResponse& operator=(const NV_UndefineSpaceResponse& rhs);
    public: NV_UndefineSpaceResponse(const NV_UndefineSpaceResponse& rhs);
    public:
    NV_UndefineSpaceResponse();
    virtual ~NV_UndefineSpaceResponse();
};
/// <summary>
/// This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
/// </summary>
class _DLLEXP_ TPM2_NV_UndefineSpaceSpecial_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// Index to be deleted
    /// Auth Index: 1
    /// Auth Role: ADMIN
    /// </summary>
    public: TPM_HANDLE nvIndex;
    /// <summary>
    /// TPM_RH_PLATFORM + {PP}
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE platform;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_NV_UndefineSpaceSpecial_REQUEST& operator=(const TPM2_NV_UndefineSpaceSpecial_REQUEST& rhs);
    public: TPM2_NV_UndefineSpaceSpecial_REQUEST(const TPM2_NV_UndefineSpaceSpecial_REQUEST& rhs);
    public:
    TPM2_NV_UndefineSpaceSpecial_REQUEST();
    virtual ~TPM2_NV_UndefineSpaceSpecial_REQUEST();
    /// <summary>
    /// This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
    /// </summary>
    ///<param name = "nvIndex">Index to be deleted Auth Index: 1 Auth Role: ADMIN</param>
    ///<param name = "platform">TPM_RH_PLATFORM + {PP} Auth Index: 2 Auth Role: USER</param>
    public: TPM2_NV_UndefineSpaceSpecial_REQUEST(
        const TPM_HANDLE& nvIndex,
        const TPM_HANDLE& platform
    );
};
/// <summary>
/// This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
/// </summary>
class _DLLEXP_ NV_UndefineSpaceSpecialResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: NV_UndefineSpaceSpecialResponse& operator=(const NV_UndefineSpaceSpecialResponse& rhs);
    public: NV_UndefineSpaceSpecialResponse(const NV_UndefineSpaceSpecialResponse& rhs);
    public:
    NV_UndefineSpaceSpecialResponse();
    virtual ~NV_UndefineSpaceSpecialResponse();
};
/// <summary>
/// This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
/// </summary>
class _DLLEXP_ TPM2_NV_ReadPublic_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the NV Index
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_NV_ReadPublic_REQUEST& operator=(const TPM2_NV_ReadPublic_REQUEST& rhs);
    public: TPM2_NV_ReadPublic_REQUEST(const TPM2_NV_ReadPublic_REQUEST& rhs);
    public:
    TPM2_NV_ReadPublic_REQUEST();
    virtual ~TPM2_NV_ReadPublic_REQUEST();
    /// <summary>
    /// This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
    /// </summary>
    ///<param name = "nvIndex">the NV Index Auth Index: None</param>
    public: TPM2_NV_ReadPublic_REQUEST(
        const TPM_HANDLE& nvIndex
    );
};
/// <summary>
/// This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
/// </summary>
class _DLLEXP_ NV_ReadPublicResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of nvPublic
    /// </summary>
    protected: mutable UINT16 nvPublicSize;
    /// <summary>
    /// the public area of the NV Index
    /// </summary>
    public: TPMS_NV_PUBLIC nvPublic;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 nvNameSize;
    /// <summary>
    /// the Name of the nvIndex
    /// </summary>
    public: std::vector<BYTE> nvName;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: NV_ReadPublicResponse& operator=(const NV_ReadPublicResponse& rhs);
    public: NV_ReadPublicResponse(const NV_ReadPublicResponse& rhs);
    public:
    NV_ReadPublicResponse();
    virtual ~NV_ReadPublicResponse();
    /// <summary>
    /// This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
    /// </summary>
    ///<param name = "nvPublic">the public area of the NV Index</param>
    ///<param name = "nvName">the Name of the nvIndex</param>
    public: NV_ReadPublicResponse(
        const TPMS_NV_PUBLIC& nvPublic,
        const std::vector<BYTE>& nvName
    );
};
/// <summary>
/// This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
/// </summary>
class _DLLEXP_ TPM2_NV_Write_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// the NV Index of the area to write
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 dataSize;
    /// <summary>
    /// the data to write
    /// </summary>
    public: std::vector<BYTE> data;
    /// <summary>
    /// the octet offset into the NV Area
    /// </summary>
    public: UINT16 offset;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_NV_Write_REQUEST& operator=(const TPM2_NV_Write_REQUEST& rhs);
    public: TPM2_NV_Write_REQUEST(const TPM2_NV_Write_REQUEST& rhs);
    public:
    TPM2_NV_Write_REQUEST();
    virtual ~TPM2_NV_Write_REQUEST();
    /// <summary>
    /// This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
    /// </summary>
    ///<param name = "authHandle">handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER</param>
    ///<param name = "nvIndex">the NV Index of the area to write Auth Index: None</param>
    ///<param name = "data">the data to write</param>
    ///<param name = "offset">the octet offset into the NV Area</param>
    public: TPM2_NV_Write_REQUEST(
        const TPM_HANDLE& authHandle,
        const TPM_HANDLE& nvIndex,
        const std::vector<BYTE>& data,
        const UINT16& offset
    );
};
/// <summary>
/// This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
/// </summary>
class _DLLEXP_ NV_WriteResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: NV_WriteResponse& operator=(const NV_WriteResponse& rhs);
    public: NV_WriteResponse(const NV_WriteResponse& rhs);
    public:
    NV_WriteResponse();
    virtual ~NV_WriteResponse();
};
/// <summary>
/// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
/// </summary>
class _DLLEXP_ TPM2_NV_Increment_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// the NV Index to increment
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_NV_Increment_REQUEST& operator=(const TPM2_NV_Increment_REQUEST& rhs);
    public: TPM2_NV_Increment_REQUEST(const TPM2_NV_Increment_REQUEST& rhs);
    public:
    TPM2_NV_Increment_REQUEST();
    virtual ~TPM2_NV_Increment_REQUEST();
    /// <summary>
    /// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
    /// </summary>
    ///<param name = "authHandle">handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER</param>
    ///<param name = "nvIndex">the NV Index to increment Auth Index: None</param>
    public: TPM2_NV_Increment_REQUEST(
        const TPM_HANDLE& authHandle,
        const TPM_HANDLE& nvIndex
    );
};
/// <summary>
/// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
/// </summary>
class _DLLEXP_ NV_IncrementResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: NV_IncrementResponse& operator=(const NV_IncrementResponse& rhs);
    public: NV_IncrementResponse(const NV_IncrementResponse& rhs);
    public:
    NV_IncrementResponse();
    virtual ~NV_IncrementResponse();
};
/// <summary>
/// This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
/// </summary>
class _DLLEXP_ TPM2_NV_Extend_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// the NV Index to extend
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 dataSize;
    /// <summary>
    /// the data to extend
    /// </summary>
    public: std::vector<BYTE> data;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_NV_Extend_REQUEST& operator=(const TPM2_NV_Extend_REQUEST& rhs);
    public: TPM2_NV_Extend_REQUEST(const TPM2_NV_Extend_REQUEST& rhs);
    public:
    TPM2_NV_Extend_REQUEST();
    virtual ~TPM2_NV_Extend_REQUEST();
    /// <summary>
    /// This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
    /// </summary>
    ///<param name = "authHandle">handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER</param>
    ///<param name = "nvIndex">the NV Index to extend Auth Index: None</param>
    ///<param name = "data">the data to extend</param>
    public: TPM2_NV_Extend_REQUEST(
        const TPM_HANDLE& authHandle,
        const TPM_HANDLE& nvIndex,
        const std::vector<BYTE>& data
    );
};
/// <summary>
/// This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
/// </summary>
class _DLLEXP_ NV_ExtendResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: NV_ExtendResponse& operator=(const NV_ExtendResponse& rhs);
    public: NV_ExtendResponse(const NV_ExtendResponse& rhs);
    public:
    NV_ExtendResponse();
    virtual ~NV_ExtendResponse();
};
/// <summary>
/// This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
/// </summary>
class _DLLEXP_ TPM2_NV_SetBits_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// NV Index of the area in which the bit is to be set
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    /// <summary>
    /// the data to OR with the current contents
    /// </summary>
    public: UINT64 bits;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_NV_SetBits_REQUEST& operator=(const TPM2_NV_SetBits_REQUEST& rhs);
    public: TPM2_NV_SetBits_REQUEST(const TPM2_NV_SetBits_REQUEST& rhs);
    public:
    TPM2_NV_SetBits_REQUEST();
    virtual ~TPM2_NV_SetBits_REQUEST();
    /// <summary>
    /// This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
    /// </summary>
    ///<param name = "authHandle">handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER</param>
    ///<param name = "nvIndex">NV Index of the area in which the bit is to be set Auth Index: None</param>
    ///<param name = "bits">the data to OR with the current contents</param>
    public: TPM2_NV_SetBits_REQUEST(
        const TPM_HANDLE& authHandle,
        const TPM_HANDLE& nvIndex,
        const UINT64& bits
    );
};
/// <summary>
/// This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
/// </summary>
class _DLLEXP_ NV_SetBitsResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: NV_SetBitsResponse& operator=(const NV_SetBitsResponse& rhs);
    public: NV_SetBitsResponse(const NV_SetBitsResponse& rhs);
    public:
    NV_SetBitsResponse();
    virtual ~NV_SetBitsResponse();
};
/// <summary>
/// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
/// </summary>
class _DLLEXP_ TPM2_NV_WriteLock_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// the NV Index of the area to lock
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_NV_WriteLock_REQUEST& operator=(const TPM2_NV_WriteLock_REQUEST& rhs);
    public: TPM2_NV_WriteLock_REQUEST(const TPM2_NV_WriteLock_REQUEST& rhs);
    public:
    TPM2_NV_WriteLock_REQUEST();
    virtual ~TPM2_NV_WriteLock_REQUEST();
    /// <summary>
    /// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
    /// </summary>
    ///<param name = "authHandle">handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER</param>
    ///<param name = "nvIndex">the NV Index of the area to lock Auth Index: None</param>
    public: TPM2_NV_WriteLock_REQUEST(
        const TPM_HANDLE& authHandle,
        const TPM_HANDLE& nvIndex
    );
};
/// <summary>
/// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
/// </summary>
class _DLLEXP_ NV_WriteLockResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: NV_WriteLockResponse& operator=(const NV_WriteLockResponse& rhs);
    public: NV_WriteLockResponse(const NV_WriteLockResponse& rhs);
    public:
    NV_WriteLockResponse();
    virtual ~NV_WriteLockResponse();
};
/// <summary>
/// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
/// </summary>
class _DLLEXP_ TPM2_NV_GlobalWriteLock_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_NV_GlobalWriteLock_REQUEST& operator=(const TPM2_NV_GlobalWriteLock_REQUEST& rhs);
    public: TPM2_NV_GlobalWriteLock_REQUEST(const TPM2_NV_GlobalWriteLock_REQUEST& rhs);
    public:
    TPM2_NV_GlobalWriteLock_REQUEST();
    virtual ~TPM2_NV_GlobalWriteLock_REQUEST();
    /// <summary>
    /// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
    /// </summary>
    ///<param name = "authHandle">TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER</param>
    public: TPM2_NV_GlobalWriteLock_REQUEST(
        const TPM_HANDLE& authHandle
    );
};
/// <summary>
/// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
/// </summary>
class _DLLEXP_ NV_GlobalWriteLockResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: NV_GlobalWriteLockResponse& operator=(const NV_GlobalWriteLockResponse& rhs);
    public: NV_GlobalWriteLockResponse(const NV_GlobalWriteLockResponse& rhs);
    public:
    NV_GlobalWriteLockResponse();
    virtual ~NV_GlobalWriteLockResponse();
};
/// <summary>
/// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
/// </summary>
class _DLLEXP_ TPM2_NV_Read_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// the NV Index to be read
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    /// <summary>
    /// number of octets to read
    /// </summary>
    public: UINT16 size;
    /// <summary>
    /// octet offset into the NV area
    /// This value shall be less than or equal to the size of the nvIndex data.
    /// </summary>
    public: UINT16 offset;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_NV_Read_REQUEST& operator=(const TPM2_NV_Read_REQUEST& rhs);
    public: TPM2_NV_Read_REQUEST(const TPM2_NV_Read_REQUEST& rhs);
    public:
    TPM2_NV_Read_REQUEST();
    virtual ~TPM2_NV_Read_REQUEST();
    /// <summary>
    /// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
    /// </summary>
    ///<param name = "authHandle">the handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER</param>
    ///<param name = "nvIndex">the NV Index to be read Auth Index: None</param>
    ///<param name = "size">number of octets to read</param>
    ///<param name = "offset">octet offset into the NV area This value shall be less than or equal to the size of the nvIndex data.</param>
    public: TPM2_NV_Read_REQUEST(
        const TPM_HANDLE& authHandle,
        const TPM_HANDLE& nvIndex,
        const UINT16& size,
        const UINT16& offset
    );
};
/// <summary>
/// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
/// </summary>
class _DLLEXP_ NV_ReadResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 dataSize;
    /// <summary>
    /// the data read
    /// </summary>
    public: std::vector<BYTE> data;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: NV_ReadResponse& operator=(const NV_ReadResponse& rhs);
    public: NV_ReadResponse(const NV_ReadResponse& rhs);
    public:
    NV_ReadResponse();
    virtual ~NV_ReadResponse();
    /// <summary>
    /// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
    /// </summary>
    ///<param name = "data">the data read</param>
    public: NV_ReadResponse(
        const std::vector<BYTE>& data
    );
};
/// <summary>
/// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
/// </summary>
class _DLLEXP_ TPM2_NV_ReadLock_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// the handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// the NV Index to be locked
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_NV_ReadLock_REQUEST& operator=(const TPM2_NV_ReadLock_REQUEST& rhs);
    public: TPM2_NV_ReadLock_REQUEST(const TPM2_NV_ReadLock_REQUEST& rhs);
    public:
    TPM2_NV_ReadLock_REQUEST();
    virtual ~TPM2_NV_ReadLock_REQUEST();
    /// <summary>
    /// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
    /// </summary>
    ///<param name = "authHandle">the handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER</param>
    ///<param name = "nvIndex">the NV Index to be locked Auth Index: None</param>
    public: TPM2_NV_ReadLock_REQUEST(
        const TPM_HANDLE& authHandle,
        const TPM_HANDLE& nvIndex
    );
};
/// <summary>
/// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
/// </summary>
class _DLLEXP_ NV_ReadLockResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: NV_ReadLockResponse& operator=(const NV_ReadLockResponse& rhs);
    public: NV_ReadLockResponse(const NV_ReadLockResponse& rhs);
    public:
    NV_ReadLockResponse();
    virtual ~NV_ReadLockResponse();
};
/// <summary>
/// This command allows the authorization secret for an NV Index to be changed.
/// </summary>
class _DLLEXP_ TPM2_NV_ChangeAuth_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of the entity
    /// Auth Index: 1
    /// Auth Role: ADMIN
    /// </summary>
    public: TPM_HANDLE nvIndex;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 newAuthSize;
    /// <summary>
    /// new authorization value
    /// </summary>
    public: std::vector<BYTE> newAuth;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_NV_ChangeAuth_REQUEST& operator=(const TPM2_NV_ChangeAuth_REQUEST& rhs);
    public: TPM2_NV_ChangeAuth_REQUEST(const TPM2_NV_ChangeAuth_REQUEST& rhs);
    public:
    TPM2_NV_ChangeAuth_REQUEST();
    virtual ~TPM2_NV_ChangeAuth_REQUEST();
    /// <summary>
    /// This command allows the authorization secret for an NV Index to be changed.
    /// </summary>
    ///<param name = "nvIndex">handle of the entity Auth Index: 1 Auth Role: ADMIN</param>
    ///<param name = "newAuth">new authorization value</param>
    public: TPM2_NV_ChangeAuth_REQUEST(
        const TPM_HANDLE& nvIndex,
        const std::vector<BYTE>& newAuth
    );
};
/// <summary>
/// This command allows the authorization secret for an NV Index to be changed.
/// </summary>
class _DLLEXP_ NV_ChangeAuthResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: NV_ChangeAuthResponse& operator=(const NV_ChangeAuthResponse& rhs);
    public: NV_ChangeAuthResponse(const NV_ChangeAuthResponse& rhs);
    public:
    NV_ChangeAuthResponse();
    virtual ~NV_ChangeAuthResponse();
};
/// <summary>
/// The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
/// </summary>
class _DLLEXP_ TPM2_NV_Certify_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of the key used to sign the attestation structure
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE signHandle;
    /// <summary>
    /// handle indicating the source of the authorization value for the NV Index
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// Index for the area to be certified
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 qualifyingDataSize;
    /// <summary>
    /// user-provided qualifying data
    /// </summary>
    public: std::vector<BYTE> qualifyingData;
    /// <summary>
    /// scheme selector
    /// </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    /// <summary>
    /// signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: TPMU_SIG_SCHEME* inScheme;
    /// <summary>
    /// number of octets to certify
    /// </summary>
    public: UINT16 size;
    /// <summary>
    /// octet offset into the NV area
    /// This value shall be less than or equal to the size of the nvIndex data.
    /// </summary>
    public: UINT16 offset;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_NV_Certify_REQUEST& operator=(const TPM2_NV_Certify_REQUEST& rhs);
    public: TPM2_NV_Certify_REQUEST(const TPM2_NV_Certify_REQUEST& rhs);
    public:
    TPM2_NV_Certify_REQUEST();
    virtual ~TPM2_NV_Certify_REQUEST();
    /// <summary>
    /// The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
    /// </summary>
    ///<param name = "signHandle">handle of the key used to sign the attestation structure Auth Index: 1 Auth Role: USER</param>
    ///<param name = "authHandle">handle indicating the source of the authorization value for the NV Index Auth Index: 2 Auth Role: USER</param>
    ///<param name = "nvIndex">Index for the area to be certified Auth Index: None</param>
    ///<param name = "qualifyingData">user-provided qualifying data</param>
    ///<param name = "inScheme">signing scheme to use if the scheme for signHandle is TPM_ALG_NULL(One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)</param>
    ///<param name = "size">number of octets to certify</param>
    ///<param name = "offset">octet offset into the NV area This value shall be less than or equal to the size of the nvIndex data.</param>
    public: TPM2_NV_Certify_REQUEST(
        const TPM_HANDLE& signHandle,
        const TPM_HANDLE& authHandle,
        const TPM_HANDLE& nvIndex,
        const std::vector<BYTE>& qualifyingData,
        const TPMU_SIG_SCHEME& inScheme,
        const UINT16& size,
        const UINT16& offset
    );
};
/// <summary>
/// The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
/// </summary>
class _DLLEXP_ NV_CertifyResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size of the attestationData structure
    /// </summary>
    protected: mutable UINT16 certifyInfoSize;
    /// <summary>
    /// the structure that was signed
    /// </summary>
    public: TPMS_ATTEST certifyInfo;
    /// <summary>
    /// selector of the algorithm used to construct the signature
    /// </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    /// <summary>
    /// the asymmetric signature over certifyInfo using the key referenced by signHandle
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: TPMU_SIGNATURE* signature;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: NV_CertifyResponse& operator=(const NV_CertifyResponse& rhs);
    public: NV_CertifyResponse(const NV_CertifyResponse& rhs);
    public:
    NV_CertifyResponse();
    virtual ~NV_CertifyResponse();
    /// <summary>
    /// The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
    /// </summary>
    ///<param name = "certifyInfo">the structure that was signed</param>
    ///<param name = "signature">the asymmetric signature over certifyInfo using the key referenced by signHandle(One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)</param>
    public: NV_CertifyResponse(
        const TPMS_ATTEST& certifyInfo,
        const TPMU_SIGNATURE& signature
    );
};
/// <summary>
/// The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
/// </summary>
class _DLLEXP_ TPM2_AC_GetCapability_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle indicating the Attached Component
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE ac;
    /// <summary>
    /// starting info type
    /// </summary>
    public: TPM_AT capability;
    /// <summary>
    /// maximum number of values to return
    /// </summary>
    public: UINT32 count;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_AC_GetCapability_REQUEST& operator=(const TPM2_AC_GetCapability_REQUEST& rhs);
    public: TPM2_AC_GetCapability_REQUEST(const TPM2_AC_GetCapability_REQUEST& rhs);
    public:
    TPM2_AC_GetCapability_REQUEST();
    virtual ~TPM2_AC_GetCapability_REQUEST();
    /// <summary>
    /// The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
    /// </summary>
    ///<param name = "ac">handle indicating the Attached Component Auth Index: None</param>
    ///<param name = "capability">starting info type</param>
    ///<param name = "count">maximum number of values to return</param>
    public: TPM2_AC_GetCapability_REQUEST(
        const TPM_HANDLE& ac,
        const TPM_AT& capability,
        const UINT32& count
    );
};
/// <summary>
/// The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
/// </summary>
class _DLLEXP_ AC_GetCapabilityResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// flag to indicate whether there are more values
    /// </summary>
    public: BYTE moreData;
    /// <summary>
    /// number of values in the acCapabilities list; may be 0
    /// </summary>
    protected: mutable UINT32 capabilitiesDataCount;
    /// <summary>
    /// list of capabilities
    /// </summary>
    public: std::vector<TPMS_AC_OUTPUT> capabilitiesData;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: AC_GetCapabilityResponse& operator=(const AC_GetCapabilityResponse& rhs);
    public: AC_GetCapabilityResponse(const AC_GetCapabilityResponse& rhs);
    public:
    AC_GetCapabilityResponse();
    virtual ~AC_GetCapabilityResponse();
    /// <summary>
    /// The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
    /// </summary>
    ///<param name = "moreData">flag to indicate whether there are more values</param>
    ///<param name = "capabilitiesData">list of capabilities</param>
    public: AC_GetCapabilityResponse(
        const BYTE& moreData,
        const std::vector<TPMS_AC_OUTPUT>& capabilitiesData
    );
};
/// <summary>
/// The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
/// </summary>
class _DLLEXP_ TPM2_AC_Send_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle of the object being sent to ac
    /// Auth Index: 1
    /// Auth Role: DUP
    /// </summary>
    public: TPM_HANDLE sendObject;
    /// <summary>
    /// the handle indicating the source of the authorization value
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    /// <summary>
    /// handle indicating the Attached Component to which the object will be sent
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE ac;
    /// <summary>
    /// size of the buffer
    /// </summary>
    protected: mutable UINT16 acDataInSize;
    /// <summary>
    /// Optional non sensitive information related to the object
    /// </summary>
    public: std::vector<BYTE> acDataIn;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_AC_Send_REQUEST& operator=(const TPM2_AC_Send_REQUEST& rhs);
    public: TPM2_AC_Send_REQUEST(const TPM2_AC_Send_REQUEST& rhs);
    public:
    TPM2_AC_Send_REQUEST();
    virtual ~TPM2_AC_Send_REQUEST();
    /// <summary>
    /// The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
    /// </summary>
    ///<param name = "sendObject">handle of the object being sent to ac Auth Index: 1 Auth Role: DUP</param>
    ///<param name = "authHandle">the handle indicating the source of the authorization value Auth Index: 2 Auth Role: USER</param>
    ///<param name = "ac">handle indicating the Attached Component to which the object will be sent Auth Index: None</param>
    ///<param name = "acDataIn">Optional non sensitive information related to the object</param>
    public: TPM2_AC_Send_REQUEST(
        const TPM_HANDLE& sendObject,
        const TPM_HANDLE& authHandle,
        const TPM_HANDLE& ac,
        const std::vector<BYTE>& acDataIn
    );
};
/// <summary>
/// The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
/// </summary>
class _DLLEXP_ AC_SendResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// May include AC specific data or information about an error.
    /// </summary>
    public: TPMS_AC_OUTPUT acDataOut;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: AC_SendResponse& operator=(const AC_SendResponse& rhs);
    public: AC_SendResponse(const AC_SendResponse& rhs);
    public:
    AC_SendResponse();
    virtual ~AC_SendResponse();
    /// <summary>
    /// The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
    /// </summary>
    ///<param name = "acDataOut">May include AC specific data or information about an error.</param>
    public: AC_SendResponse(
        const TPMS_AC_OUTPUT& acDataOut
    );
};
/// <summary>
/// This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
/// </summary>
class _DLLEXP_ TPM2_Policy_AC_SendSelect_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 objectNameSize;
    /// <summary>
    /// the Name of the Object to be sent
    /// </summary>
    public: std::vector<BYTE> objectName;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 authHandleNameSize;
    /// <summary>
    /// the Name associated with authHandle used in the TPM2_AC_Send() command
    /// </summary>
    public: std::vector<BYTE> authHandleName;
    /// <summary>
    /// size of the Name structure
    /// </summary>
    protected: mutable UINT16 acNameSize;
    /// <summary>
    /// the Name of the Attached Component to which the Object will be sent
    /// </summary>
    public: std::vector<BYTE> acName;
    /// <summary>
    /// if SET, objectName will be included in the value in policySessionpolicyDigest
    /// </summary>
    public: BYTE includeObject;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_Policy_AC_SendSelect_REQUEST& operator=(const TPM2_Policy_AC_SendSelect_REQUEST& rhs);
    public: TPM2_Policy_AC_SendSelect_REQUEST(const TPM2_Policy_AC_SendSelect_REQUEST& rhs);
    public:
    TPM2_Policy_AC_SendSelect_REQUEST();
    virtual ~TPM2_Policy_AC_SendSelect_REQUEST();
    /// <summary>
    /// This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
    /// </summary>
    ///<param name = "policySession">handle for the policy session being extended Auth Index: None</param>
    ///<param name = "objectName">the Name of the Object to be sent</param>
    ///<param name = "authHandleName">the Name associated with authHandle used in the TPM2_AC_Send() command</param>
    ///<param name = "acName">the Name of the Attached Component to which the Object will be sent</param>
    ///<param name = "includeObject">if SET, objectName will be included in the value in policySessionpolicyDigest</param>
    public: TPM2_Policy_AC_SendSelect_REQUEST(
        const TPM_HANDLE& policySession,
        const std::vector<BYTE>& objectName,
        const std::vector<BYTE>& authHandleName,
        const std::vector<BYTE>& acName,
        const BYTE& includeObject
    );
};
/// <summary>
/// This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
/// </summary>
class _DLLEXP_ Policy_AC_SendSelectResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: Policy_AC_SendSelectResponse& operator=(const Policy_AC_SendSelectResponse& rhs);
    public: Policy_AC_SendSelectResponse(const Policy_AC_SendSelectResponse& rhs);
    public:
    Policy_AC_SendSelectResponse();
    virtual ~Policy_AC_SendSelectResponse();
};
/// <summary>
/// This is a placeholder to allow testing of the dispatch code.
/// </summary>
class _DLLEXP_ TPM2_Vendor_TCG_Test_REQUEST : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 inputDataSize;
    /// <summary>
    /// dummy data
    /// </summary>
    public: std::vector<BYTE> inputData;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2_Vendor_TCG_Test_REQUEST& operator=(const TPM2_Vendor_TCG_Test_REQUEST& rhs);
    public: TPM2_Vendor_TCG_Test_REQUEST(const TPM2_Vendor_TCG_Test_REQUEST& rhs);
    public:
    TPM2_Vendor_TCG_Test_REQUEST();
    virtual ~TPM2_Vendor_TCG_Test_REQUEST();
    /// <summary>
    /// This is a placeholder to allow testing of the dispatch code.
    /// </summary>
    ///<param name = "inputData">dummy data</param>
    public: TPM2_Vendor_TCG_Test_REQUEST(
        const std::vector<BYTE>& inputData
    );
};
/// <summary>
/// This is a placeholder to allow testing of the dispatch code.
/// </summary>
class _DLLEXP_ Vendor_TCG_TestResponse : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 outputDataSize;
    /// <summary>
    /// dummy data
    /// </summary>
    public: std::vector<BYTE> outputData;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: Vendor_TCG_TestResponse& operator=(const Vendor_TCG_TestResponse& rhs);
    public: Vendor_TCG_TestResponse(const Vendor_TCG_TestResponse& rhs);
    public:
    Vendor_TCG_TestResponse();
    virtual ~Vendor_TCG_TestResponse();
    /// <summary>
    /// This is a placeholder to allow testing of the dispatch code.
    /// </summary>
    ///<param name = "outputData">dummy data</param>
    public: Vendor_TCG_TestResponse(
        const std::vector<BYTE>& outputData
    );
};
/// <summary>
/// Underlying type comment: These are the RSA schemes that only need a hash algorithm as a scheme parameter.
/// </summary>
typedef TPMS_SIG_SCHEME_RSASSA TPMS_SCHEME_RSASSA;
/// <summary>
/// Underlying type comment: These are the RSA schemes that only need a hash algorithm as a scheme parameter.
/// </summary>
typedef TPMS_SIG_SCHEME_RSAPSS TPMS_SCHEME_RSAPSS;
/// <summary>
/// Underlying type comment: Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
typedef TPMS_SIG_SCHEME_ECDSA TPMS_SCHEME_ECDSA;
/// <summary>
/// Underlying type comment: Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
typedef TPMS_SIG_SCHEME_SM2 TPMS_SCHEME_SM2;
/// <summary>
/// Underlying type comment: Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
typedef TPMS_SIG_SCHEME_ECSCHNORR TPMS_SCHEME_ECSCHNORR;
/// <summary>
/// Underlying type comment: These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
typedef TPMS_ENC_SCHEME_OAEP TPMS_SCHEME_OAEP;
/// <summary>
/// Underlying type comment: These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
typedef TPMS_ENC_SCHEME_RSAES TPMS_SCHEME_RSAES;
/// <summary>
/// Underlying type comment: These are the ECC schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
typedef TPMS_KEY_SCHEME_ECDH TPMS_SCHEME_ECDH;
/// <summary>
/// Underlying type comment: These are the ECC schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
typedef TPMS_KEY_SCHEME_ECMQV TPMS_SCHEME_ECMQV;
/// <summary>
/// Contains the public and the plaintext-sensitive and/or encrypted private part of a TPM key (or other object)
/// </summary>
class _DLLEXP_ TssObject : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// Public part of key
    /// </summary>
    public: TPMT_PUBLIC Public;
    /// <summary>
    /// Sensitive part of key
    /// </summary>
    public: TPMT_SENSITIVE Sensitive;
    /// <summary>
    /// Private part is the encrypted sensitive part of key
    /// </summary>
    public: TPM2B_PRIVATE Private;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TssObject& operator=(const TssObject& rhs);
    public: TssObject(const TssObject& rhs);
    public:
    TssObject();
    virtual ~TssObject();
    /// <summary>
    /// Contains the public and the plaintext-sensitive and/or encrypted private part of a TPM key (or other object)
    /// </summary>
    ///<param name = "Public">Public part of key</param>
    ///<param name = "Sensitive">Sensitive part of key</param>
    ///<param name = "Private">Private part is the encrypted sensitive part of key</param>
    public: TssObject(
        const TPMT_PUBLIC& Public,
        const TPMT_SENSITIVE& Sensitive,
        const TPM2B_PRIVATE& Private
    );
};
/// <summary>
/// Contains a PCR index and associated hash(pcr-value) [TSS]
/// </summary>
class _DLLEXP_ PcrValue : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// PCR Index
    /// </summary>
    public: UINT32 index;
    /// <summary>
    /// PCR Value
    /// </summary>
    public: TPMT_HA value;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: PcrValue& operator=(const PcrValue& rhs);
    public: PcrValue(const PcrValue& rhs);
    public:
    PcrValue();
    virtual ~PcrValue();
    /// <summary>
    /// Contains a PCR index and associated hash(pcr-value) [TSS]
    /// </summary>
    ///<param name = "index">PCR Index</param>
    ///<param name = "value">PCR Value</param>
    public: PcrValue(
        const UINT32& index,
        const TPMT_HA& value
    );
};
/// <summary>
/// Structure representing a session block in a command buffer [TSS]
/// </summary>
class _DLLEXP_ SessionIn : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// Session handle
    /// </summary>
    public: TPM_HANDLE handle;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 nonceCallerSize;
    /// <summary>
    /// Caller nonce
    /// </summary>
    public: std::vector<BYTE> nonceCaller;
    /// <summary>
    /// Session attributes
    /// </summary>
    public: TPMA_SESSION attributes;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 authSize;
    /// <summary>
    /// AuthValue (or HMAC)
    /// </summary>
    public: std::vector<BYTE> auth;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: SessionIn& operator=(const SessionIn& rhs);
    public: SessionIn(const SessionIn& rhs);
    public:
    SessionIn();
    virtual ~SessionIn();
    /// <summary>
    /// Structure representing a session block in a command buffer [TSS]
    /// </summary>
    ///<param name = "handle">Session handle</param>
    ///<param name = "nonceCaller">Caller nonce</param>
    ///<param name = "attributes">Session attributes</param>
    ///<param name = "auth">AuthValue (or HMAC)</param>
    public: SessionIn(
        const TPM_HANDLE& handle,
        const std::vector<BYTE>& nonceCaller,
        const TPMA_SESSION& attributes,
        const std::vector<BYTE>& auth
    );
};
/// <summary>
/// Structure representing a session block in a response buffer [TSS]
/// </summary>
class _DLLEXP_ SessionOut : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 nonceTpmSize;
    /// <summary>
    /// TPM nonce
    /// </summary>
    public: std::vector<BYTE> nonceTpm;
    /// <summary>
    /// Session attributes
    /// </summary>
    public: TPMA_SESSION attributes;
    /// <summary>
    /// size in octets of the buffer field; may be 0
    /// </summary>
    protected: mutable UINT16 authSize;
    /// <summary>
    /// HMAC value
    /// </summary>
    public: std::vector<BYTE> auth;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: SessionOut& operator=(const SessionOut& rhs);
    public: SessionOut(const SessionOut& rhs);
    public:
    SessionOut();
    virtual ~SessionOut();
    /// <summary>
    /// Structure representing a session block in a response buffer [TSS]
    /// </summary>
    ///<param name = "nonceTpm">TPM nonce</param>
    ///<param name = "attributes">Session attributes</param>
    ///<param name = "auth">HMAC value</param>
    public: SessionOut(
        const std::vector<BYTE>& nonceTpm,
        const TPMA_SESSION& attributes,
        const std::vector<BYTE>& auth
    );
};
/// <summary>
/// Command header [TSS]
/// </summary>
class _DLLEXP_ CommandHeader : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// Command tag (sessions, or no sessions)
    /// </summary>
    public: TPM_ST Tag;
    /// <summary>
    /// Total command buffer length
    /// </summary>
    public: UINT32 CommandSize;
    /// <summary>
    /// Command code
    /// </summary>
    public: TPM_CC CommandCode;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: CommandHeader& operator=(const CommandHeader& rhs);
    public: CommandHeader(const CommandHeader& rhs);
    public:
    CommandHeader();
    virtual ~CommandHeader();
    /// <summary>
    /// Command header [TSS]
    /// </summary>
    ///<param name = "Tag">Command tag (sessions, or no sessions)</param>
    ///<param name = "CommandSize">Total command buffer length</param>
    ///<param name = "CommandCode">Command code</param>
    public: CommandHeader(
        const TPM_ST& Tag,
        const UINT32& CommandSize,
        const TPM_CC& CommandCode
    );
};
/// <summary>
/// Contains the public and private part of a TPM key
/// </summary>
class _DLLEXP_ TSS_KEY : public TpmStructureBase
{
    friend class StructMarshallInfo;
    /// <summary>
    /// Public part of key
    /// </summary>
    public: TPMT_PUBLIC publicPart;
    protected: mutable UINT16 privatePartSize;
    /// <summary>
    /// Private part is the encrypted sensitive part of key
    /// </summary>
    public: std::vector<BYTE> privatePart;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TSS_KEY& operator=(const TSS_KEY& rhs);
    public: TSS_KEY(const TSS_KEY& rhs);
    public:
    TSS_KEY();
    virtual ~TSS_KEY();
    /// <summary>
    /// Contains the public and private part of a TPM key
    /// </summary>
    ///<param name = "publicPart">Public part of key</param>
    ///<param name = "privatePart">Private part is the encrypted sensitive part of key</param>
    public: TSS_KEY(
        const TPMT_PUBLIC& publicPart,
        const std::vector<BYTE>& privatePart
    );
#include "Extensions/TSS_KEY.h"
};
/// <summary>
/// Auto-derived from TPM2B_DIGEST to provide unique GetUnionSelector() implementation
/// </summary>
class _DLLEXP_ TPM2B_DIGEST_Symcipher : public virtual TPM2B_DIGEST, public virtual TPMU_PUBLIC_ID 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_DIGEST_Symcipher& operator=(const TPM2B_DIGEST_Symcipher& rhs);
    public: TPM2B_DIGEST_Symcipher(const TPM2B_DIGEST_Symcipher& rhs);
    public:
    TPM2B_DIGEST_Symcipher();
    virtual ~TPM2B_DIGEST_Symcipher();
    /// <summary>
    /// Auto-derived from TPM2B_DIGEST to provide unique GetUnionSelector() implementation
    /// </summary>
    ///<param name = "buffer">the buffer area that can be no larger than a digest</param>
    public: TPM2B_DIGEST_Symcipher(
        const std::vector<BYTE>& buffer
    );
};
/// <summary>
/// Auto-derived from TPM2B_DIGEST
/// </summary>
class _DLLEXP_ TPM2B_DIGEST_Keyedhash : public virtual TPM2B_DIGEST, public virtual TPMU_PUBLIC_ID 
{
    friend class StructMarshallInfo;
    public: virtual TpmStructureBase* Clone() const;
    public: virtual TpmTypeId GetTypeId() const;
    protected: virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pElem, int newArraySize);
    public: TPM2B_DIGEST_Keyedhash& operator=(const TPM2B_DIGEST_Keyedhash& rhs);
    public: TPM2B_DIGEST_Keyedhash(const TPM2B_DIGEST_Keyedhash& rhs);
    public:
    TPM2B_DIGEST_Keyedhash();
    virtual ~TPM2B_DIGEST_Keyedhash();
    /// <summary>
    /// Auto-derived from TPM2B_DIGEST
    /// </summary>
    ///<param name = "buffer">the buffer area that can be no larger than a digest</param>
    public: TPM2B_DIGEST_Keyedhash(
        const std::vector<BYTE>& buffer
    );
};


_TPMCPP_END
