/*++

Copyright (c) 2013, 2014  Microsoft Corporation
Microsoft Confidential

*/
#include "stdafx.h"
#include "Tpm2.h"

_TPMCPP_USING

// *************************************************************************************
//
// NOTE! Do not edit this file, it is auto generated! This source is TpmTypes_skel.cpp.
//
// *************************************************************************************

void Tpm2::Startup
(
    const TPM_SU& startupType
)
{
    TPM2_Startup_REQUEST _req;
    StartupResponse _resp;
    _req.startupType = startupType;
    this->Dispatch
    (
        TPM_CC::Startup,
        TpmTypeId::StartupResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::Shutdown
(
    const TPM_SU& shutdownType
)
{
    TPM2_Shutdown_REQUEST _req;
    ShutdownResponse _resp;
    _req.shutdownType = shutdownType;
    this->Dispatch
    (
        TPM_CC::Shutdown,
        TpmTypeId::ShutdownResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::SelfTest
(
    const BYTE& fullTest
)
{
    TPM2_SelfTest_REQUEST _req;
    SelfTestResponse _resp;
    _req.fullTest = fullTest;
    this->Dispatch
    (
        TPM_CC::SelfTest,
        TpmTypeId::SelfTestResponse_ID,
        &_req,
        &_resp
    );
return;
};
std::vector<TPM_ALG_ID> Tpm2::IncrementalSelfTest
(
    const std::vector<TPM_ALG_ID>& toTest
)
{
    TPM2_IncrementalSelfTest_REQUEST _req;
    IncrementalSelfTestResponse _resp;
    _req.toTest = toTest;
    this->Dispatch
    (
        TPM_CC::IncrementalSelfTest,
        TpmTypeId::IncrementalSelfTestResponse_ID,
        &_req,
        &_resp
    );
return _resp.toDoList;
};
GetTestResultResponse Tpm2::GetTestResult
(
)
{
    GetTestResultResponse _resp;
    this->Dispatch
    (
        TPM_CC::GetTestResult,
        TpmTypeId::GetTestResultResponse_ID,
        NULL,
        &_resp
    );
return _resp;
};
StartAuthSessionResponse Tpm2::StartAuthSession
(
    const TPM_HANDLE& tpmKey,
    const TPM_HANDLE& bind,
    const std::vector<BYTE>& nonceCaller,
    const std::vector<BYTE>& encryptedSalt,
    const TPM_SE& sessionType,
    const TPMT_SYM_DEF& symmetric,
    const TPM_ALG_ID& authHash
)
{
    TPM2_StartAuthSession_REQUEST _req;
    StartAuthSessionResponse _resp;
    _req.tpmKey = tpmKey;
    _req.bind = bind;
    _req.nonceCaller = nonceCaller;
    _req.encryptedSalt = encryptedSalt;
    _req.sessionType = sessionType;
    _req.symmetric = symmetric;
    _req.authHash = authHash;
    this->Dispatch
    (
        TPM_CC::StartAuthSession,
        TpmTypeId::StartAuthSessionResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
void Tpm2::PolicyRestart
(
    const TPM_HANDLE& sessionHandle
)
{
    TPM2_PolicyRestart_REQUEST _req;
    PolicyRestartResponse _resp;
    _req.sessionHandle = sessionHandle;
    this->Dispatch
    (
        TPM_CC::PolicyRestart,
        TpmTypeId::PolicyRestartResponse_ID,
        &_req,
        &_resp
    );
return;
};
CreateResponse Tpm2::Create
(
    const TPM_HANDLE& parentHandle,
    const TPMS_SENSITIVE_CREATE& inSensitive,
    const TPMT_PUBLIC& inPublic,
    const std::vector<BYTE>& outsideInfo,
    const std::vector<TPMS_PCR_SELECTION>& creationPCR
)
{
    TPM2_Create_REQUEST _req;
    CreateResponse _resp;
    _req.parentHandle = parentHandle;
    _req.inSensitive = inSensitive;
    _req.inPublic = inPublic;
    _req.outsideInfo = outsideInfo;
    _req.creationPCR = creationPCR;
    this->Dispatch
    (
        TPM_CC::Create,
        TpmTypeId::CreateResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
TPM_HANDLE Tpm2::Load
(
    const TPM_HANDLE& parentHandle,
    const TPM2B_PRIVATE& inPrivate,
    const TPMT_PUBLIC& inPublic
)
{
    TPM2_Load_REQUEST _req;
    LoadResponse _resp;
    _req.parentHandle = parentHandle;
    _req.inPrivate = inPrivate;
    _req.inPublic = inPublic;
    this->Dispatch
    (
        TPM_CC::Load,
        TpmTypeId::LoadResponse_ID,
        &_req,
        &_resp
    );
return _resp.handle;
};
TPM_HANDLE Tpm2::LoadExternal
(
    const TPMT_SENSITIVE& inPrivate,
    const TPMT_PUBLIC& inPublic,
    const TPM_HANDLE& hierarchy
)
{
    TPM2_LoadExternal_REQUEST _req;
    LoadExternalResponse _resp;
    _req.inPrivate = inPrivate;
    _req.inPublic = inPublic;
    _req.hierarchy = hierarchy;
    this->Dispatch
    (
        TPM_CC::LoadExternal,
        TpmTypeId::LoadExternalResponse_ID,
        &_req,
        &_resp
    );
return _resp.handle;
};
ReadPublicResponse Tpm2::ReadPublic
(
    const TPM_HANDLE& objectHandle
)
{
    TPM2_ReadPublic_REQUEST _req;
    ReadPublicResponse _resp;
    _req.objectHandle = objectHandle;
    this->Dispatch
    (
        TPM_CC::ReadPublic,
        TpmTypeId::ReadPublicResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
std::vector<BYTE> Tpm2::ActivateCredential
(
    const TPM_HANDLE& activateHandle,
    const TPM_HANDLE& keyHandle,
    const TPMS_ID_OBJECT& credentialBlob,
    const std::vector<BYTE>& secret
)
{
    TPM2_ActivateCredential_REQUEST _req;
    ActivateCredentialResponse _resp;
    _req.activateHandle = activateHandle;
    _req.keyHandle = keyHandle;
    _req.credentialBlob = credentialBlob;
    _req.secret = secret;
    this->Dispatch
    (
        TPM_CC::ActivateCredential,
        TpmTypeId::ActivateCredentialResponse_ID,
        &_req,
        &_resp
    );
return _resp.certInfo;
};
MakeCredentialResponse Tpm2::MakeCredential
(
    const TPM_HANDLE& handle,
    const std::vector<BYTE>& credential,
    const std::vector<BYTE>& objectName
)
{
    TPM2_MakeCredential_REQUEST _req;
    MakeCredentialResponse _resp;
    _req.handle = handle;
    _req.credential = credential;
    _req.objectName = objectName;
    this->Dispatch
    (
        TPM_CC::MakeCredential,
        TpmTypeId::MakeCredentialResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
std::vector<BYTE> Tpm2::Unseal
(
    const TPM_HANDLE& itemHandle
)
{
    TPM2_Unseal_REQUEST _req;
    UnsealResponse _resp;
    _req.itemHandle = itemHandle;
    this->Dispatch
    (
        TPM_CC::Unseal,
        TpmTypeId::UnsealResponse_ID,
        &_req,
        &_resp
    );
return _resp.outData;
};
TPM2B_PRIVATE Tpm2::ObjectChangeAuth
(
    const TPM_HANDLE& objectHandle,
    const TPM_HANDLE& parentHandle,
    const std::vector<BYTE>& newAuth
)
{
    TPM2_ObjectChangeAuth_REQUEST _req;
    ObjectChangeAuthResponse _resp;
    _req.objectHandle = objectHandle;
    _req.parentHandle = parentHandle;
    _req.newAuth = newAuth;
    this->Dispatch
    (
        TPM_CC::ObjectChangeAuth,
        TpmTypeId::ObjectChangeAuthResponse_ID,
        &_req,
        &_resp
    );
return _resp.outPrivate;
};
CreateLoadedResponse Tpm2::CreateLoaded
(
    const TPM_HANDLE& parentHandle,
    const TPMS_SENSITIVE_CREATE& inSensitive,
    const std::vector<BYTE>& inPublic
)
{
    TPM2_CreateLoaded_REQUEST _req;
    CreateLoadedResponse _resp;
    _req.parentHandle = parentHandle;
    _req.inSensitive = inSensitive;
    _req.inPublic = inPublic;
    this->Dispatch
    (
        TPM_CC::CreateLoaded,
        TpmTypeId::CreateLoadedResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
DuplicateResponse Tpm2::Duplicate
(
    const TPM_HANDLE& objectHandle,
    const TPM_HANDLE& newParentHandle,
    const std::vector<BYTE>& encryptionKeyIn,
    const TPMT_SYM_DEF_OBJECT& symmetricAlg
)
{
    TPM2_Duplicate_REQUEST _req;
    DuplicateResponse _resp;
    _req.objectHandle = objectHandle;
    _req.newParentHandle = newParentHandle;
    _req.encryptionKeyIn = encryptionKeyIn;
    _req.symmetricAlg = symmetricAlg;
    this->Dispatch
    (
        TPM_CC::Duplicate,
        TpmTypeId::DuplicateResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
RewrapResponse Tpm2::Rewrap
(
    const TPM_HANDLE& oldParent,
    const TPM_HANDLE& newParent,
    const TPM2B_PRIVATE& inDuplicate,
    const std::vector<BYTE>& name,
    const std::vector<BYTE>& inSymSeed
)
{
    TPM2_Rewrap_REQUEST _req;
    RewrapResponse _resp;
    _req.oldParent = oldParent;
    _req.newParent = newParent;
    _req.inDuplicate = inDuplicate;
    _req.name = name;
    _req.inSymSeed = inSymSeed;
    this->Dispatch
    (
        TPM_CC::Rewrap,
        TpmTypeId::RewrapResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
TPM2B_PRIVATE Tpm2::Import
(
    const TPM_HANDLE& parentHandle,
    const std::vector<BYTE>& encryptionKey,
    const TPMT_PUBLIC& objectPublic,
    const TPM2B_PRIVATE& duplicate,
    const std::vector<BYTE>& inSymSeed,
    const TPMT_SYM_DEF_OBJECT& symmetricAlg
)
{
    TPM2_Import_REQUEST _req;
    ImportResponse _resp;
    _req.parentHandle = parentHandle;
    _req.encryptionKey = encryptionKey;
    _req.objectPublic = objectPublic;
    _req.duplicate = duplicate;
    _req.inSymSeed = inSymSeed;
    _req.symmetricAlg = symmetricAlg;
    this->Dispatch
    (
        TPM_CC::Import,
        TpmTypeId::ImportResponse_ID,
        &_req,
        &_resp
    );
return _resp.outPrivate;
};
std::vector<BYTE> Tpm2::RSA_Encrypt
(
    const TPM_HANDLE& keyHandle,
    const std::vector<BYTE>& message,
    const TPMU_ASYM_SCHEME& inScheme,
    const std::vector<BYTE>& label
)
{
    TPM2_RSA_Encrypt_REQUEST _req;
    RSA_EncryptResponse _resp;
    _req.keyHandle = keyHandle;
    _req.message = message;
    _req.inScheme = dynamic_cast<TPMU_ASYM_SCHEME*>(inScheme.Clone());
    _req.label = label;
    this->Dispatch
    (
        TPM_CC::RSA_Encrypt,
        TpmTypeId::RSA_EncryptResponse_ID,
        &_req,
        &_resp
    );
return _resp.outData;
};
std::vector<BYTE> Tpm2::RSA_Decrypt
(
    const TPM_HANDLE& keyHandle,
    const std::vector<BYTE>& cipherText,
    const TPMU_ASYM_SCHEME& inScheme,
    const std::vector<BYTE>& label
)
{
    TPM2_RSA_Decrypt_REQUEST _req;
    RSA_DecryptResponse _resp;
    _req.keyHandle = keyHandle;
    _req.cipherText = cipherText;
    _req.inScheme = dynamic_cast<TPMU_ASYM_SCHEME*>(inScheme.Clone());
    _req.label = label;
    this->Dispatch
    (
        TPM_CC::RSA_Decrypt,
        TpmTypeId::RSA_DecryptResponse_ID,
        &_req,
        &_resp
    );
return _resp.message;
};
ECDH_KeyGenResponse Tpm2::ECDH_KeyGen
(
    const TPM_HANDLE& keyHandle
)
{
    TPM2_ECDH_KeyGen_REQUEST _req;
    ECDH_KeyGenResponse _resp;
    _req.keyHandle = keyHandle;
    this->Dispatch
    (
        TPM_CC::ECDH_KeyGen,
        TpmTypeId::ECDH_KeyGenResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
TPMS_ECC_POINT Tpm2::ECDH_ZGen
(
    const TPM_HANDLE& keyHandle,
    const TPMS_ECC_POINT& inPoint
)
{
    TPM2_ECDH_ZGen_REQUEST _req;
    ECDH_ZGenResponse _resp;
    _req.keyHandle = keyHandle;
    _req.inPoint = inPoint;
    this->Dispatch
    (
        TPM_CC::ECDH_ZGen,
        TpmTypeId::ECDH_ZGenResponse_ID,
        &_req,
        &_resp
    );
return _resp.outPoint;
};
TPMS_ALGORITHM_DETAIL_ECC Tpm2::ECC_Parameters
(
    const TPM_ECC_CURVE& curveID
)
{
    TPM2_ECC_Parameters_REQUEST _req;
    ECC_ParametersResponse _resp;
    _req.curveID = curveID;
    this->Dispatch
    (
        TPM_CC::ECC_Parameters,
        TpmTypeId::ECC_ParametersResponse_ID,
        &_req,
        &_resp
    );
return _resp.parameters;
};
ZGen_2PhaseResponse Tpm2::ZGen_2Phase
(
    const TPM_HANDLE& keyA,
    const TPMS_ECC_POINT& inQsB,
    const TPMS_ECC_POINT& inQeB,
    const TPM_ALG_ID& inScheme,
    const UINT16& counter
)
{
    TPM2_ZGen_2Phase_REQUEST _req;
    ZGen_2PhaseResponse _resp;
    _req.keyA = keyA;
    _req.inQsB = inQsB;
    _req.inQeB = inQeB;
    _req.inScheme = inScheme;
    _req.counter = counter;
    this->Dispatch
    (
        TPM_CC::ZGen_2Phase,
        TpmTypeId::ZGen_2PhaseResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
EncryptDecryptResponse Tpm2::EncryptDecrypt
(
    const TPM_HANDLE& keyHandle,
    const BYTE& decrypt,
    const TPM_ALG_ID& mode,
    const std::vector<BYTE>& ivIn,
    const std::vector<BYTE>& inData
)
{
    TPM2_EncryptDecrypt_REQUEST _req;
    EncryptDecryptResponse _resp;
    _req.keyHandle = keyHandle;
    _req.decrypt = decrypt;
    _req.mode = mode;
    _req.ivIn = ivIn;
    _req.inData = inData;
    this->Dispatch
    (
        TPM_CC::EncryptDecrypt,
        TpmTypeId::EncryptDecryptResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
EncryptDecrypt2Response Tpm2::EncryptDecrypt2
(
    const TPM_HANDLE& keyHandle,
    const std::vector<BYTE>& inData,
    const BYTE& decrypt,
    const TPM_ALG_ID& mode,
    const std::vector<BYTE>& ivIn
)
{
    TPM2_EncryptDecrypt2_REQUEST _req;
    EncryptDecrypt2Response _resp;
    _req.keyHandle = keyHandle;
    _req.inData = inData;
    _req.decrypt = decrypt;
    _req.mode = mode;
    _req.ivIn = ivIn;
    this->Dispatch
    (
        TPM_CC::EncryptDecrypt2,
        TpmTypeId::EncryptDecrypt2Response_ID,
        &_req,
        &_resp
    );
return _resp;
};
HashResponse Tpm2::Hash
(
    const std::vector<BYTE>& data,
    const TPM_ALG_ID& hashAlg,
    const TPM_HANDLE& hierarchy
)
{
    TPM2_Hash_REQUEST _req;
    HashResponse _resp;
    _req.data = data;
    _req.hashAlg = hashAlg;
    _req.hierarchy = hierarchy;
    this->Dispatch
    (
        TPM_CC::Hash,
        TpmTypeId::HashResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
std::vector<BYTE> Tpm2::HMAC
(
    const TPM_HANDLE& handle,
    const std::vector<BYTE>& buffer,
    const TPM_ALG_ID& hashAlg
)
{
    TPM2_HMAC_REQUEST _req;
    HMACResponse _resp;
    _req.handle = handle;
    _req.buffer = buffer;
    _req.hashAlg = hashAlg;
    this->Dispatch
    (
        TPM_CC::HMAC,
        TpmTypeId::HMACResponse_ID,
        &_req,
        &_resp
    );
return _resp.outHMAC;
};
std::vector<BYTE> Tpm2::MAC
(
    const TPM_HANDLE& handle,
    const std::vector<BYTE>& buffer,
    const TPM_ALG_ID& inScheme
)
{
    TPM2_MAC_REQUEST _req;
    MACResponse _resp;
    _req.handle = handle;
    _req.buffer = buffer;
    _req.inScheme = inScheme;
    this->Dispatch
    (
        TPM_CC::MAC,
        TpmTypeId::MACResponse_ID,
        &_req,
        &_resp
    );
return _resp.outMAC;
};
std::vector<BYTE> Tpm2::GetRandom
(
    const UINT16& bytesRequested
)
{
    TPM2_GetRandom_REQUEST _req;
    GetRandomResponse _resp;
    _req.bytesRequested = bytesRequested;
    this->Dispatch
    (
        TPM_CC::GetRandom,
        TpmTypeId::GetRandomResponse_ID,
        &_req,
        &_resp
    );
return _resp.randomBytes;
};
void Tpm2::StirRandom
(
    const std::vector<BYTE>& inData
)
{
    TPM2_StirRandom_REQUEST _req;
    StirRandomResponse _resp;
    _req.inData = inData;
    this->Dispatch
    (
        TPM_CC::StirRandom,
        TpmTypeId::StirRandomResponse_ID,
        &_req,
        &_resp
    );
return;
};
TPM_HANDLE Tpm2::HMAC_Start
(
    const TPM_HANDLE& handle,
    const std::vector<BYTE>& auth,
    const TPM_ALG_ID& hashAlg
)
{
    TPM2_HMAC_Start_REQUEST _req;
    HMAC_StartResponse _resp;
    _req.handle = handle;
    _req.auth = auth;
    _req.hashAlg = hashAlg;
    this->Dispatch
    (
        TPM_CC::HMAC_Start,
        TpmTypeId::HMAC_StartResponse_ID,
        &_req,
        &_resp
    );
return _resp.handle;
};
TPM_HANDLE Tpm2::MAC_Start
(
    const TPM_HANDLE& handle,
    const std::vector<BYTE>& auth,
    const TPM_ALG_ID& inScheme
)
{
    TPM2_MAC_Start_REQUEST _req;
    MAC_StartResponse _resp;
    _req.handle = handle;
    _req.auth = auth;
    _req.inScheme = inScheme;
    this->Dispatch
    (
        TPM_CC::MAC_Start,
        TpmTypeId::MAC_StartResponse_ID,
        &_req,
        &_resp
    );
return _resp.handle;
};
TPM_HANDLE Tpm2::HashSequenceStart
(
    const std::vector<BYTE>& auth,
    const TPM_ALG_ID& hashAlg
)
{
    TPM2_HashSequenceStart_REQUEST _req;
    HashSequenceStartResponse _resp;
    _req.auth = auth;
    _req.hashAlg = hashAlg;
    this->Dispatch
    (
        TPM_CC::HashSequenceStart,
        TpmTypeId::HashSequenceStartResponse_ID,
        &_req,
        &_resp
    );
return _resp.handle;
};
void Tpm2::SequenceUpdate
(
    const TPM_HANDLE& sequenceHandle,
    const std::vector<BYTE>& buffer
)
{
    TPM2_SequenceUpdate_REQUEST _req;
    SequenceUpdateResponse _resp;
    _req.sequenceHandle = sequenceHandle;
    _req.buffer = buffer;
    this->Dispatch
    (
        TPM_CC::SequenceUpdate,
        TpmTypeId::SequenceUpdateResponse_ID,
        &_req,
        &_resp
    );
return;
};
SequenceCompleteResponse Tpm2::SequenceComplete
(
    const TPM_HANDLE& sequenceHandle,
    const std::vector<BYTE>& buffer,
    const TPM_HANDLE& hierarchy
)
{
    TPM2_SequenceComplete_REQUEST _req;
    SequenceCompleteResponse _resp;
    _req.sequenceHandle = sequenceHandle;
    _req.buffer = buffer;
    _req.hierarchy = hierarchy;
    this->Dispatch
    (
        TPM_CC::SequenceComplete,
        TpmTypeId::SequenceCompleteResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
std::vector<TPMT_HA> Tpm2::EventSequenceComplete
(
    const TPM_HANDLE& pcrHandle,
    const TPM_HANDLE& sequenceHandle,
    const std::vector<BYTE>& buffer
)
{
    TPM2_EventSequenceComplete_REQUEST _req;
    EventSequenceCompleteResponse _resp;
    _req.pcrHandle = pcrHandle;
    _req.sequenceHandle = sequenceHandle;
    _req.buffer = buffer;
    this->Dispatch
    (
        TPM_CC::EventSequenceComplete,
        TpmTypeId::EventSequenceCompleteResponse_ID,
        &_req,
        &_resp
    );
return _resp.results;
};
CertifyResponse Tpm2::Certify
(
    const TPM_HANDLE& objectHandle,
    const TPM_HANDLE& signHandle,
    const std::vector<BYTE>& qualifyingData,
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_Certify_REQUEST _req;
    CertifyResponse _resp;
    _req.objectHandle = objectHandle;
    _req.signHandle = signHandle;
    _req.qualifyingData = qualifyingData;
    _req.inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(inScheme.Clone());
    this->Dispatch
    (
        TPM_CC::Certify,
        TpmTypeId::CertifyResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
CertifyCreationResponse Tpm2::CertifyCreation
(
    const TPM_HANDLE& signHandle,
    const TPM_HANDLE& objectHandle,
    const std::vector<BYTE>& qualifyingData,
    const std::vector<BYTE>& creationHash,
    const TPMU_SIG_SCHEME& inScheme,
    const TPMT_TK_CREATION& creationTicket
)
{
    TPM2_CertifyCreation_REQUEST _req;
    CertifyCreationResponse _resp;
    _req.signHandle = signHandle;
    _req.objectHandle = objectHandle;
    _req.qualifyingData = qualifyingData;
    _req.creationHash = creationHash;
    _req.inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(inScheme.Clone());
    _req.creationTicket = creationTicket;
    this->Dispatch
    (
        TPM_CC::CertifyCreation,
        TpmTypeId::CertifyCreationResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
QuoteResponse Tpm2::Quote
(
    const TPM_HANDLE& signHandle,
    const std::vector<BYTE>& qualifyingData,
    const TPMU_SIG_SCHEME& inScheme,
    const std::vector<TPMS_PCR_SELECTION>& PCRselect
)
{
    TPM2_Quote_REQUEST _req;
    QuoteResponse _resp;
    _req.signHandle = signHandle;
    _req.qualifyingData = qualifyingData;
    _req.inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(inScheme.Clone());
    _req.PCRselect = PCRselect;
    this->Dispatch
    (
        TPM_CC::Quote,
        TpmTypeId::QuoteResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
GetSessionAuditDigestResponse Tpm2::GetSessionAuditDigest
(
    const TPM_HANDLE& privacyAdminHandle,
    const TPM_HANDLE& signHandle,
    const TPM_HANDLE& sessionHandle,
    const std::vector<BYTE>& qualifyingData,
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_GetSessionAuditDigest_REQUEST _req;
    GetSessionAuditDigestResponse _resp;
    _req.privacyAdminHandle = privacyAdminHandle;
    _req.signHandle = signHandle;
    _req.sessionHandle = sessionHandle;
    _req.qualifyingData = qualifyingData;
    _req.inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(inScheme.Clone());
    this->Dispatch
    (
        TPM_CC::GetSessionAuditDigest,
        TpmTypeId::GetSessionAuditDigestResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
GetCommandAuditDigestResponse Tpm2::GetCommandAuditDigest
(
    const TPM_HANDLE& privacyHandle,
    const TPM_HANDLE& signHandle,
    const std::vector<BYTE>& qualifyingData,
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_GetCommandAuditDigest_REQUEST _req;
    GetCommandAuditDigestResponse _resp;
    _req.privacyHandle = privacyHandle;
    _req.signHandle = signHandle;
    _req.qualifyingData = qualifyingData;
    _req.inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(inScheme.Clone());
    this->Dispatch
    (
        TPM_CC::GetCommandAuditDigest,
        TpmTypeId::GetCommandAuditDigestResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
GetTimeResponse Tpm2::GetTime
(
    const TPM_HANDLE& privacyAdminHandle,
    const TPM_HANDLE& signHandle,
    const std::vector<BYTE>& qualifyingData,
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_GetTime_REQUEST _req;
    GetTimeResponse _resp;
    _req.privacyAdminHandle = privacyAdminHandle;
    _req.signHandle = signHandle;
    _req.qualifyingData = qualifyingData;
    _req.inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(inScheme.Clone());
    this->Dispatch
    (
        TPM_CC::GetTime,
        TpmTypeId::GetTimeResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
CertifyX509Response Tpm2::CertifyX509
(
    const TPM_HANDLE& objectHandle,
    const TPM_HANDLE& signHandle,
    const std::vector<BYTE>& qualifyingData,
    const TPMU_SIG_SCHEME& inScheme,
    const std::vector<BYTE>& partialCertificate
)
{
    TPM2_CertifyX509_REQUEST _req;
    CertifyX509Response _resp;
    _req.objectHandle = objectHandle;
    _req.signHandle = signHandle;
    _req.qualifyingData = qualifyingData;
    _req.inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(inScheme.Clone());
    _req.partialCertificate = partialCertificate;
    this->Dispatch
    (
        TPM_CC::CertifyX509,
        TpmTypeId::CertifyX509Response_ID,
        &_req,
        &_resp
    );
return _resp;
};
CommitResponse Tpm2::Commit
(
    const TPM_HANDLE& signHandle,
    const TPMS_ECC_POINT& P1,
    const std::vector<BYTE>& s2,
    const std::vector<BYTE>& y2
)
{
    TPM2_Commit_REQUEST _req;
    CommitResponse _resp;
    _req.signHandle = signHandle;
    _req.P1 = P1;
    _req.s2 = s2;
    _req.y2 = y2;
    this->Dispatch
    (
        TPM_CC::Commit,
        TpmTypeId::CommitResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
EC_EphemeralResponse Tpm2::EC_Ephemeral
(
    const TPM_ECC_CURVE& curveID
)
{
    TPM2_EC_Ephemeral_REQUEST _req;
    EC_EphemeralResponse _resp;
    _req.curveID = curveID;
    this->Dispatch
    (
        TPM_CC::EC_Ephemeral,
        TpmTypeId::EC_EphemeralResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
VerifySignatureResponse Tpm2::VerifySignature
(
    const TPM_HANDLE& keyHandle,
    const std::vector<BYTE>& digest,
    const TPMU_SIGNATURE& signature
)
{
    TPM2_VerifySignature_REQUEST _req;
    VerifySignatureResponse _resp;
    _req.keyHandle = keyHandle;
    _req.digest = digest;
    _req.signature = dynamic_cast<TPMU_SIGNATURE*>(signature.Clone());
    this->Dispatch
    (
        TPM_CC::VerifySignature,
        TpmTypeId::VerifySignatureResponse_ID,
        &_req,
        &_resp
    );
return _resp.validation;
};
SignResponse Tpm2::Sign
(
    const TPM_HANDLE& keyHandle,
    const std::vector<BYTE>& digest,
    const TPMU_SIG_SCHEME& inScheme,
    const TPMT_TK_HASHCHECK& validation
)
{
    TPM2_Sign_REQUEST _req;
    SignResponse _resp;
    _req.keyHandle = keyHandle;
    _req.digest = digest;
    _req.inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(inScheme.Clone());
    _req.validation = validation;
    this->Dispatch
    (
        TPM_CC::Sign,
        TpmTypeId::SignResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
void Tpm2::SetCommandCodeAuditStatus
(
    const TPM_HANDLE& auth,
    const TPM_ALG_ID& auditAlg,
    const std::vector<TPM_CC>& setList,
    const std::vector<TPM_CC>& clearList
)
{
    TPM2_SetCommandCodeAuditStatus_REQUEST _req;
    SetCommandCodeAuditStatusResponse _resp;
    _req.auth = auth;
    _req.auditAlg = auditAlg;
    _req.setList = setList;
    _req.clearList = clearList;
    this->Dispatch
    (
        TPM_CC::SetCommandCodeAuditStatus,
        TpmTypeId::SetCommandCodeAuditStatusResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PCR_Extend
(
    const TPM_HANDLE& pcrHandle,
    const std::vector<TPMT_HA>& digests
)
{
    TPM2_PCR_Extend_REQUEST _req;
    PCR_ExtendResponse _resp;
    _req.pcrHandle = pcrHandle;
    _req.digests = digests;
    this->Dispatch
    (
        TPM_CC::PCR_Extend,
        TpmTypeId::PCR_ExtendResponse_ID,
        &_req,
        &_resp
    );
return;
};
std::vector<TPMT_HA> Tpm2::PCR_Event
(
    const TPM_HANDLE& pcrHandle,
    const std::vector<BYTE>& eventData
)
{
    TPM2_PCR_Event_REQUEST _req;
    PCR_EventResponse _resp;
    _req.pcrHandle = pcrHandle;
    _req.eventData = eventData;
    this->Dispatch
    (
        TPM_CC::PCR_Event,
        TpmTypeId::PCR_EventResponse_ID,
        &_req,
        &_resp
    );
return _resp.digests;
};
PCR_ReadResponse Tpm2::PCR_Read
(
    const std::vector<TPMS_PCR_SELECTION>& pcrSelectionIn
)
{
    TPM2_PCR_Read_REQUEST _req;
    PCR_ReadResponse _resp;
    _req.pcrSelectionIn = pcrSelectionIn;
    this->Dispatch
    (
        TPM_CC::PCR_Read,
        TpmTypeId::PCR_ReadResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
PCR_AllocateResponse Tpm2::PCR_Allocate
(
    const TPM_HANDLE& authHandle,
    const std::vector<TPMS_PCR_SELECTION>& pcrAllocation
)
{
    TPM2_PCR_Allocate_REQUEST _req;
    PCR_AllocateResponse _resp;
    _req.authHandle = authHandle;
    _req.pcrAllocation = pcrAllocation;
    this->Dispatch
    (
        TPM_CC::PCR_Allocate,
        TpmTypeId::PCR_AllocateResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
void Tpm2::PCR_SetAuthPolicy
(
    const TPM_HANDLE& authHandle,
    const std::vector<BYTE>& authPolicy,
    const TPM_ALG_ID& hashAlg,
    const TPM_HANDLE& pcrNum
)
{
    TPM2_PCR_SetAuthPolicy_REQUEST _req;
    PCR_SetAuthPolicyResponse _resp;
    _req.authHandle = authHandle;
    _req.authPolicy = authPolicy;
    _req.hashAlg = hashAlg;
    _req.pcrNum = pcrNum;
    this->Dispatch
    (
        TPM_CC::PCR_SetAuthPolicy,
        TpmTypeId::PCR_SetAuthPolicyResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PCR_SetAuthValue
(
    const TPM_HANDLE& pcrHandle,
    const std::vector<BYTE>& auth
)
{
    TPM2_PCR_SetAuthValue_REQUEST _req;
    PCR_SetAuthValueResponse _resp;
    _req.pcrHandle = pcrHandle;
    _req.auth = auth;
    this->Dispatch
    (
        TPM_CC::PCR_SetAuthValue,
        TpmTypeId::PCR_SetAuthValueResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PCR_Reset
(
    const TPM_HANDLE& pcrHandle
)
{
    TPM2_PCR_Reset_REQUEST _req;
    PCR_ResetResponse _resp;
    _req.pcrHandle = pcrHandle;
    this->Dispatch
    (
        TPM_CC::PCR_Reset,
        TpmTypeId::PCR_ResetResponse_ID,
        &_req,
        &_resp
    );
return;
};
PolicySignedResponse Tpm2::PolicySigned
(
    const TPM_HANDLE& authObject,
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& nonceTPM,
    const std::vector<BYTE>& cpHashA,
    const std::vector<BYTE>& policyRef,
    const INT32& expiration,
    const TPMU_SIGNATURE& auth
)
{
    TPM2_PolicySigned_REQUEST _req;
    PolicySignedResponse _resp;
    _req.authObject = authObject;
    _req.policySession = policySession;
    _req.nonceTPM = nonceTPM;
    _req.cpHashA = cpHashA;
    _req.policyRef = policyRef;
    _req.expiration = expiration;
    _req.auth = dynamic_cast<TPMU_SIGNATURE*>(auth.Clone());
    this->Dispatch
    (
        TPM_CC::PolicySigned,
        TpmTypeId::PolicySignedResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
PolicySecretResponse Tpm2::PolicySecret
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& nonceTPM,
    const std::vector<BYTE>& cpHashA,
    const std::vector<BYTE>& policyRef,
    const INT32& expiration
)
{
    TPM2_PolicySecret_REQUEST _req;
    PolicySecretResponse _resp;
    _req.authHandle = authHandle;
    _req.policySession = policySession;
    _req.nonceTPM = nonceTPM;
    _req.cpHashA = cpHashA;
    _req.policyRef = policyRef;
    _req.expiration = expiration;
    this->Dispatch
    (
        TPM_CC::PolicySecret,
        TpmTypeId::PolicySecretResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
void Tpm2::PolicyTicket
(
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& timeout,
    const std::vector<BYTE>& cpHashA,
    const std::vector<BYTE>& policyRef,
    const std::vector<BYTE>& authName,
    const TPMT_TK_AUTH& ticket
)
{
    TPM2_PolicyTicket_REQUEST _req;
    PolicyTicketResponse _resp;
    _req.policySession = policySession;
    _req.timeout = timeout;
    _req.cpHashA = cpHashA;
    _req.policyRef = policyRef;
    _req.authName = authName;
    _req.ticket = ticket;
    this->Dispatch
    (
        TPM_CC::PolicyTicket,
        TpmTypeId::PolicyTicketResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PolicyOR
(
    const TPM_HANDLE& policySession,
    const std::vector<TPM2B_DIGEST>& pHashList
)
{
    TPM2_PolicyOR_REQUEST _req;
    PolicyORResponse _resp;
    _req.policySession = policySession;
    _req.pHashList = pHashList;
    this->Dispatch
    (
        TPM_CC::PolicyOR,
        TpmTypeId::PolicyORResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PolicyPCR
(
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& pcrDigest,
    const std::vector<TPMS_PCR_SELECTION>& pcrs
)
{
    TPM2_PolicyPCR_REQUEST _req;
    PolicyPCRResponse _resp;
    _req.policySession = policySession;
    _req.pcrDigest = pcrDigest;
    _req.pcrs = pcrs;
    this->Dispatch
    (
        TPM_CC::PolicyPCR,
        TpmTypeId::PolicyPCRResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PolicyLocality
(
    const TPM_HANDLE& policySession,
    const TPMA_LOCALITY& locality
)
{
    TPM2_PolicyLocality_REQUEST _req;
    PolicyLocalityResponse _resp;
    _req.policySession = policySession;
    _req.locality = locality;
    this->Dispatch
    (
        TPM_CC::PolicyLocality,
        TpmTypeId::PolicyLocalityResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PolicyNV
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex,
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& operandB,
    const UINT16& offset,
    const TPM_EO& operation
)
{
    TPM2_PolicyNV_REQUEST _req;
    PolicyNVResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    _req.policySession = policySession;
    _req.operandB = operandB;
    _req.offset = offset;
    _req.operation = operation;
    this->Dispatch
    (
        TPM_CC::PolicyNV,
        TpmTypeId::PolicyNVResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PolicyCounterTimer
(
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& operandB,
    const UINT16& offset,
    const TPM_EO& operation
)
{
    TPM2_PolicyCounterTimer_REQUEST _req;
    PolicyCounterTimerResponse _resp;
    _req.policySession = policySession;
    _req.operandB = operandB;
    _req.offset = offset;
    _req.operation = operation;
    this->Dispatch
    (
        TPM_CC::PolicyCounterTimer,
        TpmTypeId::PolicyCounterTimerResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PolicyCommandCode
(
    const TPM_HANDLE& policySession,
    const TPM_CC& code
)
{
    TPM2_PolicyCommandCode_REQUEST _req;
    PolicyCommandCodeResponse _resp;
    _req.policySession = policySession;
    _req.code = code;
    this->Dispatch
    (
        TPM_CC::PolicyCommandCode,
        TpmTypeId::PolicyCommandCodeResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PolicyPhysicalPresence
(
    const TPM_HANDLE& policySession
)
{
    TPM2_PolicyPhysicalPresence_REQUEST _req;
    PolicyPhysicalPresenceResponse _resp;
    _req.policySession = policySession;
    this->Dispatch
    (
        TPM_CC::PolicyPhysicalPresence,
        TpmTypeId::PolicyPhysicalPresenceResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PolicyCpHash
(
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& cpHashA
)
{
    TPM2_PolicyCpHash_REQUEST _req;
    PolicyCpHashResponse _resp;
    _req.policySession = policySession;
    _req.cpHashA = cpHashA;
    this->Dispatch
    (
        TPM_CC::PolicyCpHash,
        TpmTypeId::PolicyCpHashResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PolicyNameHash
(
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& nameHash
)
{
    TPM2_PolicyNameHash_REQUEST _req;
    PolicyNameHashResponse _resp;
    _req.policySession = policySession;
    _req.nameHash = nameHash;
    this->Dispatch
    (
        TPM_CC::PolicyNameHash,
        TpmTypeId::PolicyNameHashResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PolicyDuplicationSelect
(
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& objectName,
    const std::vector<BYTE>& newParentName,
    const BYTE& includeObject
)
{
    TPM2_PolicyDuplicationSelect_REQUEST _req;
    PolicyDuplicationSelectResponse _resp;
    _req.policySession = policySession;
    _req.objectName = objectName;
    _req.newParentName = newParentName;
    _req.includeObject = includeObject;
    this->Dispatch
    (
        TPM_CC::PolicyDuplicationSelect,
        TpmTypeId::PolicyDuplicationSelectResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PolicyAuthorize
(
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& approvedPolicy,
    const std::vector<BYTE>& policyRef,
    const std::vector<BYTE>& keySign,
    const TPMT_TK_VERIFIED& checkTicket
)
{
    TPM2_PolicyAuthorize_REQUEST _req;
    PolicyAuthorizeResponse _resp;
    _req.policySession = policySession;
    _req.approvedPolicy = approvedPolicy;
    _req.policyRef = policyRef;
    _req.keySign = keySign;
    _req.checkTicket = checkTicket;
    this->Dispatch
    (
        TPM_CC::PolicyAuthorize,
        TpmTypeId::PolicyAuthorizeResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PolicyAuthValue
(
    const TPM_HANDLE& policySession
)
{
    TPM2_PolicyAuthValue_REQUEST _req;
    PolicyAuthValueResponse _resp;
    _req.policySession = policySession;
    this->Dispatch
    (
        TPM_CC::PolicyAuthValue,
        TpmTypeId::PolicyAuthValueResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PolicyPassword
(
    const TPM_HANDLE& policySession
)
{
    TPM2_PolicyPassword_REQUEST _req;
    PolicyPasswordResponse _resp;
    _req.policySession = policySession;
    this->Dispatch
    (
        TPM_CC::PolicyPassword,
        TpmTypeId::PolicyPasswordResponse_ID,
        &_req,
        &_resp
    );
return;
};
std::vector<BYTE> Tpm2::PolicyGetDigest
(
    const TPM_HANDLE& policySession
)
{
    TPM2_PolicyGetDigest_REQUEST _req;
    PolicyGetDigestResponse _resp;
    _req.policySession = policySession;
    this->Dispatch
    (
        TPM_CC::PolicyGetDigest,
        TpmTypeId::PolicyGetDigestResponse_ID,
        &_req,
        &_resp
    );
return _resp.policyDigest;
};
void Tpm2::PolicyNvWritten
(
    const TPM_HANDLE& policySession,
    const BYTE& writtenSet
)
{
    TPM2_PolicyNvWritten_REQUEST _req;
    PolicyNvWrittenResponse _resp;
    _req.policySession = policySession;
    _req.writtenSet = writtenSet;
    this->Dispatch
    (
        TPM_CC::PolicyNvWritten,
        TpmTypeId::PolicyNvWrittenResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PolicyTemplate
(
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& templateHash
)
{
    TPM2_PolicyTemplate_REQUEST _req;
    PolicyTemplateResponse _resp;
    _req.policySession = policySession;
    _req.templateHash = templateHash;
    this->Dispatch
    (
        TPM_CC::PolicyTemplate,
        TpmTypeId::PolicyTemplateResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PolicyAuthorizeNV
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex,
    const TPM_HANDLE& policySession
)
{
    TPM2_PolicyAuthorizeNV_REQUEST _req;
    PolicyAuthorizeNVResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    _req.policySession = policySession;
    this->Dispatch
    (
        TPM_CC::PolicyAuthorizeNV,
        TpmTypeId::PolicyAuthorizeNVResponse_ID,
        &_req,
        &_resp
    );
return;
};
CreatePrimaryResponse Tpm2::CreatePrimary
(
    const TPM_HANDLE& primaryHandle,
    const TPMS_SENSITIVE_CREATE& inSensitive,
    const TPMT_PUBLIC& inPublic,
    const std::vector<BYTE>& outsideInfo,
    const std::vector<TPMS_PCR_SELECTION>& creationPCR
)
{
    TPM2_CreatePrimary_REQUEST _req;
    CreatePrimaryResponse _resp;
    _req.primaryHandle = primaryHandle;
    _req.inSensitive = inSensitive;
    _req.inPublic = inPublic;
    _req.outsideInfo = outsideInfo;
    _req.creationPCR = creationPCR;
    this->Dispatch
    (
        TPM_CC::CreatePrimary,
        TpmTypeId::CreatePrimaryResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
void Tpm2::HierarchyControl
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& enable,
    const BYTE& state
)
{
    TPM2_HierarchyControl_REQUEST _req;
    HierarchyControlResponse _resp;
    _req.authHandle = authHandle;
    _req.enable = enable;
    _req.state = state;
    this->Dispatch
    (
        TPM_CC::HierarchyControl,
        TpmTypeId::HierarchyControlResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::SetPrimaryPolicy
(
    const TPM_HANDLE& authHandle,
    const std::vector<BYTE>& authPolicy,
    const TPM_ALG_ID& hashAlg
)
{
    TPM2_SetPrimaryPolicy_REQUEST _req;
    SetPrimaryPolicyResponse _resp;
    _req.authHandle = authHandle;
    _req.authPolicy = authPolicy;
    _req.hashAlg = hashAlg;
    this->Dispatch
    (
        TPM_CC::SetPrimaryPolicy,
        TpmTypeId::SetPrimaryPolicyResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::ChangePPS
(
    const TPM_HANDLE& authHandle
)
{
    TPM2_ChangePPS_REQUEST _req;
    ChangePPSResponse _resp;
    _req.authHandle = authHandle;
    this->Dispatch
    (
        TPM_CC::ChangePPS,
        TpmTypeId::ChangePPSResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::ChangeEPS
(
    const TPM_HANDLE& authHandle
)
{
    TPM2_ChangeEPS_REQUEST _req;
    ChangeEPSResponse _resp;
    _req.authHandle = authHandle;
    this->Dispatch
    (
        TPM_CC::ChangeEPS,
        TpmTypeId::ChangeEPSResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::Clear
(
    const TPM_HANDLE& authHandle
)
{
    TPM2_Clear_REQUEST _req;
    ClearResponse _resp;
    _req.authHandle = authHandle;
    this->Dispatch
    (
        TPM_CC::Clear,
        TpmTypeId::ClearResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::ClearControl
(
    const TPM_HANDLE& auth,
    const BYTE& disable
)
{
    TPM2_ClearControl_REQUEST _req;
    ClearControlResponse _resp;
    _req.auth = auth;
    _req.disable = disable;
    this->Dispatch
    (
        TPM_CC::ClearControl,
        TpmTypeId::ClearControlResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::HierarchyChangeAuth
(
    const TPM_HANDLE& authHandle,
    const std::vector<BYTE>& newAuth
)
{
    TPM2_HierarchyChangeAuth_REQUEST _req;
    HierarchyChangeAuthResponse _resp;
    _req.authHandle = authHandle;
    _req.newAuth = newAuth;
    this->Dispatch
    (
        TPM_CC::HierarchyChangeAuth,
        TpmTypeId::HierarchyChangeAuthResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::DictionaryAttackLockReset
(
    const TPM_HANDLE& lockHandle
)
{
    TPM2_DictionaryAttackLockReset_REQUEST _req;
    DictionaryAttackLockResetResponse _resp;
    _req.lockHandle = lockHandle;
    this->Dispatch
    (
        TPM_CC::DictionaryAttackLockReset,
        TpmTypeId::DictionaryAttackLockResetResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::DictionaryAttackParameters
(
    const TPM_HANDLE& lockHandle,
    const UINT32& newMaxTries,
    const UINT32& newRecoveryTime,
    const UINT32& lockoutRecovery
)
{
    TPM2_DictionaryAttackParameters_REQUEST _req;
    DictionaryAttackParametersResponse _resp;
    _req.lockHandle = lockHandle;
    _req.newMaxTries = newMaxTries;
    _req.newRecoveryTime = newRecoveryTime;
    _req.lockoutRecovery = lockoutRecovery;
    this->Dispatch
    (
        TPM_CC::DictionaryAttackParameters,
        TpmTypeId::DictionaryAttackParametersResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::PP_Commands
(
    const TPM_HANDLE& auth,
    const std::vector<TPM_CC>& setList,
    const std::vector<TPM_CC>& clearList
)
{
    TPM2_PP_Commands_REQUEST _req;
    PP_CommandsResponse _resp;
    _req.auth = auth;
    _req.setList = setList;
    _req.clearList = clearList;
    this->Dispatch
    (
        TPM_CC::PP_Commands,
        TpmTypeId::PP_CommandsResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::SetAlgorithmSet
(
    const TPM_HANDLE& authHandle,
    const UINT32& algorithmSet
)
{
    TPM2_SetAlgorithmSet_REQUEST _req;
    SetAlgorithmSetResponse _resp;
    _req.authHandle = authHandle;
    _req.algorithmSet = algorithmSet;
    this->Dispatch
    (
        TPM_CC::SetAlgorithmSet,
        TpmTypeId::SetAlgorithmSetResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::FieldUpgradeStart
(
    const TPM_HANDLE& authorization,
    const TPM_HANDLE& keyHandle,
    const std::vector<BYTE>& fuDigest,
    const TPMU_SIGNATURE& manifestSignature
)
{
    TPM2_FieldUpgradeStart_REQUEST _req;
    FieldUpgradeStartResponse _resp;
    _req.authorization = authorization;
    _req.keyHandle = keyHandle;
    _req.fuDigest = fuDigest;
    _req.manifestSignature = dynamic_cast<TPMU_SIGNATURE*>(manifestSignature.Clone());
    this->Dispatch
    (
        TPM_CC::FieldUpgradeStart,
        TpmTypeId::FieldUpgradeStartResponse_ID,
        &_req,
        &_resp
    );
return;
};
FieldUpgradeDataResponse Tpm2::FieldUpgradeData
(
    const std::vector<BYTE>& fuData
)
{
    TPM2_FieldUpgradeData_REQUEST _req;
    FieldUpgradeDataResponse _resp;
    _req.fuData = fuData;
    this->Dispatch
    (
        TPM_CC::FieldUpgradeData,
        TpmTypeId::FieldUpgradeDataResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
std::vector<BYTE> Tpm2::FirmwareRead
(
    const UINT32& sequenceNumber
)
{
    TPM2_FirmwareRead_REQUEST _req;
    FirmwareReadResponse _resp;
    _req.sequenceNumber = sequenceNumber;
    this->Dispatch
    (
        TPM_CC::FirmwareRead,
        TpmTypeId::FirmwareReadResponse_ID,
        &_req,
        &_resp
    );
return _resp.fuData;
};
TPMS_CONTEXT Tpm2::ContextSave
(
    const TPM_HANDLE& saveHandle
)
{
    TPM2_ContextSave_REQUEST _req;
    ContextSaveResponse _resp;
    _req.saveHandle = saveHandle;
    this->Dispatch
    (
        TPM_CC::ContextSave,
        TpmTypeId::ContextSaveResponse_ID,
        &_req,
        &_resp
    );
return _resp.context;
};
TPM_HANDLE Tpm2::ContextLoad
(
    const TPMS_CONTEXT& context
)
{
    TPM2_ContextLoad_REQUEST _req;
    ContextLoadResponse _resp;
    _req.context = context;
    this->Dispatch
    (
        TPM_CC::ContextLoad,
        TpmTypeId::ContextLoadResponse_ID,
        &_req,
        &_resp
    );
return _resp.handle;
};
void Tpm2::FlushContext
(
    const TPM_HANDLE& flushHandle
)
{
    TPM2_FlushContext_REQUEST _req;
    FlushContextResponse _resp;
    _req.flushHandle = flushHandle;
    this->Dispatch
    (
        TPM_CC::FlushContext,
        TpmTypeId::FlushContextResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::EvictControl
(
    const TPM_HANDLE& auth,
    const TPM_HANDLE& objectHandle,
    const TPM_HANDLE& persistentHandle
)
{
    TPM2_EvictControl_REQUEST _req;
    EvictControlResponse _resp;
    _req.auth = auth;
    _req.objectHandle = objectHandle;
    _req.persistentHandle = persistentHandle;
    this->Dispatch
    (
        TPM_CC::EvictControl,
        TpmTypeId::EvictControlResponse_ID,
        &_req,
        &_resp
    );
return;
};
TPMS_TIME_INFO Tpm2::ReadClock
(
)
{
    ReadClockResponse _resp;
    this->Dispatch
    (
        TPM_CC::ReadClock,
        TpmTypeId::ReadClockResponse_ID,
        NULL,
        &_resp
    );
return _resp.currentTime;
};
void Tpm2::ClockSet
(
    const TPM_HANDLE& auth,
    const UINT64& newTime
)
{
    TPM2_ClockSet_REQUEST _req;
    ClockSetResponse _resp;
    _req.auth = auth;
    _req.newTime = newTime;
    this->Dispatch
    (
        TPM_CC::ClockSet,
        TpmTypeId::ClockSetResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::ClockRateAdjust
(
    const TPM_HANDLE& auth,
    const TPM_CLOCK_ADJUST& rateAdjust
)
{
    TPM2_ClockRateAdjust_REQUEST _req;
    ClockRateAdjustResponse _resp;
    _req.auth = auth;
    _req.rateAdjust = rateAdjust;
    this->Dispatch
    (
        TPM_CC::ClockRateAdjust,
        TpmTypeId::ClockRateAdjustResponse_ID,
        &_req,
        &_resp
    );
return;
};
GetCapabilityResponse Tpm2::GetCapability
(
    const TPM_CAP& capability,
    const UINT32& property,
    const UINT32& propertyCount
)
{
    TPM2_GetCapability_REQUEST _req;
    GetCapabilityResponse _resp;
    _req.capability = capability;
    _req.property = property;
    _req.propertyCount = propertyCount;
    this->Dispatch
    (
        TPM_CC::GetCapability,
        TpmTypeId::GetCapabilityResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
void Tpm2::TestParms
(
    const TPMU_PUBLIC_PARMS& parameters
)
{
    TPM2_TestParms_REQUEST _req;
    TestParmsResponse _resp;
    _req.parameters = dynamic_cast<TPMU_PUBLIC_PARMS*>(parameters.Clone());
    this->Dispatch
    (
        TPM_CC::TestParms,
        TpmTypeId::TestParmsResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::NV_DefineSpace
(
    const TPM_HANDLE& authHandle,
    const std::vector<BYTE>& auth,
    const TPMS_NV_PUBLIC& publicInfo
)
{
    TPM2_NV_DefineSpace_REQUEST _req;
    NV_DefineSpaceResponse _resp;
    _req.authHandle = authHandle;
    _req.auth = auth;
    _req.publicInfo = publicInfo;
    this->Dispatch
    (
        TPM_CC::NV_DefineSpace,
        TpmTypeId::NV_DefineSpaceResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::NV_UndefineSpace
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_UndefineSpace_REQUEST _req;
    NV_UndefineSpaceResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    this->Dispatch
    (
        TPM_CC::NV_UndefineSpace,
        TpmTypeId::NV_UndefineSpaceResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::NV_UndefineSpaceSpecial
(
    const TPM_HANDLE& nvIndex,
    const TPM_HANDLE& platform
)
{
    TPM2_NV_UndefineSpaceSpecial_REQUEST _req;
    NV_UndefineSpaceSpecialResponse _resp;
    _req.nvIndex = nvIndex;
    _req.platform = platform;
    this->Dispatch
    (
        TPM_CC::NV_UndefineSpaceSpecial,
        TpmTypeId::NV_UndefineSpaceSpecialResponse_ID,
        &_req,
        &_resp
    );
return;
};
NV_ReadPublicResponse Tpm2::NV_ReadPublic
(
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_ReadPublic_REQUEST _req;
    NV_ReadPublicResponse _resp;
    _req.nvIndex = nvIndex;
    this->Dispatch
    (
        TPM_CC::NV_ReadPublic,
        TpmTypeId::NV_ReadPublicResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
void Tpm2::NV_Write
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex,
    const std::vector<BYTE>& data,
    const UINT16& offset
)
{
    TPM2_NV_Write_REQUEST _req;
    NV_WriteResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    _req.data = data;
    _req.offset = offset;
    this->Dispatch
    (
        TPM_CC::NV_Write,
        TpmTypeId::NV_WriteResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::NV_Increment
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_Increment_REQUEST _req;
    NV_IncrementResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    this->Dispatch
    (
        TPM_CC::NV_Increment,
        TpmTypeId::NV_IncrementResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::NV_Extend
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex,
    const std::vector<BYTE>& data
)
{
    TPM2_NV_Extend_REQUEST _req;
    NV_ExtendResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    _req.data = data;
    this->Dispatch
    (
        TPM_CC::NV_Extend,
        TpmTypeId::NV_ExtendResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::NV_SetBits
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex,
    const UINT64& bits
)
{
    TPM2_NV_SetBits_REQUEST _req;
    NV_SetBitsResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    _req.bits = bits;
    this->Dispatch
    (
        TPM_CC::NV_SetBits,
        TpmTypeId::NV_SetBitsResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::NV_WriteLock
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_WriteLock_REQUEST _req;
    NV_WriteLockResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    this->Dispatch
    (
        TPM_CC::NV_WriteLock,
        TpmTypeId::NV_WriteLockResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::NV_GlobalWriteLock
(
    const TPM_HANDLE& authHandle
)
{
    TPM2_NV_GlobalWriteLock_REQUEST _req;
    NV_GlobalWriteLockResponse _resp;
    _req.authHandle = authHandle;
    this->Dispatch
    (
        TPM_CC::NV_GlobalWriteLock,
        TpmTypeId::NV_GlobalWriteLockResponse_ID,
        &_req,
        &_resp
    );
return;
};
std::vector<BYTE> Tpm2::NV_Read
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex,
    const UINT16& size,
    const UINT16& offset
)
{
    TPM2_NV_Read_REQUEST _req;
    NV_ReadResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    _req.size = size;
    _req.offset = offset;
    this->Dispatch
    (
        TPM_CC::NV_Read,
        TpmTypeId::NV_ReadResponse_ID,
        &_req,
        &_resp
    );
return _resp.data;
};
void Tpm2::NV_ReadLock
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_ReadLock_REQUEST _req;
    NV_ReadLockResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    this->Dispatch
    (
        TPM_CC::NV_ReadLock,
        TpmTypeId::NV_ReadLockResponse_ID,
        &_req,
        &_resp
    );
return;
};
void Tpm2::NV_ChangeAuth
(
    const TPM_HANDLE& nvIndex,
    const std::vector<BYTE>& newAuth
)
{
    TPM2_NV_ChangeAuth_REQUEST _req;
    NV_ChangeAuthResponse _resp;
    _req.nvIndex = nvIndex;
    _req.newAuth = newAuth;
    this->Dispatch
    (
        TPM_CC::NV_ChangeAuth,
        TpmTypeId::NV_ChangeAuthResponse_ID,
        &_req,
        &_resp
    );
return;
};
NV_CertifyResponse Tpm2::NV_Certify
(
    const TPM_HANDLE& signHandle,
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex,
    const std::vector<BYTE>& qualifyingData,
    const TPMU_SIG_SCHEME& inScheme,
    const UINT16& size,
    const UINT16& offset
)
{
    TPM2_NV_Certify_REQUEST _req;
    NV_CertifyResponse _resp;
    _req.signHandle = signHandle;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    _req.qualifyingData = qualifyingData;
    _req.inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(inScheme.Clone());
    _req.size = size;
    _req.offset = offset;
    this->Dispatch
    (
        TPM_CC::NV_Certify,
        TpmTypeId::NV_CertifyResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
AC_GetCapabilityResponse Tpm2::AC_GetCapability
(
    const TPM_HANDLE& ac,
    const TPM_AT& capability,
    const UINT32& count
)
{
    TPM2_AC_GetCapability_REQUEST _req;
    AC_GetCapabilityResponse _resp;
    _req.ac = ac;
    _req.capability = capability;
    _req.count = count;
    this->Dispatch
    (
        TPM_CC::AC_GetCapability,
        TpmTypeId::AC_GetCapabilityResponse_ID,
        &_req,
        &_resp
    );
return _resp;
};
TPMS_AC_OUTPUT Tpm2::AC_Send
(
    const TPM_HANDLE& sendObject,
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& ac,
    const std::vector<BYTE>& acDataIn
)
{
    TPM2_AC_Send_REQUEST _req;
    AC_SendResponse _resp;
    _req.sendObject = sendObject;
    _req.authHandle = authHandle;
    _req.ac = ac;
    _req.acDataIn = acDataIn;
    this->Dispatch
    (
        TPM_CC::AC_Send,
        TpmTypeId::AC_SendResponse_ID,
        &_req,
        &_resp
    );
return _resp.acDataOut;
};
void Tpm2::Policy_AC_SendSelect
(
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& objectName,
    const std::vector<BYTE>& authHandleName,
    const std::vector<BYTE>& acName,
    const BYTE& includeObject
)
{
    TPM2_Policy_AC_SendSelect_REQUEST _req;
    Policy_AC_SendSelectResponse _resp;
    _req.policySession = policySession;
    _req.objectName = objectName;
    _req.authHandleName = authHandleName;
    _req.acName = acName;
    _req.includeObject = includeObject;
    this->Dispatch
    (
        TPM_CC::Policy_AC_SendSelect,
        TpmTypeId::Policy_AC_SendSelectResponse_ID,
        &_req,
        &_resp
    );
return;
};
std::vector<BYTE> Tpm2::Vendor_TCG_Test
(
    const std::vector<BYTE>& inputData
)
{
    TPM2_Vendor_TCG_Test_REQUEST _req;
    Vendor_TCG_TestResponse _resp;
    _req.inputData = inputData;
    this->Dispatch
    (
        TPM_CC::Vendor_TCG_Test,
        TpmTypeId::Vendor_TCG_TestResponse_ID,
        &_req,
        &_resp
    );
return _resp.outputData;
};
void Tpm2::AsyncMethods::Startup
(
    const TPM_SU& startupType
)
{
    TPM2_Startup_REQUEST _req;
    StartupResponse _resp;
    _req.startupType = startupType;
    theTpm.DispatchOut
    (
        TPM_CC::Startup,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::Shutdown
(
    const TPM_SU& shutdownType
)
{
    TPM2_Shutdown_REQUEST _req;
    ShutdownResponse _resp;
    _req.shutdownType = shutdownType;
    theTpm.DispatchOut
    (
        TPM_CC::Shutdown,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::SelfTest
(
    const BYTE& fullTest
)
{
    TPM2_SelfTest_REQUEST _req;
    SelfTestResponse _resp;
    _req.fullTest = fullTest;
    theTpm.DispatchOut
    (
        TPM_CC::SelfTest,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::IncrementalSelfTest
(
    const std::vector<TPM_ALG_ID>& toTest
)
{
    TPM2_IncrementalSelfTest_REQUEST _req;
    IncrementalSelfTestResponse _resp;
    _req.toTest = toTest;
    theTpm.DispatchOut
    (
        TPM_CC::IncrementalSelfTest,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::GetTestResult
(
)
{
    GetTestResultResponse _resp;
    theTpm.DispatchOut
    (
        TPM_CC::GetTestResult,
        NULL
    );
return;
};
void Tpm2::AsyncMethods::StartAuthSession
(
    const TPM_HANDLE& tpmKey,
    const TPM_HANDLE& bind,
    const std::vector<BYTE>& nonceCaller,
    const std::vector<BYTE>& encryptedSalt,
    const TPM_SE& sessionType,
    const TPMT_SYM_DEF& symmetric,
    const TPM_ALG_ID& authHash
)
{
    TPM2_StartAuthSession_REQUEST _req;
    StartAuthSessionResponse _resp;
    _req.tpmKey = tpmKey;
    _req.bind = bind;
    _req.nonceCaller = nonceCaller;
    _req.encryptedSalt = encryptedSalt;
    _req.sessionType = sessionType;
    _req.symmetric = symmetric;
    _req.authHash = authHash;
    theTpm.DispatchOut
    (
        TPM_CC::StartAuthSession,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyRestart
(
    const TPM_HANDLE& sessionHandle
)
{
    TPM2_PolicyRestart_REQUEST _req;
    PolicyRestartResponse _resp;
    _req.sessionHandle = sessionHandle;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyRestart,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::Create
(
    const TPM_HANDLE& parentHandle,
    const TPMS_SENSITIVE_CREATE& inSensitive,
    const TPMT_PUBLIC& inPublic,
    const std::vector<BYTE>& outsideInfo,
    const std::vector<TPMS_PCR_SELECTION>& creationPCR
)
{
    TPM2_Create_REQUEST _req;
    CreateResponse _resp;
    _req.parentHandle = parentHandle;
    _req.inSensitive = inSensitive;
    _req.inPublic = inPublic;
    _req.outsideInfo = outsideInfo;
    _req.creationPCR = creationPCR;
    theTpm.DispatchOut
    (
        TPM_CC::Create,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::Load
(
    const TPM_HANDLE& parentHandle,
    const TPM2B_PRIVATE& inPrivate,
    const TPMT_PUBLIC& inPublic
)
{
    TPM2_Load_REQUEST _req;
    LoadResponse _resp;
    _req.parentHandle = parentHandle;
    _req.inPrivate = inPrivate;
    _req.inPublic = inPublic;
    theTpm.DispatchOut
    (
        TPM_CC::Load,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::LoadExternal
(
    const TPMT_SENSITIVE& inPrivate,
    const TPMT_PUBLIC& inPublic,
    const TPM_HANDLE& hierarchy
)
{
    TPM2_LoadExternal_REQUEST _req;
    LoadExternalResponse _resp;
    _req.inPrivate = inPrivate;
    _req.inPublic = inPublic;
    _req.hierarchy = hierarchy;
    theTpm.DispatchOut
    (
        TPM_CC::LoadExternal,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::ReadPublic
(
    const TPM_HANDLE& objectHandle
)
{
    TPM2_ReadPublic_REQUEST _req;
    ReadPublicResponse _resp;
    _req.objectHandle = objectHandle;
    theTpm.DispatchOut
    (
        TPM_CC::ReadPublic,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::ActivateCredential
(
    const TPM_HANDLE& activateHandle,
    const TPM_HANDLE& keyHandle,
    const TPMS_ID_OBJECT& credentialBlob,
    const std::vector<BYTE>& secret
)
{
    TPM2_ActivateCredential_REQUEST _req;
    ActivateCredentialResponse _resp;
    _req.activateHandle = activateHandle;
    _req.keyHandle = keyHandle;
    _req.credentialBlob = credentialBlob;
    _req.secret = secret;
    theTpm.DispatchOut
    (
        TPM_CC::ActivateCredential,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::MakeCredential
(
    const TPM_HANDLE& handle,
    const std::vector<BYTE>& credential,
    const std::vector<BYTE>& objectName
)
{
    TPM2_MakeCredential_REQUEST _req;
    MakeCredentialResponse _resp;
    _req.handle = handle;
    _req.credential = credential;
    _req.objectName = objectName;
    theTpm.DispatchOut
    (
        TPM_CC::MakeCredential,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::Unseal
(
    const TPM_HANDLE& itemHandle
)
{
    TPM2_Unseal_REQUEST _req;
    UnsealResponse _resp;
    _req.itemHandle = itemHandle;
    theTpm.DispatchOut
    (
        TPM_CC::Unseal,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::ObjectChangeAuth
(
    const TPM_HANDLE& objectHandle,
    const TPM_HANDLE& parentHandle,
    const std::vector<BYTE>& newAuth
)
{
    TPM2_ObjectChangeAuth_REQUEST _req;
    ObjectChangeAuthResponse _resp;
    _req.objectHandle = objectHandle;
    _req.parentHandle = parentHandle;
    _req.newAuth = newAuth;
    theTpm.DispatchOut
    (
        TPM_CC::ObjectChangeAuth,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::CreateLoaded
(
    const TPM_HANDLE& parentHandle,
    const TPMS_SENSITIVE_CREATE& inSensitive,
    const std::vector<BYTE>& inPublic
)
{
    TPM2_CreateLoaded_REQUEST _req;
    CreateLoadedResponse _resp;
    _req.parentHandle = parentHandle;
    _req.inSensitive = inSensitive;
    _req.inPublic = inPublic;
    theTpm.DispatchOut
    (
        TPM_CC::CreateLoaded,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::Duplicate
(
    const TPM_HANDLE& objectHandle,
    const TPM_HANDLE& newParentHandle,
    const std::vector<BYTE>& encryptionKeyIn,
    const TPMT_SYM_DEF_OBJECT& symmetricAlg
)
{
    TPM2_Duplicate_REQUEST _req;
    DuplicateResponse _resp;
    _req.objectHandle = objectHandle;
    _req.newParentHandle = newParentHandle;
    _req.encryptionKeyIn = encryptionKeyIn;
    _req.symmetricAlg = symmetricAlg;
    theTpm.DispatchOut
    (
        TPM_CC::Duplicate,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::Rewrap
(
    const TPM_HANDLE& oldParent,
    const TPM_HANDLE& newParent,
    const TPM2B_PRIVATE& inDuplicate,
    const std::vector<BYTE>& name,
    const std::vector<BYTE>& inSymSeed
)
{
    TPM2_Rewrap_REQUEST _req;
    RewrapResponse _resp;
    _req.oldParent = oldParent;
    _req.newParent = newParent;
    _req.inDuplicate = inDuplicate;
    _req.name = name;
    _req.inSymSeed = inSymSeed;
    theTpm.DispatchOut
    (
        TPM_CC::Rewrap,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::Import
(
    const TPM_HANDLE& parentHandle,
    const std::vector<BYTE>& encryptionKey,
    const TPMT_PUBLIC& objectPublic,
    const TPM2B_PRIVATE& duplicate,
    const std::vector<BYTE>& inSymSeed,
    const TPMT_SYM_DEF_OBJECT& symmetricAlg
)
{
    TPM2_Import_REQUEST _req;
    ImportResponse _resp;
    _req.parentHandle = parentHandle;
    _req.encryptionKey = encryptionKey;
    _req.objectPublic = objectPublic;
    _req.duplicate = duplicate;
    _req.inSymSeed = inSymSeed;
    _req.symmetricAlg = symmetricAlg;
    theTpm.DispatchOut
    (
        TPM_CC::Import,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::RSA_Encrypt
(
    const TPM_HANDLE& keyHandle,
    const std::vector<BYTE>& message,
    const TPMU_ASYM_SCHEME& inScheme,
    const std::vector<BYTE>& label
)
{
    TPM2_RSA_Encrypt_REQUEST _req;
    RSA_EncryptResponse _resp;
    _req.keyHandle = keyHandle;
    _req.message = message;
    _req.inScheme = dynamic_cast<TPMU_ASYM_SCHEME*>(inScheme.Clone());
    _req.label = label;
    theTpm.DispatchOut
    (
        TPM_CC::RSA_Encrypt,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::RSA_Decrypt
(
    const TPM_HANDLE& keyHandle,
    const std::vector<BYTE>& cipherText,
    const TPMU_ASYM_SCHEME& inScheme,
    const std::vector<BYTE>& label
)
{
    TPM2_RSA_Decrypt_REQUEST _req;
    RSA_DecryptResponse _resp;
    _req.keyHandle = keyHandle;
    _req.cipherText = cipherText;
    _req.inScheme = dynamic_cast<TPMU_ASYM_SCHEME*>(inScheme.Clone());
    _req.label = label;
    theTpm.DispatchOut
    (
        TPM_CC::RSA_Decrypt,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::ECDH_KeyGen
(
    const TPM_HANDLE& keyHandle
)
{
    TPM2_ECDH_KeyGen_REQUEST _req;
    ECDH_KeyGenResponse _resp;
    _req.keyHandle = keyHandle;
    theTpm.DispatchOut
    (
        TPM_CC::ECDH_KeyGen,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::ECDH_ZGen
(
    const TPM_HANDLE& keyHandle,
    const TPMS_ECC_POINT& inPoint
)
{
    TPM2_ECDH_ZGen_REQUEST _req;
    ECDH_ZGenResponse _resp;
    _req.keyHandle = keyHandle;
    _req.inPoint = inPoint;
    theTpm.DispatchOut
    (
        TPM_CC::ECDH_ZGen,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::ECC_Parameters
(
    const TPM_ECC_CURVE& curveID
)
{
    TPM2_ECC_Parameters_REQUEST _req;
    ECC_ParametersResponse _resp;
    _req.curveID = curveID;
    theTpm.DispatchOut
    (
        TPM_CC::ECC_Parameters,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::ZGen_2Phase
(
    const TPM_HANDLE& keyA,
    const TPMS_ECC_POINT& inQsB,
    const TPMS_ECC_POINT& inQeB,
    const TPM_ALG_ID& inScheme,
    const UINT16& counter
)
{
    TPM2_ZGen_2Phase_REQUEST _req;
    ZGen_2PhaseResponse _resp;
    _req.keyA = keyA;
    _req.inQsB = inQsB;
    _req.inQeB = inQeB;
    _req.inScheme = inScheme;
    _req.counter = counter;
    theTpm.DispatchOut
    (
        TPM_CC::ZGen_2Phase,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::EncryptDecrypt
(
    const TPM_HANDLE& keyHandle,
    const BYTE& decrypt,
    const TPM_ALG_ID& mode,
    const std::vector<BYTE>& ivIn,
    const std::vector<BYTE>& inData
)
{
    TPM2_EncryptDecrypt_REQUEST _req;
    EncryptDecryptResponse _resp;
    _req.keyHandle = keyHandle;
    _req.decrypt = decrypt;
    _req.mode = mode;
    _req.ivIn = ivIn;
    _req.inData = inData;
    theTpm.DispatchOut
    (
        TPM_CC::EncryptDecrypt,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::EncryptDecrypt2
(
    const TPM_HANDLE& keyHandle,
    const std::vector<BYTE>& inData,
    const BYTE& decrypt,
    const TPM_ALG_ID& mode,
    const std::vector<BYTE>& ivIn
)
{
    TPM2_EncryptDecrypt2_REQUEST _req;
    EncryptDecrypt2Response _resp;
    _req.keyHandle = keyHandle;
    _req.inData = inData;
    _req.decrypt = decrypt;
    _req.mode = mode;
    _req.ivIn = ivIn;
    theTpm.DispatchOut
    (
        TPM_CC::EncryptDecrypt2,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::Hash
(
    const std::vector<BYTE>& data,
    const TPM_ALG_ID& hashAlg,
    const TPM_HANDLE& hierarchy
)
{
    TPM2_Hash_REQUEST _req;
    HashResponse _resp;
    _req.data = data;
    _req.hashAlg = hashAlg;
    _req.hierarchy = hierarchy;
    theTpm.DispatchOut
    (
        TPM_CC::Hash,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::HMAC
(
    const TPM_HANDLE& handle,
    const std::vector<BYTE>& buffer,
    const TPM_ALG_ID& hashAlg
)
{
    TPM2_HMAC_REQUEST _req;
    HMACResponse _resp;
    _req.handle = handle;
    _req.buffer = buffer;
    _req.hashAlg = hashAlg;
    theTpm.DispatchOut
    (
        TPM_CC::HMAC,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::MAC
(
    const TPM_HANDLE& handle,
    const std::vector<BYTE>& buffer,
    const TPM_ALG_ID& inScheme
)
{
    TPM2_MAC_REQUEST _req;
    MACResponse _resp;
    _req.handle = handle;
    _req.buffer = buffer;
    _req.inScheme = inScheme;
    theTpm.DispatchOut
    (
        TPM_CC::MAC,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::GetRandom
(
    const UINT16& bytesRequested
)
{
    TPM2_GetRandom_REQUEST _req;
    GetRandomResponse _resp;
    _req.bytesRequested = bytesRequested;
    theTpm.DispatchOut
    (
        TPM_CC::GetRandom,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::StirRandom
(
    const std::vector<BYTE>& inData
)
{
    TPM2_StirRandom_REQUEST _req;
    StirRandomResponse _resp;
    _req.inData = inData;
    theTpm.DispatchOut
    (
        TPM_CC::StirRandom,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::HMAC_Start
(
    const TPM_HANDLE& handle,
    const std::vector<BYTE>& auth,
    const TPM_ALG_ID& hashAlg
)
{
    TPM2_HMAC_Start_REQUEST _req;
    HMAC_StartResponse _resp;
    _req.handle = handle;
    _req.auth = auth;
    _req.hashAlg = hashAlg;
    theTpm.DispatchOut
    (
        TPM_CC::HMAC_Start,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::MAC_Start
(
    const TPM_HANDLE& handle,
    const std::vector<BYTE>& auth,
    const TPM_ALG_ID& inScheme
)
{
    TPM2_MAC_Start_REQUEST _req;
    MAC_StartResponse _resp;
    _req.handle = handle;
    _req.auth = auth;
    _req.inScheme = inScheme;
    theTpm.DispatchOut
    (
        TPM_CC::MAC_Start,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::HashSequenceStart
(
    const std::vector<BYTE>& auth,
    const TPM_ALG_ID& hashAlg
)
{
    TPM2_HashSequenceStart_REQUEST _req;
    HashSequenceStartResponse _resp;
    _req.auth = auth;
    _req.hashAlg = hashAlg;
    theTpm.DispatchOut
    (
        TPM_CC::HashSequenceStart,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::SequenceUpdate
(
    const TPM_HANDLE& sequenceHandle,
    const std::vector<BYTE>& buffer
)
{
    TPM2_SequenceUpdate_REQUEST _req;
    SequenceUpdateResponse _resp;
    _req.sequenceHandle = sequenceHandle;
    _req.buffer = buffer;
    theTpm.DispatchOut
    (
        TPM_CC::SequenceUpdate,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::SequenceComplete
(
    const TPM_HANDLE& sequenceHandle,
    const std::vector<BYTE>& buffer,
    const TPM_HANDLE& hierarchy
)
{
    TPM2_SequenceComplete_REQUEST _req;
    SequenceCompleteResponse _resp;
    _req.sequenceHandle = sequenceHandle;
    _req.buffer = buffer;
    _req.hierarchy = hierarchy;
    theTpm.DispatchOut
    (
        TPM_CC::SequenceComplete,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::EventSequenceComplete
(
    const TPM_HANDLE& pcrHandle,
    const TPM_HANDLE& sequenceHandle,
    const std::vector<BYTE>& buffer
)
{
    TPM2_EventSequenceComplete_REQUEST _req;
    EventSequenceCompleteResponse _resp;
    _req.pcrHandle = pcrHandle;
    _req.sequenceHandle = sequenceHandle;
    _req.buffer = buffer;
    theTpm.DispatchOut
    (
        TPM_CC::EventSequenceComplete,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::Certify
(
    const TPM_HANDLE& objectHandle,
    const TPM_HANDLE& signHandle,
    const std::vector<BYTE>& qualifyingData,
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_Certify_REQUEST _req;
    CertifyResponse _resp;
    _req.objectHandle = objectHandle;
    _req.signHandle = signHandle;
    _req.qualifyingData = qualifyingData;
    _req.inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(inScheme.Clone());
    theTpm.DispatchOut
    (
        TPM_CC::Certify,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::CertifyCreation
(
    const TPM_HANDLE& signHandle,
    const TPM_HANDLE& objectHandle,
    const std::vector<BYTE>& qualifyingData,
    const std::vector<BYTE>& creationHash,
    const TPMU_SIG_SCHEME& inScheme,
    const TPMT_TK_CREATION& creationTicket
)
{
    TPM2_CertifyCreation_REQUEST _req;
    CertifyCreationResponse _resp;
    _req.signHandle = signHandle;
    _req.objectHandle = objectHandle;
    _req.qualifyingData = qualifyingData;
    _req.creationHash = creationHash;
    _req.inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(inScheme.Clone());
    _req.creationTicket = creationTicket;
    theTpm.DispatchOut
    (
        TPM_CC::CertifyCreation,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::Quote
(
    const TPM_HANDLE& signHandle,
    const std::vector<BYTE>& qualifyingData,
    const TPMU_SIG_SCHEME& inScheme,
    const std::vector<TPMS_PCR_SELECTION>& PCRselect
)
{
    TPM2_Quote_REQUEST _req;
    QuoteResponse _resp;
    _req.signHandle = signHandle;
    _req.qualifyingData = qualifyingData;
    _req.inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(inScheme.Clone());
    _req.PCRselect = PCRselect;
    theTpm.DispatchOut
    (
        TPM_CC::Quote,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::GetSessionAuditDigest
(
    const TPM_HANDLE& privacyAdminHandle,
    const TPM_HANDLE& signHandle,
    const TPM_HANDLE& sessionHandle,
    const std::vector<BYTE>& qualifyingData,
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_GetSessionAuditDigest_REQUEST _req;
    GetSessionAuditDigestResponse _resp;
    _req.privacyAdminHandle = privacyAdminHandle;
    _req.signHandle = signHandle;
    _req.sessionHandle = sessionHandle;
    _req.qualifyingData = qualifyingData;
    _req.inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(inScheme.Clone());
    theTpm.DispatchOut
    (
        TPM_CC::GetSessionAuditDigest,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::GetCommandAuditDigest
(
    const TPM_HANDLE& privacyHandle,
    const TPM_HANDLE& signHandle,
    const std::vector<BYTE>& qualifyingData,
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_GetCommandAuditDigest_REQUEST _req;
    GetCommandAuditDigestResponse _resp;
    _req.privacyHandle = privacyHandle;
    _req.signHandle = signHandle;
    _req.qualifyingData = qualifyingData;
    _req.inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(inScheme.Clone());
    theTpm.DispatchOut
    (
        TPM_CC::GetCommandAuditDigest,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::GetTime
(
    const TPM_HANDLE& privacyAdminHandle,
    const TPM_HANDLE& signHandle,
    const std::vector<BYTE>& qualifyingData,
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_GetTime_REQUEST _req;
    GetTimeResponse _resp;
    _req.privacyAdminHandle = privacyAdminHandle;
    _req.signHandle = signHandle;
    _req.qualifyingData = qualifyingData;
    _req.inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(inScheme.Clone());
    theTpm.DispatchOut
    (
        TPM_CC::GetTime,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::CertifyX509
(
    const TPM_HANDLE& objectHandle,
    const TPM_HANDLE& signHandle,
    const std::vector<BYTE>& qualifyingData,
    const TPMU_SIG_SCHEME& inScheme,
    const std::vector<BYTE>& partialCertificate
)
{
    TPM2_CertifyX509_REQUEST _req;
    CertifyX509Response _resp;
    _req.objectHandle = objectHandle;
    _req.signHandle = signHandle;
    _req.qualifyingData = qualifyingData;
    _req.inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(inScheme.Clone());
    _req.partialCertificate = partialCertificate;
    theTpm.DispatchOut
    (
        TPM_CC::CertifyX509,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::Commit
(
    const TPM_HANDLE& signHandle,
    const TPMS_ECC_POINT& P1,
    const std::vector<BYTE>& s2,
    const std::vector<BYTE>& y2
)
{
    TPM2_Commit_REQUEST _req;
    CommitResponse _resp;
    _req.signHandle = signHandle;
    _req.P1 = P1;
    _req.s2 = s2;
    _req.y2 = y2;
    theTpm.DispatchOut
    (
        TPM_CC::Commit,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::EC_Ephemeral
(
    const TPM_ECC_CURVE& curveID
)
{
    TPM2_EC_Ephemeral_REQUEST _req;
    EC_EphemeralResponse _resp;
    _req.curveID = curveID;
    theTpm.DispatchOut
    (
        TPM_CC::EC_Ephemeral,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::VerifySignature
(
    const TPM_HANDLE& keyHandle,
    const std::vector<BYTE>& digest,
    const TPMU_SIGNATURE& signature
)
{
    TPM2_VerifySignature_REQUEST _req;
    VerifySignatureResponse _resp;
    _req.keyHandle = keyHandle;
    _req.digest = digest;
    _req.signature = dynamic_cast<TPMU_SIGNATURE*>(signature.Clone());
    theTpm.DispatchOut
    (
        TPM_CC::VerifySignature,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::Sign
(
    const TPM_HANDLE& keyHandle,
    const std::vector<BYTE>& digest,
    const TPMU_SIG_SCHEME& inScheme,
    const TPMT_TK_HASHCHECK& validation
)
{
    TPM2_Sign_REQUEST _req;
    SignResponse _resp;
    _req.keyHandle = keyHandle;
    _req.digest = digest;
    _req.inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(inScheme.Clone());
    _req.validation = validation;
    theTpm.DispatchOut
    (
        TPM_CC::Sign,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::SetCommandCodeAuditStatus
(
    const TPM_HANDLE& auth,
    const TPM_ALG_ID& auditAlg,
    const std::vector<TPM_CC>& setList,
    const std::vector<TPM_CC>& clearList
)
{
    TPM2_SetCommandCodeAuditStatus_REQUEST _req;
    SetCommandCodeAuditStatusResponse _resp;
    _req.auth = auth;
    _req.auditAlg = auditAlg;
    _req.setList = setList;
    _req.clearList = clearList;
    theTpm.DispatchOut
    (
        TPM_CC::SetCommandCodeAuditStatus,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PCR_Extend
(
    const TPM_HANDLE& pcrHandle,
    const std::vector<TPMT_HA>& digests
)
{
    TPM2_PCR_Extend_REQUEST _req;
    PCR_ExtendResponse _resp;
    _req.pcrHandle = pcrHandle;
    _req.digests = digests;
    theTpm.DispatchOut
    (
        TPM_CC::PCR_Extend,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PCR_Event
(
    const TPM_HANDLE& pcrHandle,
    const std::vector<BYTE>& eventData
)
{
    TPM2_PCR_Event_REQUEST _req;
    PCR_EventResponse _resp;
    _req.pcrHandle = pcrHandle;
    _req.eventData = eventData;
    theTpm.DispatchOut
    (
        TPM_CC::PCR_Event,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PCR_Read
(
    const std::vector<TPMS_PCR_SELECTION>& pcrSelectionIn
)
{
    TPM2_PCR_Read_REQUEST _req;
    PCR_ReadResponse _resp;
    _req.pcrSelectionIn = pcrSelectionIn;
    theTpm.DispatchOut
    (
        TPM_CC::PCR_Read,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PCR_Allocate
(
    const TPM_HANDLE& authHandle,
    const std::vector<TPMS_PCR_SELECTION>& pcrAllocation
)
{
    TPM2_PCR_Allocate_REQUEST _req;
    PCR_AllocateResponse _resp;
    _req.authHandle = authHandle;
    _req.pcrAllocation = pcrAllocation;
    theTpm.DispatchOut
    (
        TPM_CC::PCR_Allocate,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PCR_SetAuthPolicy
(
    const TPM_HANDLE& authHandle,
    const std::vector<BYTE>& authPolicy,
    const TPM_ALG_ID& hashAlg,
    const TPM_HANDLE& pcrNum
)
{
    TPM2_PCR_SetAuthPolicy_REQUEST _req;
    PCR_SetAuthPolicyResponse _resp;
    _req.authHandle = authHandle;
    _req.authPolicy = authPolicy;
    _req.hashAlg = hashAlg;
    _req.pcrNum = pcrNum;
    theTpm.DispatchOut
    (
        TPM_CC::PCR_SetAuthPolicy,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PCR_SetAuthValue
(
    const TPM_HANDLE& pcrHandle,
    const std::vector<BYTE>& auth
)
{
    TPM2_PCR_SetAuthValue_REQUEST _req;
    PCR_SetAuthValueResponse _resp;
    _req.pcrHandle = pcrHandle;
    _req.auth = auth;
    theTpm.DispatchOut
    (
        TPM_CC::PCR_SetAuthValue,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PCR_Reset
(
    const TPM_HANDLE& pcrHandle
)
{
    TPM2_PCR_Reset_REQUEST _req;
    PCR_ResetResponse _resp;
    _req.pcrHandle = pcrHandle;
    theTpm.DispatchOut
    (
        TPM_CC::PCR_Reset,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicySigned
(
    const TPM_HANDLE& authObject,
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& nonceTPM,
    const std::vector<BYTE>& cpHashA,
    const std::vector<BYTE>& policyRef,
    const INT32& expiration,
    const TPMU_SIGNATURE& auth
)
{
    TPM2_PolicySigned_REQUEST _req;
    PolicySignedResponse _resp;
    _req.authObject = authObject;
    _req.policySession = policySession;
    _req.nonceTPM = nonceTPM;
    _req.cpHashA = cpHashA;
    _req.policyRef = policyRef;
    _req.expiration = expiration;
    _req.auth = dynamic_cast<TPMU_SIGNATURE*>(auth.Clone());
    theTpm.DispatchOut
    (
        TPM_CC::PolicySigned,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicySecret
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& nonceTPM,
    const std::vector<BYTE>& cpHashA,
    const std::vector<BYTE>& policyRef,
    const INT32& expiration
)
{
    TPM2_PolicySecret_REQUEST _req;
    PolicySecretResponse _resp;
    _req.authHandle = authHandle;
    _req.policySession = policySession;
    _req.nonceTPM = nonceTPM;
    _req.cpHashA = cpHashA;
    _req.policyRef = policyRef;
    _req.expiration = expiration;
    theTpm.DispatchOut
    (
        TPM_CC::PolicySecret,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyTicket
(
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& timeout,
    const std::vector<BYTE>& cpHashA,
    const std::vector<BYTE>& policyRef,
    const std::vector<BYTE>& authName,
    const TPMT_TK_AUTH& ticket
)
{
    TPM2_PolicyTicket_REQUEST _req;
    PolicyTicketResponse _resp;
    _req.policySession = policySession;
    _req.timeout = timeout;
    _req.cpHashA = cpHashA;
    _req.policyRef = policyRef;
    _req.authName = authName;
    _req.ticket = ticket;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyTicket,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyOR
(
    const TPM_HANDLE& policySession,
    const std::vector<TPM2B_DIGEST>& pHashList
)
{
    TPM2_PolicyOR_REQUEST _req;
    PolicyORResponse _resp;
    _req.policySession = policySession;
    _req.pHashList = pHashList;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyOR,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyPCR
(
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& pcrDigest,
    const std::vector<TPMS_PCR_SELECTION>& pcrs
)
{
    TPM2_PolicyPCR_REQUEST _req;
    PolicyPCRResponse _resp;
    _req.policySession = policySession;
    _req.pcrDigest = pcrDigest;
    _req.pcrs = pcrs;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyPCR,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyLocality
(
    const TPM_HANDLE& policySession,
    const TPMA_LOCALITY& locality
)
{
    TPM2_PolicyLocality_REQUEST _req;
    PolicyLocalityResponse _resp;
    _req.policySession = policySession;
    _req.locality = locality;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyLocality,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyNV
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex,
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& operandB,
    const UINT16& offset,
    const TPM_EO& operation
)
{
    TPM2_PolicyNV_REQUEST _req;
    PolicyNVResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    _req.policySession = policySession;
    _req.operandB = operandB;
    _req.offset = offset;
    _req.operation = operation;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyNV,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyCounterTimer
(
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& operandB,
    const UINT16& offset,
    const TPM_EO& operation
)
{
    TPM2_PolicyCounterTimer_REQUEST _req;
    PolicyCounterTimerResponse _resp;
    _req.policySession = policySession;
    _req.operandB = operandB;
    _req.offset = offset;
    _req.operation = operation;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyCounterTimer,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyCommandCode
(
    const TPM_HANDLE& policySession,
    const TPM_CC& code
)
{
    TPM2_PolicyCommandCode_REQUEST _req;
    PolicyCommandCodeResponse _resp;
    _req.policySession = policySession;
    _req.code = code;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyCommandCode,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyPhysicalPresence
(
    const TPM_HANDLE& policySession
)
{
    TPM2_PolicyPhysicalPresence_REQUEST _req;
    PolicyPhysicalPresenceResponse _resp;
    _req.policySession = policySession;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyPhysicalPresence,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyCpHash
(
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& cpHashA
)
{
    TPM2_PolicyCpHash_REQUEST _req;
    PolicyCpHashResponse _resp;
    _req.policySession = policySession;
    _req.cpHashA = cpHashA;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyCpHash,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyNameHash
(
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& nameHash
)
{
    TPM2_PolicyNameHash_REQUEST _req;
    PolicyNameHashResponse _resp;
    _req.policySession = policySession;
    _req.nameHash = nameHash;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyNameHash,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyDuplicationSelect
(
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& objectName,
    const std::vector<BYTE>& newParentName,
    const BYTE& includeObject
)
{
    TPM2_PolicyDuplicationSelect_REQUEST _req;
    PolicyDuplicationSelectResponse _resp;
    _req.policySession = policySession;
    _req.objectName = objectName;
    _req.newParentName = newParentName;
    _req.includeObject = includeObject;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyDuplicationSelect,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyAuthorize
(
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& approvedPolicy,
    const std::vector<BYTE>& policyRef,
    const std::vector<BYTE>& keySign,
    const TPMT_TK_VERIFIED& checkTicket
)
{
    TPM2_PolicyAuthorize_REQUEST _req;
    PolicyAuthorizeResponse _resp;
    _req.policySession = policySession;
    _req.approvedPolicy = approvedPolicy;
    _req.policyRef = policyRef;
    _req.keySign = keySign;
    _req.checkTicket = checkTicket;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyAuthorize,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyAuthValue
(
    const TPM_HANDLE& policySession
)
{
    TPM2_PolicyAuthValue_REQUEST _req;
    PolicyAuthValueResponse _resp;
    _req.policySession = policySession;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyAuthValue,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyPassword
(
    const TPM_HANDLE& policySession
)
{
    TPM2_PolicyPassword_REQUEST _req;
    PolicyPasswordResponse _resp;
    _req.policySession = policySession;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyPassword,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyGetDigest
(
    const TPM_HANDLE& policySession
)
{
    TPM2_PolicyGetDigest_REQUEST _req;
    PolicyGetDigestResponse _resp;
    _req.policySession = policySession;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyGetDigest,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyNvWritten
(
    const TPM_HANDLE& policySession,
    const BYTE& writtenSet
)
{
    TPM2_PolicyNvWritten_REQUEST _req;
    PolicyNvWrittenResponse _resp;
    _req.policySession = policySession;
    _req.writtenSet = writtenSet;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyNvWritten,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyTemplate
(
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& templateHash
)
{
    TPM2_PolicyTemplate_REQUEST _req;
    PolicyTemplateResponse _resp;
    _req.policySession = policySession;
    _req.templateHash = templateHash;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyTemplate,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PolicyAuthorizeNV
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex,
    const TPM_HANDLE& policySession
)
{
    TPM2_PolicyAuthorizeNV_REQUEST _req;
    PolicyAuthorizeNVResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    _req.policySession = policySession;
    theTpm.DispatchOut
    (
        TPM_CC::PolicyAuthorizeNV,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::CreatePrimary
(
    const TPM_HANDLE& primaryHandle,
    const TPMS_SENSITIVE_CREATE& inSensitive,
    const TPMT_PUBLIC& inPublic,
    const std::vector<BYTE>& outsideInfo,
    const std::vector<TPMS_PCR_SELECTION>& creationPCR
)
{
    TPM2_CreatePrimary_REQUEST _req;
    CreatePrimaryResponse _resp;
    _req.primaryHandle = primaryHandle;
    _req.inSensitive = inSensitive;
    _req.inPublic = inPublic;
    _req.outsideInfo = outsideInfo;
    _req.creationPCR = creationPCR;
    theTpm.DispatchOut
    (
        TPM_CC::CreatePrimary,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::HierarchyControl
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& enable,
    const BYTE& state
)
{
    TPM2_HierarchyControl_REQUEST _req;
    HierarchyControlResponse _resp;
    _req.authHandle = authHandle;
    _req.enable = enable;
    _req.state = state;
    theTpm.DispatchOut
    (
        TPM_CC::HierarchyControl,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::SetPrimaryPolicy
(
    const TPM_HANDLE& authHandle,
    const std::vector<BYTE>& authPolicy,
    const TPM_ALG_ID& hashAlg
)
{
    TPM2_SetPrimaryPolicy_REQUEST _req;
    SetPrimaryPolicyResponse _resp;
    _req.authHandle = authHandle;
    _req.authPolicy = authPolicy;
    _req.hashAlg = hashAlg;
    theTpm.DispatchOut
    (
        TPM_CC::SetPrimaryPolicy,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::ChangePPS
(
    const TPM_HANDLE& authHandle
)
{
    TPM2_ChangePPS_REQUEST _req;
    ChangePPSResponse _resp;
    _req.authHandle = authHandle;
    theTpm.DispatchOut
    (
        TPM_CC::ChangePPS,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::ChangeEPS
(
    const TPM_HANDLE& authHandle
)
{
    TPM2_ChangeEPS_REQUEST _req;
    ChangeEPSResponse _resp;
    _req.authHandle = authHandle;
    theTpm.DispatchOut
    (
        TPM_CC::ChangeEPS,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::Clear
(
    const TPM_HANDLE& authHandle
)
{
    TPM2_Clear_REQUEST _req;
    ClearResponse _resp;
    _req.authHandle = authHandle;
    theTpm.DispatchOut
    (
        TPM_CC::Clear,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::ClearControl
(
    const TPM_HANDLE& auth,
    const BYTE& disable
)
{
    TPM2_ClearControl_REQUEST _req;
    ClearControlResponse _resp;
    _req.auth = auth;
    _req.disable = disable;
    theTpm.DispatchOut
    (
        TPM_CC::ClearControl,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::HierarchyChangeAuth
(
    const TPM_HANDLE& authHandle,
    const std::vector<BYTE>& newAuth
)
{
    TPM2_HierarchyChangeAuth_REQUEST _req;
    HierarchyChangeAuthResponse _resp;
    _req.authHandle = authHandle;
    _req.newAuth = newAuth;
    theTpm.DispatchOut
    (
        TPM_CC::HierarchyChangeAuth,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::DictionaryAttackLockReset
(
    const TPM_HANDLE& lockHandle
)
{
    TPM2_DictionaryAttackLockReset_REQUEST _req;
    DictionaryAttackLockResetResponse _resp;
    _req.lockHandle = lockHandle;
    theTpm.DispatchOut
    (
        TPM_CC::DictionaryAttackLockReset,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::DictionaryAttackParameters
(
    const TPM_HANDLE& lockHandle,
    const UINT32& newMaxTries,
    const UINT32& newRecoveryTime,
    const UINT32& lockoutRecovery
)
{
    TPM2_DictionaryAttackParameters_REQUEST _req;
    DictionaryAttackParametersResponse _resp;
    _req.lockHandle = lockHandle;
    _req.newMaxTries = newMaxTries;
    _req.newRecoveryTime = newRecoveryTime;
    _req.lockoutRecovery = lockoutRecovery;
    theTpm.DispatchOut
    (
        TPM_CC::DictionaryAttackParameters,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::PP_Commands
(
    const TPM_HANDLE& auth,
    const std::vector<TPM_CC>& setList,
    const std::vector<TPM_CC>& clearList
)
{
    TPM2_PP_Commands_REQUEST _req;
    PP_CommandsResponse _resp;
    _req.auth = auth;
    _req.setList = setList;
    _req.clearList = clearList;
    theTpm.DispatchOut
    (
        TPM_CC::PP_Commands,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::SetAlgorithmSet
(
    const TPM_HANDLE& authHandle,
    const UINT32& algorithmSet
)
{
    TPM2_SetAlgorithmSet_REQUEST _req;
    SetAlgorithmSetResponse _resp;
    _req.authHandle = authHandle;
    _req.algorithmSet = algorithmSet;
    theTpm.DispatchOut
    (
        TPM_CC::SetAlgorithmSet,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::FieldUpgradeStart
(
    const TPM_HANDLE& authorization,
    const TPM_HANDLE& keyHandle,
    const std::vector<BYTE>& fuDigest,
    const TPMU_SIGNATURE& manifestSignature
)
{
    TPM2_FieldUpgradeStart_REQUEST _req;
    FieldUpgradeStartResponse _resp;
    _req.authorization = authorization;
    _req.keyHandle = keyHandle;
    _req.fuDigest = fuDigest;
    _req.manifestSignature = dynamic_cast<TPMU_SIGNATURE*>(manifestSignature.Clone());
    theTpm.DispatchOut
    (
        TPM_CC::FieldUpgradeStart,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::FieldUpgradeData
(
    const std::vector<BYTE>& fuData
)
{
    TPM2_FieldUpgradeData_REQUEST _req;
    FieldUpgradeDataResponse _resp;
    _req.fuData = fuData;
    theTpm.DispatchOut
    (
        TPM_CC::FieldUpgradeData,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::FirmwareRead
(
    const UINT32& sequenceNumber
)
{
    TPM2_FirmwareRead_REQUEST _req;
    FirmwareReadResponse _resp;
    _req.sequenceNumber = sequenceNumber;
    theTpm.DispatchOut
    (
        TPM_CC::FirmwareRead,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::ContextSave
(
    const TPM_HANDLE& saveHandle
)
{
    TPM2_ContextSave_REQUEST _req;
    ContextSaveResponse _resp;
    _req.saveHandle = saveHandle;
    theTpm.DispatchOut
    (
        TPM_CC::ContextSave,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::ContextLoad
(
    const TPMS_CONTEXT& context
)
{
    TPM2_ContextLoad_REQUEST _req;
    ContextLoadResponse _resp;
    _req.context = context;
    theTpm.DispatchOut
    (
        TPM_CC::ContextLoad,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::FlushContext
(
    const TPM_HANDLE& flushHandle
)
{
    TPM2_FlushContext_REQUEST _req;
    FlushContextResponse _resp;
    _req.flushHandle = flushHandle;
    theTpm.DispatchOut
    (
        TPM_CC::FlushContext,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::EvictControl
(
    const TPM_HANDLE& auth,
    const TPM_HANDLE& objectHandle,
    const TPM_HANDLE& persistentHandle
)
{
    TPM2_EvictControl_REQUEST _req;
    EvictControlResponse _resp;
    _req.auth = auth;
    _req.objectHandle = objectHandle;
    _req.persistentHandle = persistentHandle;
    theTpm.DispatchOut
    (
        TPM_CC::EvictControl,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::ReadClock
(
)
{
    ReadClockResponse _resp;
    theTpm.DispatchOut
    (
        TPM_CC::ReadClock,
        NULL
    );
return;
};
void Tpm2::AsyncMethods::ClockSet
(
    const TPM_HANDLE& auth,
    const UINT64& newTime
)
{
    TPM2_ClockSet_REQUEST _req;
    ClockSetResponse _resp;
    _req.auth = auth;
    _req.newTime = newTime;
    theTpm.DispatchOut
    (
        TPM_CC::ClockSet,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::ClockRateAdjust
(
    const TPM_HANDLE& auth,
    const TPM_CLOCK_ADJUST& rateAdjust
)
{
    TPM2_ClockRateAdjust_REQUEST _req;
    ClockRateAdjustResponse _resp;
    _req.auth = auth;
    _req.rateAdjust = rateAdjust;
    theTpm.DispatchOut
    (
        TPM_CC::ClockRateAdjust,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::GetCapability
(
    const TPM_CAP& capability,
    const UINT32& property,
    const UINT32& propertyCount
)
{
    TPM2_GetCapability_REQUEST _req;
    GetCapabilityResponse _resp;
    _req.capability = capability;
    _req.property = property;
    _req.propertyCount = propertyCount;
    theTpm.DispatchOut
    (
        TPM_CC::GetCapability,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::TestParms
(
    const TPMU_PUBLIC_PARMS& parameters
)
{
    TPM2_TestParms_REQUEST _req;
    TestParmsResponse _resp;
    _req.parameters = dynamic_cast<TPMU_PUBLIC_PARMS*>(parameters.Clone());
    theTpm.DispatchOut
    (
        TPM_CC::TestParms,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::NV_DefineSpace
(
    const TPM_HANDLE& authHandle,
    const std::vector<BYTE>& auth,
    const TPMS_NV_PUBLIC& publicInfo
)
{
    TPM2_NV_DefineSpace_REQUEST _req;
    NV_DefineSpaceResponse _resp;
    _req.authHandle = authHandle;
    _req.auth = auth;
    _req.publicInfo = publicInfo;
    theTpm.DispatchOut
    (
        TPM_CC::NV_DefineSpace,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::NV_UndefineSpace
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_UndefineSpace_REQUEST _req;
    NV_UndefineSpaceResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    theTpm.DispatchOut
    (
        TPM_CC::NV_UndefineSpace,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::NV_UndefineSpaceSpecial
(
    const TPM_HANDLE& nvIndex,
    const TPM_HANDLE& platform
)
{
    TPM2_NV_UndefineSpaceSpecial_REQUEST _req;
    NV_UndefineSpaceSpecialResponse _resp;
    _req.nvIndex = nvIndex;
    _req.platform = platform;
    theTpm.DispatchOut
    (
        TPM_CC::NV_UndefineSpaceSpecial,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::NV_ReadPublic
(
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_ReadPublic_REQUEST _req;
    NV_ReadPublicResponse _resp;
    _req.nvIndex = nvIndex;
    theTpm.DispatchOut
    (
        TPM_CC::NV_ReadPublic,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::NV_Write
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex,
    const std::vector<BYTE>& data,
    const UINT16& offset
)
{
    TPM2_NV_Write_REQUEST _req;
    NV_WriteResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    _req.data = data;
    _req.offset = offset;
    theTpm.DispatchOut
    (
        TPM_CC::NV_Write,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::NV_Increment
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_Increment_REQUEST _req;
    NV_IncrementResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    theTpm.DispatchOut
    (
        TPM_CC::NV_Increment,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::NV_Extend
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex,
    const std::vector<BYTE>& data
)
{
    TPM2_NV_Extend_REQUEST _req;
    NV_ExtendResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    _req.data = data;
    theTpm.DispatchOut
    (
        TPM_CC::NV_Extend,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::NV_SetBits
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex,
    const UINT64& bits
)
{
    TPM2_NV_SetBits_REQUEST _req;
    NV_SetBitsResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    _req.bits = bits;
    theTpm.DispatchOut
    (
        TPM_CC::NV_SetBits,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::NV_WriteLock
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_WriteLock_REQUEST _req;
    NV_WriteLockResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    theTpm.DispatchOut
    (
        TPM_CC::NV_WriteLock,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::NV_GlobalWriteLock
(
    const TPM_HANDLE& authHandle
)
{
    TPM2_NV_GlobalWriteLock_REQUEST _req;
    NV_GlobalWriteLockResponse _resp;
    _req.authHandle = authHandle;
    theTpm.DispatchOut
    (
        TPM_CC::NV_GlobalWriteLock,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::NV_Read
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex,
    const UINT16& size,
    const UINT16& offset
)
{
    TPM2_NV_Read_REQUEST _req;
    NV_ReadResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    _req.size = size;
    _req.offset = offset;
    theTpm.DispatchOut
    (
        TPM_CC::NV_Read,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::NV_ReadLock
(
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_ReadLock_REQUEST _req;
    NV_ReadLockResponse _resp;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    theTpm.DispatchOut
    (
        TPM_CC::NV_ReadLock,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::NV_ChangeAuth
(
    const TPM_HANDLE& nvIndex,
    const std::vector<BYTE>& newAuth
)
{
    TPM2_NV_ChangeAuth_REQUEST _req;
    NV_ChangeAuthResponse _resp;
    _req.nvIndex = nvIndex;
    _req.newAuth = newAuth;
    theTpm.DispatchOut
    (
        TPM_CC::NV_ChangeAuth,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::NV_Certify
(
    const TPM_HANDLE& signHandle,
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& nvIndex,
    const std::vector<BYTE>& qualifyingData,
    const TPMU_SIG_SCHEME& inScheme,
    const UINT16& size,
    const UINT16& offset
)
{
    TPM2_NV_Certify_REQUEST _req;
    NV_CertifyResponse _resp;
    _req.signHandle = signHandle;
    _req.authHandle = authHandle;
    _req.nvIndex = nvIndex;
    _req.qualifyingData = qualifyingData;
    _req.inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(inScheme.Clone());
    _req.size = size;
    _req.offset = offset;
    theTpm.DispatchOut
    (
        TPM_CC::NV_Certify,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::AC_GetCapability
(
    const TPM_HANDLE& ac,
    const TPM_AT& capability,
    const UINT32& count
)
{
    TPM2_AC_GetCapability_REQUEST _req;
    AC_GetCapabilityResponse _resp;
    _req.ac = ac;
    _req.capability = capability;
    _req.count = count;
    theTpm.DispatchOut
    (
        TPM_CC::AC_GetCapability,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::AC_Send
(
    const TPM_HANDLE& sendObject,
    const TPM_HANDLE& authHandle,
    const TPM_HANDLE& ac,
    const std::vector<BYTE>& acDataIn
)
{
    TPM2_AC_Send_REQUEST _req;
    AC_SendResponse _resp;
    _req.sendObject = sendObject;
    _req.authHandle = authHandle;
    _req.ac = ac;
    _req.acDataIn = acDataIn;
    theTpm.DispatchOut
    (
        TPM_CC::AC_Send,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::Policy_AC_SendSelect
(
    const TPM_HANDLE& policySession,
    const std::vector<BYTE>& objectName,
    const std::vector<BYTE>& authHandleName,
    const std::vector<BYTE>& acName,
    const BYTE& includeObject
)
{
    TPM2_Policy_AC_SendSelect_REQUEST _req;
    Policy_AC_SendSelectResponse _resp;
    _req.policySession = policySession;
    _req.objectName = objectName;
    _req.authHandleName = authHandleName;
    _req.acName = acName;
    _req.includeObject = includeObject;
    theTpm.DispatchOut
    (
        TPM_CC::Policy_AC_SendSelect,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::Vendor_TCG_Test
(
    const std::vector<BYTE>& inputData
)
{
    TPM2_Vendor_TCG_Test_REQUEST _req;
    Vendor_TCG_TestResponse _resp;
    _req.inputData = inputData;
    theTpm.DispatchOut
    (
        TPM_CC::Vendor_TCG_Test,
        &_req
    );
return;
};
void Tpm2::AsyncMethods::StartupComplete
(
)
{
    StartupResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::Startup,
        TpmTypeId::StartupResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::ShutdownComplete
(
)
{
    ShutdownResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::Shutdown,
        TpmTypeId::ShutdownResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::SelfTestComplete
(
)
{
    SelfTestResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::SelfTest,
        TpmTypeId::SelfTestResponse_ID,
        &_resp
    );
return;
};
std::vector<TPM_ALG_ID> Tpm2::AsyncMethods::IncrementalSelfTestComplete
(
)
{
    IncrementalSelfTestResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::IncrementalSelfTest,
        TpmTypeId::IncrementalSelfTestResponse_ID,
        &_resp
    );
return _resp.toDoList;
};
GetTestResultResponse Tpm2::AsyncMethods::GetTestResultComplete
(
)
{
    GetTestResultResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::GetTestResult,
        TpmTypeId::GetTestResultResponse_ID,
        &_resp
    );
return _resp;
};
StartAuthSessionResponse Tpm2::AsyncMethods::StartAuthSessionComplete
(
)
{
    StartAuthSessionResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::StartAuthSession,
        TpmTypeId::StartAuthSessionResponse_ID,
        &_resp
    );
return _resp;
};
void Tpm2::AsyncMethods::PolicyRestartComplete
(
)
{
    PolicyRestartResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyRestart,
        TpmTypeId::PolicyRestartResponse_ID,
        &_resp
    );
return;
};
CreateResponse Tpm2::AsyncMethods::CreateComplete
(
)
{
    CreateResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::Create,
        TpmTypeId::CreateResponse_ID,
        &_resp
    );
return _resp;
};
LoadResponse Tpm2::AsyncMethods::LoadComplete
(
)
{
    LoadResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::Load,
        TpmTypeId::LoadResponse_ID,
        &_resp
    );
return _resp;
};
LoadExternalResponse Tpm2::AsyncMethods::LoadExternalComplete
(
)
{
    LoadExternalResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::LoadExternal,
        TpmTypeId::LoadExternalResponse_ID,
        &_resp
    );
return _resp;
};
ReadPublicResponse Tpm2::AsyncMethods::ReadPublicComplete
(
)
{
    ReadPublicResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::ReadPublic,
        TpmTypeId::ReadPublicResponse_ID,
        &_resp
    );
return _resp;
};
std::vector<BYTE> Tpm2::AsyncMethods::ActivateCredentialComplete
(
)
{
    ActivateCredentialResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::ActivateCredential,
        TpmTypeId::ActivateCredentialResponse_ID,
        &_resp
    );
return _resp.certInfo;
};
MakeCredentialResponse Tpm2::AsyncMethods::MakeCredentialComplete
(
)
{
    MakeCredentialResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::MakeCredential,
        TpmTypeId::MakeCredentialResponse_ID,
        &_resp
    );
return _resp;
};
std::vector<BYTE> Tpm2::AsyncMethods::UnsealComplete
(
)
{
    UnsealResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::Unseal,
        TpmTypeId::UnsealResponse_ID,
        &_resp
    );
return _resp.outData;
};
TPM2B_PRIVATE Tpm2::AsyncMethods::ObjectChangeAuthComplete
(
)
{
    ObjectChangeAuthResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::ObjectChangeAuth,
        TpmTypeId::ObjectChangeAuthResponse_ID,
        &_resp
    );
return _resp.outPrivate;
};
CreateLoadedResponse Tpm2::AsyncMethods::CreateLoadedComplete
(
)
{
    CreateLoadedResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::CreateLoaded,
        TpmTypeId::CreateLoadedResponse_ID,
        &_resp
    );
return _resp;
};
DuplicateResponse Tpm2::AsyncMethods::DuplicateComplete
(
)
{
    DuplicateResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::Duplicate,
        TpmTypeId::DuplicateResponse_ID,
        &_resp
    );
return _resp;
};
RewrapResponse Tpm2::AsyncMethods::RewrapComplete
(
)
{
    RewrapResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::Rewrap,
        TpmTypeId::RewrapResponse_ID,
        &_resp
    );
return _resp;
};
TPM2B_PRIVATE Tpm2::AsyncMethods::ImportComplete
(
)
{
    ImportResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::Import,
        TpmTypeId::ImportResponse_ID,
        &_resp
    );
return _resp.outPrivate;
};
std::vector<BYTE> Tpm2::AsyncMethods::RSA_EncryptComplete
(
)
{
    RSA_EncryptResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::RSA_Encrypt,
        TpmTypeId::RSA_EncryptResponse_ID,
        &_resp
    );
return _resp.outData;
};
std::vector<BYTE> Tpm2::AsyncMethods::RSA_DecryptComplete
(
)
{
    RSA_DecryptResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::RSA_Decrypt,
        TpmTypeId::RSA_DecryptResponse_ID,
        &_resp
    );
return _resp.message;
};
ECDH_KeyGenResponse Tpm2::AsyncMethods::ECDH_KeyGenComplete
(
)
{
    ECDH_KeyGenResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::ECDH_KeyGen,
        TpmTypeId::ECDH_KeyGenResponse_ID,
        &_resp
    );
return _resp;
};
TPMS_ECC_POINT Tpm2::AsyncMethods::ECDH_ZGenComplete
(
)
{
    ECDH_ZGenResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::ECDH_ZGen,
        TpmTypeId::ECDH_ZGenResponse_ID,
        &_resp
    );
return _resp.outPoint;
};
TPMS_ALGORITHM_DETAIL_ECC Tpm2::AsyncMethods::ECC_ParametersComplete
(
)
{
    ECC_ParametersResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::ECC_Parameters,
        TpmTypeId::ECC_ParametersResponse_ID,
        &_resp
    );
return _resp.parameters;
};
ZGen_2PhaseResponse Tpm2::AsyncMethods::ZGen_2PhaseComplete
(
)
{
    ZGen_2PhaseResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::ZGen_2Phase,
        TpmTypeId::ZGen_2PhaseResponse_ID,
        &_resp
    );
return _resp;
};
EncryptDecryptResponse Tpm2::AsyncMethods::EncryptDecryptComplete
(
)
{
    EncryptDecryptResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::EncryptDecrypt,
        TpmTypeId::EncryptDecryptResponse_ID,
        &_resp
    );
return _resp;
};
EncryptDecrypt2Response Tpm2::AsyncMethods::EncryptDecrypt2Complete
(
)
{
    EncryptDecrypt2Response _resp;
    theTpm.DispatchIn
    (
        TPM_CC::EncryptDecrypt2,
        TpmTypeId::EncryptDecrypt2Response_ID,
        &_resp
    );
return _resp;
};
HashResponse Tpm2::AsyncMethods::HashComplete
(
)
{
    HashResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::Hash,
        TpmTypeId::HashResponse_ID,
        &_resp
    );
return _resp;
};
std::vector<BYTE> Tpm2::AsyncMethods::HMACComplete
(
)
{
    HMACResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::HMAC,
        TpmTypeId::HMACResponse_ID,
        &_resp
    );
return _resp.outHMAC;
};
std::vector<BYTE> Tpm2::AsyncMethods::MACComplete
(
)
{
    MACResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::MAC,
        TpmTypeId::MACResponse_ID,
        &_resp
    );
return _resp.outMAC;
};
std::vector<BYTE> Tpm2::AsyncMethods::GetRandomComplete
(
)
{
    GetRandomResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::GetRandom,
        TpmTypeId::GetRandomResponse_ID,
        &_resp
    );
return _resp.randomBytes;
};
void Tpm2::AsyncMethods::StirRandomComplete
(
)
{
    StirRandomResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::StirRandom,
        TpmTypeId::StirRandomResponse_ID,
        &_resp
    );
return;
};
TPM_HANDLE Tpm2::AsyncMethods::HMAC_StartComplete
(
)
{
    HMAC_StartResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::HMAC_Start,
        TpmTypeId::HMAC_StartResponse_ID,
        &_resp
    );
return _resp.handle;
};
TPM_HANDLE Tpm2::AsyncMethods::MAC_StartComplete
(
)
{
    MAC_StartResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::MAC_Start,
        TpmTypeId::MAC_StartResponse_ID,
        &_resp
    );
return _resp.handle;
};
TPM_HANDLE Tpm2::AsyncMethods::HashSequenceStartComplete
(
)
{
    HashSequenceStartResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::HashSequenceStart,
        TpmTypeId::HashSequenceStartResponse_ID,
        &_resp
    );
return _resp.handle;
};
void Tpm2::AsyncMethods::SequenceUpdateComplete
(
)
{
    SequenceUpdateResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::SequenceUpdate,
        TpmTypeId::SequenceUpdateResponse_ID,
        &_resp
    );
return;
};
SequenceCompleteResponse Tpm2::AsyncMethods::SequenceCompleteComplete
(
)
{
    SequenceCompleteResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::SequenceComplete,
        TpmTypeId::SequenceCompleteResponse_ID,
        &_resp
    );
return _resp;
};
std::vector<TPMT_HA> Tpm2::AsyncMethods::EventSequenceCompleteComplete
(
)
{
    EventSequenceCompleteResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::EventSequenceComplete,
        TpmTypeId::EventSequenceCompleteResponse_ID,
        &_resp
    );
return _resp.results;
};
CertifyResponse Tpm2::AsyncMethods::CertifyComplete
(
)
{
    CertifyResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::Certify,
        TpmTypeId::CertifyResponse_ID,
        &_resp
    );
return _resp;
};
CertifyCreationResponse Tpm2::AsyncMethods::CertifyCreationComplete
(
)
{
    CertifyCreationResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::CertifyCreation,
        TpmTypeId::CertifyCreationResponse_ID,
        &_resp
    );
return _resp;
};
QuoteResponse Tpm2::AsyncMethods::QuoteComplete
(
)
{
    QuoteResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::Quote,
        TpmTypeId::QuoteResponse_ID,
        &_resp
    );
return _resp;
};
GetSessionAuditDigestResponse Tpm2::AsyncMethods::GetSessionAuditDigestComplete
(
)
{
    GetSessionAuditDigestResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::GetSessionAuditDigest,
        TpmTypeId::GetSessionAuditDigestResponse_ID,
        &_resp
    );
return _resp;
};
GetCommandAuditDigestResponse Tpm2::AsyncMethods::GetCommandAuditDigestComplete
(
)
{
    GetCommandAuditDigestResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::GetCommandAuditDigest,
        TpmTypeId::GetCommandAuditDigestResponse_ID,
        &_resp
    );
return _resp;
};
GetTimeResponse Tpm2::AsyncMethods::GetTimeComplete
(
)
{
    GetTimeResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::GetTime,
        TpmTypeId::GetTimeResponse_ID,
        &_resp
    );
return _resp;
};
CertifyX509Response Tpm2::AsyncMethods::CertifyX509Complete
(
)
{
    CertifyX509Response _resp;
    theTpm.DispatchIn
    (
        TPM_CC::CertifyX509,
        TpmTypeId::CertifyX509Response_ID,
        &_resp
    );
return _resp;
};
CommitResponse Tpm2::AsyncMethods::CommitComplete
(
)
{
    CommitResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::Commit,
        TpmTypeId::CommitResponse_ID,
        &_resp
    );
return _resp;
};
EC_EphemeralResponse Tpm2::AsyncMethods::EC_EphemeralComplete
(
)
{
    EC_EphemeralResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::EC_Ephemeral,
        TpmTypeId::EC_EphemeralResponse_ID,
        &_resp
    );
return _resp;
};
VerifySignatureResponse Tpm2::AsyncMethods::VerifySignatureComplete
(
)
{
    VerifySignatureResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::VerifySignature,
        TpmTypeId::VerifySignatureResponse_ID,
        &_resp
    );
return _resp.validation;
};
SignResponse Tpm2::AsyncMethods::SignComplete
(
)
{
    SignResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::Sign,
        TpmTypeId::SignResponse_ID,
        &_resp
    );
return _resp;
};
void Tpm2::AsyncMethods::SetCommandCodeAuditStatusComplete
(
)
{
    SetCommandCodeAuditStatusResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::SetCommandCodeAuditStatus,
        TpmTypeId::SetCommandCodeAuditStatusResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PCR_ExtendComplete
(
)
{
    PCR_ExtendResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PCR_Extend,
        TpmTypeId::PCR_ExtendResponse_ID,
        &_resp
    );
return;
};
std::vector<TPMT_HA> Tpm2::AsyncMethods::PCR_EventComplete
(
)
{
    PCR_EventResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PCR_Event,
        TpmTypeId::PCR_EventResponse_ID,
        &_resp
    );
return _resp.digests;
};
PCR_ReadResponse Tpm2::AsyncMethods::PCR_ReadComplete
(
)
{
    PCR_ReadResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PCR_Read,
        TpmTypeId::PCR_ReadResponse_ID,
        &_resp
    );
return _resp;
};
PCR_AllocateResponse Tpm2::AsyncMethods::PCR_AllocateComplete
(
)
{
    PCR_AllocateResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PCR_Allocate,
        TpmTypeId::PCR_AllocateResponse_ID,
        &_resp
    );
return _resp;
};
void Tpm2::AsyncMethods::PCR_SetAuthPolicyComplete
(
)
{
    PCR_SetAuthPolicyResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PCR_SetAuthPolicy,
        TpmTypeId::PCR_SetAuthPolicyResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PCR_SetAuthValueComplete
(
)
{
    PCR_SetAuthValueResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PCR_SetAuthValue,
        TpmTypeId::PCR_SetAuthValueResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PCR_ResetComplete
(
)
{
    PCR_ResetResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PCR_Reset,
        TpmTypeId::PCR_ResetResponse_ID,
        &_resp
    );
return;
};
PolicySignedResponse Tpm2::AsyncMethods::PolicySignedComplete
(
)
{
    PolicySignedResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicySigned,
        TpmTypeId::PolicySignedResponse_ID,
        &_resp
    );
return _resp;
};
PolicySecretResponse Tpm2::AsyncMethods::PolicySecretComplete
(
)
{
    PolicySecretResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicySecret,
        TpmTypeId::PolicySecretResponse_ID,
        &_resp
    );
return _resp;
};
void Tpm2::AsyncMethods::PolicyTicketComplete
(
)
{
    PolicyTicketResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyTicket,
        TpmTypeId::PolicyTicketResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PolicyORComplete
(
)
{
    PolicyORResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyOR,
        TpmTypeId::PolicyORResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PolicyPCRComplete
(
)
{
    PolicyPCRResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyPCR,
        TpmTypeId::PolicyPCRResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PolicyLocalityComplete
(
)
{
    PolicyLocalityResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyLocality,
        TpmTypeId::PolicyLocalityResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PolicyNVComplete
(
)
{
    PolicyNVResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyNV,
        TpmTypeId::PolicyNVResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PolicyCounterTimerComplete
(
)
{
    PolicyCounterTimerResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyCounterTimer,
        TpmTypeId::PolicyCounterTimerResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PolicyCommandCodeComplete
(
)
{
    PolicyCommandCodeResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyCommandCode,
        TpmTypeId::PolicyCommandCodeResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PolicyPhysicalPresenceComplete
(
)
{
    PolicyPhysicalPresenceResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyPhysicalPresence,
        TpmTypeId::PolicyPhysicalPresenceResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PolicyCpHashComplete
(
)
{
    PolicyCpHashResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyCpHash,
        TpmTypeId::PolicyCpHashResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PolicyNameHashComplete
(
)
{
    PolicyNameHashResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyNameHash,
        TpmTypeId::PolicyNameHashResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PolicyDuplicationSelectComplete
(
)
{
    PolicyDuplicationSelectResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyDuplicationSelect,
        TpmTypeId::PolicyDuplicationSelectResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PolicyAuthorizeComplete
(
)
{
    PolicyAuthorizeResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyAuthorize,
        TpmTypeId::PolicyAuthorizeResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PolicyAuthValueComplete
(
)
{
    PolicyAuthValueResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyAuthValue,
        TpmTypeId::PolicyAuthValueResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PolicyPasswordComplete
(
)
{
    PolicyPasswordResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyPassword,
        TpmTypeId::PolicyPasswordResponse_ID,
        &_resp
    );
return;
};
std::vector<BYTE> Tpm2::AsyncMethods::PolicyGetDigestComplete
(
)
{
    PolicyGetDigestResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyGetDigest,
        TpmTypeId::PolicyGetDigestResponse_ID,
        &_resp
    );
return _resp.policyDigest;
};
void Tpm2::AsyncMethods::PolicyNvWrittenComplete
(
)
{
    PolicyNvWrittenResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyNvWritten,
        TpmTypeId::PolicyNvWrittenResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PolicyTemplateComplete
(
)
{
    PolicyTemplateResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyTemplate,
        TpmTypeId::PolicyTemplateResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PolicyAuthorizeNVComplete
(
)
{
    PolicyAuthorizeNVResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PolicyAuthorizeNV,
        TpmTypeId::PolicyAuthorizeNVResponse_ID,
        &_resp
    );
return;
};
CreatePrimaryResponse Tpm2::AsyncMethods::CreatePrimaryComplete
(
)
{
    CreatePrimaryResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::CreatePrimary,
        TpmTypeId::CreatePrimaryResponse_ID,
        &_resp
    );
return _resp;
};
void Tpm2::AsyncMethods::HierarchyControlComplete
(
)
{
    HierarchyControlResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::HierarchyControl,
        TpmTypeId::HierarchyControlResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::SetPrimaryPolicyComplete
(
)
{
    SetPrimaryPolicyResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::SetPrimaryPolicy,
        TpmTypeId::SetPrimaryPolicyResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::ChangePPSComplete
(
)
{
    ChangePPSResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::ChangePPS,
        TpmTypeId::ChangePPSResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::ChangeEPSComplete
(
)
{
    ChangeEPSResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::ChangeEPS,
        TpmTypeId::ChangeEPSResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::ClearComplete
(
)
{
    ClearResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::Clear,
        TpmTypeId::ClearResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::ClearControlComplete
(
)
{
    ClearControlResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::ClearControl,
        TpmTypeId::ClearControlResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::HierarchyChangeAuthComplete
(
)
{
    HierarchyChangeAuthResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::HierarchyChangeAuth,
        TpmTypeId::HierarchyChangeAuthResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::DictionaryAttackLockResetComplete
(
)
{
    DictionaryAttackLockResetResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::DictionaryAttackLockReset,
        TpmTypeId::DictionaryAttackLockResetResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::DictionaryAttackParametersComplete
(
)
{
    DictionaryAttackParametersResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::DictionaryAttackParameters,
        TpmTypeId::DictionaryAttackParametersResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::PP_CommandsComplete
(
)
{
    PP_CommandsResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::PP_Commands,
        TpmTypeId::PP_CommandsResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::SetAlgorithmSetComplete
(
)
{
    SetAlgorithmSetResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::SetAlgorithmSet,
        TpmTypeId::SetAlgorithmSetResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::FieldUpgradeStartComplete
(
)
{
    FieldUpgradeStartResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::FieldUpgradeStart,
        TpmTypeId::FieldUpgradeStartResponse_ID,
        &_resp
    );
return;
};
FieldUpgradeDataResponse Tpm2::AsyncMethods::FieldUpgradeDataComplete
(
)
{
    FieldUpgradeDataResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::FieldUpgradeData,
        TpmTypeId::FieldUpgradeDataResponse_ID,
        &_resp
    );
return _resp;
};
std::vector<BYTE> Tpm2::AsyncMethods::FirmwareReadComplete
(
)
{
    FirmwareReadResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::FirmwareRead,
        TpmTypeId::FirmwareReadResponse_ID,
        &_resp
    );
return _resp.fuData;
};
TPMS_CONTEXT Tpm2::AsyncMethods::ContextSaveComplete
(
)
{
    ContextSaveResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::ContextSave,
        TpmTypeId::ContextSaveResponse_ID,
        &_resp
    );
return _resp.context;
};
TPM_HANDLE Tpm2::AsyncMethods::ContextLoadComplete
(
)
{
    ContextLoadResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::ContextLoad,
        TpmTypeId::ContextLoadResponse_ID,
        &_resp
    );
return _resp.handle;
};
void Tpm2::AsyncMethods::FlushContextComplete
(
)
{
    FlushContextResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::FlushContext,
        TpmTypeId::FlushContextResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::EvictControlComplete
(
)
{
    EvictControlResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::EvictControl,
        TpmTypeId::EvictControlResponse_ID,
        &_resp
    );
return;
};
TPMS_TIME_INFO Tpm2::AsyncMethods::ReadClockComplete
(
)
{
    ReadClockResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::ReadClock,
        TpmTypeId::ReadClockResponse_ID,
        &_resp
    );
return _resp.currentTime;
};
void Tpm2::AsyncMethods::ClockSetComplete
(
)
{
    ClockSetResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::ClockSet,
        TpmTypeId::ClockSetResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::ClockRateAdjustComplete
(
)
{
    ClockRateAdjustResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::ClockRateAdjust,
        TpmTypeId::ClockRateAdjustResponse_ID,
        &_resp
    );
return;
};
GetCapabilityResponse Tpm2::AsyncMethods::GetCapabilityComplete
(
)
{
    GetCapabilityResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::GetCapability,
        TpmTypeId::GetCapabilityResponse_ID,
        &_resp
    );
return _resp;
};
void Tpm2::AsyncMethods::TestParmsComplete
(
)
{
    TestParmsResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::TestParms,
        TpmTypeId::TestParmsResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::NV_DefineSpaceComplete
(
)
{
    NV_DefineSpaceResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::NV_DefineSpace,
        TpmTypeId::NV_DefineSpaceResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::NV_UndefineSpaceComplete
(
)
{
    NV_UndefineSpaceResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::NV_UndefineSpace,
        TpmTypeId::NV_UndefineSpaceResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::NV_UndefineSpaceSpecialComplete
(
)
{
    NV_UndefineSpaceSpecialResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::NV_UndefineSpaceSpecial,
        TpmTypeId::NV_UndefineSpaceSpecialResponse_ID,
        &_resp
    );
return;
};
NV_ReadPublicResponse Tpm2::AsyncMethods::NV_ReadPublicComplete
(
)
{
    NV_ReadPublicResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::NV_ReadPublic,
        TpmTypeId::NV_ReadPublicResponse_ID,
        &_resp
    );
return _resp;
};
void Tpm2::AsyncMethods::NV_WriteComplete
(
)
{
    NV_WriteResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::NV_Write,
        TpmTypeId::NV_WriteResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::NV_IncrementComplete
(
)
{
    NV_IncrementResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::NV_Increment,
        TpmTypeId::NV_IncrementResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::NV_ExtendComplete
(
)
{
    NV_ExtendResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::NV_Extend,
        TpmTypeId::NV_ExtendResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::NV_SetBitsComplete
(
)
{
    NV_SetBitsResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::NV_SetBits,
        TpmTypeId::NV_SetBitsResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::NV_WriteLockComplete
(
)
{
    NV_WriteLockResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::NV_WriteLock,
        TpmTypeId::NV_WriteLockResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::NV_GlobalWriteLockComplete
(
)
{
    NV_GlobalWriteLockResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::NV_GlobalWriteLock,
        TpmTypeId::NV_GlobalWriteLockResponse_ID,
        &_resp
    );
return;
};
std::vector<BYTE> Tpm2::AsyncMethods::NV_ReadComplete
(
)
{
    NV_ReadResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::NV_Read,
        TpmTypeId::NV_ReadResponse_ID,
        &_resp
    );
return _resp.data;
};
void Tpm2::AsyncMethods::NV_ReadLockComplete
(
)
{
    NV_ReadLockResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::NV_ReadLock,
        TpmTypeId::NV_ReadLockResponse_ID,
        &_resp
    );
return;
};
void Tpm2::AsyncMethods::NV_ChangeAuthComplete
(
)
{
    NV_ChangeAuthResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::NV_ChangeAuth,
        TpmTypeId::NV_ChangeAuthResponse_ID,
        &_resp
    );
return;
};
NV_CertifyResponse Tpm2::AsyncMethods::NV_CertifyComplete
(
)
{
    NV_CertifyResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::NV_Certify,
        TpmTypeId::NV_CertifyResponse_ID,
        &_resp
    );
return _resp;
};
AC_GetCapabilityResponse Tpm2::AsyncMethods::AC_GetCapabilityComplete
(
)
{
    AC_GetCapabilityResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::AC_GetCapability,
        TpmTypeId::AC_GetCapabilityResponse_ID,
        &_resp
    );
return _resp;
};
TPMS_AC_OUTPUT Tpm2::AsyncMethods::AC_SendComplete
(
)
{
    AC_SendResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::AC_Send,
        TpmTypeId::AC_SendResponse_ID,
        &_resp
    );
return _resp.acDataOut;
};
void Tpm2::AsyncMethods::Policy_AC_SendSelectComplete
(
)
{
    Policy_AC_SendSelectResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::Policy_AC_SendSelect,
        TpmTypeId::Policy_AC_SendSelectResponse_ID,
        &_resp
    );
return;
};
std::vector<BYTE> Tpm2::AsyncMethods::Vendor_TCG_TestComplete
(
)
{
    Vendor_TCG_TestResponse _resp;
    theTpm.DispatchIn
    (
        TPM_CC::Vendor_TCG_Test,
        TpmTypeId::Vendor_TCG_TestResponse_ID,
        &_resp
    );
return _resp.outputData;
};
TpmTypeId TPMS_NULL_UNION::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_UNION_ID;
};
/// <summary>
/// Base class for empty union elements.
/// An empty union element does not contain any data to marshal.
/// This data structure can be used in place of any other union
/// initialized with its own empty element.
/// </summary>
TPMS_NULL_UNION::TPMS_NULL_UNION()
{
    return;
};
/// <summary>
/// Base class for empty union elements.
/// An empty union element does not contain any data to marshal.
/// This data structure can be used in place of any other union
/// initialized with its own empty element.
/// </summary>
TPMS_NULL_UNION::~TPMS_NULL_UNION()
{
    return;
};
/// <summary>
/// Base class for empty union elements.
/// An empty union element does not contain any data to marshal.
/// This data structure can be used in place of any other union
/// initialized with its own empty element.
/// </summary>
TPMS_NULL_UNION& TPMS_NULL_UNION::operator=(const TPMS_NULL_UNION& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// Base class for empty union elements.
/// An empty union element does not contain any data to marshal.
/// This data structure can be used in place of any other union
/// initialized with its own empty element.
/// </summary>
TPMS_NULL_UNION::TPMS_NULL_UNION(const TPMS_NULL_UNION& r)
{
};
/// <summary>
/// Base class for empty union elements.
/// An empty union element does not contain any data to marshal.
/// This data structure can be used in place of any other union
/// initialized with its own empty element.
/// </summary>
TpmStructureBase* TPMS_NULL_UNION::Clone() const
{
    TPMS_NULL_UNION* _x = new TPMS_NULL_UNION(*this);
    return _x;
};
void* TPMS_NULL_UNION::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPMT_HA::GetTypeId() const
{
    return TpmTypeId::TPMT_HA_ID;
};
/// <summary>
/// TPM Hash structure
/// </summary>
TPMT_HA::TPMT_HA()
{
    return;
};
TPMT_HA::TPMT_HA
(
    const TPM_ALG_ID& _hashAlg,
    const std::vector<BYTE>& _digest
)
{
    hashAlg= _hashAlg;
    digest= _digest;
};
/// <summary>
/// TPM Hash structure
/// </summary>
TPMT_HA::~TPMT_HA()
{
    return;
};
/// <summary>
/// TPM Hash structure
/// </summary>
TPMT_HA& TPMT_HA::operator=(const TPMT_HA& rhs)
{
    if(this == &rhs) return *this;
    this->hashAlg = rhs.hashAlg;
    this->digest = rhs.digest;
    TPMT_HA_CUSTOM_CLONE(this, rhs)
    return *this;
};
/// <summary>
/// TPM Hash structure
/// </summary>
TPMT_HA::TPMT_HA(const TPMT_HA& r)
{
    this->hashAlg = r.hashAlg;
    this->digest = r.digest;
    TPMT_HA_CUSTOM_CLONE(this, r)
};
/// <summary>
/// TPM Hash structure
/// </summary>
TpmStructureBase* TPMT_HA::Clone() const
{
    TPMT_HA* _x = new TPMT_HA(*this);
    return _x;
};
void* TPMT_HA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hashAlg);
            case 1: { if(newArraySize != -1)digest.resize(newArraySize); arraySize = (int)digest.size(); return (void*)(&digest); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&digest[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM_HANDLE::GetTypeId() const
{
    return TpmTypeId::TPM_HANDLE_ID;
};
/// <summary>
/// TPM object handle (and related data)
/// </summary>
TPM_HANDLE::TPM_HANDLE()
{
    return;
};
TPM_HANDLE::TPM_HANDLE
(
    const UINT32& _handle
)
{
    handle= _handle;
};
/// <summary>
/// TPM object handle (and related data)
/// </summary>
TPM_HANDLE::~TPM_HANDLE()
{
    return;
};
/// <summary>
/// TPM object handle (and related data)
/// </summary>
TPM_HANDLE& TPM_HANDLE::operator=(const TPM_HANDLE& rhs)
{
    if(this == &rhs) return *this;
    this->handle = rhs.handle;
    TPM_HANDLE_CUSTOM_CLONE(this, rhs)
    return *this;
};
/// <summary>
/// TPM object handle (and related data)
/// </summary>
TPM_HANDLE::TPM_HANDLE(const TPM_HANDLE& r)
{
    this->handle = r.handle;
    TPM_HANDLE_CUSTOM_CLONE(this, r)
};
/// <summary>
/// TPM object handle (and related data)
/// </summary>
TpmStructureBase* TPM_HANDLE::Clone() const
{
    TPM_HANDLE* _x = new TPM_HANDLE(*this);
    return _x;
};
void* TPM_HANDLE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&handle);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_EMPTY::GetTypeId() const
{
    return TpmTypeId::TPMS_EMPTY_ID;
};
/// <summary>
/// This structure is used as a placeholder. In some cases, a union will have a selector value with no data to unmarshal when that type is selected. Rather than leave the entry empty, TPMS_EMPTY may be selected.
/// </summary>
TPMS_EMPTY::TPMS_EMPTY()
{
    return;
};
/// <summary>
/// This structure is used as a placeholder. In some cases, a union will have a selector value with no data to unmarshal when that type is selected. Rather than leave the entry empty, TPMS_EMPTY may be selected.
/// </summary>
TPMS_EMPTY::~TPMS_EMPTY()
{
    return;
};
/// <summary>
/// This structure is used as a placeholder. In some cases, a union will have a selector value with no data to unmarshal when that type is selected. Rather than leave the entry empty, TPMS_EMPTY may be selected.
/// </summary>
TPMS_EMPTY& TPMS_EMPTY::operator=(const TPMS_EMPTY& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This structure is used as a placeholder. In some cases, a union will have a selector value with no data to unmarshal when that type is selected. Rather than leave the entry empty, TPMS_EMPTY may be selected.
/// </summary>
TPMS_EMPTY::TPMS_EMPTY(const TPMS_EMPTY& r)
{
};
/// <summary>
/// This structure is used as a placeholder. In some cases, a union will have a selector value with no data to unmarshal when that type is selected. Rather than leave the entry empty, TPMS_EMPTY may be selected.
/// </summary>
TpmStructureBase* TPMS_EMPTY::Clone() const
{
    TPMS_EMPTY* _x = new TPMS_EMPTY(*this);
    return _x;
};
void* TPMS_EMPTY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPMS_ALGORITHM_DESCRIPTION::GetTypeId() const
{
    return TpmTypeId::TPMS_ALGORITHM_DESCRIPTION_ID;
};
/// <summary>
/// This structure is a return value for a TPM2_GetCapability() that reads the installed algorithms.
/// </summary>
TPMS_ALGORITHM_DESCRIPTION::TPMS_ALGORITHM_DESCRIPTION()
{
    return;
};
TPMS_ALGORITHM_DESCRIPTION::TPMS_ALGORITHM_DESCRIPTION
(
    const TPM_ALG_ID& _alg,
    const TPMA_ALGORITHM& _attributes
)
{
    alg= _alg;
    attributes= _attributes;
};
/// <summary>
/// This structure is a return value for a TPM2_GetCapability() that reads the installed algorithms.
/// </summary>
TPMS_ALGORITHM_DESCRIPTION::~TPMS_ALGORITHM_DESCRIPTION()
{
    return;
};
/// <summary>
/// This structure is a return value for a TPM2_GetCapability() that reads the installed algorithms.
/// </summary>
TPMS_ALGORITHM_DESCRIPTION& TPMS_ALGORITHM_DESCRIPTION::operator=(const TPMS_ALGORITHM_DESCRIPTION& rhs)
{
    if(this == &rhs) return *this;
    this->alg = rhs.alg;
    this->attributes = rhs.attributes;
    return *this;
};
/// <summary>
/// This structure is a return value for a TPM2_GetCapability() that reads the installed algorithms.
/// </summary>
TPMS_ALGORITHM_DESCRIPTION::TPMS_ALGORITHM_DESCRIPTION(const TPMS_ALGORITHM_DESCRIPTION& r)
{
    this->alg = r.alg;
    this->attributes = r.attributes;
};
/// <summary>
/// This structure is a return value for a TPM2_GetCapability() that reads the installed algorithms.
/// </summary>
TpmStructureBase* TPMS_ALGORITHM_DESCRIPTION::Clone() const
{
    TPMS_ALGORITHM_DESCRIPTION* _x = new TPMS_ALGORITHM_DESCRIPTION(*this);
    return _x;
};
void* TPMS_ALGORITHM_DESCRIPTION::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&alg);
            case 1: return (void*) (&attributes);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2B_DIGEST::GetTypeId() const
{
    return TpmTypeId::TPM2B_DIGEST_ID;
};
/// <summary>
/// This structure is used for a sized buffer that cannot be larger than the largest digest produced by any hash algorithm implemented on the TPM.
/// </summary>
TPM2B_DIGEST::TPM2B_DIGEST()
{
    return;
};
TPM2B_DIGEST::TPM2B_DIGEST
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// This structure is used for a sized buffer that cannot be larger than the largest digest produced by any hash algorithm implemented on the TPM.
/// </summary>
TPM2B_DIGEST::~TPM2B_DIGEST()
{
    return;
};
/// <summary>
/// This structure is used for a sized buffer that cannot be larger than the largest digest produced by any hash algorithm implemented on the TPM.
/// </summary>
TPM2B_DIGEST& TPM2B_DIGEST::operator=(const TPM2B_DIGEST& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This structure is used for a sized buffer that cannot be larger than the largest digest produced by any hash algorithm implemented on the TPM.
/// </summary>
TPM2B_DIGEST::TPM2B_DIGEST(const TPM2B_DIGEST& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// This structure is used for a sized buffer that cannot be larger than the largest digest produced by any hash algorithm implemented on the TPM.
/// </summary>
TpmStructureBase* TPM2B_DIGEST::Clone() const
{
    TPM2B_DIGEST* _x = new TPM2B_DIGEST(*this);
    return _x;
};
void* TPM2B_DIGEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_DATA::GetTypeId() const
{
    return TpmTypeId::TPM2B_DATA_ID;
};
/// <summary>
/// This structure is used for a data buffer that is required to be no larger than the size of the Name of an object.
/// </summary>
TPM2B_DATA::TPM2B_DATA()
{
    return;
};
TPM2B_DATA::TPM2B_DATA
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// This structure is used for a data buffer that is required to be no larger than the size of the Name of an object.
/// </summary>
TPM2B_DATA::~TPM2B_DATA()
{
    return;
};
/// <summary>
/// This structure is used for a data buffer that is required to be no larger than the size of the Name of an object.
/// </summary>
TPM2B_DATA& TPM2B_DATA::operator=(const TPM2B_DATA& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This structure is used for a data buffer that is required to be no larger than the size of the Name of an object.
/// </summary>
TPM2B_DATA::TPM2B_DATA(const TPM2B_DATA& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// This structure is used for a data buffer that is required to be no larger than the size of the Name of an object.
/// </summary>
TpmStructureBase* TPM2B_DATA::Clone() const
{
    TPM2B_DATA* _x = new TPM2B_DATA(*this);
    return _x;
};
void* TPM2B_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_EVENT::GetTypeId() const
{
    return TpmTypeId::TPM2B_EVENT_ID;
};
/// <summary>
/// This type is a sized buffer that can hold event data.
/// </summary>
TPM2B_EVENT::TPM2B_EVENT()
{
    return;
};
TPM2B_EVENT::TPM2B_EVENT
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// This type is a sized buffer that can hold event data.
/// </summary>
TPM2B_EVENT::~TPM2B_EVENT()
{
    return;
};
/// <summary>
/// This type is a sized buffer that can hold event data.
/// </summary>
TPM2B_EVENT& TPM2B_EVENT::operator=(const TPM2B_EVENT& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This type is a sized buffer that can hold event data.
/// </summary>
TPM2B_EVENT::TPM2B_EVENT(const TPM2B_EVENT& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// This type is a sized buffer that can hold event data.
/// </summary>
TpmStructureBase* TPM2B_EVENT::Clone() const
{
    TPM2B_EVENT* _x = new TPM2B_EVENT(*this);
    return _x;
};
void* TPM2B_EVENT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_MAX_BUFFER::GetTypeId() const
{
    return TpmTypeId::TPM2B_MAX_BUFFER_ID;
};
/// <summary>
/// This type is a sized buffer that can hold a maximally sized buffer for commands that use a large data buffer such as TPM2_Hash(), TPM2_SequenceUpdate(), or TPM2_FieldUpgradeData().
/// </summary>
TPM2B_MAX_BUFFER::TPM2B_MAX_BUFFER()
{
    return;
};
TPM2B_MAX_BUFFER::TPM2B_MAX_BUFFER
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// This type is a sized buffer that can hold a maximally sized buffer for commands that use a large data buffer such as TPM2_Hash(), TPM2_SequenceUpdate(), or TPM2_FieldUpgradeData().
/// </summary>
TPM2B_MAX_BUFFER::~TPM2B_MAX_BUFFER()
{
    return;
};
/// <summary>
/// This type is a sized buffer that can hold a maximally sized buffer for commands that use a large data buffer such as TPM2_Hash(), TPM2_SequenceUpdate(), or TPM2_FieldUpgradeData().
/// </summary>
TPM2B_MAX_BUFFER& TPM2B_MAX_BUFFER::operator=(const TPM2B_MAX_BUFFER& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This type is a sized buffer that can hold a maximally sized buffer for commands that use a large data buffer such as TPM2_Hash(), TPM2_SequenceUpdate(), or TPM2_FieldUpgradeData().
/// </summary>
TPM2B_MAX_BUFFER::TPM2B_MAX_BUFFER(const TPM2B_MAX_BUFFER& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// This type is a sized buffer that can hold a maximally sized buffer for commands that use a large data buffer such as TPM2_Hash(), TPM2_SequenceUpdate(), or TPM2_FieldUpgradeData().
/// </summary>
TpmStructureBase* TPM2B_MAX_BUFFER::Clone() const
{
    TPM2B_MAX_BUFFER* _x = new TPM2B_MAX_BUFFER(*this);
    return _x;
};
void* TPM2B_MAX_BUFFER::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_MAX_NV_BUFFER::GetTypeId() const
{
    return TpmTypeId::TPM2B_MAX_NV_BUFFER_ID;
};
/// <summary>
/// This type is a sized buffer that can hold a maximally sized buffer for NV data commands such as TPM2_NV_Read(), TPM2_NV_Write(), and TPM2_NV_Certify().
/// </summary>
TPM2B_MAX_NV_BUFFER::TPM2B_MAX_NV_BUFFER()
{
    return;
};
TPM2B_MAX_NV_BUFFER::TPM2B_MAX_NV_BUFFER
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// This type is a sized buffer that can hold a maximally sized buffer for NV data commands such as TPM2_NV_Read(), TPM2_NV_Write(), and TPM2_NV_Certify().
/// </summary>
TPM2B_MAX_NV_BUFFER::~TPM2B_MAX_NV_BUFFER()
{
    return;
};
/// <summary>
/// This type is a sized buffer that can hold a maximally sized buffer for NV data commands such as TPM2_NV_Read(), TPM2_NV_Write(), and TPM2_NV_Certify().
/// </summary>
TPM2B_MAX_NV_BUFFER& TPM2B_MAX_NV_BUFFER::operator=(const TPM2B_MAX_NV_BUFFER& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This type is a sized buffer that can hold a maximally sized buffer for NV data commands such as TPM2_NV_Read(), TPM2_NV_Write(), and TPM2_NV_Certify().
/// </summary>
TPM2B_MAX_NV_BUFFER::TPM2B_MAX_NV_BUFFER(const TPM2B_MAX_NV_BUFFER& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// This type is a sized buffer that can hold a maximally sized buffer for NV data commands such as TPM2_NV_Read(), TPM2_NV_Write(), and TPM2_NV_Certify().
/// </summary>
TpmStructureBase* TPM2B_MAX_NV_BUFFER::Clone() const
{
    TPM2B_MAX_NV_BUFFER* _x = new TPM2B_MAX_NV_BUFFER(*this);
    return _x;
};
void* TPM2B_MAX_NV_BUFFER::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_TIMEOUT::GetTypeId() const
{
    return TpmTypeId::TPM2B_TIMEOUT_ID;
};
/// <summary>
/// This TPM-dependent structure is used to provide the timeout value for an authorization. The size shall be 8 or less.
/// </summary>
TPM2B_TIMEOUT::TPM2B_TIMEOUT()
{
    return;
};
TPM2B_TIMEOUT::TPM2B_TIMEOUT
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// This TPM-dependent structure is used to provide the timeout value for an authorization. The size shall be 8 or less.
/// </summary>
TPM2B_TIMEOUT::~TPM2B_TIMEOUT()
{
    return;
};
/// <summary>
/// This TPM-dependent structure is used to provide the timeout value for an authorization. The size shall be 8 or less.
/// </summary>
TPM2B_TIMEOUT& TPM2B_TIMEOUT::operator=(const TPM2B_TIMEOUT& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This TPM-dependent structure is used to provide the timeout value for an authorization. The size shall be 8 or less.
/// </summary>
TPM2B_TIMEOUT::TPM2B_TIMEOUT(const TPM2B_TIMEOUT& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// This TPM-dependent structure is used to provide the timeout value for an authorization. The size shall be 8 or less.
/// </summary>
TpmStructureBase* TPM2B_TIMEOUT::Clone() const
{
    TPM2B_TIMEOUT* _x = new TPM2B_TIMEOUT(*this);
    return _x;
};
void* TPM2B_TIMEOUT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_IV::GetTypeId() const
{
    return TpmTypeId::TPM2B_IV_ID;
};
/// <summary>
/// This structure is used for passing an initial value for a symmetric block cipher to or from the TPM. The size is set to be the largest block size of any implemented symmetric cipher implemented on the TPM.
/// </summary>
TPM2B_IV::TPM2B_IV()
{
    return;
};
TPM2B_IV::TPM2B_IV
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// This structure is used for passing an initial value for a symmetric block cipher to or from the TPM. The size is set to be the largest block size of any implemented symmetric cipher implemented on the TPM.
/// </summary>
TPM2B_IV::~TPM2B_IV()
{
    return;
};
/// <summary>
/// This structure is used for passing an initial value for a symmetric block cipher to or from the TPM. The size is set to be the largest block size of any implemented symmetric cipher implemented on the TPM.
/// </summary>
TPM2B_IV& TPM2B_IV::operator=(const TPM2B_IV& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This structure is used for passing an initial value for a symmetric block cipher to or from the TPM. The size is set to be the largest block size of any implemented symmetric cipher implemented on the TPM.
/// </summary>
TPM2B_IV::TPM2B_IV(const TPM2B_IV& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// This structure is used for passing an initial value for a symmetric block cipher to or from the TPM. The size is set to be the largest block size of any implemented symmetric cipher implemented on the TPM.
/// </summary>
TpmStructureBase* TPM2B_IV::Clone() const
{
    TPM2B_IV* _x = new TPM2B_IV(*this);
    return _x;
};
void* TPM2B_IV::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_NAME::GetTypeId() const
{
    return TpmTypeId::TPM2B_NAME_ID;
};
/// <summary>
/// This buffer holds a Name for any entity type.
/// </summary>
TPM2B_NAME::TPM2B_NAME()
{
    return;
};
TPM2B_NAME::TPM2B_NAME
(
    const std::vector<BYTE>& _name
)
{
    name= _name;
};
/// <summary>
/// This buffer holds a Name for any entity type.
/// </summary>
TPM2B_NAME::~TPM2B_NAME()
{
    return;
};
/// <summary>
/// This buffer holds a Name for any entity type.
/// </summary>
TPM2B_NAME& TPM2B_NAME::operator=(const TPM2B_NAME& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->name = rhs.name;
    return *this;
};
/// <summary>
/// This buffer holds a Name for any entity type.
/// </summary>
TPM2B_NAME::TPM2B_NAME(const TPM2B_NAME& r)
{
    this->size = r.size;
    this->name = r.name;
};
/// <summary>
/// This buffer holds a Name for any entity type.
/// </summary>
TpmStructureBase* TPM2B_NAME::Clone() const
{
    TPM2B_NAME* _x = new TPM2B_NAME(*this);
    return _x;
};
void* TPM2B_NAME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)name.resize(newArraySize); arraySize = (int)name.size(); return (void*)(&name); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&name[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_PCR_SELECT::GetTypeId() const
{
    return TpmTypeId::TPMS_PCR_SELECT_ID;
};
/// <summary>
/// This structure provides a standard method of specifying a list of PCR.
/// </summary>
TPMS_PCR_SELECT::TPMS_PCR_SELECT()
{
    return;
};
TPMS_PCR_SELECT::TPMS_PCR_SELECT
(
    const std::vector<BYTE>& _pcrSelect
)
{
    pcrSelect= _pcrSelect;
};
/// <summary>
/// This structure provides a standard method of specifying a list of PCR.
/// </summary>
TPMS_PCR_SELECT::~TPMS_PCR_SELECT()
{
    return;
};
/// <summary>
/// This structure provides a standard method of specifying a list of PCR.
/// </summary>
TPMS_PCR_SELECT& TPMS_PCR_SELECT::operator=(const TPMS_PCR_SELECT& rhs)
{
    if(this == &rhs) return *this;
    this->sizeofSelect = rhs.sizeofSelect;
    this->pcrSelect = rhs.pcrSelect;
    return *this;
};
/// <summary>
/// This structure provides a standard method of specifying a list of PCR.
/// </summary>
TPMS_PCR_SELECT::TPMS_PCR_SELECT(const TPMS_PCR_SELECT& r)
{
    this->sizeofSelect = r.sizeofSelect;
    this->pcrSelect = r.pcrSelect;
};
/// <summary>
/// This structure provides a standard method of specifying a list of PCR.
/// </summary>
TpmStructureBase* TPMS_PCR_SELECT::Clone() const
{
    TPMS_PCR_SELECT* _x = new TPMS_PCR_SELECT(*this);
    return _x;
};
void* TPMS_PCR_SELECT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&sizeofSelect);
            case 1: { if(newArraySize != -1)pcrSelect.resize(newArraySize); arraySize = (int)pcrSelect.size(); return (void*)(&pcrSelect); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&pcrSelect[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_PCR_SELECTION::GetTypeId() const
{
    return TpmTypeId::TPMS_PCR_SELECTION_ID;
};
/// <summary>
/// Table 91  Definition of TPMS_PCR_SELECTION Structure
/// </summary>
TPMS_PCR_SELECTION::TPMS_PCR_SELECTION()
{
    return;
};
TPMS_PCR_SELECTION::TPMS_PCR_SELECTION
(
    const TPM_ALG_ID& _hash,
    const std::vector<BYTE>& _pcrSelect
)
{
    hash= _hash;
    pcrSelect= _pcrSelect;
};
/// <summary>
/// Table 91  Definition of TPMS_PCR_SELECTION Structure
/// </summary>
TPMS_PCR_SELECTION::~TPMS_PCR_SELECTION()
{
    return;
};
/// <summary>
/// Table 91  Definition of TPMS_PCR_SELECTION Structure
/// </summary>
TPMS_PCR_SELECTION& TPMS_PCR_SELECTION::operator=(const TPMS_PCR_SELECTION& rhs)
{
    if(this == &rhs) return *this;
    this->hash = rhs.hash;
    this->sizeofSelect = rhs.sizeofSelect;
    this->pcrSelect = rhs.pcrSelect;
    TPMS_PCR_SELECTION_CUSTOM_CLONE(this, rhs)
    return *this;
};
/// <summary>
/// Table 91  Definition of TPMS_PCR_SELECTION Structure
/// </summary>
TPMS_PCR_SELECTION::TPMS_PCR_SELECTION(const TPMS_PCR_SELECTION& r)
{
    this->hash = r.hash;
    this->sizeofSelect = r.sizeofSelect;
    this->pcrSelect = r.pcrSelect;
    TPMS_PCR_SELECTION_CUSTOM_CLONE(this, r)
};
/// <summary>
/// Table 91  Definition of TPMS_PCR_SELECTION Structure
/// </summary>
TpmStructureBase* TPMS_PCR_SELECTION::Clone() const
{
    TPMS_PCR_SELECTION* _x = new TPMS_PCR_SELECTION(*this);
    return _x;
};
void* TPMS_PCR_SELECTION::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hash);
            case 1: return (void*) (&sizeofSelect);
            case 2: { if(newArraySize != -1)pcrSelect.resize(newArraySize); arraySize = (int)pcrSelect.size(); return (void*)(&pcrSelect); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&pcrSelect[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMT_TK_CREATION::GetTypeId() const
{
    return TpmTypeId::TPMT_TK_CREATION_ID;
};
/// <summary>
/// This ticket is produced by TPM2_Create() or TPM2_CreatePrimary(). It is used to bind the creation data to the object to which it applies. The ticket is computed by
/// </summary>
TPMT_TK_CREATION::TPMT_TK_CREATION()
{
    return;
};
TPMT_TK_CREATION::TPMT_TK_CREATION
(
    const TPM_ST& _tag,
    const TPM_HANDLE& _hierarchy,
    const std::vector<BYTE>& _digest
)
{
    tag= _tag;
    hierarchy= _hierarchy;
    digest= _digest;
};
/// <summary>
/// This ticket is produced by TPM2_Create() or TPM2_CreatePrimary(). It is used to bind the creation data to the object to which it applies. The ticket is computed by
/// </summary>
TPMT_TK_CREATION::~TPMT_TK_CREATION()
{
    return;
};
/// <summary>
/// This ticket is produced by TPM2_Create() or TPM2_CreatePrimary(). It is used to bind the creation data to the object to which it applies. The ticket is computed by
/// </summary>
TPMT_TK_CREATION& TPMT_TK_CREATION::operator=(const TPMT_TK_CREATION& rhs)
{
    if(this == &rhs) return *this;
    this->tag = rhs.tag;
    this->hierarchy = rhs.hierarchy;
    this->digestSize = rhs.digestSize;
    this->digest = rhs.digest;
    return *this;
};
/// <summary>
/// This ticket is produced by TPM2_Create() or TPM2_CreatePrimary(). It is used to bind the creation data to the object to which it applies. The ticket is computed by
/// </summary>
TPMT_TK_CREATION::TPMT_TK_CREATION(const TPMT_TK_CREATION& r)
{
    this->tag = r.tag;
    this->hierarchy = r.hierarchy;
    this->digestSize = r.digestSize;
    this->digest = r.digest;
};
/// <summary>
/// This ticket is produced by TPM2_Create() or TPM2_CreatePrimary(). It is used to bind the creation data to the object to which it applies. The ticket is computed by
/// </summary>
TpmStructureBase* TPMT_TK_CREATION::Clone() const
{
    TPMT_TK_CREATION* _x = new TPMT_TK_CREATION(*this);
    return _x;
};
void* TPMT_TK_CREATION::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&tag);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return (void*) (&hierarchy);
            case 2: return (void*) (&digestSize);
            case 3: { if(newArraySize != -1)digest.resize(newArraySize); arraySize = (int)digest.size(); return (void*)(&digest); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&digest[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMT_TK_VERIFIED::GetTypeId() const
{
    return TpmTypeId::TPMT_TK_VERIFIED_ID;
};
/// <summary>
/// This ticket is produced by TPM2_VerifySignature(). This formulation is used for multiple ticket uses. The ticket provides evidence that the TPM has validated that a digest was signed by a key with the Name of keyName. The ticket is computed by
/// </summary>
TPMT_TK_VERIFIED::TPMT_TK_VERIFIED()
{
    return;
};
TPMT_TK_VERIFIED::TPMT_TK_VERIFIED
(
    const TPM_ST& _tag,
    const TPM_HANDLE& _hierarchy,
    const std::vector<BYTE>& _digest
)
{
    tag= _tag;
    hierarchy= _hierarchy;
    digest= _digest;
};
/// <summary>
/// This ticket is produced by TPM2_VerifySignature(). This formulation is used for multiple ticket uses. The ticket provides evidence that the TPM has validated that a digest was signed by a key with the Name of keyName. The ticket is computed by
/// </summary>
TPMT_TK_VERIFIED::~TPMT_TK_VERIFIED()
{
    return;
};
/// <summary>
/// This ticket is produced by TPM2_VerifySignature(). This formulation is used for multiple ticket uses. The ticket provides evidence that the TPM has validated that a digest was signed by a key with the Name of keyName. The ticket is computed by
/// </summary>
TPMT_TK_VERIFIED& TPMT_TK_VERIFIED::operator=(const TPMT_TK_VERIFIED& rhs)
{
    if(this == &rhs) return *this;
    this->tag = rhs.tag;
    this->hierarchy = rhs.hierarchy;
    this->digestSize = rhs.digestSize;
    this->digest = rhs.digest;
    return *this;
};
/// <summary>
/// This ticket is produced by TPM2_VerifySignature(). This formulation is used for multiple ticket uses. The ticket provides evidence that the TPM has validated that a digest was signed by a key with the Name of keyName. The ticket is computed by
/// </summary>
TPMT_TK_VERIFIED::TPMT_TK_VERIFIED(const TPMT_TK_VERIFIED& r)
{
    this->tag = r.tag;
    this->hierarchy = r.hierarchy;
    this->digestSize = r.digestSize;
    this->digest = r.digest;
};
/// <summary>
/// This ticket is produced by TPM2_VerifySignature(). This formulation is used for multiple ticket uses. The ticket provides evidence that the TPM has validated that a digest was signed by a key with the Name of keyName. The ticket is computed by
/// </summary>
TpmStructureBase* TPMT_TK_VERIFIED::Clone() const
{
    TPMT_TK_VERIFIED* _x = new TPMT_TK_VERIFIED(*this);
    return _x;
};
void* TPMT_TK_VERIFIED::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&tag);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return (void*) (&hierarchy);
            case 2: return (void*) (&digestSize);
            case 3: { if(newArraySize != -1)digest.resize(newArraySize); arraySize = (int)digest.size(); return (void*)(&digest); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&digest[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMT_TK_AUTH::GetTypeId() const
{
    return TpmTypeId::TPMT_TK_AUTH_ID;
};
/// <summary>
/// This ticket is produced by TPM2_PolicySigned() and TPM2_PolicySecret() when the authorization has an expiration time. If nonceTPM was provided in the policy command, the ticket is computed by
/// </summary>
TPMT_TK_AUTH::TPMT_TK_AUTH()
{
    return;
};
TPMT_TK_AUTH::TPMT_TK_AUTH
(
    const TPM_ST& _tag,
    const TPM_HANDLE& _hierarchy,
    const std::vector<BYTE>& _digest
)
{
    tag= _tag;
    hierarchy= _hierarchy;
    digest= _digest;
};
/// <summary>
/// This ticket is produced by TPM2_PolicySigned() and TPM2_PolicySecret() when the authorization has an expiration time. If nonceTPM was provided in the policy command, the ticket is computed by
/// </summary>
TPMT_TK_AUTH::~TPMT_TK_AUTH()
{
    return;
};
/// <summary>
/// This ticket is produced by TPM2_PolicySigned() and TPM2_PolicySecret() when the authorization has an expiration time. If nonceTPM was provided in the policy command, the ticket is computed by
/// </summary>
TPMT_TK_AUTH& TPMT_TK_AUTH::operator=(const TPMT_TK_AUTH& rhs)
{
    if(this == &rhs) return *this;
    this->tag = rhs.tag;
    this->hierarchy = rhs.hierarchy;
    this->digestSize = rhs.digestSize;
    this->digest = rhs.digest;
    return *this;
};
/// <summary>
/// This ticket is produced by TPM2_PolicySigned() and TPM2_PolicySecret() when the authorization has an expiration time. If nonceTPM was provided in the policy command, the ticket is computed by
/// </summary>
TPMT_TK_AUTH::TPMT_TK_AUTH(const TPMT_TK_AUTH& r)
{
    this->tag = r.tag;
    this->hierarchy = r.hierarchy;
    this->digestSize = r.digestSize;
    this->digest = r.digest;
};
/// <summary>
/// This ticket is produced by TPM2_PolicySigned() and TPM2_PolicySecret() when the authorization has an expiration time. If nonceTPM was provided in the policy command, the ticket is computed by
/// </summary>
TpmStructureBase* TPMT_TK_AUTH::Clone() const
{
    TPMT_TK_AUTH* _x = new TPMT_TK_AUTH(*this);
    return _x;
};
void* TPMT_TK_AUTH::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&tag);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return (void*) (&hierarchy);
            case 2: return (void*) (&digestSize);
            case 3: { if(newArraySize != -1)digest.resize(newArraySize); arraySize = (int)digest.size(); return (void*)(&digest); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&digest[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMT_TK_HASHCHECK::GetTypeId() const
{
    return TpmTypeId::TPMT_TK_HASHCHECK_ID;
};
/// <summary>
/// This ticket is produced by TPM2_SequenceComplete() or TPM2_Hash() when the message that was digested did not start with TPM_GENERATED_VALUE. The ticket is computed by
/// </summary>
TPMT_TK_HASHCHECK::TPMT_TK_HASHCHECK()
{
    return;
};
TPMT_TK_HASHCHECK::TPMT_TK_HASHCHECK
(
    const TPM_ST& _tag,
    const TPM_HANDLE& _hierarchy,
    const std::vector<BYTE>& _digest
)
{
    tag= _tag;
    hierarchy= _hierarchy;
    digest= _digest;
};
/// <summary>
/// This ticket is produced by TPM2_SequenceComplete() or TPM2_Hash() when the message that was digested did not start with TPM_GENERATED_VALUE. The ticket is computed by
/// </summary>
TPMT_TK_HASHCHECK::~TPMT_TK_HASHCHECK()
{
    return;
};
/// <summary>
/// This ticket is produced by TPM2_SequenceComplete() or TPM2_Hash() when the message that was digested did not start with TPM_GENERATED_VALUE. The ticket is computed by
/// </summary>
TPMT_TK_HASHCHECK& TPMT_TK_HASHCHECK::operator=(const TPMT_TK_HASHCHECK& rhs)
{
    if(this == &rhs) return *this;
    this->tag = rhs.tag;
    this->hierarchy = rhs.hierarchy;
    this->digestSize = rhs.digestSize;
    this->digest = rhs.digest;
    TPMT_TK_HASHCHECK_CUSTOM_CLONE(this, rhs)
    return *this;
};
/// <summary>
/// This ticket is produced by TPM2_SequenceComplete() or TPM2_Hash() when the message that was digested did not start with TPM_GENERATED_VALUE. The ticket is computed by
/// </summary>
TPMT_TK_HASHCHECK::TPMT_TK_HASHCHECK(const TPMT_TK_HASHCHECK& r)
{
    this->tag = r.tag;
    this->hierarchy = r.hierarchy;
    this->digestSize = r.digestSize;
    this->digest = r.digest;
    TPMT_TK_HASHCHECK_CUSTOM_CLONE(this, r)
};
/// <summary>
/// This ticket is produced by TPM2_SequenceComplete() or TPM2_Hash() when the message that was digested did not start with TPM_GENERATED_VALUE. The ticket is computed by
/// </summary>
TpmStructureBase* TPMT_TK_HASHCHECK::Clone() const
{
    TPMT_TK_HASHCHECK* _x = new TPMT_TK_HASHCHECK(*this);
    return _x;
};
void* TPMT_TK_HASHCHECK::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&tag);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return (void*) (&hierarchy);
            case 2: return (void*) (&digestSize);
            case 3: { if(newArraySize != -1)digest.resize(newArraySize); arraySize = (int)digest.size(); return (void*)(&digest); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&digest[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_ALG_PROPERTY::GetTypeId() const
{
    return TpmTypeId::TPMS_ALG_PROPERTY_ID;
};
/// <summary>
/// This structure is used to report the properties of an algorithm identifier. It is returned in response to a TPM2_GetCapability() with capability = TPM_CAP_ALG.
/// </summary>
TPMS_ALG_PROPERTY::TPMS_ALG_PROPERTY()
{
    return;
};
TPMS_ALG_PROPERTY::TPMS_ALG_PROPERTY
(
    const TPM_ALG_ID& _alg,
    const TPMA_ALGORITHM& _algProperties
)
{
    alg= _alg;
    algProperties= _algProperties;
};
/// <summary>
/// This structure is used to report the properties of an algorithm identifier. It is returned in response to a TPM2_GetCapability() with capability = TPM_CAP_ALG.
/// </summary>
TPMS_ALG_PROPERTY::~TPMS_ALG_PROPERTY()
{
    return;
};
/// <summary>
/// This structure is used to report the properties of an algorithm identifier. It is returned in response to a TPM2_GetCapability() with capability = TPM_CAP_ALG.
/// </summary>
TPMS_ALG_PROPERTY& TPMS_ALG_PROPERTY::operator=(const TPMS_ALG_PROPERTY& rhs)
{
    if(this == &rhs) return *this;
    this->alg = rhs.alg;
    this->algProperties = rhs.algProperties;
    return *this;
};
/// <summary>
/// This structure is used to report the properties of an algorithm identifier. It is returned in response to a TPM2_GetCapability() with capability = TPM_CAP_ALG.
/// </summary>
TPMS_ALG_PROPERTY::TPMS_ALG_PROPERTY(const TPMS_ALG_PROPERTY& r)
{
    this->alg = r.alg;
    this->algProperties = r.algProperties;
};
/// <summary>
/// This structure is used to report the properties of an algorithm identifier. It is returned in response to a TPM2_GetCapability() with capability = TPM_CAP_ALG.
/// </summary>
TpmStructureBase* TPMS_ALG_PROPERTY::Clone() const
{
    TPMS_ALG_PROPERTY* _x = new TPMS_ALG_PROPERTY(*this);
    return _x;
};
void* TPMS_ALG_PROPERTY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&alg);
            case 1: return (void*) (&algProperties);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_TAGGED_PROPERTY::GetTypeId() const
{
    return TpmTypeId::TPMS_TAGGED_PROPERTY_ID;
};
/// <summary>
/// This structure is used to report the properties that are UINT32 values. It is returned in response to a TPM2_GetCapability().
/// </summary>
TPMS_TAGGED_PROPERTY::TPMS_TAGGED_PROPERTY()
{
    return;
};
TPMS_TAGGED_PROPERTY::TPMS_TAGGED_PROPERTY
(
    const TPM_PT& _property,
    const UINT32& _value
)
{
    property= _property;
    value= _value;
};
/// <summary>
/// This structure is used to report the properties that are UINT32 values. It is returned in response to a TPM2_GetCapability().
/// </summary>
TPMS_TAGGED_PROPERTY::~TPMS_TAGGED_PROPERTY()
{
    return;
};
/// <summary>
/// This structure is used to report the properties that are UINT32 values. It is returned in response to a TPM2_GetCapability().
/// </summary>
TPMS_TAGGED_PROPERTY& TPMS_TAGGED_PROPERTY::operator=(const TPMS_TAGGED_PROPERTY& rhs)
{
    if(this == &rhs) return *this;
    this->property = rhs.property;
    this->value = rhs.value;
    return *this;
};
/// <summary>
/// This structure is used to report the properties that are UINT32 values. It is returned in response to a TPM2_GetCapability().
/// </summary>
TPMS_TAGGED_PROPERTY::TPMS_TAGGED_PROPERTY(const TPMS_TAGGED_PROPERTY& r)
{
    this->property = r.property;
    this->value = r.value;
};
/// <summary>
/// This structure is used to report the properties that are UINT32 values. It is returned in response to a TPM2_GetCapability().
/// </summary>
TpmStructureBase* TPMS_TAGGED_PROPERTY::Clone() const
{
    TPMS_TAGGED_PROPERTY* _x = new TPMS_TAGGED_PROPERTY(*this);
    return _x;
};
void* TPMS_TAGGED_PROPERTY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&property);
            case 1: return (void*) (&value);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_TAGGED_PCR_SELECT::GetTypeId() const
{
    return TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID;
};
/// <summary>
/// This structure is used in TPM2_GetCapability() to return the attributes of the PCR.
/// </summary>
TPMS_TAGGED_PCR_SELECT::TPMS_TAGGED_PCR_SELECT()
{
    return;
};
TPMS_TAGGED_PCR_SELECT::TPMS_TAGGED_PCR_SELECT
(
    const TPM_PT_PCR& _tag,
    const std::vector<BYTE>& _pcrSelect
)
{
    tag= _tag;
    pcrSelect= _pcrSelect;
};
/// <summary>
/// This structure is used in TPM2_GetCapability() to return the attributes of the PCR.
/// </summary>
TPMS_TAGGED_PCR_SELECT::~TPMS_TAGGED_PCR_SELECT()
{
    return;
};
/// <summary>
/// This structure is used in TPM2_GetCapability() to return the attributes of the PCR.
/// </summary>
TPMS_TAGGED_PCR_SELECT& TPMS_TAGGED_PCR_SELECT::operator=(const TPMS_TAGGED_PCR_SELECT& rhs)
{
    if(this == &rhs) return *this;
    this->tag = rhs.tag;
    this->sizeofSelect = rhs.sizeofSelect;
    this->pcrSelect = rhs.pcrSelect;
    return *this;
};
/// <summary>
/// This structure is used in TPM2_GetCapability() to return the attributes of the PCR.
/// </summary>
TPMS_TAGGED_PCR_SELECT::TPMS_TAGGED_PCR_SELECT(const TPMS_TAGGED_PCR_SELECT& r)
{
    this->tag = r.tag;
    this->sizeofSelect = r.sizeofSelect;
    this->pcrSelect = r.pcrSelect;
};
/// <summary>
/// This structure is used in TPM2_GetCapability() to return the attributes of the PCR.
/// </summary>
TpmStructureBase* TPMS_TAGGED_PCR_SELECT::Clone() const
{
    TPMS_TAGGED_PCR_SELECT* _x = new TPMS_TAGGED_PCR_SELECT(*this);
    return _x;
};
void* TPMS_TAGGED_PCR_SELECT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&tag);
            case 1: return (void*) (&sizeofSelect);
            case 2: { if(newArraySize != -1)pcrSelect.resize(newArraySize); arraySize = (int)pcrSelect.size(); return (void*)(&pcrSelect); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&pcrSelect[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_TAGGED_POLICY::GetTypeId() const
{
    return TpmTypeId::TPMS_TAGGED_POLICY_ID;
};
/// <summary>
/// This structure is used in TPM2_GetCapability() to return the policy associated with a permanent handle.
/// </summary>
TPMS_TAGGED_POLICY::TPMS_TAGGED_POLICY()
{
    return;
};
TPMS_TAGGED_POLICY::TPMS_TAGGED_POLICY
(
    const TPM_HANDLE& _handle,
    const TPMT_HA& _policyHash
)
{
    handle= _handle;
    policyHash= _policyHash;
};
/// <summary>
/// This structure is used in TPM2_GetCapability() to return the policy associated with a permanent handle.
/// </summary>
TPMS_TAGGED_POLICY::~TPMS_TAGGED_POLICY()
{
    return;
};
/// <summary>
/// This structure is used in TPM2_GetCapability() to return the policy associated with a permanent handle.
/// </summary>
TPMS_TAGGED_POLICY& TPMS_TAGGED_POLICY::operator=(const TPMS_TAGGED_POLICY& rhs)
{
    if(this == &rhs) return *this;
    this->handle = rhs.handle;
    this->policyHash = rhs.policyHash;
    return *this;
};
/// <summary>
/// This structure is used in TPM2_GetCapability() to return the policy associated with a permanent handle.
/// </summary>
TPMS_TAGGED_POLICY::TPMS_TAGGED_POLICY(const TPMS_TAGGED_POLICY& r)
{
    this->handle = r.handle;
    this->policyHash = r.policyHash;
};
/// <summary>
/// This structure is used in TPM2_GetCapability() to return the policy associated with a permanent handle.
/// </summary>
TpmStructureBase* TPMS_TAGGED_POLICY::Clone() const
{
    TPMS_TAGGED_POLICY* _x = new TPMS_TAGGED_POLICY(*this);
    return _x;
};
void* TPMS_TAGGED_POLICY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return (void*) (&handle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&policyHash); return (void*) (&policyHash);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPML_CC::GetTypeId() const
{
    return TpmTypeId::TPML_CC_ID;
};
/// <summary>
/// A list of command codes may be input to the TPM or returned by the TPM depending on the command.
/// </summary>
TPML_CC::TPML_CC()
{
    return;
};
TPML_CC::TPML_CC
(
    const std::vector<TPM_CC>& _commandCodes
)
{
    commandCodes= _commandCodes;
};
/// <summary>
/// A list of command codes may be input to the TPM or returned by the TPM depending on the command.
/// </summary>
TPML_CC::~TPML_CC()
{
    return;
};
/// <summary>
/// A list of command codes may be input to the TPM or returned by the TPM depending on the command.
/// </summary>
TPML_CC& TPML_CC::operator=(const TPML_CC& rhs)
{
    if(this == &rhs) return *this;
    this->count = rhs.count;
    this->commandCodes = rhs.commandCodes;
    return *this;
};
/// <summary>
/// A list of command codes may be input to the TPM or returned by the TPM depending on the command.
/// </summary>
TPML_CC::TPML_CC(const TPML_CC& r)
{
    this->count = r.count;
    this->commandCodes = r.commandCodes;
};
/// <summary>
/// A list of command codes may be input to the TPM or returned by the TPM depending on the command.
/// </summary>
TpmStructureBase* TPML_CC::Clone() const
{
    TPML_CC* _x = new TPML_CC(*this);
    return _x;
};
void* TPML_CC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&count);
            case 1: { if(newArraySize != -1)commandCodes.resize(newArraySize); arraySize = (int)commandCodes.size(); return (void*)(&commandCodes); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&commandCodes[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPML_CCA::GetTypeId() const
{
    return TpmTypeId::TPML_CCA_ID;
};
/// <summary>
/// This list is only used in TPM2_GetCapability(capability = TPM_CAP_COMMANDS).
/// </summary>
TPML_CCA::TPML_CCA()
{
    return;
};
TPML_CCA::TPML_CCA
(
    const std::vector<TPMA_CC>& _commandAttributes
)
{
    commandAttributes= _commandAttributes;
};
/// <summary>
/// This list is only used in TPM2_GetCapability(capability = TPM_CAP_COMMANDS).
/// </summary>
TPML_CCA::~TPML_CCA()
{
    return;
};
/// <summary>
/// This list is only used in TPM2_GetCapability(capability = TPM_CAP_COMMANDS).
/// </summary>
TPML_CCA& TPML_CCA::operator=(const TPML_CCA& rhs)
{
    if(this == &rhs) return *this;
    this->count = rhs.count;
    this->commandAttributes = rhs.commandAttributes;
    return *this;
};
/// <summary>
/// This list is only used in TPM2_GetCapability(capability = TPM_CAP_COMMANDS).
/// </summary>
TPML_CCA::TPML_CCA(const TPML_CCA& r)
{
    this->count = r.count;
    this->commandAttributes = r.commandAttributes;
};
/// <summary>
/// This list is only used in TPM2_GetCapability(capability = TPM_CAP_COMMANDS).
/// </summary>
TpmStructureBase* TPML_CCA::Clone() const
{
    TPML_CCA* _x = new TPML_CCA(*this);
    return _x;
};
void* TPML_CCA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&count);
            case 1: { if(newArraySize != -1)commandAttributes.resize(newArraySize); arraySize = (int)commandAttributes.size(); return (void*)(&commandAttributes); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&commandAttributes[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPML_ALG::GetTypeId() const
{
    return TpmTypeId::TPML_ALG_ID;
};
/// <summary>
/// This list is returned by TPM2_IncrementalSelfTest().
/// </summary>
TPML_ALG::TPML_ALG()
{
    return;
};
TPML_ALG::TPML_ALG
(
    const std::vector<TPM_ALG_ID>& _algorithms
)
{
    algorithms= _algorithms;
};
/// <summary>
/// This list is returned by TPM2_IncrementalSelfTest().
/// </summary>
TPML_ALG::~TPML_ALG()
{
    return;
};
/// <summary>
/// This list is returned by TPM2_IncrementalSelfTest().
/// </summary>
TPML_ALG& TPML_ALG::operator=(const TPML_ALG& rhs)
{
    if(this == &rhs) return *this;
    this->count = rhs.count;
    this->algorithms = rhs.algorithms;
    return *this;
};
/// <summary>
/// This list is returned by TPM2_IncrementalSelfTest().
/// </summary>
TPML_ALG::TPML_ALG(const TPML_ALG& r)
{
    this->count = r.count;
    this->algorithms = r.algorithms;
};
/// <summary>
/// This list is returned by TPM2_IncrementalSelfTest().
/// </summary>
TpmStructureBase* TPML_ALG::Clone() const
{
    TPML_ALG* _x = new TPML_ALG(*this);
    return _x;
};
void* TPML_ALG::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&count);
            case 1: { if(newArraySize != -1)algorithms.resize(newArraySize); arraySize = (int)algorithms.size(); return (void*)(&algorithms); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&algorithms[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPML_HANDLE::GetTypeId() const
{
    return TpmTypeId::TPML_HANDLE_ID;
};
/// <summary>
/// This structure is used when the TPM returns a list of loaded handles when the capability in TPM2_GetCapability() is TPM_CAP_HANDLE.
/// </summary>
TPML_HANDLE::TPML_HANDLE()
{
    return;
};
TPML_HANDLE::TPML_HANDLE
(
    const std::vector<TPM_HANDLE>& _handle
)
{
    handle= _handle;
};
/// <summary>
/// This structure is used when the TPM returns a list of loaded handles when the capability in TPM2_GetCapability() is TPM_CAP_HANDLE.
/// </summary>
TPML_HANDLE::~TPML_HANDLE()
{
    return;
};
/// <summary>
/// This structure is used when the TPM returns a list of loaded handles when the capability in TPM2_GetCapability() is TPM_CAP_HANDLE.
/// </summary>
TPML_HANDLE& TPML_HANDLE::operator=(const TPML_HANDLE& rhs)
{
    if(this == &rhs) return *this;
    this->count = rhs.count;
    this->handle = rhs.handle;
    return *this;
};
/// <summary>
/// This structure is used when the TPM returns a list of loaded handles when the capability in TPM2_GetCapability() is TPM_CAP_HANDLE.
/// </summary>
TPML_HANDLE::TPML_HANDLE(const TPML_HANDLE& r)
{
    this->count = r.count;
    this->handle = r.handle;
};
/// <summary>
/// This structure is used when the TPM returns a list of loaded handles when the capability in TPM2_GetCapability() is TPM_CAP_HANDLE.
/// </summary>
TpmStructureBase* TPML_HANDLE::Clone() const
{
    TPML_HANDLE* _x = new TPML_HANDLE(*this);
    return _x;
};
void* TPML_HANDLE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&count);
            case 1: { if(newArraySize != -1)handle.resize(newArraySize); arraySize = (int)handle.size(); return (void*)(&handle); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&handle[arrayIndex]);return (void*)(&handle[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPML_DIGEST::GetTypeId() const
{
    return TpmTypeId::TPML_DIGEST_ID;
};
/// <summary>
/// This list is used to convey a list of digest values. This type is used in TPM2_PolicyOR() and in TPM2_PCR_Read().
/// </summary>
TPML_DIGEST::TPML_DIGEST()
{
    return;
};
TPML_DIGEST::TPML_DIGEST
(
    const std::vector<TPM2B_DIGEST>& _digests
)
{
    digests= _digests;
};
/// <summary>
/// This list is used to convey a list of digest values. This type is used in TPM2_PolicyOR() and in TPM2_PCR_Read().
/// </summary>
TPML_DIGEST::~TPML_DIGEST()
{
    return;
};
/// <summary>
/// This list is used to convey a list of digest values. This type is used in TPM2_PolicyOR() and in TPM2_PCR_Read().
/// </summary>
TPML_DIGEST& TPML_DIGEST::operator=(const TPML_DIGEST& rhs)
{
    if(this == &rhs) return *this;
    this->count = rhs.count;
    this->digests = rhs.digests;
    return *this;
};
/// <summary>
/// This list is used to convey a list of digest values. This type is used in TPM2_PolicyOR() and in TPM2_PCR_Read().
/// </summary>
TPML_DIGEST::TPML_DIGEST(const TPML_DIGEST& r)
{
    this->count = r.count;
    this->digests = r.digests;
};
/// <summary>
/// This list is used to convey a list of digest values. This type is used in TPM2_PolicyOR() and in TPM2_PCR_Read().
/// </summary>
TpmStructureBase* TPML_DIGEST::Clone() const
{
    TPML_DIGEST* _x = new TPML_DIGEST(*this);
    return _x;
};
void* TPML_DIGEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&count);
            case 1: { if(newArraySize != -1)digests.resize(newArraySize); arraySize = (int)digests.size(); return (void*)(&digests); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&digests[arrayIndex]);return (void*)(&digests[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPML_DIGEST_VALUES::GetTypeId() const
{
    return TpmTypeId::TPML_DIGEST_VALUES_ID;
};
/// <summary>
/// This list is used to convey a list of digest values. This type is returned by TPM2_Event() and TPM2_SequenceComplete() and is an input for TPM2_PCR_Extend().
/// </summary>
TPML_DIGEST_VALUES::TPML_DIGEST_VALUES()
{
    return;
};
TPML_DIGEST_VALUES::TPML_DIGEST_VALUES
(
    const std::vector<TPMT_HA>& _digests
)
{
    digests= _digests;
};
/// <summary>
/// This list is used to convey a list of digest values. This type is returned by TPM2_Event() and TPM2_SequenceComplete() and is an input for TPM2_PCR_Extend().
/// </summary>
TPML_DIGEST_VALUES::~TPML_DIGEST_VALUES()
{
    return;
};
/// <summary>
/// This list is used to convey a list of digest values. This type is returned by TPM2_Event() and TPM2_SequenceComplete() and is an input for TPM2_PCR_Extend().
/// </summary>
TPML_DIGEST_VALUES& TPML_DIGEST_VALUES::operator=(const TPML_DIGEST_VALUES& rhs)
{
    if(this == &rhs) return *this;
    this->count = rhs.count;
    this->digests = rhs.digests;
    return *this;
};
/// <summary>
/// This list is used to convey a list of digest values. This type is returned by TPM2_Event() and TPM2_SequenceComplete() and is an input for TPM2_PCR_Extend().
/// </summary>
TPML_DIGEST_VALUES::TPML_DIGEST_VALUES(const TPML_DIGEST_VALUES& r)
{
    this->count = r.count;
    this->digests = r.digests;
};
/// <summary>
/// This list is used to convey a list of digest values. This type is returned by TPM2_Event() and TPM2_SequenceComplete() and is an input for TPM2_PCR_Extend().
/// </summary>
TpmStructureBase* TPML_DIGEST_VALUES::Clone() const
{
    TPML_DIGEST_VALUES* _x = new TPML_DIGEST_VALUES(*this);
    return _x;
};
void* TPML_DIGEST_VALUES::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&count);
            case 1: { if(newArraySize != -1)digests.resize(newArraySize); arraySize = (int)digests.size(); return (void*)(&digests); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&digests[arrayIndex]);return (void*)(&digests[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPML_PCR_SELECTION::GetTypeId() const
{
    return TpmTypeId::TPML_PCR_SELECTION_ID;
};
/// <summary>
/// This list is used to indicate the PCR that are included in a selection when more than one PCR value may be selected.
/// </summary>
TPML_PCR_SELECTION::TPML_PCR_SELECTION()
{
    return;
};
TPML_PCR_SELECTION::TPML_PCR_SELECTION
(
    const std::vector<TPMS_PCR_SELECTION>& _pcrSelections
)
{
    pcrSelections= _pcrSelections;
};
/// <summary>
/// This list is used to indicate the PCR that are included in a selection when more than one PCR value may be selected.
/// </summary>
TPML_PCR_SELECTION::~TPML_PCR_SELECTION()
{
    return;
};
/// <summary>
/// This list is used to indicate the PCR that are included in a selection when more than one PCR value may be selected.
/// </summary>
TPML_PCR_SELECTION& TPML_PCR_SELECTION::operator=(const TPML_PCR_SELECTION& rhs)
{
    if(this == &rhs) return *this;
    this->count = rhs.count;
    this->pcrSelections = rhs.pcrSelections;
    return *this;
};
/// <summary>
/// This list is used to indicate the PCR that are included in a selection when more than one PCR value may be selected.
/// </summary>
TPML_PCR_SELECTION::TPML_PCR_SELECTION(const TPML_PCR_SELECTION& r)
{
    this->count = r.count;
    this->pcrSelections = r.pcrSelections;
};
/// <summary>
/// This list is used to indicate the PCR that are included in a selection when more than one PCR value may be selected.
/// </summary>
TpmStructureBase* TPML_PCR_SELECTION::Clone() const
{
    TPML_PCR_SELECTION* _x = new TPML_PCR_SELECTION(*this);
    return _x;
};
void* TPML_PCR_SELECTION::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&count);
            case 1: { if(newArraySize != -1)pcrSelections.resize(newArraySize); arraySize = (int)pcrSelections.size(); return (void*)(&pcrSelections); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&pcrSelections[arrayIndex]);return (void*)(&pcrSelections[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPML_ALG_PROPERTY::GetTypeId() const
{
    return TpmTypeId::TPML_ALG_PROPERTY_ID;
};
/// <summary>
/// This list is used to report on a list of algorithm attributes. It is returned in a TPM2_GetCapability().
/// </summary>
TPML_ALG_PROPERTY::TPML_ALG_PROPERTY()
{
    return;
};
TPML_ALG_PROPERTY::TPML_ALG_PROPERTY
(
    const std::vector<TPMS_ALG_PROPERTY>& _algProperties
)
{
    algProperties= _algProperties;
};
/// <summary>
/// This list is used to report on a list of algorithm attributes. It is returned in a TPM2_GetCapability().
/// </summary>
TPML_ALG_PROPERTY::~TPML_ALG_PROPERTY()
{
    return;
};
/// <summary>
/// This list is used to report on a list of algorithm attributes. It is returned in a TPM2_GetCapability().
/// </summary>
TPML_ALG_PROPERTY& TPML_ALG_PROPERTY::operator=(const TPML_ALG_PROPERTY& rhs)
{
    if(this == &rhs) return *this;
    this->count = rhs.count;
    this->algProperties = rhs.algProperties;
    return *this;
};
/// <summary>
/// This list is used to report on a list of algorithm attributes. It is returned in a TPM2_GetCapability().
/// </summary>
TPML_ALG_PROPERTY::TPML_ALG_PROPERTY(const TPML_ALG_PROPERTY& r)
{
    this->count = r.count;
    this->algProperties = r.algProperties;
};
/// <summary>
/// This list is used to report on a list of algorithm attributes. It is returned in a TPM2_GetCapability().
/// </summary>
TpmStructureBase* TPML_ALG_PROPERTY::Clone() const
{
    TPML_ALG_PROPERTY* _x = new TPML_ALG_PROPERTY(*this);
    return _x;
};
void* TPML_ALG_PROPERTY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&count);
            case 1: { if(newArraySize != -1)algProperties.resize(newArraySize); arraySize = (int)algProperties.size(); return (void*)(&algProperties); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&algProperties[arrayIndex]);return (void*)(&algProperties[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPML_TAGGED_TPM_PROPERTY::GetTypeId() const
{
    return TpmTypeId::TPML_TAGGED_TPM_PROPERTY_ID;
};
/// <summary>
/// This list is used to report on a list of properties that are TPMS_TAGGED_PROPERTY values. It is returned by a TPM2_GetCapability().
/// </summary>
TPML_TAGGED_TPM_PROPERTY::TPML_TAGGED_TPM_PROPERTY()
{
    return;
};
TPML_TAGGED_TPM_PROPERTY::TPML_TAGGED_TPM_PROPERTY
(
    const std::vector<TPMS_TAGGED_PROPERTY>& _tpmProperty
)
{
    tpmProperty= _tpmProperty;
};
/// <summary>
/// This list is used to report on a list of properties that are TPMS_TAGGED_PROPERTY values. It is returned by a TPM2_GetCapability().
/// </summary>
TPML_TAGGED_TPM_PROPERTY::~TPML_TAGGED_TPM_PROPERTY()
{
    return;
};
/// <summary>
/// This list is used to report on a list of properties that are TPMS_TAGGED_PROPERTY values. It is returned by a TPM2_GetCapability().
/// </summary>
TPML_TAGGED_TPM_PROPERTY& TPML_TAGGED_TPM_PROPERTY::operator=(const TPML_TAGGED_TPM_PROPERTY& rhs)
{
    if(this == &rhs) return *this;
    this->count = rhs.count;
    this->tpmProperty = rhs.tpmProperty;
    return *this;
};
/// <summary>
/// This list is used to report on a list of properties that are TPMS_TAGGED_PROPERTY values. It is returned by a TPM2_GetCapability().
/// </summary>
TPML_TAGGED_TPM_PROPERTY::TPML_TAGGED_TPM_PROPERTY(const TPML_TAGGED_TPM_PROPERTY& r)
{
    this->count = r.count;
    this->tpmProperty = r.tpmProperty;
};
/// <summary>
/// This list is used to report on a list of properties that are TPMS_TAGGED_PROPERTY values. It is returned by a TPM2_GetCapability().
/// </summary>
TpmStructureBase* TPML_TAGGED_TPM_PROPERTY::Clone() const
{
    TPML_TAGGED_TPM_PROPERTY* _x = new TPML_TAGGED_TPM_PROPERTY(*this);
    return _x;
};
void* TPML_TAGGED_TPM_PROPERTY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&count);
            case 1: { if(newArraySize != -1)tpmProperty.resize(newArraySize); arraySize = (int)tpmProperty.size(); return (void*)(&tpmProperty); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&tpmProperty[arrayIndex]);return (void*)(&tpmProperty[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPML_TAGGED_PCR_PROPERTY::GetTypeId() const
{
    return TpmTypeId::TPML_TAGGED_PCR_PROPERTY_ID;
};
/// <summary>
/// This list is used to report on a list of properties that are TPMS_PCR_SELECT values. It is returned by a TPM2_GetCapability().
/// </summary>
TPML_TAGGED_PCR_PROPERTY::TPML_TAGGED_PCR_PROPERTY()
{
    return;
};
TPML_TAGGED_PCR_PROPERTY::TPML_TAGGED_PCR_PROPERTY
(
    const std::vector<TPMS_TAGGED_PCR_SELECT>& _pcrProperty
)
{
    pcrProperty= _pcrProperty;
};
/// <summary>
/// This list is used to report on a list of properties that are TPMS_PCR_SELECT values. It is returned by a TPM2_GetCapability().
/// </summary>
TPML_TAGGED_PCR_PROPERTY::~TPML_TAGGED_PCR_PROPERTY()
{
    return;
};
/// <summary>
/// This list is used to report on a list of properties that are TPMS_PCR_SELECT values. It is returned by a TPM2_GetCapability().
/// </summary>
TPML_TAGGED_PCR_PROPERTY& TPML_TAGGED_PCR_PROPERTY::operator=(const TPML_TAGGED_PCR_PROPERTY& rhs)
{
    if(this == &rhs) return *this;
    this->count = rhs.count;
    this->pcrProperty = rhs.pcrProperty;
    return *this;
};
/// <summary>
/// This list is used to report on a list of properties that are TPMS_PCR_SELECT values. It is returned by a TPM2_GetCapability().
/// </summary>
TPML_TAGGED_PCR_PROPERTY::TPML_TAGGED_PCR_PROPERTY(const TPML_TAGGED_PCR_PROPERTY& r)
{
    this->count = r.count;
    this->pcrProperty = r.pcrProperty;
};
/// <summary>
/// This list is used to report on a list of properties that are TPMS_PCR_SELECT values. It is returned by a TPM2_GetCapability().
/// </summary>
TpmStructureBase* TPML_TAGGED_PCR_PROPERTY::Clone() const
{
    TPML_TAGGED_PCR_PROPERTY* _x = new TPML_TAGGED_PCR_PROPERTY(*this);
    return _x;
};
void* TPML_TAGGED_PCR_PROPERTY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&count);
            case 1: { if(newArraySize != -1)pcrProperty.resize(newArraySize); arraySize = (int)pcrProperty.size(); return (void*)(&pcrProperty); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&pcrProperty[arrayIndex]);return (void*)(&pcrProperty[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPML_ECC_CURVE::GetTypeId() const
{
    return TpmTypeId::TPML_ECC_CURVE_ID;
};
/// <summary>
/// This list is used to report the ECC curve ID values supported by the TPM. It is returned by a TPM2_GetCapability().
/// </summary>
TPML_ECC_CURVE::TPML_ECC_CURVE()
{
    return;
};
TPML_ECC_CURVE::TPML_ECC_CURVE
(
    const std::vector<TPM_ECC_CURVE>& _eccCurves
)
{
    eccCurves= _eccCurves;
};
/// <summary>
/// This list is used to report the ECC curve ID values supported by the TPM. It is returned by a TPM2_GetCapability().
/// </summary>
TPML_ECC_CURVE::~TPML_ECC_CURVE()
{
    return;
};
/// <summary>
/// This list is used to report the ECC curve ID values supported by the TPM. It is returned by a TPM2_GetCapability().
/// </summary>
TPML_ECC_CURVE& TPML_ECC_CURVE::operator=(const TPML_ECC_CURVE& rhs)
{
    if(this == &rhs) return *this;
    this->count = rhs.count;
    this->eccCurves = rhs.eccCurves;
    return *this;
};
/// <summary>
/// This list is used to report the ECC curve ID values supported by the TPM. It is returned by a TPM2_GetCapability().
/// </summary>
TPML_ECC_CURVE::TPML_ECC_CURVE(const TPML_ECC_CURVE& r)
{
    this->count = r.count;
    this->eccCurves = r.eccCurves;
};
/// <summary>
/// This list is used to report the ECC curve ID values supported by the TPM. It is returned by a TPM2_GetCapability().
/// </summary>
TpmStructureBase* TPML_ECC_CURVE::Clone() const
{
    TPML_ECC_CURVE* _x = new TPML_ECC_CURVE(*this);
    return _x;
};
void* TPML_ECC_CURVE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&count);
            case 1: { if(newArraySize != -1)eccCurves.resize(newArraySize); arraySize = (int)eccCurves.size(); return (void*)(&eccCurves); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&eccCurves[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPML_TAGGED_POLICY::GetTypeId() const
{
    return TpmTypeId::TPML_TAGGED_POLICY_ID;
};
/// <summary>
/// This list is used to report the authorization policy values for permanent handles. This is list may be generated by TPM2_GetCapabiltiy(). A permanent handle that cannot have a policy is not included in the list.
/// </summary>
TPML_TAGGED_POLICY::TPML_TAGGED_POLICY()
{
    return;
};
TPML_TAGGED_POLICY::TPML_TAGGED_POLICY
(
    const std::vector<TPMS_TAGGED_POLICY>& _policies
)
{
    policies= _policies;
};
/// <summary>
/// This list is used to report the authorization policy values for permanent handles. This is list may be generated by TPM2_GetCapabiltiy(). A permanent handle that cannot have a policy is not included in the list.
/// </summary>
TPML_TAGGED_POLICY::~TPML_TAGGED_POLICY()
{
    return;
};
/// <summary>
/// This list is used to report the authorization policy values for permanent handles. This is list may be generated by TPM2_GetCapabiltiy(). A permanent handle that cannot have a policy is not included in the list.
/// </summary>
TPML_TAGGED_POLICY& TPML_TAGGED_POLICY::operator=(const TPML_TAGGED_POLICY& rhs)
{
    if(this == &rhs) return *this;
    this->count = rhs.count;
    this->policies = rhs.policies;
    return *this;
};
/// <summary>
/// This list is used to report the authorization policy values for permanent handles. This is list may be generated by TPM2_GetCapabiltiy(). A permanent handle that cannot have a policy is not included in the list.
/// </summary>
TPML_TAGGED_POLICY::TPML_TAGGED_POLICY(const TPML_TAGGED_POLICY& r)
{
    this->count = r.count;
    this->policies = r.policies;
};
/// <summary>
/// This list is used to report the authorization policy values for permanent handles. This is list may be generated by TPM2_GetCapabiltiy(). A permanent handle that cannot have a policy is not included in the list.
/// </summary>
TpmStructureBase* TPML_TAGGED_POLICY::Clone() const
{
    TPML_TAGGED_POLICY* _x = new TPML_TAGGED_POLICY(*this);
    return _x;
};
void* TPML_TAGGED_POLICY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&count);
            case 1: { if(newArraySize != -1)policies.resize(newArraySize); arraySize = (int)policies.size(); return (void*)(&policies); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&policies[arrayIndex]);return (void*)(&policies[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_CAPABILITY_DATA::GetTypeId() const
{
    return TpmTypeId::TPMS_CAPABILITY_DATA_ID;
};
/// <summary>
/// This data area is returned in response to a TPM2_GetCapability().
/// </summary>
TPMS_CAPABILITY_DATA::TPMS_CAPABILITY_DATA()
{
    data = NULL;
    return;
};
TPMS_CAPABILITY_DATA::TPMS_CAPABILITY_DATA
(
    const TPMU_CAPABILITIES& _data
)
{
    data = dynamic_cast<TPMU_CAPABILITIES*> (_data.Clone());
};
/// <summary>
/// This data area is returned in response to a TPM2_GetCapability().
/// </summary>
TPMS_CAPABILITY_DATA::~TPMS_CAPABILITY_DATA()
{
    if(data != NULL) { delete data;data=NULL; }
    return;
};
/// <summary>
/// This data area is returned in response to a TPM2_GetCapability().
/// </summary>
TPMS_CAPABILITY_DATA& TPMS_CAPABILITY_DATA::operator=(const TPMS_CAPABILITY_DATA& rhs)
{
    if(this == &rhs) return *this;
    this->capability = rhs.capability;
    if(data != NULL) delete data;
    if(rhs.data != NULL)data = dynamic_cast<TPMU_CAPABILITIES*>(rhs.data->Clone());
    return *this;
};
/// <summary>
/// This data area is returned in response to a TPM2_GetCapability().
/// </summary>
TPMS_CAPABILITY_DATA::TPMS_CAPABILITY_DATA(const TPMS_CAPABILITY_DATA& r)
{
    this->capability = r.capability;
    if(r.data != NULL)data = dynamic_cast<TPMU_CAPABILITIES*>(r.data->Clone());
};
/// <summary>
/// This data area is returned in response to a TPM2_GetCapability().
/// </summary>
TpmStructureBase* TPMS_CAPABILITY_DATA::Clone() const
{
    TPMS_CAPABILITY_DATA* _x = new TPMS_CAPABILITY_DATA(*this);
    return _x;
};
void* TPMS_CAPABILITY_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&capability);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(data); return (void*) (&data);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_CLOCK_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_CLOCK_INFO_ID;
};
/// <summary>
/// This structure is used in each of the attestation commands.
/// </summary>
TPMS_CLOCK_INFO::TPMS_CLOCK_INFO()
{
    return;
};
TPMS_CLOCK_INFO::TPMS_CLOCK_INFO
(
    const UINT64& _clock,
    const UINT32& _resetCount,
    const UINT32& _restartCount,
    const BYTE& _safe
)
{
    clock= _clock;
    resetCount= _resetCount;
    restartCount= _restartCount;
    safe= _safe;
};
/// <summary>
/// This structure is used in each of the attestation commands.
/// </summary>
TPMS_CLOCK_INFO::~TPMS_CLOCK_INFO()
{
    return;
};
/// <summary>
/// This structure is used in each of the attestation commands.
/// </summary>
TPMS_CLOCK_INFO& TPMS_CLOCK_INFO::operator=(const TPMS_CLOCK_INFO& rhs)
{
    if(this == &rhs) return *this;
    this->clock = rhs.clock;
    this->resetCount = rhs.resetCount;
    this->restartCount = rhs.restartCount;
    this->safe = rhs.safe;
    return *this;
};
/// <summary>
/// This structure is used in each of the attestation commands.
/// </summary>
TPMS_CLOCK_INFO::TPMS_CLOCK_INFO(const TPMS_CLOCK_INFO& r)
{
    this->clock = r.clock;
    this->resetCount = r.resetCount;
    this->restartCount = r.restartCount;
    this->safe = r.safe;
};
/// <summary>
/// This structure is used in each of the attestation commands.
/// </summary>
TpmStructureBase* TPMS_CLOCK_INFO::Clone() const
{
    TPMS_CLOCK_INFO* _x = new TPMS_CLOCK_INFO(*this);
    return _x;
};
void* TPMS_CLOCK_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&clock);
            case 1: return (void*) (&resetCount);
            case 2: return (void*) (&restartCount);
            case 3: return (void*) (&safe);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_TIME_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_TIME_INFO_ID;
};
/// <summary>
/// This structure is used in, e.g., the TPM2_GetTime() attestation and TPM2_ReadClock().
/// </summary>
TPMS_TIME_INFO::TPMS_TIME_INFO()
{
    return;
};
TPMS_TIME_INFO::TPMS_TIME_INFO
(
    const UINT64& _time,
    const TPMS_CLOCK_INFO& _clockInfo
)
{
    time= _time;
    clockInfo= _clockInfo;
};
/// <summary>
/// This structure is used in, e.g., the TPM2_GetTime() attestation and TPM2_ReadClock().
/// </summary>
TPMS_TIME_INFO::~TPMS_TIME_INFO()
{
    return;
};
/// <summary>
/// This structure is used in, e.g., the TPM2_GetTime() attestation and TPM2_ReadClock().
/// </summary>
TPMS_TIME_INFO& TPMS_TIME_INFO::operator=(const TPMS_TIME_INFO& rhs)
{
    if(this == &rhs) return *this;
    this->time = rhs.time;
    this->clockInfo = rhs.clockInfo;
    return *this;
};
/// <summary>
/// This structure is used in, e.g., the TPM2_GetTime() attestation and TPM2_ReadClock().
/// </summary>
TPMS_TIME_INFO::TPMS_TIME_INFO(const TPMS_TIME_INFO& r)
{
    this->time = r.time;
    this->clockInfo = r.clockInfo;
};
/// <summary>
/// This structure is used in, e.g., the TPM2_GetTime() attestation and TPM2_ReadClock().
/// </summary>
TpmStructureBase* TPMS_TIME_INFO::Clone() const
{
    TPMS_TIME_INFO* _x = new TPMS_TIME_INFO(*this);
    return _x;
};
void* TPMS_TIME_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&time);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&clockInfo); return (void*) (&clockInfo);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_TIME_ATTEST_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_TIME_ATTEST_INFO_ID;
};
/// <summary>
/// This structure is used when the TPM performs TPM2_GetTime.
/// </summary>
TPMS_TIME_ATTEST_INFO::TPMS_TIME_ATTEST_INFO()
{
    return;
};
TPMS_TIME_ATTEST_INFO::TPMS_TIME_ATTEST_INFO
(
    const TPMS_TIME_INFO& _time,
    const UINT64& _firmwareVersion
)
{
    time= _time;
    firmwareVersion= _firmwareVersion;
};
/// <summary>
/// This structure is used when the TPM performs TPM2_GetTime.
/// </summary>
TPMS_TIME_ATTEST_INFO::~TPMS_TIME_ATTEST_INFO()
{
    return;
};
/// <summary>
/// This structure is used when the TPM performs TPM2_GetTime.
/// </summary>
TPMS_TIME_ATTEST_INFO& TPMS_TIME_ATTEST_INFO::operator=(const TPMS_TIME_ATTEST_INFO& rhs)
{
    if(this == &rhs) return *this;
    this->time = rhs.time;
    this->firmwareVersion = rhs.firmwareVersion;
    return *this;
};
/// <summary>
/// This structure is used when the TPM performs TPM2_GetTime.
/// </summary>
TPMS_TIME_ATTEST_INFO::TPMS_TIME_ATTEST_INFO(const TPMS_TIME_ATTEST_INFO& r)
{
    this->time = r.time;
    this->firmwareVersion = r.firmwareVersion;
};
/// <summary>
/// This structure is used when the TPM performs TPM2_GetTime.
/// </summary>
TpmStructureBase* TPMS_TIME_ATTEST_INFO::Clone() const
{
    TPMS_TIME_ATTEST_INFO* _x = new TPMS_TIME_ATTEST_INFO(*this);
    return _x;
};
void* TPMS_TIME_ATTEST_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&time); return (void*) (&time);
            case 1: return (void*) (&firmwareVersion);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_CERTIFY_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_CERTIFY_INFO_ID;
};
/// <summary>
/// This is the attested data for TPM2_Certify().
/// </summary>
TPMS_CERTIFY_INFO::TPMS_CERTIFY_INFO()
{
    return;
};
TPMS_CERTIFY_INFO::TPMS_CERTIFY_INFO
(
    const std::vector<BYTE>& _name,
    const std::vector<BYTE>& _qualifiedName
)
{
    name= _name;
    qualifiedName= _qualifiedName;
};
/// <summary>
/// This is the attested data for TPM2_Certify().
/// </summary>
TPMS_CERTIFY_INFO::~TPMS_CERTIFY_INFO()
{
    return;
};
/// <summary>
/// This is the attested data for TPM2_Certify().
/// </summary>
TPMS_CERTIFY_INFO& TPMS_CERTIFY_INFO::operator=(const TPMS_CERTIFY_INFO& rhs)
{
    if(this == &rhs) return *this;
    this->nameSize = rhs.nameSize;
    this->name = rhs.name;
    this->qualifiedNameSize = rhs.qualifiedNameSize;
    this->qualifiedName = rhs.qualifiedName;
    return *this;
};
/// <summary>
/// This is the attested data for TPM2_Certify().
/// </summary>
TPMS_CERTIFY_INFO::TPMS_CERTIFY_INFO(const TPMS_CERTIFY_INFO& r)
{
    this->nameSize = r.nameSize;
    this->name = r.name;
    this->qualifiedNameSize = r.qualifiedNameSize;
    this->qualifiedName = r.qualifiedName;
};
/// <summary>
/// This is the attested data for TPM2_Certify().
/// </summary>
TpmStructureBase* TPMS_CERTIFY_INFO::Clone() const
{
    TPMS_CERTIFY_INFO* _x = new TPMS_CERTIFY_INFO(*this);
    return _x;
};
void* TPMS_CERTIFY_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&nameSize);
            case 1: { if(newArraySize != -1)name.resize(newArraySize); arraySize = (int)name.size(); return (void*)(&name); }
            case 2: return (void*) (&qualifiedNameSize);
            case 3: { if(newArraySize != -1)qualifiedName.resize(newArraySize); arraySize = (int)qualifiedName.size(); return (void*)(&qualifiedName); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&name[arrayIndex]);
            case 3: return (void*)(&qualifiedName[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_QUOTE_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_QUOTE_INFO_ID;
};
/// <summary>
/// This is the attested data for TPM2_Quote().
/// </summary>
TPMS_QUOTE_INFO::TPMS_QUOTE_INFO()
{
    return;
};
TPMS_QUOTE_INFO::TPMS_QUOTE_INFO
(
    const std::vector<TPMS_PCR_SELECTION>& _pcrSelect,
    const std::vector<BYTE>& _pcrDigest
)
{
    pcrSelect= _pcrSelect;
    pcrDigest= _pcrDigest;
};
/// <summary>
/// This is the attested data for TPM2_Quote().
/// </summary>
TPMS_QUOTE_INFO::~TPMS_QUOTE_INFO()
{
    return;
};
/// <summary>
/// This is the attested data for TPM2_Quote().
/// </summary>
TPMS_QUOTE_INFO& TPMS_QUOTE_INFO::operator=(const TPMS_QUOTE_INFO& rhs)
{
    if(this == &rhs) return *this;
    this->pcrSelectCount = rhs.pcrSelectCount;
    this->pcrSelect = rhs.pcrSelect;
    this->pcrDigestSize = rhs.pcrDigestSize;
    this->pcrDigest = rhs.pcrDigest;
    return *this;
};
/// <summary>
/// This is the attested data for TPM2_Quote().
/// </summary>
TPMS_QUOTE_INFO::TPMS_QUOTE_INFO(const TPMS_QUOTE_INFO& r)
{
    this->pcrSelectCount = r.pcrSelectCount;
    this->pcrSelect = r.pcrSelect;
    this->pcrDigestSize = r.pcrDigestSize;
    this->pcrDigest = r.pcrDigest;
};
/// <summary>
/// This is the attested data for TPM2_Quote().
/// </summary>
TpmStructureBase* TPMS_QUOTE_INFO::Clone() const
{
    TPMS_QUOTE_INFO* _x = new TPMS_QUOTE_INFO(*this);
    return _x;
};
void* TPMS_QUOTE_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&pcrSelectCount);
            case 1: { if(newArraySize != -1)pcrSelect.resize(newArraySize); arraySize = (int)pcrSelect.size(); return (void*)(&pcrSelect); }
            case 2: return (void*) (&pcrDigestSize);
            case 3: { if(newArraySize != -1)pcrDigest.resize(newArraySize); arraySize = (int)pcrDigest.size(); return (void*)(&pcrDigest); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&pcrSelect[arrayIndex]);return (void*)(&pcrSelect[arrayIndex]);
            case 3: return (void*)(&pcrDigest[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_COMMAND_AUDIT_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
};
/// <summary>
/// This is the attested data for TPM2_GetCommandAuditDigest().
/// </summary>
TPMS_COMMAND_AUDIT_INFO::TPMS_COMMAND_AUDIT_INFO()
{
    return;
};
TPMS_COMMAND_AUDIT_INFO::TPMS_COMMAND_AUDIT_INFO
(
    const UINT64& _auditCounter,
    const TPM_ALG_ID& _digestAlg,
    const std::vector<BYTE>& _auditDigest,
    const std::vector<BYTE>& _commandDigest
)
{
    auditCounter= _auditCounter;
    digestAlg= _digestAlg;
    auditDigest= _auditDigest;
    commandDigest= _commandDigest;
};
/// <summary>
/// This is the attested data for TPM2_GetCommandAuditDigest().
/// </summary>
TPMS_COMMAND_AUDIT_INFO::~TPMS_COMMAND_AUDIT_INFO()
{
    return;
};
/// <summary>
/// This is the attested data for TPM2_GetCommandAuditDigest().
/// </summary>
TPMS_COMMAND_AUDIT_INFO& TPMS_COMMAND_AUDIT_INFO::operator=(const TPMS_COMMAND_AUDIT_INFO& rhs)
{
    if(this == &rhs) return *this;
    this->auditCounter = rhs.auditCounter;
    this->digestAlg = rhs.digestAlg;
    this->auditDigestSize = rhs.auditDigestSize;
    this->auditDigest = rhs.auditDigest;
    this->commandDigestSize = rhs.commandDigestSize;
    this->commandDigest = rhs.commandDigest;
    return *this;
};
/// <summary>
/// This is the attested data for TPM2_GetCommandAuditDigest().
/// </summary>
TPMS_COMMAND_AUDIT_INFO::TPMS_COMMAND_AUDIT_INFO(const TPMS_COMMAND_AUDIT_INFO& r)
{
    this->auditCounter = r.auditCounter;
    this->digestAlg = r.digestAlg;
    this->auditDigestSize = r.auditDigestSize;
    this->auditDigest = r.auditDigest;
    this->commandDigestSize = r.commandDigestSize;
    this->commandDigest = r.commandDigest;
};
/// <summary>
/// This is the attested data for TPM2_GetCommandAuditDigest().
/// </summary>
TpmStructureBase* TPMS_COMMAND_AUDIT_INFO::Clone() const
{
    TPMS_COMMAND_AUDIT_INFO* _x = new TPMS_COMMAND_AUDIT_INFO(*this);
    return _x;
};
void* TPMS_COMMAND_AUDIT_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&auditCounter);
            case 1: return (void*) (&digestAlg);
            case 2: return (void*) (&auditDigestSize);
            case 3: { if(newArraySize != -1)auditDigest.resize(newArraySize); arraySize = (int)auditDigest.size(); return (void*)(&auditDigest); }
            case 4: return (void*) (&commandDigestSize);
            case 5: { if(newArraySize != -1)commandDigest.resize(newArraySize); arraySize = (int)commandDigest.size(); return (void*)(&commandDigest); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&auditDigest[arrayIndex]);
            case 5: return (void*)(&commandDigest[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_SESSION_AUDIT_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID;
};
/// <summary>
/// This is the attested data for TPM2_GetSessionAuditDigest().
/// </summary>
TPMS_SESSION_AUDIT_INFO::TPMS_SESSION_AUDIT_INFO()
{
    return;
};
TPMS_SESSION_AUDIT_INFO::TPMS_SESSION_AUDIT_INFO
(
    const BYTE& _exclusiveSession,
    const std::vector<BYTE>& _sessionDigest
)
{
    exclusiveSession= _exclusiveSession;
    sessionDigest= _sessionDigest;
};
/// <summary>
/// This is the attested data for TPM2_GetSessionAuditDigest().
/// </summary>
TPMS_SESSION_AUDIT_INFO::~TPMS_SESSION_AUDIT_INFO()
{
    return;
};
/// <summary>
/// This is the attested data for TPM2_GetSessionAuditDigest().
/// </summary>
TPMS_SESSION_AUDIT_INFO& TPMS_SESSION_AUDIT_INFO::operator=(const TPMS_SESSION_AUDIT_INFO& rhs)
{
    if(this == &rhs) return *this;
    this->exclusiveSession = rhs.exclusiveSession;
    this->sessionDigestSize = rhs.sessionDigestSize;
    this->sessionDigest = rhs.sessionDigest;
    return *this;
};
/// <summary>
/// This is the attested data for TPM2_GetSessionAuditDigest().
/// </summary>
TPMS_SESSION_AUDIT_INFO::TPMS_SESSION_AUDIT_INFO(const TPMS_SESSION_AUDIT_INFO& r)
{
    this->exclusiveSession = r.exclusiveSession;
    this->sessionDigestSize = r.sessionDigestSize;
    this->sessionDigest = r.sessionDigest;
};
/// <summary>
/// This is the attested data for TPM2_GetSessionAuditDigest().
/// </summary>
TpmStructureBase* TPMS_SESSION_AUDIT_INFO::Clone() const
{
    TPMS_SESSION_AUDIT_INFO* _x = new TPMS_SESSION_AUDIT_INFO(*this);
    return _x;
};
void* TPMS_SESSION_AUDIT_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&exclusiveSession);
            case 1: return (void*) (&sessionDigestSize);
            case 2: { if(newArraySize != -1)sessionDigest.resize(newArraySize); arraySize = (int)sessionDigest.size(); return (void*)(&sessionDigest); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&sessionDigest[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_CREATION_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_CREATION_INFO_ID;
};
/// <summary>
/// This is the attested data for TPM2_CertifyCreation().
/// </summary>
TPMS_CREATION_INFO::TPMS_CREATION_INFO()
{
    return;
};
TPMS_CREATION_INFO::TPMS_CREATION_INFO
(
    const std::vector<BYTE>& _objectName,
    const std::vector<BYTE>& _creationHash
)
{
    objectName= _objectName;
    creationHash= _creationHash;
};
/// <summary>
/// This is the attested data for TPM2_CertifyCreation().
/// </summary>
TPMS_CREATION_INFO::~TPMS_CREATION_INFO()
{
    return;
};
/// <summary>
/// This is the attested data for TPM2_CertifyCreation().
/// </summary>
TPMS_CREATION_INFO& TPMS_CREATION_INFO::operator=(const TPMS_CREATION_INFO& rhs)
{
    if(this == &rhs) return *this;
    this->objectNameSize = rhs.objectNameSize;
    this->objectName = rhs.objectName;
    this->creationHashSize = rhs.creationHashSize;
    this->creationHash = rhs.creationHash;
    return *this;
};
/// <summary>
/// This is the attested data for TPM2_CertifyCreation().
/// </summary>
TPMS_CREATION_INFO::TPMS_CREATION_INFO(const TPMS_CREATION_INFO& r)
{
    this->objectNameSize = r.objectNameSize;
    this->objectName = r.objectName;
    this->creationHashSize = r.creationHashSize;
    this->creationHash = r.creationHash;
};
/// <summary>
/// This is the attested data for TPM2_CertifyCreation().
/// </summary>
TpmStructureBase* TPMS_CREATION_INFO::Clone() const
{
    TPMS_CREATION_INFO* _x = new TPMS_CREATION_INFO(*this);
    return _x;
};
void* TPMS_CREATION_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&objectNameSize);
            case 1: { if(newArraySize != -1)objectName.resize(newArraySize); arraySize = (int)objectName.size(); return (void*)(&objectName); }
            case 2: return (void*) (&creationHashSize);
            case 3: { if(newArraySize != -1)creationHash.resize(newArraySize); arraySize = (int)creationHash.size(); return (void*)(&creationHash); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&objectName[arrayIndex]);
            case 3: return (void*)(&creationHash[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_NV_CERTIFY_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
};
/// <summary>
/// This structure contains the Name and contents of the selected NV Index that is certified by TPM2_NV_Certify().
/// </summary>
TPMS_NV_CERTIFY_INFO::TPMS_NV_CERTIFY_INFO()
{
    return;
};
TPMS_NV_CERTIFY_INFO::TPMS_NV_CERTIFY_INFO
(
    const std::vector<BYTE>& _indexName,
    const UINT16& _offset,
    const std::vector<BYTE>& _nvContents
)
{
    indexName= _indexName;
    offset= _offset;
    nvContents= _nvContents;
};
/// <summary>
/// This structure contains the Name and contents of the selected NV Index that is certified by TPM2_NV_Certify().
/// </summary>
TPMS_NV_CERTIFY_INFO::~TPMS_NV_CERTIFY_INFO()
{
    return;
};
/// <summary>
/// This structure contains the Name and contents of the selected NV Index that is certified by TPM2_NV_Certify().
/// </summary>
TPMS_NV_CERTIFY_INFO& TPMS_NV_CERTIFY_INFO::operator=(const TPMS_NV_CERTIFY_INFO& rhs)
{
    if(this == &rhs) return *this;
    this->indexNameSize = rhs.indexNameSize;
    this->indexName = rhs.indexName;
    this->offset = rhs.offset;
    this->nvContentsSize = rhs.nvContentsSize;
    this->nvContents = rhs.nvContents;
    return *this;
};
/// <summary>
/// This structure contains the Name and contents of the selected NV Index that is certified by TPM2_NV_Certify().
/// </summary>
TPMS_NV_CERTIFY_INFO::TPMS_NV_CERTIFY_INFO(const TPMS_NV_CERTIFY_INFO& r)
{
    this->indexNameSize = r.indexNameSize;
    this->indexName = r.indexName;
    this->offset = r.offset;
    this->nvContentsSize = r.nvContentsSize;
    this->nvContents = r.nvContents;
};
/// <summary>
/// This structure contains the Name and contents of the selected NV Index that is certified by TPM2_NV_Certify().
/// </summary>
TpmStructureBase* TPMS_NV_CERTIFY_INFO::Clone() const
{
    TPMS_NV_CERTIFY_INFO* _x = new TPMS_NV_CERTIFY_INFO(*this);
    return _x;
};
void* TPMS_NV_CERTIFY_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&indexNameSize);
            case 1: { if(newArraySize != -1)indexName.resize(newArraySize); arraySize = (int)indexName.size(); return (void*)(&indexName); }
            case 2: return (void*) (&offset);
            case 3: return (void*) (&nvContentsSize);
            case 4: { if(newArraySize != -1)nvContents.resize(newArraySize); arraySize = (int)nvContents.size(); return (void*)(&nvContents); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&indexName[arrayIndex]);
            case 4: return (void*)(&nvContents[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_NV_DIGEST_CERTIFY_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID;
};
/// <summary>
/// This structure contains the Name and hash of the contents of the selected NV Index that is certified by TPM2_NV_Certify(). The data is hashed using hash of the signing scheme.
/// </summary>
TPMS_NV_DIGEST_CERTIFY_INFO::TPMS_NV_DIGEST_CERTIFY_INFO()
{
    return;
};
TPMS_NV_DIGEST_CERTIFY_INFO::TPMS_NV_DIGEST_CERTIFY_INFO
(
    const std::vector<BYTE>& _indexName,
    const std::vector<BYTE>& _nvDigest
)
{
    indexName= _indexName;
    nvDigest= _nvDigest;
};
/// <summary>
/// This structure contains the Name and hash of the contents of the selected NV Index that is certified by TPM2_NV_Certify(). The data is hashed using hash of the signing scheme.
/// </summary>
TPMS_NV_DIGEST_CERTIFY_INFO::~TPMS_NV_DIGEST_CERTIFY_INFO()
{
    return;
};
/// <summary>
/// This structure contains the Name and hash of the contents of the selected NV Index that is certified by TPM2_NV_Certify(). The data is hashed using hash of the signing scheme.
/// </summary>
TPMS_NV_DIGEST_CERTIFY_INFO& TPMS_NV_DIGEST_CERTIFY_INFO::operator=(const TPMS_NV_DIGEST_CERTIFY_INFO& rhs)
{
    if(this == &rhs) return *this;
    this->indexNameSize = rhs.indexNameSize;
    this->indexName = rhs.indexName;
    this->nvDigestSize = rhs.nvDigestSize;
    this->nvDigest = rhs.nvDigest;
    return *this;
};
/// <summary>
/// This structure contains the Name and hash of the contents of the selected NV Index that is certified by TPM2_NV_Certify(). The data is hashed using hash of the signing scheme.
/// </summary>
TPMS_NV_DIGEST_CERTIFY_INFO::TPMS_NV_DIGEST_CERTIFY_INFO(const TPMS_NV_DIGEST_CERTIFY_INFO& r)
{
    this->indexNameSize = r.indexNameSize;
    this->indexName = r.indexName;
    this->nvDigestSize = r.nvDigestSize;
    this->nvDigest = r.nvDigest;
};
/// <summary>
/// This structure contains the Name and hash of the contents of the selected NV Index that is certified by TPM2_NV_Certify(). The data is hashed using hash of the signing scheme.
/// </summary>
TpmStructureBase* TPMS_NV_DIGEST_CERTIFY_INFO::Clone() const
{
    TPMS_NV_DIGEST_CERTIFY_INFO* _x = new TPMS_NV_DIGEST_CERTIFY_INFO(*this);
    return _x;
};
void* TPMS_NV_DIGEST_CERTIFY_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&indexNameSize);
            case 1: { if(newArraySize != -1)indexName.resize(newArraySize); arraySize = (int)indexName.size(); return (void*)(&indexName); }
            case 2: return (void*) (&nvDigestSize);
            case 3: { if(newArraySize != -1)nvDigest.resize(newArraySize); arraySize = (int)nvDigest.size(); return (void*)(&nvDigest); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&indexName[arrayIndex]);
            case 3: return (void*)(&nvDigest[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_ATTEST::GetTypeId() const
{
    return TpmTypeId::TPMS_ATTEST_ID;
};
/// <summary>
/// This structure is used on each TPM-generated signed structure. The signature is over this structure.
/// </summary>
TPMS_ATTEST::TPMS_ATTEST()
{
    attested = NULL;
    return;
};
TPMS_ATTEST::TPMS_ATTEST
(
    const TPM_GENERATED& _magic,
    const std::vector<BYTE>& _qualifiedSigner,
    const std::vector<BYTE>& _extraData,
    const TPMS_CLOCK_INFO& _clockInfo,
    const UINT64& _firmwareVersion,
    const TPMU_ATTEST& _attested
)
{
    magic= _magic;
    qualifiedSigner= _qualifiedSigner;
    extraData= _extraData;
    clockInfo= _clockInfo;
    firmwareVersion= _firmwareVersion;
    attested = dynamic_cast<TPMU_ATTEST*> (_attested.Clone());
};
/// <summary>
/// This structure is used on each TPM-generated signed structure. The signature is over this structure.
/// </summary>
TPMS_ATTEST::~TPMS_ATTEST()
{
    if(attested != NULL) { delete attested;attested=NULL; }
    return;
};
/// <summary>
/// This structure is used on each TPM-generated signed structure. The signature is over this structure.
/// </summary>
TPMS_ATTEST& TPMS_ATTEST::operator=(const TPMS_ATTEST& rhs)
{
    if(this == &rhs) return *this;
    this->magic = rhs.magic;
    this->type = rhs.type;
    this->qualifiedSignerSize = rhs.qualifiedSignerSize;
    this->qualifiedSigner = rhs.qualifiedSigner;
    this->extraDataSize = rhs.extraDataSize;
    this->extraData = rhs.extraData;
    this->clockInfo = rhs.clockInfo;
    this->firmwareVersion = rhs.firmwareVersion;
    if(attested != NULL) delete attested;
    if(rhs.attested != NULL)attested = dynamic_cast<TPMU_ATTEST*>(rhs.attested->Clone());
    return *this;
};
/// <summary>
/// This structure is used on each TPM-generated signed structure. The signature is over this structure.
/// </summary>
TPMS_ATTEST::TPMS_ATTEST(const TPMS_ATTEST& r)
{
    this->magic = r.magic;
    this->type = r.type;
    this->qualifiedSignerSize = r.qualifiedSignerSize;
    this->qualifiedSigner = r.qualifiedSigner;
    this->extraDataSize = r.extraDataSize;
    this->extraData = r.extraData;
    this->clockInfo = r.clockInfo;
    this->firmwareVersion = r.firmwareVersion;
    if(r.attested != NULL)attested = dynamic_cast<TPMU_ATTEST*>(r.attested->Clone());
};
/// <summary>
/// This structure is used on each TPM-generated signed structure. The signature is over this structure.
/// </summary>
TpmStructureBase* TPMS_ATTEST::Clone() const
{
    TPMS_ATTEST* _x = new TPMS_ATTEST(*this);
    return _x;
};
void* TPMS_ATTEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&magic);
            case 1: return (void*) (&type);
            case 2: return (void*) (&qualifiedSignerSize);
            case 3: { if(newArraySize != -1)qualifiedSigner.resize(newArraySize); arraySize = (int)qualifiedSigner.size(); return (void*)(&qualifiedSigner); }
            case 4: return (void*) (&extraDataSize);
            case 5: { if(newArraySize != -1)extraData.resize(newArraySize); arraySize = (int)extraData.size(); return (void*)(&extraData); }
            case 6: pStruct = dynamic_cast<TpmStructureBase*>(&clockInfo); return (void*) (&clockInfo);
            case 7: return (void*) (&firmwareVersion);
            case 8: pStruct = dynamic_cast<TpmStructureBase*>(attested); return (void*) (&attested);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&qualifiedSigner[arrayIndex]);
            case 5: return (void*)(&extraData[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_ATTEST::GetTypeId() const
{
    return TpmTypeId::TPM2B_ATTEST_ID;
};
/// <summary>
/// This sized buffer to contain the signed structure. The attestationData is the signed portion of the structure. The size parameter is not signed.
/// </summary>
TPM2B_ATTEST::TPM2B_ATTEST()
{
    return;
};
TPM2B_ATTEST::TPM2B_ATTEST
(
    const TPMS_ATTEST& _attestationData
)
{
    attestationData= _attestationData;
};
/// <summary>
/// This sized buffer to contain the signed structure. The attestationData is the signed portion of the structure. The size parameter is not signed.
/// </summary>
TPM2B_ATTEST::~TPM2B_ATTEST()
{
    return;
};
/// <summary>
/// This sized buffer to contain the signed structure. The attestationData is the signed portion of the structure. The size parameter is not signed.
/// </summary>
TPM2B_ATTEST& TPM2B_ATTEST::operator=(const TPM2B_ATTEST& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->attestationData = rhs.attestationData;
    return *this;
};
/// <summary>
/// This sized buffer to contain the signed structure. The attestationData is the signed portion of the structure. The size parameter is not signed.
/// </summary>
TPM2B_ATTEST::TPM2B_ATTEST(const TPM2B_ATTEST& r)
{
    this->size = r.size;
    this->attestationData = r.attestationData;
};
/// <summary>
/// This sized buffer to contain the signed structure. The attestationData is the signed portion of the structure. The size parameter is not signed.
/// </summary>
TpmStructureBase* TPM2B_ATTEST::Clone() const
{
    TPM2B_ATTEST* _x = new TPM2B_ATTEST(*this);
    return _x;
};
void* TPM2B_ATTEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&attestationData); return (void*) (&attestationData);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_AUTH_COMMAND::GetTypeId() const
{
    return TpmTypeId::TPMS_AUTH_COMMAND_ID;
};
/// <summary>
/// This is the format used for each of the authorizations in the session area of a command.
/// </summary>
TPMS_AUTH_COMMAND::TPMS_AUTH_COMMAND()
{
    return;
};
TPMS_AUTH_COMMAND::TPMS_AUTH_COMMAND
(
    const TPM_HANDLE& _sessionHandle,
    const std::vector<BYTE>& _nonce,
    const TPMA_SESSION& _sessionAttributes,
    const std::vector<BYTE>& _hmac
)
{
    sessionHandle= _sessionHandle;
    nonce= _nonce;
    sessionAttributes= _sessionAttributes;
    hmac= _hmac;
};
/// <summary>
/// This is the format used for each of the authorizations in the session area of a command.
/// </summary>
TPMS_AUTH_COMMAND::~TPMS_AUTH_COMMAND()
{
    return;
};
/// <summary>
/// This is the format used for each of the authorizations in the session area of a command.
/// </summary>
TPMS_AUTH_COMMAND& TPMS_AUTH_COMMAND::operator=(const TPMS_AUTH_COMMAND& rhs)
{
    if(this == &rhs) return *this;
    this->sessionHandle = rhs.sessionHandle;
    this->nonceSize = rhs.nonceSize;
    this->nonce = rhs.nonce;
    this->sessionAttributes = rhs.sessionAttributes;
    this->hmacSize = rhs.hmacSize;
    this->hmac = rhs.hmac;
    return *this;
};
/// <summary>
/// This is the format used for each of the authorizations in the session area of a command.
/// </summary>
TPMS_AUTH_COMMAND::TPMS_AUTH_COMMAND(const TPMS_AUTH_COMMAND& r)
{
    this->sessionHandle = r.sessionHandle;
    this->nonceSize = r.nonceSize;
    this->nonce = r.nonce;
    this->sessionAttributes = r.sessionAttributes;
    this->hmacSize = r.hmacSize;
    this->hmac = r.hmac;
};
/// <summary>
/// This is the format used for each of the authorizations in the session area of a command.
/// </summary>
TpmStructureBase* TPMS_AUTH_COMMAND::Clone() const
{
    TPMS_AUTH_COMMAND* _x = new TPMS_AUTH_COMMAND(*this);
    return _x;
};
void* TPMS_AUTH_COMMAND::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&sessionHandle); return (void*) (&sessionHandle);
            case 1: return (void*) (&nonceSize);
            case 2: { if(newArraySize != -1)nonce.resize(newArraySize); arraySize = (int)nonce.size(); return (void*)(&nonce); }
            case 3: return (void*) (&sessionAttributes);
            case 4: return (void*) (&hmacSize);
            case 5: { if(newArraySize != -1)hmac.resize(newArraySize); arraySize = (int)hmac.size(); return (void*)(&hmac); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&nonce[arrayIndex]);
            case 5: return (void*)(&hmac[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId AUTHResponse::GetTypeId() const
{
    return TpmTypeId::AUTHResponse_ID;
};
/// <summary>
/// This is the format for each of the authorizations in the session area of the response. If the TPM returns TPM_RC_SUCCESS, then the session area of the response contains the same number of authorizations as the command and the authorizations are in the same order.
/// </summary>
AUTHResponse::AUTHResponse()
{
    return;
};
AUTHResponse::AUTHResponse
(
    const std::vector<BYTE>& _nonce,
    const TPMA_SESSION& _sessionAttributes,
    const std::vector<BYTE>& _hmac
)
{
    nonce= _nonce;
    sessionAttributes= _sessionAttributes;
    hmac= _hmac;
};
/// <summary>
/// This is the format for each of the authorizations in the session area of the response. If the TPM returns TPM_RC_SUCCESS, then the session area of the response contains the same number of authorizations as the command and the authorizations are in the same order.
/// </summary>
AUTHResponse::~AUTHResponse()
{
    return;
};
/// <summary>
/// This is the format for each of the authorizations in the session area of the response. If the TPM returns TPM_RC_SUCCESS, then the session area of the response contains the same number of authorizations as the command and the authorizations are in the same order.
/// </summary>
AUTHResponse& AUTHResponse::operator=(const AUTHResponse& rhs)
{
    if(this == &rhs) return *this;
    this->nonceSize = rhs.nonceSize;
    this->nonce = rhs.nonce;
    this->sessionAttributes = rhs.sessionAttributes;
    this->hmacSize = rhs.hmacSize;
    this->hmac = rhs.hmac;
    return *this;
};
/// <summary>
/// This is the format for each of the authorizations in the session area of the response. If the TPM returns TPM_RC_SUCCESS, then the session area of the response contains the same number of authorizations as the command and the authorizations are in the same order.
/// </summary>
AUTHResponse::AUTHResponse(const AUTHResponse& r)
{
    this->nonceSize = r.nonceSize;
    this->nonce = r.nonce;
    this->sessionAttributes = r.sessionAttributes;
    this->hmacSize = r.hmacSize;
    this->hmac = r.hmac;
};
/// <summary>
/// This is the format for each of the authorizations in the session area of the response. If the TPM returns TPM_RC_SUCCESS, then the session area of the response contains the same number of authorizations as the command and the authorizations are in the same order.
/// </summary>
TpmStructureBase* AUTHResponse::Clone() const
{
    AUTHResponse* _x = new AUTHResponse(*this);
    return _x;
};
void* AUTHResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&nonceSize);
            case 1: { if(newArraySize != -1)nonce.resize(newArraySize); arraySize = (int)nonce.size(); return (void*)(&nonce); }
            case 2: return (void*) (&sessionAttributes);
            case 3: return (void*) (&hmacSize);
            case 4: { if(newArraySize != -1)hmac.resize(newArraySize); arraySize = (int)hmac.size(); return (void*)(&hmac); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&nonce[arrayIndex]);
            case 4: return (void*)(&hmac[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_NULL_SYM_KEY_BITS::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_SYM_KEY_BITS_ID;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymKeyBits
/// </summary>
TPMS_NULL_SYM_KEY_BITS::TPMS_NULL_SYM_KEY_BITS()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymKeyBits
/// </summary>
TPMS_NULL_SYM_KEY_BITS::~TPMS_NULL_SYM_KEY_BITS()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymKeyBits
/// </summary>
TPMS_NULL_SYM_KEY_BITS& TPMS_NULL_SYM_KEY_BITS::operator=(const TPMS_NULL_SYM_KEY_BITS& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_NULL_UNION&)*this = (TPMS_NULL_UNION)rhs;
    return *this;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymKeyBits
/// </summary>
TPMS_NULL_SYM_KEY_BITS::TPMS_NULL_SYM_KEY_BITS(const TPMS_NULL_SYM_KEY_BITS& r)
  : TPMS_NULL_UNION(r)
{
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymKeyBits
/// </summary>
TpmStructureBase* TPMS_NULL_SYM_KEY_BITS::Clone() const
{
    TPMS_NULL_SYM_KEY_BITS* _x = new TPMS_NULL_SYM_KEY_BITS(*this);
    return _x;
};
void* TPMS_NULL_SYM_KEY_BITS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPMS_XOR_SYM_MODE::GetTypeId() const
{
    return TpmTypeId::TPMS_XOR_SYM_MODE_ID;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymMode
/// </summary>
TPMS_XOR_SYM_MODE::TPMS_XOR_SYM_MODE()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymMode
/// </summary>
TPMS_XOR_SYM_MODE::~TPMS_XOR_SYM_MODE()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymMode
/// </summary>
TPMS_XOR_SYM_MODE& TPMS_XOR_SYM_MODE::operator=(const TPMS_XOR_SYM_MODE& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_NULL_UNION&)*this = (TPMS_NULL_UNION)rhs;
    return *this;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymMode
/// </summary>
TPMS_XOR_SYM_MODE::TPMS_XOR_SYM_MODE(const TPMS_XOR_SYM_MODE& r)
  : TPMS_NULL_UNION(r)
{
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymMode
/// </summary>
TpmStructureBase* TPMS_XOR_SYM_MODE::Clone() const
{
    TPMS_XOR_SYM_MODE* _x = new TPMS_XOR_SYM_MODE(*this);
    return _x;
};
void* TPMS_XOR_SYM_MODE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPMS_NULL_SYM_MODE::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_SYM_MODE_ID;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymMode
/// </summary>
TPMS_NULL_SYM_MODE::TPMS_NULL_SYM_MODE()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymMode
/// </summary>
TPMS_NULL_SYM_MODE::~TPMS_NULL_SYM_MODE()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymMode
/// </summary>
TPMS_NULL_SYM_MODE& TPMS_NULL_SYM_MODE::operator=(const TPMS_NULL_SYM_MODE& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_NULL_UNION&)*this = (TPMS_NULL_UNION)rhs;
    return *this;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymMode
/// </summary>
TPMS_NULL_SYM_MODE::TPMS_NULL_SYM_MODE(const TPMS_NULL_SYM_MODE& r)
  : TPMS_NULL_UNION(r)
{
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymMode
/// </summary>
TpmStructureBase* TPMS_NULL_SYM_MODE::Clone() const
{
    TPMS_NULL_SYM_MODE* _x = new TPMS_NULL_SYM_MODE(*this);
    return _x;
};
void* TPMS_NULL_SYM_MODE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPMS_TDES_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_TDES_SYM_DETAILS_ID;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_TDES for the union TpmuSymDetails
/// </summary>
TPMS_TDES_SYM_DETAILS::TPMS_TDES_SYM_DETAILS()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_TDES for the union TpmuSymDetails
/// </summary>
TPMS_TDES_SYM_DETAILS::~TPMS_TDES_SYM_DETAILS()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_TDES for the union TpmuSymDetails
/// </summary>
TPMS_TDES_SYM_DETAILS& TPMS_TDES_SYM_DETAILS::operator=(const TPMS_TDES_SYM_DETAILS& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_NULL_UNION&)*this = (TPMS_NULL_UNION)rhs;
    return *this;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_TDES for the union TpmuSymDetails
/// </summary>
TPMS_TDES_SYM_DETAILS::TPMS_TDES_SYM_DETAILS(const TPMS_TDES_SYM_DETAILS& r)
  : TPMS_NULL_UNION(r)
{
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_TDES for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_TDES_SYM_DETAILS::Clone() const
{
    TPMS_TDES_SYM_DETAILS* _x = new TPMS_TDES_SYM_DETAILS(*this);
    return _x;
};
void* TPMS_TDES_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPMS_AES_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_AES_SYM_DETAILS_ID;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_AES for the union TpmuSymDetails
/// </summary>
TPMS_AES_SYM_DETAILS::TPMS_AES_SYM_DETAILS()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_AES for the union TpmuSymDetails
/// </summary>
TPMS_AES_SYM_DETAILS::~TPMS_AES_SYM_DETAILS()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_AES for the union TpmuSymDetails
/// </summary>
TPMS_AES_SYM_DETAILS& TPMS_AES_SYM_DETAILS::operator=(const TPMS_AES_SYM_DETAILS& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_NULL_UNION&)*this = (TPMS_NULL_UNION)rhs;
    return *this;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_AES for the union TpmuSymDetails
/// </summary>
TPMS_AES_SYM_DETAILS::TPMS_AES_SYM_DETAILS(const TPMS_AES_SYM_DETAILS& r)
  : TPMS_NULL_UNION(r)
{
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_AES for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_AES_SYM_DETAILS::Clone() const
{
    TPMS_AES_SYM_DETAILS* _x = new TPMS_AES_SYM_DETAILS(*this);
    return _x;
};
void* TPMS_AES_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPMS_SM4_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_SM4_SYM_DETAILS_ID;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_SM4 for the union TpmuSymDetails
/// </summary>
TPMS_SM4_SYM_DETAILS::TPMS_SM4_SYM_DETAILS()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_SM4 for the union TpmuSymDetails
/// </summary>
TPMS_SM4_SYM_DETAILS::~TPMS_SM4_SYM_DETAILS()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_SM4 for the union TpmuSymDetails
/// </summary>
TPMS_SM4_SYM_DETAILS& TPMS_SM4_SYM_DETAILS::operator=(const TPMS_SM4_SYM_DETAILS& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_NULL_UNION&)*this = (TPMS_NULL_UNION)rhs;
    return *this;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_SM4 for the union TpmuSymDetails
/// </summary>
TPMS_SM4_SYM_DETAILS::TPMS_SM4_SYM_DETAILS(const TPMS_SM4_SYM_DETAILS& r)
  : TPMS_NULL_UNION(r)
{
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_SM4 for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_SM4_SYM_DETAILS::Clone() const
{
    TPMS_SM4_SYM_DETAILS* _x = new TPMS_SM4_SYM_DETAILS(*this);
    return _x;
};
void* TPMS_SM4_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPMS_CAMELLIA_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_CAMELLIA_SYM_DETAILS_ID;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_CAMELLIA for the union TpmuSymDetails
/// </summary>
TPMS_CAMELLIA_SYM_DETAILS::TPMS_CAMELLIA_SYM_DETAILS()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_CAMELLIA for the union TpmuSymDetails
/// </summary>
TPMS_CAMELLIA_SYM_DETAILS::~TPMS_CAMELLIA_SYM_DETAILS()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_CAMELLIA for the union TpmuSymDetails
/// </summary>
TPMS_CAMELLIA_SYM_DETAILS& TPMS_CAMELLIA_SYM_DETAILS::operator=(const TPMS_CAMELLIA_SYM_DETAILS& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_NULL_UNION&)*this = (TPMS_NULL_UNION)rhs;
    return *this;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_CAMELLIA for the union TpmuSymDetails
/// </summary>
TPMS_CAMELLIA_SYM_DETAILS::TPMS_CAMELLIA_SYM_DETAILS(const TPMS_CAMELLIA_SYM_DETAILS& r)
  : TPMS_NULL_UNION(r)
{
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_CAMELLIA for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_CAMELLIA_SYM_DETAILS::Clone() const
{
    TPMS_CAMELLIA_SYM_DETAILS* _x = new TPMS_CAMELLIA_SYM_DETAILS(*this);
    return _x;
};
void* TPMS_CAMELLIA_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPMS_ANY_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_ANY_SYM_DETAILS_ID;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_ANY for the union TpmuSymDetails
/// </summary>
TPMS_ANY_SYM_DETAILS::TPMS_ANY_SYM_DETAILS()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_ANY for the union TpmuSymDetails
/// </summary>
TPMS_ANY_SYM_DETAILS::~TPMS_ANY_SYM_DETAILS()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_ANY for the union TpmuSymDetails
/// </summary>
TPMS_ANY_SYM_DETAILS& TPMS_ANY_SYM_DETAILS::operator=(const TPMS_ANY_SYM_DETAILS& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_NULL_UNION&)*this = (TPMS_NULL_UNION)rhs;
    return *this;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_ANY for the union TpmuSymDetails
/// </summary>
TPMS_ANY_SYM_DETAILS::TPMS_ANY_SYM_DETAILS(const TPMS_ANY_SYM_DETAILS& r)
  : TPMS_NULL_UNION(r)
{
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_ANY for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_ANY_SYM_DETAILS::Clone() const
{
    TPMS_ANY_SYM_DETAILS* _x = new TPMS_ANY_SYM_DETAILS(*this);
    return _x;
};
void* TPMS_ANY_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPMS_XOR_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_XOR_SYM_DETAILS_ID;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymDetails
/// </summary>
TPMS_XOR_SYM_DETAILS::TPMS_XOR_SYM_DETAILS()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymDetails
/// </summary>
TPMS_XOR_SYM_DETAILS::~TPMS_XOR_SYM_DETAILS()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymDetails
/// </summary>
TPMS_XOR_SYM_DETAILS& TPMS_XOR_SYM_DETAILS::operator=(const TPMS_XOR_SYM_DETAILS& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_NULL_UNION&)*this = (TPMS_NULL_UNION)rhs;
    return *this;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymDetails
/// </summary>
TPMS_XOR_SYM_DETAILS::TPMS_XOR_SYM_DETAILS(const TPMS_XOR_SYM_DETAILS& r)
  : TPMS_NULL_UNION(r)
{
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_XOR_SYM_DETAILS::Clone() const
{
    TPMS_XOR_SYM_DETAILS* _x = new TPMS_XOR_SYM_DETAILS(*this);
    return _x;
};
void* TPMS_XOR_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPMS_NULL_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_SYM_DETAILS_ID;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymDetails
/// </summary>
TPMS_NULL_SYM_DETAILS::TPMS_NULL_SYM_DETAILS()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymDetails
/// </summary>
TPMS_NULL_SYM_DETAILS::~TPMS_NULL_SYM_DETAILS()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymDetails
/// </summary>
TPMS_NULL_SYM_DETAILS& TPMS_NULL_SYM_DETAILS::operator=(const TPMS_NULL_SYM_DETAILS& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_NULL_UNION&)*this = (TPMS_NULL_UNION)rhs;
    return *this;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymDetails
/// </summary>
TPMS_NULL_SYM_DETAILS::TPMS_NULL_SYM_DETAILS(const TPMS_NULL_SYM_DETAILS& r)
  : TPMS_NULL_UNION(r)
{
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_NULL_SYM_DETAILS::Clone() const
{
    TPMS_NULL_SYM_DETAILS* _x = new TPMS_NULL_SYM_DETAILS(*this);
    return _x;
};
void* TPMS_NULL_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPMT_SYM_DEF::GetTypeId() const
{
    return TpmTypeId::TPMT_SYM_DEF_ID;
};
/// <summary>
/// The TPMT_SYM_DEF structure is used to select an algorithm to be used for parameter encryption in those cases when different symmetric algorithms may be selected.
/// </summary>
TPMT_SYM_DEF::TPMT_SYM_DEF()
{
    return;
};
TPMT_SYM_DEF::TPMT_SYM_DEF
(
    const TPM_ALG_ID& _algorithm,
    const UINT16& _keyBits,
    const TPM_ALG_ID& _mode
)
{
    algorithm= _algorithm;
    keyBits= _keyBits;
    mode= _mode;
};
/// <summary>
/// The TPMT_SYM_DEF structure is used to select an algorithm to be used for parameter encryption in those cases when different symmetric algorithms may be selected.
/// </summary>
TPMT_SYM_DEF::~TPMT_SYM_DEF()
{
    return;
};
/// <summary>
/// The TPMT_SYM_DEF structure is used to select an algorithm to be used for parameter encryption in those cases when different symmetric algorithms may be selected.
/// </summary>
TPMT_SYM_DEF& TPMT_SYM_DEF::operator=(const TPMT_SYM_DEF& rhs)
{
    if(this == &rhs) return *this;
    this->algorithm = rhs.algorithm;
    this->keyBits = rhs.keyBits;
    this->mode = rhs.mode;
    TPMT_SYM_DEF_CUSTOM_CLONE(this, rhs)
    return *this;
};
/// <summary>
/// The TPMT_SYM_DEF structure is used to select an algorithm to be used for parameter encryption in those cases when different symmetric algorithms may be selected.
/// </summary>
TPMT_SYM_DEF::TPMT_SYM_DEF(const TPMT_SYM_DEF& r)
{
    this->algorithm = r.algorithm;
    this->keyBits = r.keyBits;
    this->mode = r.mode;
    TPMT_SYM_DEF_CUSTOM_CLONE(this, r)
};
/// <summary>
/// The TPMT_SYM_DEF structure is used to select an algorithm to be used for parameter encryption in those cases when different symmetric algorithms may be selected.
/// </summary>
TpmStructureBase* TPMT_SYM_DEF::Clone() const
{
    TPMT_SYM_DEF* _x = new TPMT_SYM_DEF(*this);
    return _x;
};
void* TPMT_SYM_DEF::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&algorithm);
            case 1: return (void*) (&keyBits);
            case 2: return (void*) (&mode);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMT_SYM_DEF_OBJECT::GetTypeId() const
{
    return TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
};
/// <summary>
/// This structure is used when different symmetric block cipher (not XOR) algorithms may be selected. If the Object can be an ordinary parent (not a derivation parent), this must be the first field in the Object's parameter (see 12.2.3.7) field.
/// </summary>
TPMT_SYM_DEF_OBJECT::TPMT_SYM_DEF_OBJECT()
{
    return;
};
TPMT_SYM_DEF_OBJECT::TPMT_SYM_DEF_OBJECT
(
    const TPM_ALG_ID& _algorithm,
    const UINT16& _keyBits,
    const TPM_ALG_ID& _mode
)
{
    algorithm= _algorithm;
    keyBits= _keyBits;
    mode= _mode;
};
/// <summary>
/// This structure is used when different symmetric block cipher (not XOR) algorithms may be selected. If the Object can be an ordinary parent (not a derivation parent), this must be the first field in the Object's parameter (see 12.2.3.7) field.
/// </summary>
TPMT_SYM_DEF_OBJECT::~TPMT_SYM_DEF_OBJECT()
{
    return;
};
/// <summary>
/// This structure is used when different symmetric block cipher (not XOR) algorithms may be selected. If the Object can be an ordinary parent (not a derivation parent), this must be the first field in the Object's parameter (see 12.2.3.7) field.
/// </summary>
TPMT_SYM_DEF_OBJECT& TPMT_SYM_DEF_OBJECT::operator=(const TPMT_SYM_DEF_OBJECT& rhs)
{
    if(this == &rhs) return *this;
    this->algorithm = rhs.algorithm;
    this->keyBits = rhs.keyBits;
    this->mode = rhs.mode;
    TPMT_SYM_DEF_OBJECT_CUSTOM_CLONE(this, rhs)
    return *this;
};
/// <summary>
/// This structure is used when different symmetric block cipher (not XOR) algorithms may be selected. If the Object can be an ordinary parent (not a derivation parent), this must be the first field in the Object's parameter (see 12.2.3.7) field.
/// </summary>
TPMT_SYM_DEF_OBJECT::TPMT_SYM_DEF_OBJECT(const TPMT_SYM_DEF_OBJECT& r)
{
    this->algorithm = r.algorithm;
    this->keyBits = r.keyBits;
    this->mode = r.mode;
    TPMT_SYM_DEF_OBJECT_CUSTOM_CLONE(this, r)
};
/// <summary>
/// This structure is used when different symmetric block cipher (not XOR) algorithms may be selected. If the Object can be an ordinary parent (not a derivation parent), this must be the first field in the Object's parameter (see 12.2.3.7) field.
/// </summary>
TpmStructureBase* TPMT_SYM_DEF_OBJECT::Clone() const
{
    TPMT_SYM_DEF_OBJECT* _x = new TPMT_SYM_DEF_OBJECT(*this);
    return _x;
};
void* TPMT_SYM_DEF_OBJECT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&algorithm);
            case 1: return (void*) (&keyBits);
            case 2: return (void*) (&mode);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2B_SYM_KEY::GetTypeId() const
{
    return TpmTypeId::TPM2B_SYM_KEY_ID;
};
/// <summary>
/// This structure is used to hold a symmetric key in the sensitive area of an asymmetric object.
/// </summary>
TPM2B_SYM_KEY::TPM2B_SYM_KEY()
{
    return;
};
TPM2B_SYM_KEY::TPM2B_SYM_KEY
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// This structure is used to hold a symmetric key in the sensitive area of an asymmetric object.
/// </summary>
TPM2B_SYM_KEY::~TPM2B_SYM_KEY()
{
    return;
};
/// <summary>
/// This structure is used to hold a symmetric key in the sensitive area of an asymmetric object.
/// </summary>
TPM2B_SYM_KEY& TPM2B_SYM_KEY::operator=(const TPM2B_SYM_KEY& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This structure is used to hold a symmetric key in the sensitive area of an asymmetric object.
/// </summary>
TPM2B_SYM_KEY::TPM2B_SYM_KEY(const TPM2B_SYM_KEY& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// This structure is used to hold a symmetric key in the sensitive area of an asymmetric object.
/// </summary>
TpmStructureBase* TPM2B_SYM_KEY::Clone() const
{
    TPM2B_SYM_KEY* _x = new TPM2B_SYM_KEY(*this);
    return _x;
};
void* TPM2B_SYM_KEY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_SYMCIPHER_PARMS::GetTypeId() const
{
    return TpmTypeId::TPMS_SYMCIPHER_PARMS_ID;
};
/// <summary>
/// This structure contains the parameters for a symmetric block cipher object.
/// </summary>
TPMS_SYMCIPHER_PARMS::TPMS_SYMCIPHER_PARMS()
{
    return;
};
TPMS_SYMCIPHER_PARMS::TPMS_SYMCIPHER_PARMS
(
    const TPMT_SYM_DEF_OBJECT& _sym
)
{
    sym= _sym;
};
/// <summary>
/// This structure contains the parameters for a symmetric block cipher object.
/// </summary>
TPMS_SYMCIPHER_PARMS::~TPMS_SYMCIPHER_PARMS()
{
    return;
};
/// <summary>
/// This structure contains the parameters for a symmetric block cipher object.
/// </summary>
TPMS_SYMCIPHER_PARMS& TPMS_SYMCIPHER_PARMS::operator=(const TPMS_SYMCIPHER_PARMS& rhs)
{
    if(this == &rhs) return *this;
    this->sym = rhs.sym;
    return *this;
};
/// <summary>
/// This structure contains the parameters for a symmetric block cipher object.
/// </summary>
TPMS_SYMCIPHER_PARMS::TPMS_SYMCIPHER_PARMS(const TPMS_SYMCIPHER_PARMS& r)
{
    this->sym = r.sym;
};
/// <summary>
/// This structure contains the parameters for a symmetric block cipher object.
/// </summary>
TpmStructureBase* TPMS_SYMCIPHER_PARMS::Clone() const
{
    TPMS_SYMCIPHER_PARMS* _x = new TPMS_SYMCIPHER_PARMS(*this);
    return _x;
};
void* TPMS_SYMCIPHER_PARMS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&sym); return (void*) (&sym);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2B_LABEL::GetTypeId() const
{
    return TpmTypeId::TPM2B_LABEL_ID;
};
/// <summary>
/// This buffer holds a label or context value. For interoperability and backwards compatibility, LABEL_MAX_BUFFER is the minimum of the largest digest on the device and the largest ECC parameter (MAX_ECC_KEY_BYTES) but no more than 32 bytes.
/// </summary>
TPM2B_LABEL::TPM2B_LABEL()
{
    return;
};
TPM2B_LABEL::TPM2B_LABEL
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// This buffer holds a label or context value. For interoperability and backwards compatibility, LABEL_MAX_BUFFER is the minimum of the largest digest on the device and the largest ECC parameter (MAX_ECC_KEY_BYTES) but no more than 32 bytes.
/// </summary>
TPM2B_LABEL::~TPM2B_LABEL()
{
    return;
};
/// <summary>
/// This buffer holds a label or context value. For interoperability and backwards compatibility, LABEL_MAX_BUFFER is the minimum of the largest digest on the device and the largest ECC parameter (MAX_ECC_KEY_BYTES) but no more than 32 bytes.
/// </summary>
TPM2B_LABEL& TPM2B_LABEL::operator=(const TPM2B_LABEL& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This buffer holds a label or context value. For interoperability and backwards compatibility, LABEL_MAX_BUFFER is the minimum of the largest digest on the device and the largest ECC parameter (MAX_ECC_KEY_BYTES) but no more than 32 bytes.
/// </summary>
TPM2B_LABEL::TPM2B_LABEL(const TPM2B_LABEL& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// This buffer holds a label or context value. For interoperability and backwards compatibility, LABEL_MAX_BUFFER is the minimum of the largest digest on the device and the largest ECC parameter (MAX_ECC_KEY_BYTES) but no more than 32 bytes.
/// </summary>
TpmStructureBase* TPM2B_LABEL::Clone() const
{
    TPM2B_LABEL* _x = new TPM2B_LABEL(*this);
    return _x;
};
void* TPM2B_LABEL::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_DERIVE::GetTypeId() const
{
    return TpmTypeId::TPMS_DERIVE_ID;
};
/// <summary>
/// This structure contains the label and context fields for a derived object. These values are used in the derivation KDF. The values in the unique field of inPublic area template take precedence over the values in the inSensitive parameter.
/// </summary>
TPMS_DERIVE::TPMS_DERIVE()
{
    return;
};
TPMS_DERIVE::TPMS_DERIVE
(
    const std::vector<BYTE>& _label,
    const std::vector<BYTE>& _context
)
{
    label= _label;
    context= _context;
};
/// <summary>
/// This structure contains the label and context fields for a derived object. These values are used in the derivation KDF. The values in the unique field of inPublic area template take precedence over the values in the inSensitive parameter.
/// </summary>
TPMS_DERIVE::~TPMS_DERIVE()
{
    return;
};
/// <summary>
/// This structure contains the label and context fields for a derived object. These values are used in the derivation KDF. The values in the unique field of inPublic area template take precedence over the values in the inSensitive parameter.
/// </summary>
TPMS_DERIVE& TPMS_DERIVE::operator=(const TPMS_DERIVE& rhs)
{
    if(this == &rhs) return *this;
    this->labelSize = rhs.labelSize;
    this->label = rhs.label;
    this->contextSize = rhs.contextSize;
    this->context = rhs.context;
    return *this;
};
/// <summary>
/// This structure contains the label and context fields for a derived object. These values are used in the derivation KDF. The values in the unique field of inPublic area template take precedence over the values in the inSensitive parameter.
/// </summary>
TPMS_DERIVE::TPMS_DERIVE(const TPMS_DERIVE& r)
{
    this->labelSize = r.labelSize;
    this->label = r.label;
    this->contextSize = r.contextSize;
    this->context = r.context;
};
/// <summary>
/// This structure contains the label and context fields for a derived object. These values are used in the derivation KDF. The values in the unique field of inPublic area template take precedence over the values in the inSensitive parameter.
/// </summary>
TpmStructureBase* TPMS_DERIVE::Clone() const
{
    TPMS_DERIVE* _x = new TPMS_DERIVE(*this);
    return _x;
};
void* TPMS_DERIVE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&labelSize);
            case 1: { if(newArraySize != -1)label.resize(newArraySize); arraySize = (int)label.size(); return (void*)(&label); }
            case 2: return (void*) (&contextSize);
            case 3: { if(newArraySize != -1)context.resize(newArraySize); arraySize = (int)context.size(); return (void*)(&context); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&label[arrayIndex]);
            case 3: return (void*)(&context[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_DERIVE::GetTypeId() const
{
    return TpmTypeId::TPM2B_DERIVE_ID;
};
/// <summary>
/// Table 142  Definition of TPM2B_DERIVE Structure
/// </summary>
TPM2B_DERIVE::TPM2B_DERIVE()
{
    return;
};
TPM2B_DERIVE::TPM2B_DERIVE
(
    const TPMS_DERIVE& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// Table 142  Definition of TPM2B_DERIVE Structure
/// </summary>
TPM2B_DERIVE::~TPM2B_DERIVE()
{
    return;
};
/// <summary>
/// Table 142  Definition of TPM2B_DERIVE Structure
/// </summary>
TPM2B_DERIVE& TPM2B_DERIVE::operator=(const TPM2B_DERIVE& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// Table 142  Definition of TPM2B_DERIVE Structure
/// </summary>
TPM2B_DERIVE::TPM2B_DERIVE(const TPM2B_DERIVE& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// Table 142  Definition of TPM2B_DERIVE Structure
/// </summary>
TpmStructureBase* TPM2B_DERIVE::Clone() const
{
    TPM2B_DERIVE* _x = new TPM2B_DERIVE(*this);
    return _x;
};
void* TPM2B_DERIVE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&buffer); return (void*) (&buffer);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2B_SENSITIVE_DATA::GetTypeId() const
{
    return TpmTypeId::TPM2B_SENSITIVE_DATA_ID;
};
/// <summary>
/// This buffer wraps the TPMU_SENSITIVE_CREATE structure.
/// </summary>
TPM2B_SENSITIVE_DATA::TPM2B_SENSITIVE_DATA()
{
    return;
};
TPM2B_SENSITIVE_DATA::TPM2B_SENSITIVE_DATA
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// This buffer wraps the TPMU_SENSITIVE_CREATE structure.
/// </summary>
TPM2B_SENSITIVE_DATA::~TPM2B_SENSITIVE_DATA()
{
    return;
};
/// <summary>
/// This buffer wraps the TPMU_SENSITIVE_CREATE structure.
/// </summary>
TPM2B_SENSITIVE_DATA& TPM2B_SENSITIVE_DATA::operator=(const TPM2B_SENSITIVE_DATA& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This buffer wraps the TPMU_SENSITIVE_CREATE structure.
/// </summary>
TPM2B_SENSITIVE_DATA::TPM2B_SENSITIVE_DATA(const TPM2B_SENSITIVE_DATA& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// This buffer wraps the TPMU_SENSITIVE_CREATE structure.
/// </summary>
TpmStructureBase* TPM2B_SENSITIVE_DATA::Clone() const
{
    TPM2B_SENSITIVE_DATA* _x = new TPM2B_SENSITIVE_DATA(*this);
    return _x;
};
void* TPM2B_SENSITIVE_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_SENSITIVE_CREATE::GetTypeId() const
{
    return TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
};
/// <summary>
/// This structure defines the values to be placed in the sensitive area of a created object. This structure is only used within a TPM2B_SENSITIVE_CREATE structure.
/// </summary>
TPMS_SENSITIVE_CREATE::TPMS_SENSITIVE_CREATE()
{
    return;
};
TPMS_SENSITIVE_CREATE::TPMS_SENSITIVE_CREATE
(
    const std::vector<BYTE>& _userAuth,
    const std::vector<BYTE>& _data
)
{
    userAuth= _userAuth;
    data= _data;
};
/// <summary>
/// This structure defines the values to be placed in the sensitive area of a created object. This structure is only used within a TPM2B_SENSITIVE_CREATE structure.
/// </summary>
TPMS_SENSITIVE_CREATE::~TPMS_SENSITIVE_CREATE()
{
    return;
};
/// <summary>
/// This structure defines the values to be placed in the sensitive area of a created object. This structure is only used within a TPM2B_SENSITIVE_CREATE structure.
/// </summary>
TPMS_SENSITIVE_CREATE& TPMS_SENSITIVE_CREATE::operator=(const TPMS_SENSITIVE_CREATE& rhs)
{
    if(this == &rhs) return *this;
    this->userAuthSize = rhs.userAuthSize;
    this->userAuth = rhs.userAuth;
    this->dataSize = rhs.dataSize;
    this->data = rhs.data;
    return *this;
};
/// <summary>
/// This structure defines the values to be placed in the sensitive area of a created object. This structure is only used within a TPM2B_SENSITIVE_CREATE structure.
/// </summary>
TPMS_SENSITIVE_CREATE::TPMS_SENSITIVE_CREATE(const TPMS_SENSITIVE_CREATE& r)
{
    this->userAuthSize = r.userAuthSize;
    this->userAuth = r.userAuth;
    this->dataSize = r.dataSize;
    this->data = r.data;
};
/// <summary>
/// This structure defines the values to be placed in the sensitive area of a created object. This structure is only used within a TPM2B_SENSITIVE_CREATE structure.
/// </summary>
TpmStructureBase* TPMS_SENSITIVE_CREATE::Clone() const
{
    TPMS_SENSITIVE_CREATE* _x = new TPMS_SENSITIVE_CREATE(*this);
    return _x;
};
void* TPMS_SENSITIVE_CREATE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&userAuthSize);
            case 1: { if(newArraySize != -1)userAuth.resize(newArraySize); arraySize = (int)userAuth.size(); return (void*)(&userAuth); }
            case 2: return (void*) (&dataSize);
            case 3: { if(newArraySize != -1)data.resize(newArraySize); arraySize = (int)data.size(); return (void*)(&data); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&userAuth[arrayIndex]);
            case 3: return (void*)(&data[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_SENSITIVE_CREATE::GetTypeId() const
{
    return TpmTypeId::TPM2B_SENSITIVE_CREATE_ID;
};
/// <summary>
/// This structure contains the sensitive creation data in a sized buffer. This structure is defined so that both the userAuth and data values of the TPMS_SENSITIVE_CREATE may be passed as a single parameter for parameter encryption purposes.
/// </summary>
TPM2B_SENSITIVE_CREATE::TPM2B_SENSITIVE_CREATE()
{
    return;
};
TPM2B_SENSITIVE_CREATE::TPM2B_SENSITIVE_CREATE
(
    const TPMS_SENSITIVE_CREATE& _sensitive
)
{
    sensitive= _sensitive;
};
/// <summary>
/// This structure contains the sensitive creation data in a sized buffer. This structure is defined so that both the userAuth and data values of the TPMS_SENSITIVE_CREATE may be passed as a single parameter for parameter encryption purposes.
/// </summary>
TPM2B_SENSITIVE_CREATE::~TPM2B_SENSITIVE_CREATE()
{
    return;
};
/// <summary>
/// This structure contains the sensitive creation data in a sized buffer. This structure is defined so that both the userAuth and data values of the TPMS_SENSITIVE_CREATE may be passed as a single parameter for parameter encryption purposes.
/// </summary>
TPM2B_SENSITIVE_CREATE& TPM2B_SENSITIVE_CREATE::operator=(const TPM2B_SENSITIVE_CREATE& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->sensitive = rhs.sensitive;
    return *this;
};
/// <summary>
/// This structure contains the sensitive creation data in a sized buffer. This structure is defined so that both the userAuth and data values of the TPMS_SENSITIVE_CREATE may be passed as a single parameter for parameter encryption purposes.
/// </summary>
TPM2B_SENSITIVE_CREATE::TPM2B_SENSITIVE_CREATE(const TPM2B_SENSITIVE_CREATE& r)
{
    this->size = r.size;
    this->sensitive = r.sensitive;
};
/// <summary>
/// This structure contains the sensitive creation data in a sized buffer. This structure is defined so that both the userAuth and data values of the TPMS_SENSITIVE_CREATE may be passed as a single parameter for parameter encryption purposes.
/// </summary>
TpmStructureBase* TPM2B_SENSITIVE_CREATE::Clone() const
{
    TPM2B_SENSITIVE_CREATE* _x = new TPM2B_SENSITIVE_CREATE(*this);
    return _x;
};
void* TPM2B_SENSITIVE_CREATE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&sensitive); return (void*) (&sensitive);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_SCHEME_HASH::GetTypeId() const
{
    return TpmTypeId::TPMS_SCHEME_HASH_ID;
};
/// <summary>
/// This structure is the scheme data for schemes that only require a hash to complete their definition.
/// </summary>
TPMS_SCHEME_HASH::TPMS_SCHEME_HASH()
{
    return;
};
TPMS_SCHEME_HASH::TPMS_SCHEME_HASH
(
    const TPM_ALG_ID& _hashAlg
)
{
    hashAlg= _hashAlg;
};
/// <summary>
/// This structure is the scheme data for schemes that only require a hash to complete their definition.
/// </summary>
TPMS_SCHEME_HASH::~TPMS_SCHEME_HASH()
{
    return;
};
/// <summary>
/// This structure is the scheme data for schemes that only require a hash to complete their definition.
/// </summary>
TPMS_SCHEME_HASH& TPMS_SCHEME_HASH::operator=(const TPMS_SCHEME_HASH& rhs)
{
    if(this == &rhs) return *this;
    this->hashAlg = rhs.hashAlg;
    return *this;
};
/// <summary>
/// This structure is the scheme data for schemes that only require a hash to complete their definition.
/// </summary>
TPMS_SCHEME_HASH::TPMS_SCHEME_HASH(const TPMS_SCHEME_HASH& r)
{
    this->hashAlg = r.hashAlg;
};
/// <summary>
/// This structure is the scheme data for schemes that only require a hash to complete their definition.
/// </summary>
TpmStructureBase* TPMS_SCHEME_HASH::Clone() const
{
    TPMS_SCHEME_HASH* _x = new TPMS_SCHEME_HASH(*this);
    return _x;
};
void* TPMS_SCHEME_HASH::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hashAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_SCHEME_ECDAA::GetTypeId() const
{
    return TpmTypeId::TPMS_SCHEME_ECDAA_ID;
};
/// <summary>
/// This definition is for split signing schemes that require a commit count.
/// </summary>
TPMS_SCHEME_ECDAA::TPMS_SCHEME_ECDAA()
{
    return;
};
TPMS_SCHEME_ECDAA::TPMS_SCHEME_ECDAA
(
    const TPM_ALG_ID& _hashAlg,
    const UINT16& _count
)
{
    hashAlg= _hashAlg;
    count= _count;
};
/// <summary>
/// This definition is for split signing schemes that require a commit count.
/// </summary>
TPMS_SCHEME_ECDAA::~TPMS_SCHEME_ECDAA()
{
    return;
};
/// <summary>
/// This definition is for split signing schemes that require a commit count.
/// </summary>
TPMS_SCHEME_ECDAA& TPMS_SCHEME_ECDAA::operator=(const TPMS_SCHEME_ECDAA& rhs)
{
    if(this == &rhs) return *this;
    this->hashAlg = rhs.hashAlg;
    this->count = rhs.count;
    return *this;
};
/// <summary>
/// This definition is for split signing schemes that require a commit count.
/// </summary>
TPMS_SCHEME_ECDAA::TPMS_SCHEME_ECDAA(const TPMS_SCHEME_ECDAA& r)
{
    this->hashAlg = r.hashAlg;
    this->count = r.count;
};
/// <summary>
/// This definition is for split signing schemes that require a commit count.
/// </summary>
TpmStructureBase* TPMS_SCHEME_ECDAA::Clone() const
{
    TPMS_SCHEME_ECDAA* _x = new TPMS_SCHEME_ECDAA(*this);
    return _x;
};
void* TPMS_SCHEME_ECDAA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hashAlg);
            case 1: return (void*) (&count);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_SCHEME_HMAC::GetTypeId() const
{
    return TpmTypeId::TPMS_SCHEME_HMAC_ID;
};
/// <summary>
/// Table 150  Definition of Types for HMAC_SIG_SCHEME
/// </summary>
TPMS_SCHEME_HMAC::TPMS_SCHEME_HMAC()
{
    return;
};
TPMS_SCHEME_HMAC::TPMS_SCHEME_HMAC
(
    const TPM_ALG_ID& _hashAlg
)
{
    hashAlg= _hashAlg;
};
/// <summary>
/// Table 150  Definition of Types for HMAC_SIG_SCHEME
/// </summary>
TPMS_SCHEME_HMAC::~TPMS_SCHEME_HMAC()
{
    return;
};
/// <summary>
/// Table 150  Definition of Types for HMAC_SIG_SCHEME
/// </summary>
TPMS_SCHEME_HMAC& TPMS_SCHEME_HMAC::operator=(const TPMS_SCHEME_HMAC& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SCHEME_HASH&)*this = (TPMS_SCHEME_HASH)rhs;
    return *this;
};
/// <summary>
/// Table 150  Definition of Types for HMAC_SIG_SCHEME
/// </summary>
TPMS_SCHEME_HMAC::TPMS_SCHEME_HMAC(const TPMS_SCHEME_HMAC& r)
  : TPMS_SCHEME_HASH(r)
{
};
/// <summary>
/// Table 150  Definition of Types for HMAC_SIG_SCHEME
/// </summary>
TpmStructureBase* TPMS_SCHEME_HMAC::Clone() const
{
    TPMS_SCHEME_HMAC* _x = new TPMS_SCHEME_HMAC(*this);
    return _x;
};
void* TPMS_SCHEME_HMAC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hashAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_SCHEME_XOR::GetTypeId() const
{
    return TpmTypeId::TPMS_SCHEME_XOR_ID;
};
/// <summary>
/// This structure is for the XOR encryption scheme.
/// </summary>
TPMS_SCHEME_XOR::TPMS_SCHEME_XOR()
{
    return;
};
TPMS_SCHEME_XOR::TPMS_SCHEME_XOR
(
    const TPM_ALG_ID& _hashAlg,
    const TPM_ALG_ID& _kdf
)
{
    hashAlg= _hashAlg;
    kdf= _kdf;
};
/// <summary>
/// This structure is for the XOR encryption scheme.
/// </summary>
TPMS_SCHEME_XOR::~TPMS_SCHEME_XOR()
{
    return;
};
/// <summary>
/// This structure is for the XOR encryption scheme.
/// </summary>
TPMS_SCHEME_XOR& TPMS_SCHEME_XOR::operator=(const TPMS_SCHEME_XOR& rhs)
{
    if(this == &rhs) return *this;
    this->hashAlg = rhs.hashAlg;
    this->kdf = rhs.kdf;
    return *this;
};
/// <summary>
/// This structure is for the XOR encryption scheme.
/// </summary>
TPMS_SCHEME_XOR::TPMS_SCHEME_XOR(const TPMS_SCHEME_XOR& r)
{
    this->hashAlg = r.hashAlg;
    this->kdf = r.kdf;
};
/// <summary>
/// This structure is for the XOR encryption scheme.
/// </summary>
TpmStructureBase* TPMS_SCHEME_XOR::Clone() const
{
    TPMS_SCHEME_XOR* _x = new TPMS_SCHEME_XOR(*this);
    return _x;
};
void* TPMS_SCHEME_XOR::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hashAlg);
            case 1: return (void*) (&kdf);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_NULL_SCHEME_KEYEDHASH::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_SCHEME_KEYEDHASH_ID;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSchemeKeyedhash
/// </summary>
TPMS_NULL_SCHEME_KEYEDHASH::TPMS_NULL_SCHEME_KEYEDHASH()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSchemeKeyedhash
/// </summary>
TPMS_NULL_SCHEME_KEYEDHASH::~TPMS_NULL_SCHEME_KEYEDHASH()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSchemeKeyedhash
/// </summary>
TPMS_NULL_SCHEME_KEYEDHASH& TPMS_NULL_SCHEME_KEYEDHASH::operator=(const TPMS_NULL_SCHEME_KEYEDHASH& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_NULL_UNION&)*this = (TPMS_NULL_UNION)rhs;
    return *this;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSchemeKeyedhash
/// </summary>
TPMS_NULL_SCHEME_KEYEDHASH::TPMS_NULL_SCHEME_KEYEDHASH(const TPMS_NULL_SCHEME_KEYEDHASH& r)
  : TPMS_NULL_UNION(r)
{
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSchemeKeyedhash
/// </summary>
TpmStructureBase* TPMS_NULL_SCHEME_KEYEDHASH::Clone() const
{
    TPMS_NULL_SCHEME_KEYEDHASH* _x = new TPMS_NULL_SCHEME_KEYEDHASH(*this);
    return _x;
};
void* TPMS_NULL_SCHEME_KEYEDHASH::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPMT_KEYEDHASH_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMT_KEYEDHASH_SCHEME_ID;
};
/// <summary>
/// This structure is used for a hash signing object.
/// </summary>
TPMT_KEYEDHASH_SCHEME::TPMT_KEYEDHASH_SCHEME()
{
    details = NULL;
    return;
};
TPMT_KEYEDHASH_SCHEME::TPMT_KEYEDHASH_SCHEME
(
    const TPMU_SCHEME_KEYEDHASH& _details
)
{
    details = dynamic_cast<TPMU_SCHEME_KEYEDHASH*> (_details.Clone());
};
/// <summary>
/// This structure is used for a hash signing object.
/// </summary>
TPMT_KEYEDHASH_SCHEME::~TPMT_KEYEDHASH_SCHEME()
{
    if(details != NULL) { delete details;details=NULL; }
    return;
};
/// <summary>
/// This structure is used for a hash signing object.
/// </summary>
TPMT_KEYEDHASH_SCHEME& TPMT_KEYEDHASH_SCHEME::operator=(const TPMT_KEYEDHASH_SCHEME& rhs)
{
    if(this == &rhs) return *this;
    this->scheme = rhs.scheme;
    if(details != NULL) delete details;
    if(rhs.details != NULL)details = dynamic_cast<TPMU_SCHEME_KEYEDHASH*>(rhs.details->Clone());
    return *this;
};
/// <summary>
/// This structure is used for a hash signing object.
/// </summary>
TPMT_KEYEDHASH_SCHEME::TPMT_KEYEDHASH_SCHEME(const TPMT_KEYEDHASH_SCHEME& r)
{
    this->scheme = r.scheme;
    if(r.details != NULL)details = dynamic_cast<TPMU_SCHEME_KEYEDHASH*>(r.details->Clone());
};
/// <summary>
/// This structure is used for a hash signing object.
/// </summary>
TpmStructureBase* TPMT_KEYEDHASH_SCHEME::Clone() const
{
    TPMT_KEYEDHASH_SCHEME* _x = new TPMT_KEYEDHASH_SCHEME(*this);
    return _x;
};
void* TPMT_KEYEDHASH_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&scheme);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(details); return (void*) (&details);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_SIG_SCHEME_RSASSA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIG_SCHEME_RSASSA_ID;
};
/// <summary>
/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
/// </summary>
TPMS_SIG_SCHEME_RSASSA::TPMS_SIG_SCHEME_RSASSA()
{
    return;
};
TPMS_SIG_SCHEME_RSASSA::TPMS_SIG_SCHEME_RSASSA
(
    const TPM_ALG_ID& _hashAlg
)
{
    hashAlg= _hashAlg;
};
/// <summary>
/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
/// </summary>
TPMS_SIG_SCHEME_RSASSA::~TPMS_SIG_SCHEME_RSASSA()
{
    return;
};
/// <summary>
/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
/// </summary>
TPMS_SIG_SCHEME_RSASSA& TPMS_SIG_SCHEME_RSASSA::operator=(const TPMS_SIG_SCHEME_RSASSA& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SCHEME_HASH&)*this = (TPMS_SCHEME_HASH)rhs;
    return *this;
};
/// <summary>
/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
/// </summary>
TPMS_SIG_SCHEME_RSASSA::TPMS_SIG_SCHEME_RSASSA(const TPMS_SIG_SCHEME_RSASSA& r)
  : TPMS_SCHEME_HASH(r)
{
};
/// <summary>
/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
/// </summary>
TpmStructureBase* TPMS_SIG_SCHEME_RSASSA::Clone() const
{
    TPMS_SIG_SCHEME_RSASSA* _x = new TPMS_SIG_SCHEME_RSASSA(*this);
    return _x;
};
void* TPMS_SIG_SCHEME_RSASSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hashAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_SIG_SCHEME_RSAPSS::GetTypeId() const
{
    return TpmTypeId::TPMS_SIG_SCHEME_RSAPSS_ID;
};
/// <summary>
/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
/// </summary>
TPMS_SIG_SCHEME_RSAPSS::TPMS_SIG_SCHEME_RSAPSS()
{
    return;
};
TPMS_SIG_SCHEME_RSAPSS::TPMS_SIG_SCHEME_RSAPSS
(
    const TPM_ALG_ID& _hashAlg
)
{
    hashAlg= _hashAlg;
};
/// <summary>
/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
/// </summary>
TPMS_SIG_SCHEME_RSAPSS::~TPMS_SIG_SCHEME_RSAPSS()
{
    return;
};
/// <summary>
/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
/// </summary>
TPMS_SIG_SCHEME_RSAPSS& TPMS_SIG_SCHEME_RSAPSS::operator=(const TPMS_SIG_SCHEME_RSAPSS& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SCHEME_HASH&)*this = (TPMS_SCHEME_HASH)rhs;
    return *this;
};
/// <summary>
/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
/// </summary>
TPMS_SIG_SCHEME_RSAPSS::TPMS_SIG_SCHEME_RSAPSS(const TPMS_SIG_SCHEME_RSAPSS& r)
  : TPMS_SCHEME_HASH(r)
{
};
/// <summary>
/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
/// </summary>
TpmStructureBase* TPMS_SIG_SCHEME_RSAPSS::Clone() const
{
    TPMS_SIG_SCHEME_RSAPSS* _x = new TPMS_SIG_SCHEME_RSAPSS(*this);
    return _x;
};
void* TPMS_SIG_SCHEME_RSAPSS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hashAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_SIG_SCHEME_ECDSA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIG_SCHEME_ECDSA_ID;
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TPMS_SIG_SCHEME_ECDSA::TPMS_SIG_SCHEME_ECDSA()
{
    return;
};
TPMS_SIG_SCHEME_ECDSA::TPMS_SIG_SCHEME_ECDSA
(
    const TPM_ALG_ID& _hashAlg
)
{
    hashAlg= _hashAlg;
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TPMS_SIG_SCHEME_ECDSA::~TPMS_SIG_SCHEME_ECDSA()
{
    return;
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TPMS_SIG_SCHEME_ECDSA& TPMS_SIG_SCHEME_ECDSA::operator=(const TPMS_SIG_SCHEME_ECDSA& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SCHEME_HASH&)*this = (TPMS_SCHEME_HASH)rhs;
    return *this;
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TPMS_SIG_SCHEME_ECDSA::TPMS_SIG_SCHEME_ECDSA(const TPMS_SIG_SCHEME_ECDSA& r)
  : TPMS_SCHEME_HASH(r)
{
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TpmStructureBase* TPMS_SIG_SCHEME_ECDSA::Clone() const
{
    TPMS_SIG_SCHEME_ECDSA* _x = new TPMS_SIG_SCHEME_ECDSA(*this);
    return _x;
};
void* TPMS_SIG_SCHEME_ECDSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hashAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_SIG_SCHEME_SM2::GetTypeId() const
{
    return TpmTypeId::TPMS_SIG_SCHEME_SM2_ID;
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TPMS_SIG_SCHEME_SM2::TPMS_SIG_SCHEME_SM2()
{
    return;
};
TPMS_SIG_SCHEME_SM2::TPMS_SIG_SCHEME_SM2
(
    const TPM_ALG_ID& _hashAlg
)
{
    hashAlg= _hashAlg;
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TPMS_SIG_SCHEME_SM2::~TPMS_SIG_SCHEME_SM2()
{
    return;
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TPMS_SIG_SCHEME_SM2& TPMS_SIG_SCHEME_SM2::operator=(const TPMS_SIG_SCHEME_SM2& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SCHEME_HASH&)*this = (TPMS_SCHEME_HASH)rhs;
    return *this;
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TPMS_SIG_SCHEME_SM2::TPMS_SIG_SCHEME_SM2(const TPMS_SIG_SCHEME_SM2& r)
  : TPMS_SCHEME_HASH(r)
{
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TpmStructureBase* TPMS_SIG_SCHEME_SM2::Clone() const
{
    TPMS_SIG_SCHEME_SM2* _x = new TPMS_SIG_SCHEME_SM2(*this);
    return _x;
};
void* TPMS_SIG_SCHEME_SM2::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hashAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_SIG_SCHEME_ECSCHNORR::GetTypeId() const
{
    return TpmTypeId::TPMS_SIG_SCHEME_ECSCHNORR_ID;
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TPMS_SIG_SCHEME_ECSCHNORR::TPMS_SIG_SCHEME_ECSCHNORR()
{
    return;
};
TPMS_SIG_SCHEME_ECSCHNORR::TPMS_SIG_SCHEME_ECSCHNORR
(
    const TPM_ALG_ID& _hashAlg
)
{
    hashAlg= _hashAlg;
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TPMS_SIG_SCHEME_ECSCHNORR::~TPMS_SIG_SCHEME_ECSCHNORR()
{
    return;
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TPMS_SIG_SCHEME_ECSCHNORR& TPMS_SIG_SCHEME_ECSCHNORR::operator=(const TPMS_SIG_SCHEME_ECSCHNORR& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SCHEME_HASH&)*this = (TPMS_SCHEME_HASH)rhs;
    return *this;
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TPMS_SIG_SCHEME_ECSCHNORR::TPMS_SIG_SCHEME_ECSCHNORR(const TPMS_SIG_SCHEME_ECSCHNORR& r)
  : TPMS_SCHEME_HASH(r)
{
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TpmStructureBase* TPMS_SIG_SCHEME_ECSCHNORR::Clone() const
{
    TPMS_SIG_SCHEME_ECSCHNORR* _x = new TPMS_SIG_SCHEME_ECSCHNORR(*this);
    return _x;
};
void* TPMS_SIG_SCHEME_ECSCHNORR::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hashAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_SIG_SCHEME_ECDAA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID;
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TPMS_SIG_SCHEME_ECDAA::TPMS_SIG_SCHEME_ECDAA()
{
    return;
};
TPMS_SIG_SCHEME_ECDAA::TPMS_SIG_SCHEME_ECDAA
(
    const TPM_ALG_ID& _hashAlg,
    const UINT16& _count
)
{
    hashAlg= _hashAlg;
    count= _count;
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TPMS_SIG_SCHEME_ECDAA::~TPMS_SIG_SCHEME_ECDAA()
{
    return;
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TPMS_SIG_SCHEME_ECDAA& TPMS_SIG_SCHEME_ECDAA::operator=(const TPMS_SIG_SCHEME_ECDAA& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SCHEME_ECDAA&)*this = (TPMS_SCHEME_ECDAA)rhs;
    return *this;
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TPMS_SIG_SCHEME_ECDAA::TPMS_SIG_SCHEME_ECDAA(const TPMS_SIG_SCHEME_ECDAA& r)
  : TPMS_SCHEME_ECDAA(r)
{
};
/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
TpmStructureBase* TPMS_SIG_SCHEME_ECDAA::Clone() const
{
    TPMS_SIG_SCHEME_ECDAA* _x = new TPMS_SIG_SCHEME_ECDAA(*this);
    return _x;
};
void* TPMS_SIG_SCHEME_ECDAA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hashAlg);
            case 1: return (void*) (&count);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_NULL_SIG_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_SIG_SCHEME_ID;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSigScheme
/// </summary>
TPMS_NULL_SIG_SCHEME::TPMS_NULL_SIG_SCHEME()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSigScheme
/// </summary>
TPMS_NULL_SIG_SCHEME::~TPMS_NULL_SIG_SCHEME()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSigScheme
/// </summary>
TPMS_NULL_SIG_SCHEME& TPMS_NULL_SIG_SCHEME::operator=(const TPMS_NULL_SIG_SCHEME& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_NULL_UNION&)*this = (TPMS_NULL_UNION)rhs;
    return *this;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSigScheme
/// </summary>
TPMS_NULL_SIG_SCHEME::TPMS_NULL_SIG_SCHEME(const TPMS_NULL_SIG_SCHEME& r)
  : TPMS_NULL_UNION(r)
{
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSigScheme
/// </summary>
TpmStructureBase* TPMS_NULL_SIG_SCHEME::Clone() const
{
    TPMS_NULL_SIG_SCHEME* _x = new TPMS_NULL_SIG_SCHEME(*this);
    return _x;
};
void* TPMS_NULL_SIG_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPMT_SIG_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMT_SIG_SCHEME_ID;
};
/// <summary>
/// Table 157  Definition of TPMT_SIG_SCHEME Structure
/// </summary>
TPMT_SIG_SCHEME::TPMT_SIG_SCHEME()
{
    details = NULL;
    return;
};
TPMT_SIG_SCHEME::TPMT_SIG_SCHEME
(
    const TPMU_SIG_SCHEME& _details
)
{
    details = dynamic_cast<TPMU_SIG_SCHEME*> (_details.Clone());
};
/// <summary>
/// Table 157  Definition of TPMT_SIG_SCHEME Structure
/// </summary>
TPMT_SIG_SCHEME::~TPMT_SIG_SCHEME()
{
    if(details != NULL) { delete details;details=NULL; }
    return;
};
/// <summary>
/// Table 157  Definition of TPMT_SIG_SCHEME Structure
/// </summary>
TPMT_SIG_SCHEME& TPMT_SIG_SCHEME::operator=(const TPMT_SIG_SCHEME& rhs)
{
    if(this == &rhs) return *this;
    this->scheme = rhs.scheme;
    if(details != NULL) delete details;
    if(rhs.details != NULL)details = dynamic_cast<TPMU_SIG_SCHEME*>(rhs.details->Clone());
    return *this;
};
/// <summary>
/// Table 157  Definition of TPMT_SIG_SCHEME Structure
/// </summary>
TPMT_SIG_SCHEME::TPMT_SIG_SCHEME(const TPMT_SIG_SCHEME& r)
{
    this->scheme = r.scheme;
    if(r.details != NULL)details = dynamic_cast<TPMU_SIG_SCHEME*>(r.details->Clone());
};
/// <summary>
/// Table 157  Definition of TPMT_SIG_SCHEME Structure
/// </summary>
TpmStructureBase* TPMT_SIG_SCHEME::Clone() const
{
    TPMT_SIG_SCHEME* _x = new TPMT_SIG_SCHEME(*this);
    return _x;
};
void* TPMT_SIG_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&scheme);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(details); return (void*) (&details);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_ENC_SCHEME_OAEP::GetTypeId() const
{
    return TpmTypeId::TPMS_ENC_SCHEME_OAEP_ID;
};
/// <summary>
/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TPMS_ENC_SCHEME_OAEP::TPMS_ENC_SCHEME_OAEP()
{
    return;
};
TPMS_ENC_SCHEME_OAEP::TPMS_ENC_SCHEME_OAEP
(
    const TPM_ALG_ID& _hashAlg
)
{
    hashAlg= _hashAlg;
};
/// <summary>
/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TPMS_ENC_SCHEME_OAEP::~TPMS_ENC_SCHEME_OAEP()
{
    return;
};
/// <summary>
/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TPMS_ENC_SCHEME_OAEP& TPMS_ENC_SCHEME_OAEP::operator=(const TPMS_ENC_SCHEME_OAEP& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SCHEME_HASH&)*this = (TPMS_SCHEME_HASH)rhs;
    return *this;
};
/// <summary>
/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TPMS_ENC_SCHEME_OAEP::TPMS_ENC_SCHEME_OAEP(const TPMS_ENC_SCHEME_OAEP& r)
  : TPMS_SCHEME_HASH(r)
{
};
/// <summary>
/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TpmStructureBase* TPMS_ENC_SCHEME_OAEP::Clone() const
{
    TPMS_ENC_SCHEME_OAEP* _x = new TPMS_ENC_SCHEME_OAEP(*this);
    return _x;
};
void* TPMS_ENC_SCHEME_OAEP::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hashAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_ENC_SCHEME_RSAES::GetTypeId() const
{
    return TpmTypeId::TPMS_ENC_SCHEME_RSAES_ID;
};
/// <summary>
/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TPMS_ENC_SCHEME_RSAES::TPMS_ENC_SCHEME_RSAES()
{
    return;
};
/// <summary>
/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TPMS_ENC_SCHEME_RSAES::~TPMS_ENC_SCHEME_RSAES()
{
    return;
};
/// <summary>
/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TPMS_ENC_SCHEME_RSAES& TPMS_ENC_SCHEME_RSAES::operator=(const TPMS_ENC_SCHEME_RSAES& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_EMPTY&)*this = (TPMS_EMPTY)rhs;
    return *this;
};
/// <summary>
/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TPMS_ENC_SCHEME_RSAES::TPMS_ENC_SCHEME_RSAES(const TPMS_ENC_SCHEME_RSAES& r)
  : TPMS_EMPTY(r)
{
};
/// <summary>
/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TpmStructureBase* TPMS_ENC_SCHEME_RSAES::Clone() const
{
    TPMS_ENC_SCHEME_RSAES* _x = new TPMS_ENC_SCHEME_RSAES(*this);
    return _x;
};
void* TPMS_ENC_SCHEME_RSAES::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPMS_KEY_SCHEME_ECDH::GetTypeId() const
{
    return TpmTypeId::TPMS_KEY_SCHEME_ECDH_ID;
};
/// <summary>
/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TPMS_KEY_SCHEME_ECDH::TPMS_KEY_SCHEME_ECDH()
{
    return;
};
TPMS_KEY_SCHEME_ECDH::TPMS_KEY_SCHEME_ECDH
(
    const TPM_ALG_ID& _hashAlg
)
{
    hashAlg= _hashAlg;
};
/// <summary>
/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TPMS_KEY_SCHEME_ECDH::~TPMS_KEY_SCHEME_ECDH()
{
    return;
};
/// <summary>
/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TPMS_KEY_SCHEME_ECDH& TPMS_KEY_SCHEME_ECDH::operator=(const TPMS_KEY_SCHEME_ECDH& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SCHEME_HASH&)*this = (TPMS_SCHEME_HASH)rhs;
    return *this;
};
/// <summary>
/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TPMS_KEY_SCHEME_ECDH::TPMS_KEY_SCHEME_ECDH(const TPMS_KEY_SCHEME_ECDH& r)
  : TPMS_SCHEME_HASH(r)
{
};
/// <summary>
/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TpmStructureBase* TPMS_KEY_SCHEME_ECDH::Clone() const
{
    TPMS_KEY_SCHEME_ECDH* _x = new TPMS_KEY_SCHEME_ECDH(*this);
    return _x;
};
void* TPMS_KEY_SCHEME_ECDH::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hashAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_KEY_SCHEME_ECMQV::GetTypeId() const
{
    return TpmTypeId::TPMS_KEY_SCHEME_ECMQV_ID;
};
/// <summary>
/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TPMS_KEY_SCHEME_ECMQV::TPMS_KEY_SCHEME_ECMQV()
{
    return;
};
TPMS_KEY_SCHEME_ECMQV::TPMS_KEY_SCHEME_ECMQV
(
    const TPM_ALG_ID& _hashAlg
)
{
    hashAlg= _hashAlg;
};
/// <summary>
/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TPMS_KEY_SCHEME_ECMQV::~TPMS_KEY_SCHEME_ECMQV()
{
    return;
};
/// <summary>
/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TPMS_KEY_SCHEME_ECMQV& TPMS_KEY_SCHEME_ECMQV::operator=(const TPMS_KEY_SCHEME_ECMQV& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SCHEME_HASH&)*this = (TPMS_SCHEME_HASH)rhs;
    return *this;
};
/// <summary>
/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TPMS_KEY_SCHEME_ECMQV::TPMS_KEY_SCHEME_ECMQV(const TPMS_KEY_SCHEME_ECMQV& r)
  : TPMS_SCHEME_HASH(r)
{
};
/// <summary>
/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
/// </summary>
TpmStructureBase* TPMS_KEY_SCHEME_ECMQV::Clone() const
{
    TPMS_KEY_SCHEME_ECMQV* _x = new TPMS_KEY_SCHEME_ECMQV(*this);
    return _x;
};
void* TPMS_KEY_SCHEME_ECMQV::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hashAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_SCHEME_MGF1::GetTypeId() const
{
    return TpmTypeId::TPMS_SCHEME_MGF1_ID;
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TPMS_SCHEME_MGF1::TPMS_SCHEME_MGF1()
{
    return;
};
TPMS_SCHEME_MGF1::TPMS_SCHEME_MGF1
(
    const TPM_ALG_ID& _hashAlg
)
{
    hashAlg= _hashAlg;
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TPMS_SCHEME_MGF1::~TPMS_SCHEME_MGF1()
{
    return;
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TPMS_SCHEME_MGF1& TPMS_SCHEME_MGF1::operator=(const TPMS_SCHEME_MGF1& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SCHEME_HASH&)*this = (TPMS_SCHEME_HASH)rhs;
    return *this;
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TPMS_SCHEME_MGF1::TPMS_SCHEME_MGF1(const TPMS_SCHEME_MGF1& r)
  : TPMS_SCHEME_HASH(r)
{
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TpmStructureBase* TPMS_SCHEME_MGF1::Clone() const
{
    TPMS_SCHEME_MGF1* _x = new TPMS_SCHEME_MGF1(*this);
    return _x;
};
void* TPMS_SCHEME_MGF1::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hashAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_SCHEME_KDF1_SP800_56A::GetTypeId() const
{
    return TpmTypeId::TPMS_SCHEME_KDF1_SP800_56A_ID;
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TPMS_SCHEME_KDF1_SP800_56A::TPMS_SCHEME_KDF1_SP800_56A()
{
    return;
};
TPMS_SCHEME_KDF1_SP800_56A::TPMS_SCHEME_KDF1_SP800_56A
(
    const TPM_ALG_ID& _hashAlg
)
{
    hashAlg= _hashAlg;
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TPMS_SCHEME_KDF1_SP800_56A::~TPMS_SCHEME_KDF1_SP800_56A()
{
    return;
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TPMS_SCHEME_KDF1_SP800_56A& TPMS_SCHEME_KDF1_SP800_56A::operator=(const TPMS_SCHEME_KDF1_SP800_56A& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SCHEME_HASH&)*this = (TPMS_SCHEME_HASH)rhs;
    return *this;
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TPMS_SCHEME_KDF1_SP800_56A::TPMS_SCHEME_KDF1_SP800_56A(const TPMS_SCHEME_KDF1_SP800_56A& r)
  : TPMS_SCHEME_HASH(r)
{
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TpmStructureBase* TPMS_SCHEME_KDF1_SP800_56A::Clone() const
{
    TPMS_SCHEME_KDF1_SP800_56A* _x = new TPMS_SCHEME_KDF1_SP800_56A(*this);
    return _x;
};
void* TPMS_SCHEME_KDF1_SP800_56A::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hashAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_SCHEME_KDF2::GetTypeId() const
{
    return TpmTypeId::TPMS_SCHEME_KDF2_ID;
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TPMS_SCHEME_KDF2::TPMS_SCHEME_KDF2()
{
    return;
};
TPMS_SCHEME_KDF2::TPMS_SCHEME_KDF2
(
    const TPM_ALG_ID& _hashAlg
)
{
    hashAlg= _hashAlg;
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TPMS_SCHEME_KDF2::~TPMS_SCHEME_KDF2()
{
    return;
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TPMS_SCHEME_KDF2& TPMS_SCHEME_KDF2::operator=(const TPMS_SCHEME_KDF2& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SCHEME_HASH&)*this = (TPMS_SCHEME_HASH)rhs;
    return *this;
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TPMS_SCHEME_KDF2::TPMS_SCHEME_KDF2(const TPMS_SCHEME_KDF2& r)
  : TPMS_SCHEME_HASH(r)
{
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TpmStructureBase* TPMS_SCHEME_KDF2::Clone() const
{
    TPMS_SCHEME_KDF2* _x = new TPMS_SCHEME_KDF2(*this);
    return _x;
};
void* TPMS_SCHEME_KDF2::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hashAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_SCHEME_KDF1_SP800_108::GetTypeId() const
{
    return TpmTypeId::TPMS_SCHEME_KDF1_SP800_108_ID;
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TPMS_SCHEME_KDF1_SP800_108::TPMS_SCHEME_KDF1_SP800_108()
{
    return;
};
TPMS_SCHEME_KDF1_SP800_108::TPMS_SCHEME_KDF1_SP800_108
(
    const TPM_ALG_ID& _hashAlg
)
{
    hashAlg= _hashAlg;
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TPMS_SCHEME_KDF1_SP800_108::~TPMS_SCHEME_KDF1_SP800_108()
{
    return;
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TPMS_SCHEME_KDF1_SP800_108& TPMS_SCHEME_KDF1_SP800_108::operator=(const TPMS_SCHEME_KDF1_SP800_108& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SCHEME_HASH&)*this = (TPMS_SCHEME_HASH)rhs;
    return *this;
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TPMS_SCHEME_KDF1_SP800_108::TPMS_SCHEME_KDF1_SP800_108(const TPMS_SCHEME_KDF1_SP800_108& r)
  : TPMS_SCHEME_HASH(r)
{
};
/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
/// </summary>
TpmStructureBase* TPMS_SCHEME_KDF1_SP800_108::Clone() const
{
    TPMS_SCHEME_KDF1_SP800_108* _x = new TPMS_SCHEME_KDF1_SP800_108(*this);
    return _x;
};
void* TPMS_SCHEME_KDF1_SP800_108::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hashAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_NULL_KDF_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_KDF_SCHEME_ID;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuKdfScheme
/// </summary>
TPMS_NULL_KDF_SCHEME::TPMS_NULL_KDF_SCHEME()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuKdfScheme
/// </summary>
TPMS_NULL_KDF_SCHEME::~TPMS_NULL_KDF_SCHEME()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuKdfScheme
/// </summary>
TPMS_NULL_KDF_SCHEME& TPMS_NULL_KDF_SCHEME::operator=(const TPMS_NULL_KDF_SCHEME& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_NULL_UNION&)*this = (TPMS_NULL_UNION)rhs;
    return *this;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuKdfScheme
/// </summary>
TPMS_NULL_KDF_SCHEME::TPMS_NULL_KDF_SCHEME(const TPMS_NULL_KDF_SCHEME& r)
  : TPMS_NULL_UNION(r)
{
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuKdfScheme
/// </summary>
TpmStructureBase* TPMS_NULL_KDF_SCHEME::Clone() const
{
    TPMS_NULL_KDF_SCHEME* _x = new TPMS_NULL_KDF_SCHEME(*this);
    return _x;
};
void* TPMS_NULL_KDF_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPMT_KDF_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMT_KDF_SCHEME_ID;
};
/// <summary>
/// Table 162  Definition of TPMT_KDF_SCHEME Structure
/// </summary>
TPMT_KDF_SCHEME::TPMT_KDF_SCHEME()
{
    details = NULL;
    return;
};
TPMT_KDF_SCHEME::TPMT_KDF_SCHEME
(
    const TPMU_KDF_SCHEME& _details
)
{
    details = dynamic_cast<TPMU_KDF_SCHEME*> (_details.Clone());
};
/// <summary>
/// Table 162  Definition of TPMT_KDF_SCHEME Structure
/// </summary>
TPMT_KDF_SCHEME::~TPMT_KDF_SCHEME()
{
    if(details != NULL) { delete details;details=NULL; }
    return;
};
/// <summary>
/// Table 162  Definition of TPMT_KDF_SCHEME Structure
/// </summary>
TPMT_KDF_SCHEME& TPMT_KDF_SCHEME::operator=(const TPMT_KDF_SCHEME& rhs)
{
    if(this == &rhs) return *this;
    this->scheme = rhs.scheme;
    if(details != NULL) delete details;
    if(rhs.details != NULL)details = dynamic_cast<TPMU_KDF_SCHEME*>(rhs.details->Clone());
    return *this;
};
/// <summary>
/// Table 162  Definition of TPMT_KDF_SCHEME Structure
/// </summary>
TPMT_KDF_SCHEME::TPMT_KDF_SCHEME(const TPMT_KDF_SCHEME& r)
{
    this->scheme = r.scheme;
    if(r.details != NULL)details = dynamic_cast<TPMU_KDF_SCHEME*>(r.details->Clone());
};
/// <summary>
/// Table 162  Definition of TPMT_KDF_SCHEME Structure
/// </summary>
TpmStructureBase* TPMT_KDF_SCHEME::Clone() const
{
    TPMT_KDF_SCHEME* _x = new TPMT_KDF_SCHEME(*this);
    return _x;
};
void* TPMT_KDF_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&scheme);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(details); return (void*) (&details);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_NULL_ASYM_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_ASYM_SCHEME_ID;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuAsymScheme
/// </summary>
TPMS_NULL_ASYM_SCHEME::TPMS_NULL_ASYM_SCHEME()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuAsymScheme
/// </summary>
TPMS_NULL_ASYM_SCHEME::~TPMS_NULL_ASYM_SCHEME()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuAsymScheme
/// </summary>
TPMS_NULL_ASYM_SCHEME& TPMS_NULL_ASYM_SCHEME::operator=(const TPMS_NULL_ASYM_SCHEME& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_NULL_UNION&)*this = (TPMS_NULL_UNION)rhs;
    return *this;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuAsymScheme
/// </summary>
TPMS_NULL_ASYM_SCHEME::TPMS_NULL_ASYM_SCHEME(const TPMS_NULL_ASYM_SCHEME& r)
  : TPMS_NULL_UNION(r)
{
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuAsymScheme
/// </summary>
TpmStructureBase* TPMS_NULL_ASYM_SCHEME::Clone() const
{
    TPMS_NULL_ASYM_SCHEME* _x = new TPMS_NULL_ASYM_SCHEME(*this);
    return _x;
};
void* TPMS_NULL_ASYM_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPMT_ASYM_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMT_ASYM_SCHEME_ID;
};
/// <summary>
/// This structure is defined to allow overlay of all of the schemes for any asymmetric object. This structure is not sent on the interface. It is defined so that common functions may operate on any similar scheme structure.
/// </summary>
TPMT_ASYM_SCHEME::TPMT_ASYM_SCHEME()
{
    details = NULL;
    return;
};
TPMT_ASYM_SCHEME::TPMT_ASYM_SCHEME
(
    const TPMU_ASYM_SCHEME& _details
)
{
    details = dynamic_cast<TPMU_ASYM_SCHEME*> (_details.Clone());
};
/// <summary>
/// This structure is defined to allow overlay of all of the schemes for any asymmetric object. This structure is not sent on the interface. It is defined so that common functions may operate on any similar scheme structure.
/// </summary>
TPMT_ASYM_SCHEME::~TPMT_ASYM_SCHEME()
{
    if(details != NULL) { delete details;details=NULL; }
    return;
};
/// <summary>
/// This structure is defined to allow overlay of all of the schemes for any asymmetric object. This structure is not sent on the interface. It is defined so that common functions may operate on any similar scheme structure.
/// </summary>
TPMT_ASYM_SCHEME& TPMT_ASYM_SCHEME::operator=(const TPMT_ASYM_SCHEME& rhs)
{
    if(this == &rhs) return *this;
    this->scheme = rhs.scheme;
    if(details != NULL) delete details;
    if(rhs.details != NULL)details = dynamic_cast<TPMU_ASYM_SCHEME*>(rhs.details->Clone());
    return *this;
};
/// <summary>
/// This structure is defined to allow overlay of all of the schemes for any asymmetric object. This structure is not sent on the interface. It is defined so that common functions may operate on any similar scheme structure.
/// </summary>
TPMT_ASYM_SCHEME::TPMT_ASYM_SCHEME(const TPMT_ASYM_SCHEME& r)
{
    this->scheme = r.scheme;
    if(r.details != NULL)details = dynamic_cast<TPMU_ASYM_SCHEME*>(r.details->Clone());
};
/// <summary>
/// This structure is defined to allow overlay of all of the schemes for any asymmetric object. This structure is not sent on the interface. It is defined so that common functions may operate on any similar scheme structure.
/// </summary>
TpmStructureBase* TPMT_ASYM_SCHEME::Clone() const
{
    TPMT_ASYM_SCHEME* _x = new TPMT_ASYM_SCHEME(*this);
    return _x;
};
void* TPMT_ASYM_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&scheme);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(details); return (void*) (&details);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMT_RSA_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMT_RSA_SCHEME_ID;
};
/// <summary>
/// Table 167  Definition of {RSA} TPMT_RSA_SCHEME Structure
/// </summary>
TPMT_RSA_SCHEME::TPMT_RSA_SCHEME()
{
    details = NULL;
    return;
};
TPMT_RSA_SCHEME::TPMT_RSA_SCHEME
(
    const TPMU_ASYM_SCHEME& _details
)
{
    details = dynamic_cast<TPMU_ASYM_SCHEME*> (_details.Clone());
};
/// <summary>
/// Table 167  Definition of {RSA} TPMT_RSA_SCHEME Structure
/// </summary>
TPMT_RSA_SCHEME::~TPMT_RSA_SCHEME()
{
    if(details != NULL) { delete details;details=NULL; }
    return;
};
/// <summary>
/// Table 167  Definition of {RSA} TPMT_RSA_SCHEME Structure
/// </summary>
TPMT_RSA_SCHEME& TPMT_RSA_SCHEME::operator=(const TPMT_RSA_SCHEME& rhs)
{
    if(this == &rhs) return *this;
    this->scheme = rhs.scheme;
    if(details != NULL) delete details;
    if(rhs.details != NULL)details = dynamic_cast<TPMU_ASYM_SCHEME*>(rhs.details->Clone());
    return *this;
};
/// <summary>
/// Table 167  Definition of {RSA} TPMT_RSA_SCHEME Structure
/// </summary>
TPMT_RSA_SCHEME::TPMT_RSA_SCHEME(const TPMT_RSA_SCHEME& r)
{
    this->scheme = r.scheme;
    if(r.details != NULL)details = dynamic_cast<TPMU_ASYM_SCHEME*>(r.details->Clone());
};
/// <summary>
/// Table 167  Definition of {RSA} TPMT_RSA_SCHEME Structure
/// </summary>
TpmStructureBase* TPMT_RSA_SCHEME::Clone() const
{
    TPMT_RSA_SCHEME* _x = new TPMT_RSA_SCHEME(*this);
    return _x;
};
void* TPMT_RSA_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&scheme);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(details); return (void*) (&details);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMT_RSA_DECRYPT::GetTypeId() const
{
    return TpmTypeId::TPMT_RSA_DECRYPT_ID;
};
/// <summary>
/// Table 169  Definition of {RSA} TPMT_RSA_DECRYPT Structure
/// </summary>
TPMT_RSA_DECRYPT::TPMT_RSA_DECRYPT()
{
    details = NULL;
    return;
};
TPMT_RSA_DECRYPT::TPMT_RSA_DECRYPT
(
    const TPMU_ASYM_SCHEME& _details
)
{
    details = dynamic_cast<TPMU_ASYM_SCHEME*> (_details.Clone());
};
/// <summary>
/// Table 169  Definition of {RSA} TPMT_RSA_DECRYPT Structure
/// </summary>
TPMT_RSA_DECRYPT::~TPMT_RSA_DECRYPT()
{
    if(details != NULL) { delete details;details=NULL; }
    return;
};
/// <summary>
/// Table 169  Definition of {RSA} TPMT_RSA_DECRYPT Structure
/// </summary>
TPMT_RSA_DECRYPT& TPMT_RSA_DECRYPT::operator=(const TPMT_RSA_DECRYPT& rhs)
{
    if(this == &rhs) return *this;
    this->scheme = rhs.scheme;
    if(details != NULL) delete details;
    if(rhs.details != NULL)details = dynamic_cast<TPMU_ASYM_SCHEME*>(rhs.details->Clone());
    return *this;
};
/// <summary>
/// Table 169  Definition of {RSA} TPMT_RSA_DECRYPT Structure
/// </summary>
TPMT_RSA_DECRYPT::TPMT_RSA_DECRYPT(const TPMT_RSA_DECRYPT& r)
{
    this->scheme = r.scheme;
    if(r.details != NULL)details = dynamic_cast<TPMU_ASYM_SCHEME*>(r.details->Clone());
};
/// <summary>
/// Table 169  Definition of {RSA} TPMT_RSA_DECRYPT Structure
/// </summary>
TpmStructureBase* TPMT_RSA_DECRYPT::Clone() const
{
    TPMT_RSA_DECRYPT* _x = new TPMT_RSA_DECRYPT(*this);
    return _x;
};
void* TPMT_RSA_DECRYPT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&scheme);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(details); return (void*) (&details);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2B_PUBLIC_KEY_RSA::GetTypeId() const
{
    return TpmTypeId::TPM2B_PUBLIC_KEY_RSA_ID;
};
/// <summary>
/// This sized buffer holds the largest RSA public key supported by the TPM.
/// </summary>
TPM2B_PUBLIC_KEY_RSA::TPM2B_PUBLIC_KEY_RSA()
{
    return;
};
TPM2B_PUBLIC_KEY_RSA::TPM2B_PUBLIC_KEY_RSA
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// This sized buffer holds the largest RSA public key supported by the TPM.
/// </summary>
TPM2B_PUBLIC_KEY_RSA::~TPM2B_PUBLIC_KEY_RSA()
{
    return;
};
/// <summary>
/// This sized buffer holds the largest RSA public key supported by the TPM.
/// </summary>
TPM2B_PUBLIC_KEY_RSA& TPM2B_PUBLIC_KEY_RSA::operator=(const TPM2B_PUBLIC_KEY_RSA& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This sized buffer holds the largest RSA public key supported by the TPM.
/// </summary>
TPM2B_PUBLIC_KEY_RSA::TPM2B_PUBLIC_KEY_RSA(const TPM2B_PUBLIC_KEY_RSA& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// This sized buffer holds the largest RSA public key supported by the TPM.
/// </summary>
TpmStructureBase* TPM2B_PUBLIC_KEY_RSA::Clone() const
{
    TPM2B_PUBLIC_KEY_RSA* _x = new TPM2B_PUBLIC_KEY_RSA(*this);
    return _x;
};
void* TPM2B_PUBLIC_KEY_RSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_PRIVATE_KEY_RSA::GetTypeId() const
{
    return TpmTypeId::TPM2B_PRIVATE_KEY_RSA_ID;
};
/// <summary>
/// This sized buffer holds the largest RSA prime number supported by the TPM.
/// </summary>
TPM2B_PRIVATE_KEY_RSA::TPM2B_PRIVATE_KEY_RSA()
{
    return;
};
TPM2B_PRIVATE_KEY_RSA::TPM2B_PRIVATE_KEY_RSA
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// This sized buffer holds the largest RSA prime number supported by the TPM.
/// </summary>
TPM2B_PRIVATE_KEY_RSA::~TPM2B_PRIVATE_KEY_RSA()
{
    return;
};
/// <summary>
/// This sized buffer holds the largest RSA prime number supported by the TPM.
/// </summary>
TPM2B_PRIVATE_KEY_RSA& TPM2B_PRIVATE_KEY_RSA::operator=(const TPM2B_PRIVATE_KEY_RSA& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This sized buffer holds the largest RSA prime number supported by the TPM.
/// </summary>
TPM2B_PRIVATE_KEY_RSA::TPM2B_PRIVATE_KEY_RSA(const TPM2B_PRIVATE_KEY_RSA& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// This sized buffer holds the largest RSA prime number supported by the TPM.
/// </summary>
TpmStructureBase* TPM2B_PRIVATE_KEY_RSA::Clone() const
{
    TPM2B_PRIVATE_KEY_RSA* _x = new TPM2B_PRIVATE_KEY_RSA(*this);
    return _x;
};
void* TPM2B_PRIVATE_KEY_RSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_ECC_PARAMETER::GetTypeId() const
{
    return TpmTypeId::TPM2B_ECC_PARAMETER_ID;
};
/// <summary>
/// This sized buffer holds the largest ECC parameter (coordinate) supported by the TPM.
/// </summary>
TPM2B_ECC_PARAMETER::TPM2B_ECC_PARAMETER()
{
    return;
};
TPM2B_ECC_PARAMETER::TPM2B_ECC_PARAMETER
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// This sized buffer holds the largest ECC parameter (coordinate) supported by the TPM.
/// </summary>
TPM2B_ECC_PARAMETER::~TPM2B_ECC_PARAMETER()
{
    return;
};
/// <summary>
/// This sized buffer holds the largest ECC parameter (coordinate) supported by the TPM.
/// </summary>
TPM2B_ECC_PARAMETER& TPM2B_ECC_PARAMETER::operator=(const TPM2B_ECC_PARAMETER& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This sized buffer holds the largest ECC parameter (coordinate) supported by the TPM.
/// </summary>
TPM2B_ECC_PARAMETER::TPM2B_ECC_PARAMETER(const TPM2B_ECC_PARAMETER& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// This sized buffer holds the largest ECC parameter (coordinate) supported by the TPM.
/// </summary>
TpmStructureBase* TPM2B_ECC_PARAMETER::Clone() const
{
    TPM2B_ECC_PARAMETER* _x = new TPM2B_ECC_PARAMETER(*this);
    return _x;
};
void* TPM2B_ECC_PARAMETER::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_ECC_POINT::GetTypeId() const
{
    return TpmTypeId::TPMS_ECC_POINT_ID;
};
/// <summary>
/// This structure holds two ECC coordinates that, together, make up an ECC point.
/// </summary>
TPMS_ECC_POINT::TPMS_ECC_POINT()
{
    return;
};
TPMS_ECC_POINT::TPMS_ECC_POINT
(
    const std::vector<BYTE>& _x,
    const std::vector<BYTE>& _y
)
{
    x= _x;
    y= _y;
};
/// <summary>
/// This structure holds two ECC coordinates that, together, make up an ECC point.
/// </summary>
TPMS_ECC_POINT::~TPMS_ECC_POINT()
{
    return;
};
/// <summary>
/// This structure holds two ECC coordinates that, together, make up an ECC point.
/// </summary>
TPMS_ECC_POINT& TPMS_ECC_POINT::operator=(const TPMS_ECC_POINT& rhs)
{
    if(this == &rhs) return *this;
    this->xSize = rhs.xSize;
    this->x = rhs.x;
    this->ySize = rhs.ySize;
    this->y = rhs.y;
    return *this;
};
/// <summary>
/// This structure holds two ECC coordinates that, together, make up an ECC point.
/// </summary>
TPMS_ECC_POINT::TPMS_ECC_POINT(const TPMS_ECC_POINT& r)
{
    this->xSize = r.xSize;
    this->x = r.x;
    this->ySize = r.ySize;
    this->y = r.y;
};
/// <summary>
/// This structure holds two ECC coordinates that, together, make up an ECC point.
/// </summary>
TpmStructureBase* TPMS_ECC_POINT::Clone() const
{
    TPMS_ECC_POINT* _x = new TPMS_ECC_POINT(*this);
    return _x;
};
void* TPMS_ECC_POINT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&xSize);
            case 1: { if(newArraySize != -1)x.resize(newArraySize); arraySize = (int)x.size(); return (void*)(&x); }
            case 2: return (void*) (&ySize);
            case 3: { if(newArraySize != -1)y.resize(newArraySize); arraySize = (int)y.size(); return (void*)(&y); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&x[arrayIndex]);
            case 3: return (void*)(&y[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_ECC_POINT::GetTypeId() const
{
    return TpmTypeId::TPM2B_ECC_POINT_ID;
};
/// <summary>
/// This structure is defined to allow a point to be a single sized parameter so that it may be encrypted.
/// </summary>
TPM2B_ECC_POINT::TPM2B_ECC_POINT()
{
    return;
};
TPM2B_ECC_POINT::TPM2B_ECC_POINT
(
    const TPMS_ECC_POINT& _point
)
{
    point= _point;
};
/// <summary>
/// This structure is defined to allow a point to be a single sized parameter so that it may be encrypted.
/// </summary>
TPM2B_ECC_POINT::~TPM2B_ECC_POINT()
{
    return;
};
/// <summary>
/// This structure is defined to allow a point to be a single sized parameter so that it may be encrypted.
/// </summary>
TPM2B_ECC_POINT& TPM2B_ECC_POINT::operator=(const TPM2B_ECC_POINT& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->point = rhs.point;
    return *this;
};
/// <summary>
/// This structure is defined to allow a point to be a single sized parameter so that it may be encrypted.
/// </summary>
TPM2B_ECC_POINT::TPM2B_ECC_POINT(const TPM2B_ECC_POINT& r)
{
    this->size = r.size;
    this->point = r.point;
};
/// <summary>
/// This structure is defined to allow a point to be a single sized parameter so that it may be encrypted.
/// </summary>
TpmStructureBase* TPM2B_ECC_POINT::Clone() const
{
    TPM2B_ECC_POINT* _x = new TPM2B_ECC_POINT(*this);
    return _x;
};
void* TPM2B_ECC_POINT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&point); return (void*) (&point);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMT_ECC_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMT_ECC_SCHEME_ID;
};
/// <summary>
/// Table 178  Definition of (TPMT_SIG_SCHEME) {ECC} TPMT_ECC_SCHEME Structure
/// </summary>
TPMT_ECC_SCHEME::TPMT_ECC_SCHEME()
{
    details = NULL;
    return;
};
TPMT_ECC_SCHEME::TPMT_ECC_SCHEME
(
    const TPMU_ASYM_SCHEME& _details
)
{
    details = dynamic_cast<TPMU_ASYM_SCHEME*> (_details.Clone());
};
/// <summary>
/// Table 178  Definition of (TPMT_SIG_SCHEME) {ECC} TPMT_ECC_SCHEME Structure
/// </summary>
TPMT_ECC_SCHEME::~TPMT_ECC_SCHEME()
{
    if(details != NULL) { delete details;details=NULL; }
    return;
};
/// <summary>
/// Table 178  Definition of (TPMT_SIG_SCHEME) {ECC} TPMT_ECC_SCHEME Structure
/// </summary>
TPMT_ECC_SCHEME& TPMT_ECC_SCHEME::operator=(const TPMT_ECC_SCHEME& rhs)
{
    if(this == &rhs) return *this;
    this->scheme = rhs.scheme;
    if(details != NULL) delete details;
    if(rhs.details != NULL)details = dynamic_cast<TPMU_ASYM_SCHEME*>(rhs.details->Clone());
    return *this;
};
/// <summary>
/// Table 178  Definition of (TPMT_SIG_SCHEME) {ECC} TPMT_ECC_SCHEME Structure
/// </summary>
TPMT_ECC_SCHEME::TPMT_ECC_SCHEME(const TPMT_ECC_SCHEME& r)
{
    this->scheme = r.scheme;
    if(r.details != NULL)details = dynamic_cast<TPMU_ASYM_SCHEME*>(r.details->Clone());
};
/// <summary>
/// Table 178  Definition of (TPMT_SIG_SCHEME) {ECC} TPMT_ECC_SCHEME Structure
/// </summary>
TpmStructureBase* TPMT_ECC_SCHEME::Clone() const
{
    TPMT_ECC_SCHEME* _x = new TPMT_ECC_SCHEME(*this);
    return _x;
};
void* TPMT_ECC_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&scheme);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(details); return (void*) (&details);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_ALGORITHM_DETAIL_ECC::GetTypeId() const
{
    return TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
};
/// <summary>
/// This structure is used to report on the curve parameters of an ECC curve. It is returned by TPM2_ECC_Parameters().
/// </summary>
TPMS_ALGORITHM_DETAIL_ECC::TPMS_ALGORITHM_DETAIL_ECC()
{
    kdf = NULL;
    sign = NULL;
    return;
};
TPMS_ALGORITHM_DETAIL_ECC::TPMS_ALGORITHM_DETAIL_ECC
(
    const TPM_ECC_CURVE& _curveID,
    const UINT16& _keySize,
    const TPMU_KDF_SCHEME& _kdf,
    const TPMU_ASYM_SCHEME& _sign,
    const std::vector<BYTE>& _p,
    const std::vector<BYTE>& _a,
    const std::vector<BYTE>& _b,
    const std::vector<BYTE>& _gX,
    const std::vector<BYTE>& _gY,
    const std::vector<BYTE>& _n,
    const std::vector<BYTE>& _h
)
{
    curveID= _curveID;
    keySize= _keySize;
    kdf = dynamic_cast<TPMU_KDF_SCHEME*> (_kdf.Clone());
    sign = dynamic_cast<TPMU_ASYM_SCHEME*> (_sign.Clone());
    p= _p;
    a= _a;
    b= _b;
    gX= _gX;
    gY= _gY;
    n= _n;
    h= _h;
};
/// <summary>
/// This structure is used to report on the curve parameters of an ECC curve. It is returned by TPM2_ECC_Parameters().
/// </summary>
TPMS_ALGORITHM_DETAIL_ECC::~TPMS_ALGORITHM_DETAIL_ECC()
{
    if(kdf != NULL) { delete kdf;kdf=NULL; }
    if(sign != NULL) { delete sign;sign=NULL; }
    return;
};
/// <summary>
/// This structure is used to report on the curve parameters of an ECC curve. It is returned by TPM2_ECC_Parameters().
/// </summary>
TPMS_ALGORITHM_DETAIL_ECC& TPMS_ALGORITHM_DETAIL_ECC::operator=(const TPMS_ALGORITHM_DETAIL_ECC& rhs)
{
    if(this == &rhs) return *this;
    this->curveID = rhs.curveID;
    this->keySize = rhs.keySize;
    this->kdfScheme = rhs.kdfScheme;
    if(kdf != NULL) delete kdf;
    if(rhs.kdf != NULL)kdf = dynamic_cast<TPMU_KDF_SCHEME*>(rhs.kdf->Clone());
    this->signScheme = rhs.signScheme;
    if(sign != NULL) delete sign;
    if(rhs.sign != NULL)sign = dynamic_cast<TPMU_ASYM_SCHEME*>(rhs.sign->Clone());
    this->pSize = rhs.pSize;
    this->p = rhs.p;
    this->aSize = rhs.aSize;
    this->a = rhs.a;
    this->bSize = rhs.bSize;
    this->b = rhs.b;
    this->gXSize = rhs.gXSize;
    this->gX = rhs.gX;
    this->gYSize = rhs.gYSize;
    this->gY = rhs.gY;
    this->nSize = rhs.nSize;
    this->n = rhs.n;
    this->hSize = rhs.hSize;
    this->h = rhs.h;
    return *this;
};
/// <summary>
/// This structure is used to report on the curve parameters of an ECC curve. It is returned by TPM2_ECC_Parameters().
/// </summary>
TPMS_ALGORITHM_DETAIL_ECC::TPMS_ALGORITHM_DETAIL_ECC(const TPMS_ALGORITHM_DETAIL_ECC& r)
{
    this->curveID = r.curveID;
    this->keySize = r.keySize;
    this->kdfScheme = r.kdfScheme;
    if(r.kdf != NULL)kdf = dynamic_cast<TPMU_KDF_SCHEME*>(r.kdf->Clone());
    this->signScheme = r.signScheme;
    if(r.sign != NULL)sign = dynamic_cast<TPMU_ASYM_SCHEME*>(r.sign->Clone());
    this->pSize = r.pSize;
    this->p = r.p;
    this->aSize = r.aSize;
    this->a = r.a;
    this->bSize = r.bSize;
    this->b = r.b;
    this->gXSize = r.gXSize;
    this->gX = r.gX;
    this->gYSize = r.gYSize;
    this->gY = r.gY;
    this->nSize = r.nSize;
    this->n = r.n;
    this->hSize = r.hSize;
    this->h = r.h;
};
/// <summary>
/// This structure is used to report on the curve parameters of an ECC curve. It is returned by TPM2_ECC_Parameters().
/// </summary>
TpmStructureBase* TPMS_ALGORITHM_DETAIL_ECC::Clone() const
{
    TPMS_ALGORITHM_DETAIL_ECC* _x = new TPMS_ALGORITHM_DETAIL_ECC(*this);
    return _x;
};
void* TPMS_ALGORITHM_DETAIL_ECC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&curveID);
            case 1: return (void*) (&keySize);
            case 2: return (void*) (&kdfScheme);
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(kdf); return (void*) (&kdf);
            case 4: return (void*) (&signScheme);
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(sign); return (void*) (&sign);
            case 6: return (void*) (&pSize);
            case 7: { if(newArraySize != -1)p.resize(newArraySize); arraySize = (int)p.size(); return (void*)(&p); }
            case 8: return (void*) (&aSize);
            case 9: { if(newArraySize != -1)a.resize(newArraySize); arraySize = (int)a.size(); return (void*)(&a); }
            case 10: return (void*) (&bSize);
            case 11: { if(newArraySize != -1)b.resize(newArraySize); arraySize = (int)b.size(); return (void*)(&b); }
            case 12: return (void*) (&gXSize);
            case 13: { if(newArraySize != -1)gX.resize(newArraySize); arraySize = (int)gX.size(); return (void*)(&gX); }
            case 14: return (void*) (&gYSize);
            case 15: { if(newArraySize != -1)gY.resize(newArraySize); arraySize = (int)gY.size(); return (void*)(&gY); }
            case 16: return (void*) (&nSize);
            case 17: { if(newArraySize != -1)n.resize(newArraySize); arraySize = (int)n.size(); return (void*)(&n); }
            case 18: return (void*) (&hSize);
            case 19: { if(newArraySize != -1)h.resize(newArraySize); arraySize = (int)h.size(); return (void*)(&h); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 7: return (void*)(&p[arrayIndex]);
            case 9: return (void*)(&a[arrayIndex]);
            case 11: return (void*)(&b[arrayIndex]);
            case 13: return (void*)(&gX[arrayIndex]);
            case 15: return (void*)(&gY[arrayIndex]);
            case 17: return (void*)(&n[arrayIndex]);
            case 19: return (void*)(&h[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_SIGNATURE_RSA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_RSA_ID;
};
/// <summary>
/// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
/// </summary>
TPMS_SIGNATURE_RSA::TPMS_SIGNATURE_RSA()
{
    return;
};
TPMS_SIGNATURE_RSA::TPMS_SIGNATURE_RSA
(
    const TPM_ALG_ID& _hash,
    const std::vector<BYTE>& _sig
)
{
    hash= _hash;
    sig= _sig;
};
/// <summary>
/// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
/// </summary>
TPMS_SIGNATURE_RSA::~TPMS_SIGNATURE_RSA()
{
    return;
};
/// <summary>
/// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
/// </summary>
TPMS_SIGNATURE_RSA& TPMS_SIGNATURE_RSA::operator=(const TPMS_SIGNATURE_RSA& rhs)
{
    if(this == &rhs) return *this;
    this->hash = rhs.hash;
    this->sigSize = rhs.sigSize;
    this->sig = rhs.sig;
    return *this;
};
/// <summary>
/// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
/// </summary>
TPMS_SIGNATURE_RSA::TPMS_SIGNATURE_RSA(const TPMS_SIGNATURE_RSA& r)
{
    this->hash = r.hash;
    this->sigSize = r.sigSize;
    this->sig = r.sig;
};
/// <summary>
/// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
/// </summary>
TpmStructureBase* TPMS_SIGNATURE_RSA::Clone() const
{
    TPMS_SIGNATURE_RSA* _x = new TPMS_SIGNATURE_RSA(*this);
    return _x;
};
void* TPMS_SIGNATURE_RSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hash);
            case 1: return (void*) (&sigSize);
            case 2: { if(newArraySize != -1)sig.resize(newArraySize); arraySize = (int)sig.size(); return (void*)(&sig); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&sig[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_SIGNATURE_RSASSA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_RSASSA_ID;
};
/// <summary>
/// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
/// </summary>
TPMS_SIGNATURE_RSASSA::TPMS_SIGNATURE_RSASSA()
{
    return;
};
TPMS_SIGNATURE_RSASSA::TPMS_SIGNATURE_RSASSA
(
    const TPM_ALG_ID& _hash,
    const std::vector<BYTE>& _sig
)
{
    hash= _hash;
    sig= _sig;
};
/// <summary>
/// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
/// </summary>
TPMS_SIGNATURE_RSASSA::~TPMS_SIGNATURE_RSASSA()
{
    return;
};
/// <summary>
/// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
/// </summary>
TPMS_SIGNATURE_RSASSA& TPMS_SIGNATURE_RSASSA::operator=(const TPMS_SIGNATURE_RSASSA& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SIGNATURE_RSA&)*this = (TPMS_SIGNATURE_RSA)rhs;
    return *this;
};
/// <summary>
/// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
/// </summary>
TPMS_SIGNATURE_RSASSA::TPMS_SIGNATURE_RSASSA(const TPMS_SIGNATURE_RSASSA& r)
  : TPMS_SIGNATURE_RSA(r)
{
};
/// <summary>
/// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
/// </summary>
TpmStructureBase* TPMS_SIGNATURE_RSASSA::Clone() const
{
    TPMS_SIGNATURE_RSASSA* _x = new TPMS_SIGNATURE_RSASSA(*this);
    return _x;
};
void* TPMS_SIGNATURE_RSASSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hash);
            case 1: return (void*) (&sigSize);
            case 2: { if(newArraySize != -1)sig.resize(newArraySize); arraySize = (int)sig.size(); return (void*)(&sig); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&sig[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_SIGNATURE_RSAPSS::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID;
};
/// <summary>
/// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
/// </summary>
TPMS_SIGNATURE_RSAPSS::TPMS_SIGNATURE_RSAPSS()
{
    return;
};
TPMS_SIGNATURE_RSAPSS::TPMS_SIGNATURE_RSAPSS
(
    const TPM_ALG_ID& _hash,
    const std::vector<BYTE>& _sig
)
{
    hash= _hash;
    sig= _sig;
};
/// <summary>
/// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
/// </summary>
TPMS_SIGNATURE_RSAPSS::~TPMS_SIGNATURE_RSAPSS()
{
    return;
};
/// <summary>
/// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
/// </summary>
TPMS_SIGNATURE_RSAPSS& TPMS_SIGNATURE_RSAPSS::operator=(const TPMS_SIGNATURE_RSAPSS& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SIGNATURE_RSA&)*this = (TPMS_SIGNATURE_RSA)rhs;
    return *this;
};
/// <summary>
/// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
/// </summary>
TPMS_SIGNATURE_RSAPSS::TPMS_SIGNATURE_RSAPSS(const TPMS_SIGNATURE_RSAPSS& r)
  : TPMS_SIGNATURE_RSA(r)
{
};
/// <summary>
/// Table 180  Definition of {RSA} TPMS_SIGNATURE_RSA Structure
/// </summary>
TpmStructureBase* TPMS_SIGNATURE_RSAPSS::Clone() const
{
    TPMS_SIGNATURE_RSAPSS* _x = new TPMS_SIGNATURE_RSAPSS(*this);
    return _x;
};
void* TPMS_SIGNATURE_RSAPSS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hash);
            case 1: return (void*) (&sigSize);
            case 2: { if(newArraySize != -1)sig.resize(newArraySize); arraySize = (int)sig.size(); return (void*)(&sig); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&sig[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_SIGNATURE_ECC::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_ECC_ID;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_ECC::TPMS_SIGNATURE_ECC()
{
    return;
};
TPMS_SIGNATURE_ECC::TPMS_SIGNATURE_ECC
(
    const TPM_ALG_ID& _hash,
    const std::vector<BYTE>& _signatureR,
    const std::vector<BYTE>& _signatureS
)
{
    hash= _hash;
    signatureR= _signatureR;
    signatureS= _signatureS;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_ECC::~TPMS_SIGNATURE_ECC()
{
    return;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_ECC& TPMS_SIGNATURE_ECC::operator=(const TPMS_SIGNATURE_ECC& rhs)
{
    if(this == &rhs) return *this;
    this->hash = rhs.hash;
    this->signatureRSize = rhs.signatureRSize;
    this->signatureR = rhs.signatureR;
    this->signatureSSize = rhs.signatureSSize;
    this->signatureS = rhs.signatureS;
    return *this;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_ECC::TPMS_SIGNATURE_ECC(const TPMS_SIGNATURE_ECC& r)
{
    this->hash = r.hash;
    this->signatureRSize = r.signatureRSize;
    this->signatureR = r.signatureR;
    this->signatureSSize = r.signatureSSize;
    this->signatureS = r.signatureS;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TpmStructureBase* TPMS_SIGNATURE_ECC::Clone() const
{
    TPMS_SIGNATURE_ECC* _x = new TPMS_SIGNATURE_ECC(*this);
    return _x;
};
void* TPMS_SIGNATURE_ECC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hash);
            case 1: return (void*) (&signatureRSize);
            case 2: { if(newArraySize != -1)signatureR.resize(newArraySize); arraySize = (int)signatureR.size(); return (void*)(&signatureR); }
            case 3: return (void*) (&signatureSSize);
            case 4: { if(newArraySize != -1)signatureS.resize(newArraySize); arraySize = (int)signatureS.size(); return (void*)(&signatureS); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&signatureR[arrayIndex]);
            case 4: return (void*)(&signatureS[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_SIGNATURE_ECDSA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_ECDSA::TPMS_SIGNATURE_ECDSA()
{
    return;
};
TPMS_SIGNATURE_ECDSA::TPMS_SIGNATURE_ECDSA
(
    const TPM_ALG_ID& _hash,
    const std::vector<BYTE>& _signatureR,
    const std::vector<BYTE>& _signatureS
)
{
    hash= _hash;
    signatureR= _signatureR;
    signatureS= _signatureS;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_ECDSA::~TPMS_SIGNATURE_ECDSA()
{
    return;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_ECDSA& TPMS_SIGNATURE_ECDSA::operator=(const TPMS_SIGNATURE_ECDSA& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SIGNATURE_ECC&)*this = (TPMS_SIGNATURE_ECC)rhs;
    return *this;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_ECDSA::TPMS_SIGNATURE_ECDSA(const TPMS_SIGNATURE_ECDSA& r)
  : TPMS_SIGNATURE_ECC(r)
{
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TpmStructureBase* TPMS_SIGNATURE_ECDSA::Clone() const
{
    TPMS_SIGNATURE_ECDSA* _x = new TPMS_SIGNATURE_ECDSA(*this);
    return _x;
};
void* TPMS_SIGNATURE_ECDSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hash);
            case 1: return (void*) (&signatureRSize);
            case 2: { if(newArraySize != -1)signatureR.resize(newArraySize); arraySize = (int)signatureR.size(); return (void*)(&signatureR); }
            case 3: return (void*) (&signatureSSize);
            case 4: { if(newArraySize != -1)signatureS.resize(newArraySize); arraySize = (int)signatureS.size(); return (void*)(&signatureS); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&signatureR[arrayIndex]);
            case 4: return (void*)(&signatureS[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_SIGNATURE_ECDAA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_ECDAA::TPMS_SIGNATURE_ECDAA()
{
    return;
};
TPMS_SIGNATURE_ECDAA::TPMS_SIGNATURE_ECDAA
(
    const TPM_ALG_ID& _hash,
    const std::vector<BYTE>& _signatureR,
    const std::vector<BYTE>& _signatureS
)
{
    hash= _hash;
    signatureR= _signatureR;
    signatureS= _signatureS;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_ECDAA::~TPMS_SIGNATURE_ECDAA()
{
    return;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_ECDAA& TPMS_SIGNATURE_ECDAA::operator=(const TPMS_SIGNATURE_ECDAA& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SIGNATURE_ECC&)*this = (TPMS_SIGNATURE_ECC)rhs;
    return *this;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_ECDAA::TPMS_SIGNATURE_ECDAA(const TPMS_SIGNATURE_ECDAA& r)
  : TPMS_SIGNATURE_ECC(r)
{
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TpmStructureBase* TPMS_SIGNATURE_ECDAA::Clone() const
{
    TPMS_SIGNATURE_ECDAA* _x = new TPMS_SIGNATURE_ECDAA(*this);
    return _x;
};
void* TPMS_SIGNATURE_ECDAA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hash);
            case 1: return (void*) (&signatureRSize);
            case 2: { if(newArraySize != -1)signatureR.resize(newArraySize); arraySize = (int)signatureR.size(); return (void*)(&signatureR); }
            case 3: return (void*) (&signatureSSize);
            case 4: { if(newArraySize != -1)signatureS.resize(newArraySize); arraySize = (int)signatureS.size(); return (void*)(&signatureS); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&signatureR[arrayIndex]);
            case 4: return (void*)(&signatureS[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_SIGNATURE_SM2::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_SM2_ID;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_SM2::TPMS_SIGNATURE_SM2()
{
    return;
};
TPMS_SIGNATURE_SM2::TPMS_SIGNATURE_SM2
(
    const TPM_ALG_ID& _hash,
    const std::vector<BYTE>& _signatureR,
    const std::vector<BYTE>& _signatureS
)
{
    hash= _hash;
    signatureR= _signatureR;
    signatureS= _signatureS;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_SM2::~TPMS_SIGNATURE_SM2()
{
    return;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_SM2& TPMS_SIGNATURE_SM2::operator=(const TPMS_SIGNATURE_SM2& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SIGNATURE_ECC&)*this = (TPMS_SIGNATURE_ECC)rhs;
    return *this;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_SM2::TPMS_SIGNATURE_SM2(const TPMS_SIGNATURE_SM2& r)
  : TPMS_SIGNATURE_ECC(r)
{
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TpmStructureBase* TPMS_SIGNATURE_SM2::Clone() const
{
    TPMS_SIGNATURE_SM2* _x = new TPMS_SIGNATURE_SM2(*this);
    return _x;
};
void* TPMS_SIGNATURE_SM2::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hash);
            case 1: return (void*) (&signatureRSize);
            case 2: { if(newArraySize != -1)signatureR.resize(newArraySize); arraySize = (int)signatureR.size(); return (void*)(&signatureR); }
            case 3: return (void*) (&signatureSSize);
            case 4: { if(newArraySize != -1)signatureS.resize(newArraySize); arraySize = (int)signatureS.size(); return (void*)(&signatureS); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&signatureR[arrayIndex]);
            case 4: return (void*)(&signatureS[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_SIGNATURE_ECSCHNORR::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_ECSCHNORR::TPMS_SIGNATURE_ECSCHNORR()
{
    return;
};
TPMS_SIGNATURE_ECSCHNORR::TPMS_SIGNATURE_ECSCHNORR
(
    const TPM_ALG_ID& _hash,
    const std::vector<BYTE>& _signatureR,
    const std::vector<BYTE>& _signatureS
)
{
    hash= _hash;
    signatureR= _signatureR;
    signatureS= _signatureS;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_ECSCHNORR::~TPMS_SIGNATURE_ECSCHNORR()
{
    return;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_ECSCHNORR& TPMS_SIGNATURE_ECSCHNORR::operator=(const TPMS_SIGNATURE_ECSCHNORR& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_SIGNATURE_ECC&)*this = (TPMS_SIGNATURE_ECC)rhs;
    return *this;
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TPMS_SIGNATURE_ECSCHNORR::TPMS_SIGNATURE_ECSCHNORR(const TPMS_SIGNATURE_ECSCHNORR& r)
  : TPMS_SIGNATURE_ECC(r)
{
};
/// <summary>
/// Table 182  Definition of {ECC} TPMS_SIGNATURE_ECC Structure
/// </summary>
TpmStructureBase* TPMS_SIGNATURE_ECSCHNORR::Clone() const
{
    TPMS_SIGNATURE_ECSCHNORR* _x = new TPMS_SIGNATURE_ECSCHNORR(*this);
    return _x;
};
void* TPMS_SIGNATURE_ECSCHNORR::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&hash);
            case 1: return (void*) (&signatureRSize);
            case 2: { if(newArraySize != -1)signatureR.resize(newArraySize); arraySize = (int)signatureR.size(); return (void*)(&signatureR); }
            case 3: return (void*) (&signatureSSize);
            case 4: { if(newArraySize != -1)signatureS.resize(newArraySize); arraySize = (int)signatureS.size(); return (void*)(&signatureS); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&signatureR[arrayIndex]);
            case 4: return (void*)(&signatureS[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_NULL_SIGNATURE::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_SIGNATURE_ID;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSignature
/// </summary>
TPMS_NULL_SIGNATURE::TPMS_NULL_SIGNATURE()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSignature
/// </summary>
TPMS_NULL_SIGNATURE::~TPMS_NULL_SIGNATURE()
{
    return;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSignature
/// </summary>
TPMS_NULL_SIGNATURE& TPMS_NULL_SIGNATURE::operator=(const TPMS_NULL_SIGNATURE& rhs)
{
    if(this == &rhs) return *this;
    (TPMS_NULL_UNION&)*this = (TPMS_NULL_UNION)rhs;
    return *this;
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSignature
/// </summary>
TPMS_NULL_SIGNATURE::TPMS_NULL_SIGNATURE(const TPMS_NULL_SIGNATURE& r)
  : TPMS_NULL_UNION(r)
{
};
/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSignature
/// </summary>
TpmStructureBase* TPMS_NULL_SIGNATURE::Clone() const
{
    TPMS_NULL_SIGNATURE* _x = new TPMS_NULL_SIGNATURE(*this);
    return _x;
};
void* TPMS_NULL_SIGNATURE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPMT_SIGNATURE::GetTypeId() const
{
    return TpmTypeId::TPMT_SIGNATURE_ID;
};
/// <summary>
/// Table 185 shows the basic algorithm-agile structure when a symmetric or asymmetric signature is indicated. The sigAlg parameter indicates the algorithm used for the signature. This structure is output from commands such as the attestation commands and TPM2_Sign, and is an input to commands such as TPM2_VerifySignature(), TPM2_PolicySigned(), and TPM2_FieldUpgradeStart().
/// </summary>
TPMT_SIGNATURE::TPMT_SIGNATURE()
{
    signature = NULL;
    return;
};
TPMT_SIGNATURE::TPMT_SIGNATURE
(
    const TPMU_SIGNATURE& _signature
)
{
    signature = dynamic_cast<TPMU_SIGNATURE*> (_signature.Clone());
};
/// <summary>
/// Table 185 shows the basic algorithm-agile structure when a symmetric or asymmetric signature is indicated. The sigAlg parameter indicates the algorithm used for the signature. This structure is output from commands such as the attestation commands and TPM2_Sign, and is an input to commands such as TPM2_VerifySignature(), TPM2_PolicySigned(), and TPM2_FieldUpgradeStart().
/// </summary>
TPMT_SIGNATURE::~TPMT_SIGNATURE()
{
    if(signature != NULL) { delete signature;signature=NULL; }
    return;
};
/// <summary>
/// Table 185 shows the basic algorithm-agile structure when a symmetric or asymmetric signature is indicated. The sigAlg parameter indicates the algorithm used for the signature. This structure is output from commands such as the attestation commands and TPM2_Sign, and is an input to commands such as TPM2_VerifySignature(), TPM2_PolicySigned(), and TPM2_FieldUpgradeStart().
/// </summary>
TPMT_SIGNATURE& TPMT_SIGNATURE::operator=(const TPMT_SIGNATURE& rhs)
{
    if(this == &rhs) return *this;
    this->sigAlg = rhs.sigAlg;
    if(signature != NULL) delete signature;
    if(rhs.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(rhs.signature->Clone());
    return *this;
};
/// <summary>
/// Table 185 shows the basic algorithm-agile structure when a symmetric or asymmetric signature is indicated. The sigAlg parameter indicates the algorithm used for the signature. This structure is output from commands such as the attestation commands and TPM2_Sign, and is an input to commands such as TPM2_VerifySignature(), TPM2_PolicySigned(), and TPM2_FieldUpgradeStart().
/// </summary>
TPMT_SIGNATURE::TPMT_SIGNATURE(const TPMT_SIGNATURE& r)
{
    this->sigAlg = r.sigAlg;
    if(r.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(r.signature->Clone());
};
/// <summary>
/// Table 185 shows the basic algorithm-agile structure when a symmetric or asymmetric signature is indicated. The sigAlg parameter indicates the algorithm used for the signature. This structure is output from commands such as the attestation commands and TPM2_Sign, and is an input to commands such as TPM2_VerifySignature(), TPM2_PolicySigned(), and TPM2_FieldUpgradeStart().
/// </summary>
TpmStructureBase* TPMT_SIGNATURE::Clone() const
{
    TPMT_SIGNATURE* _x = new TPMT_SIGNATURE(*this);
    return _x;
};
void* TPMT_SIGNATURE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&sigAlg);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(signature); return (void*) (&signature);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2B_ENCRYPTED_SECRET::GetTypeId() const
{
    return TpmTypeId::TPM2B_ENCRYPTED_SECRET_ID;
};
/// <summary>
/// Table 187  Definition of TPM2B_ENCRYPTED_SECRET Structure
/// </summary>
TPM2B_ENCRYPTED_SECRET::TPM2B_ENCRYPTED_SECRET()
{
    return;
};
TPM2B_ENCRYPTED_SECRET::TPM2B_ENCRYPTED_SECRET
(
    const std::vector<BYTE>& _secret
)
{
    secret= _secret;
};
/// <summary>
/// Table 187  Definition of TPM2B_ENCRYPTED_SECRET Structure
/// </summary>
TPM2B_ENCRYPTED_SECRET::~TPM2B_ENCRYPTED_SECRET()
{
    return;
};
/// <summary>
/// Table 187  Definition of TPM2B_ENCRYPTED_SECRET Structure
/// </summary>
TPM2B_ENCRYPTED_SECRET& TPM2B_ENCRYPTED_SECRET::operator=(const TPM2B_ENCRYPTED_SECRET& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->secret = rhs.secret;
    return *this;
};
/// <summary>
/// Table 187  Definition of TPM2B_ENCRYPTED_SECRET Structure
/// </summary>
TPM2B_ENCRYPTED_SECRET::TPM2B_ENCRYPTED_SECRET(const TPM2B_ENCRYPTED_SECRET& r)
{
    this->size = r.size;
    this->secret = r.secret;
};
/// <summary>
/// Table 187  Definition of TPM2B_ENCRYPTED_SECRET Structure
/// </summary>
TpmStructureBase* TPM2B_ENCRYPTED_SECRET::Clone() const
{
    TPM2B_ENCRYPTED_SECRET* _x = new TPM2B_ENCRYPTED_SECRET(*this);
    return _x;
};
void* TPM2B_ENCRYPTED_SECRET::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)secret.resize(newArraySize); arraySize = (int)secret.size(); return (void*)(&secret); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&secret[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_KEYEDHASH_PARMS::GetTypeId() const
{
    return TpmTypeId::TPMS_KEYEDHASH_PARMS_ID;
};
/// <summary>
/// This structure describes the parameters that would appear in the public area of a KEYEDHASH object.
/// </summary>
TPMS_KEYEDHASH_PARMS::TPMS_KEYEDHASH_PARMS()
{
    scheme = NULL;
    return;
};
TPMS_KEYEDHASH_PARMS::TPMS_KEYEDHASH_PARMS
(
    const TPMU_SCHEME_KEYEDHASH& _scheme
)
{
    scheme = dynamic_cast<TPMU_SCHEME_KEYEDHASH*> (_scheme.Clone());
};
/// <summary>
/// This structure describes the parameters that would appear in the public area of a KEYEDHASH object.
/// </summary>
TPMS_KEYEDHASH_PARMS::~TPMS_KEYEDHASH_PARMS()
{
    if(scheme != NULL) { delete scheme;scheme=NULL; }
    return;
};
/// <summary>
/// This structure describes the parameters that would appear in the public area of a KEYEDHASH object.
/// </summary>
TPMS_KEYEDHASH_PARMS& TPMS_KEYEDHASH_PARMS::operator=(const TPMS_KEYEDHASH_PARMS& rhs)
{
    if(this == &rhs) return *this;
    this->schemeScheme = rhs.schemeScheme;
    if(scheme != NULL) delete scheme;
    if(rhs.scheme != NULL)scheme = dynamic_cast<TPMU_SCHEME_KEYEDHASH*>(rhs.scheme->Clone());
    return *this;
};
/// <summary>
/// This structure describes the parameters that would appear in the public area of a KEYEDHASH object.
/// </summary>
TPMS_KEYEDHASH_PARMS::TPMS_KEYEDHASH_PARMS(const TPMS_KEYEDHASH_PARMS& r)
{
    this->schemeScheme = r.schemeScheme;
    if(r.scheme != NULL)scheme = dynamic_cast<TPMU_SCHEME_KEYEDHASH*>(r.scheme->Clone());
};
/// <summary>
/// This structure describes the parameters that would appear in the public area of a KEYEDHASH object.
/// </summary>
TpmStructureBase* TPMS_KEYEDHASH_PARMS::Clone() const
{
    TPMS_KEYEDHASH_PARMS* _x = new TPMS_KEYEDHASH_PARMS(*this);
    return _x;
};
void* TPMS_KEYEDHASH_PARMS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&schemeScheme);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(scheme); return (void*) (&scheme);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_ASYM_PARMS::GetTypeId() const
{
    return TpmTypeId::TPMS_ASYM_PARMS_ID;
};
/// <summary>
/// This structure contains the common public area parameters for an asymmetric key. The first two parameters of the parameter definition structures of an asymmetric key shall have the same two first components.
/// </summary>
TPMS_ASYM_PARMS::TPMS_ASYM_PARMS()
{
    scheme = NULL;
    return;
};
TPMS_ASYM_PARMS::TPMS_ASYM_PARMS
(
    const TPMT_SYM_DEF_OBJECT& _symmetric,
    const TPMU_ASYM_SCHEME& _scheme
)
{
    symmetric= _symmetric;
    scheme = dynamic_cast<TPMU_ASYM_SCHEME*> (_scheme.Clone());
};
/// <summary>
/// This structure contains the common public area parameters for an asymmetric key. The first two parameters of the parameter definition structures of an asymmetric key shall have the same two first components.
/// </summary>
TPMS_ASYM_PARMS::~TPMS_ASYM_PARMS()
{
    if(scheme != NULL) { delete scheme;scheme=NULL; }
    return;
};
/// <summary>
/// This structure contains the common public area parameters for an asymmetric key. The first two parameters of the parameter definition structures of an asymmetric key shall have the same two first components.
/// </summary>
TPMS_ASYM_PARMS& TPMS_ASYM_PARMS::operator=(const TPMS_ASYM_PARMS& rhs)
{
    if(this == &rhs) return *this;
    this->symmetric = rhs.symmetric;
    this->schemeScheme = rhs.schemeScheme;
    if(scheme != NULL) delete scheme;
    if(rhs.scheme != NULL)scheme = dynamic_cast<TPMU_ASYM_SCHEME*>(rhs.scheme->Clone());
    return *this;
};
/// <summary>
/// This structure contains the common public area parameters for an asymmetric key. The first two parameters of the parameter definition structures of an asymmetric key shall have the same two first components.
/// </summary>
TPMS_ASYM_PARMS::TPMS_ASYM_PARMS(const TPMS_ASYM_PARMS& r)
{
    this->symmetric = r.symmetric;
    this->schemeScheme = r.schemeScheme;
    if(r.scheme != NULL)scheme = dynamic_cast<TPMU_ASYM_SCHEME*>(r.scheme->Clone());
};
/// <summary>
/// This structure contains the common public area parameters for an asymmetric key. The first two parameters of the parameter definition structures of an asymmetric key shall have the same two first components.
/// </summary>
TpmStructureBase* TPMS_ASYM_PARMS::Clone() const
{
    TPMS_ASYM_PARMS* _x = new TPMS_ASYM_PARMS(*this);
    return _x;
};
void* TPMS_ASYM_PARMS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&symmetric); return (void*) (&symmetric);
            case 1: return (void*) (&schemeScheme);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(scheme); return (void*) (&scheme);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_RSA_PARMS::GetTypeId() const
{
    return TpmTypeId::TPMS_RSA_PARMS_ID;
};
/// <summary>
/// A TPM compatible with this specification and supporting RSA shall support two primes and an exponent of zero. An exponent of zero indicates that the exponent is the default of 216 + 1. Support for other values is optional. Use of other exponents in duplicated keys is not recommended because the resulting keys would not be interoperable with other TPMs.
/// </summary>
TPMS_RSA_PARMS::TPMS_RSA_PARMS()
{
    scheme = NULL;
    return;
};
TPMS_RSA_PARMS::TPMS_RSA_PARMS
(
    const TPMT_SYM_DEF_OBJECT& _symmetric,
    const TPMU_ASYM_SCHEME& _scheme,
    const UINT16& _keyBits,
    const UINT32& _exponent
)
{
    symmetric= _symmetric;
    scheme = dynamic_cast<TPMU_ASYM_SCHEME*> (_scheme.Clone());
    keyBits= _keyBits;
    exponent= _exponent;
};
/// <summary>
/// A TPM compatible with this specification and supporting RSA shall support two primes and an exponent of zero. An exponent of zero indicates that the exponent is the default of 216 + 1. Support for other values is optional. Use of other exponents in duplicated keys is not recommended because the resulting keys would not be interoperable with other TPMs.
/// </summary>
TPMS_RSA_PARMS::~TPMS_RSA_PARMS()
{
    if(scheme != NULL) { delete scheme;scheme=NULL; }
    return;
};
/// <summary>
/// A TPM compatible with this specification and supporting RSA shall support two primes and an exponent of zero. An exponent of zero indicates that the exponent is the default of 216 + 1. Support for other values is optional. Use of other exponents in duplicated keys is not recommended because the resulting keys would not be interoperable with other TPMs.
/// </summary>
TPMS_RSA_PARMS& TPMS_RSA_PARMS::operator=(const TPMS_RSA_PARMS& rhs)
{
    if(this == &rhs) return *this;
    this->symmetric = rhs.symmetric;
    this->schemeScheme = rhs.schemeScheme;
    if(scheme != NULL) delete scheme;
    if(rhs.scheme != NULL)scheme = dynamic_cast<TPMU_ASYM_SCHEME*>(rhs.scheme->Clone());
    this->keyBits = rhs.keyBits;
    this->exponent = rhs.exponent;
    return *this;
};
/// <summary>
/// A TPM compatible with this specification and supporting RSA shall support two primes and an exponent of zero. An exponent of zero indicates that the exponent is the default of 216 + 1. Support for other values is optional. Use of other exponents in duplicated keys is not recommended because the resulting keys would not be interoperable with other TPMs.
/// </summary>
TPMS_RSA_PARMS::TPMS_RSA_PARMS(const TPMS_RSA_PARMS& r)
{
    this->symmetric = r.symmetric;
    this->schemeScheme = r.schemeScheme;
    if(r.scheme != NULL)scheme = dynamic_cast<TPMU_ASYM_SCHEME*>(r.scheme->Clone());
    this->keyBits = r.keyBits;
    this->exponent = r.exponent;
};
/// <summary>
/// A TPM compatible with this specification and supporting RSA shall support two primes and an exponent of zero. An exponent of zero indicates that the exponent is the default of 216 + 1. Support for other values is optional. Use of other exponents in duplicated keys is not recommended because the resulting keys would not be interoperable with other TPMs.
/// </summary>
TpmStructureBase* TPMS_RSA_PARMS::Clone() const
{
    TPMS_RSA_PARMS* _x = new TPMS_RSA_PARMS(*this);
    return _x;
};
void* TPMS_RSA_PARMS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&symmetric); return (void*) (&symmetric);
            case 1: return (void*) (&schemeScheme);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(scheme); return (void*) (&scheme);
            case 3: return (void*) (&keyBits);
            case 4: return (void*) (&exponent);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_ECC_PARMS::GetTypeId() const
{
    return TpmTypeId::TPMS_ECC_PARMS_ID;
};
/// <summary>
/// This structure contains the parameters for prime modulus ECC.
/// </summary>
TPMS_ECC_PARMS::TPMS_ECC_PARMS()
{
    scheme = NULL;
    kdf = NULL;
    return;
};
TPMS_ECC_PARMS::TPMS_ECC_PARMS
(
    const TPMT_SYM_DEF_OBJECT& _symmetric,
    const TPMU_ASYM_SCHEME& _scheme,
    const TPM_ECC_CURVE& _curveID,
    const TPMU_KDF_SCHEME& _kdf
)
{
    symmetric= _symmetric;
    scheme = dynamic_cast<TPMU_ASYM_SCHEME*> (_scheme.Clone());
    curveID= _curveID;
    kdf = dynamic_cast<TPMU_KDF_SCHEME*> (_kdf.Clone());
};
/// <summary>
/// This structure contains the parameters for prime modulus ECC.
/// </summary>
TPMS_ECC_PARMS::~TPMS_ECC_PARMS()
{
    if(scheme != NULL) { delete scheme;scheme=NULL; }
    if(kdf != NULL) { delete kdf;kdf=NULL; }
    return;
};
/// <summary>
/// This structure contains the parameters for prime modulus ECC.
/// </summary>
TPMS_ECC_PARMS& TPMS_ECC_PARMS::operator=(const TPMS_ECC_PARMS& rhs)
{
    if(this == &rhs) return *this;
    this->symmetric = rhs.symmetric;
    this->schemeScheme = rhs.schemeScheme;
    if(scheme != NULL) delete scheme;
    if(rhs.scheme != NULL)scheme = dynamic_cast<TPMU_ASYM_SCHEME*>(rhs.scheme->Clone());
    this->curveID = rhs.curveID;
    this->kdfScheme = rhs.kdfScheme;
    if(kdf != NULL) delete kdf;
    if(rhs.kdf != NULL)kdf = dynamic_cast<TPMU_KDF_SCHEME*>(rhs.kdf->Clone());
    return *this;
};
/// <summary>
/// This structure contains the parameters for prime modulus ECC.
/// </summary>
TPMS_ECC_PARMS::TPMS_ECC_PARMS(const TPMS_ECC_PARMS& r)
{
    this->symmetric = r.symmetric;
    this->schemeScheme = r.schemeScheme;
    if(r.scheme != NULL)scheme = dynamic_cast<TPMU_ASYM_SCHEME*>(r.scheme->Clone());
    this->curveID = r.curveID;
    this->kdfScheme = r.kdfScheme;
    if(r.kdf != NULL)kdf = dynamic_cast<TPMU_KDF_SCHEME*>(r.kdf->Clone());
};
/// <summary>
/// This structure contains the parameters for prime modulus ECC.
/// </summary>
TpmStructureBase* TPMS_ECC_PARMS::Clone() const
{
    TPMS_ECC_PARMS* _x = new TPMS_ECC_PARMS(*this);
    return _x;
};
void* TPMS_ECC_PARMS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&symmetric); return (void*) (&symmetric);
            case 1: return (void*) (&schemeScheme);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(scheme); return (void*) (&scheme);
            case 3: return (void*) (&curveID);
            case 4: return (void*) (&kdfScheme);
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(kdf); return (void*) (&kdf);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMT_PUBLIC_PARMS::GetTypeId() const
{
    return TpmTypeId::TPMT_PUBLIC_PARMS_ID;
};
/// <summary>
/// This structure is used in TPM2_TestParms() to validate that a set of algorithm parameters is supported by the TPM.
/// </summary>
TPMT_PUBLIC_PARMS::TPMT_PUBLIC_PARMS()
{
    parameters = NULL;
    return;
};
TPMT_PUBLIC_PARMS::TPMT_PUBLIC_PARMS
(
    const TPMU_PUBLIC_PARMS& _parameters
)
{
    parameters = dynamic_cast<TPMU_PUBLIC_PARMS*> (_parameters.Clone());
};
/// <summary>
/// This structure is used in TPM2_TestParms() to validate that a set of algorithm parameters is supported by the TPM.
/// </summary>
TPMT_PUBLIC_PARMS::~TPMT_PUBLIC_PARMS()
{
    if(parameters != NULL) { delete parameters;parameters=NULL; }
    return;
};
/// <summary>
/// This structure is used in TPM2_TestParms() to validate that a set of algorithm parameters is supported by the TPM.
/// </summary>
TPMT_PUBLIC_PARMS& TPMT_PUBLIC_PARMS::operator=(const TPMT_PUBLIC_PARMS& rhs)
{
    if(this == &rhs) return *this;
    this->type = rhs.type;
    if(parameters != NULL) delete parameters;
    if(rhs.parameters != NULL)parameters = dynamic_cast<TPMU_PUBLIC_PARMS*>(rhs.parameters->Clone());
    return *this;
};
/// <summary>
/// This structure is used in TPM2_TestParms() to validate that a set of algorithm parameters is supported by the TPM.
/// </summary>
TPMT_PUBLIC_PARMS::TPMT_PUBLIC_PARMS(const TPMT_PUBLIC_PARMS& r)
{
    this->type = r.type;
    if(r.parameters != NULL)parameters = dynamic_cast<TPMU_PUBLIC_PARMS*>(r.parameters->Clone());
};
/// <summary>
/// This structure is used in TPM2_TestParms() to validate that a set of algorithm parameters is supported by the TPM.
/// </summary>
TpmStructureBase* TPMT_PUBLIC_PARMS::Clone() const
{
    TPMT_PUBLIC_PARMS* _x = new TPMT_PUBLIC_PARMS(*this);
    return _x;
};
void* TPMT_PUBLIC_PARMS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&type);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(parameters); return (void*) (&parameters);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMT_PUBLIC::GetTypeId() const
{
    return TpmTypeId::TPMT_PUBLIC_ID;
};
/// <summary>
/// Table 196 defines the public area structure. The Name of the object is nameAlg concatenated with the digest of this structure using nameAlg.
/// </summary>
TPMT_PUBLIC::TPMT_PUBLIC()
{
    parameters = NULL;
    unique = NULL;
    return;
};
TPMT_PUBLIC::TPMT_PUBLIC
(
    const TPM_ALG_ID& _nameAlg,
    const TPMA_OBJECT& _objectAttributes,
    const std::vector<BYTE>& _authPolicy,
    const TPMU_PUBLIC_PARMS& _parameters,
    const TPMU_PUBLIC_ID& _unique
)
{
    nameAlg= _nameAlg;
    objectAttributes= _objectAttributes;
    authPolicy= _authPolicy;
    parameters = dynamic_cast<TPMU_PUBLIC_PARMS*> (_parameters.Clone());
    unique = dynamic_cast<TPMU_PUBLIC_ID*> (_unique.Clone());
};
/// <summary>
/// Table 196 defines the public area structure. The Name of the object is nameAlg concatenated with the digest of this structure using nameAlg.
/// </summary>
TPMT_PUBLIC::~TPMT_PUBLIC()
{
    if(parameters != NULL) { delete parameters;parameters=NULL; }
    if(unique != NULL) { delete unique;unique=NULL; }
    return;
};
/// <summary>
/// Table 196 defines the public area structure. The Name of the object is nameAlg concatenated with the digest of this structure using nameAlg.
/// </summary>
TPMT_PUBLIC& TPMT_PUBLIC::operator=(const TPMT_PUBLIC& rhs)
{
    if(this == &rhs) return *this;
    this->type = rhs.type;
    this->nameAlg = rhs.nameAlg;
    this->objectAttributes = rhs.objectAttributes;
    this->authPolicySize = rhs.authPolicySize;
    this->authPolicy = rhs.authPolicy;
    if(parameters != NULL) delete parameters;
    if(rhs.parameters != NULL)parameters = dynamic_cast<TPMU_PUBLIC_PARMS*>(rhs.parameters->Clone());
    if(unique != NULL) delete unique;
    if(rhs.unique != NULL)unique = dynamic_cast<TPMU_PUBLIC_ID*>(rhs.unique->Clone());
    TPMT_PUBLIC_CUSTOM_CLONE(this, rhs)
    return *this;
};
/// <summary>
/// Table 196 defines the public area structure. The Name of the object is nameAlg concatenated with the digest of this structure using nameAlg.
/// </summary>
TPMT_PUBLIC::TPMT_PUBLIC(const TPMT_PUBLIC& r)
{
    this->type = r.type;
    this->nameAlg = r.nameAlg;
    this->objectAttributes = r.objectAttributes;
    this->authPolicySize = r.authPolicySize;
    this->authPolicy = r.authPolicy;
    if(r.parameters != NULL)parameters = dynamic_cast<TPMU_PUBLIC_PARMS*>(r.parameters->Clone());
    if(r.unique != NULL)unique = dynamic_cast<TPMU_PUBLIC_ID*>(r.unique->Clone());
    TPMT_PUBLIC_CUSTOM_CLONE(this, r)
};
/// <summary>
/// Table 196 defines the public area structure. The Name of the object is nameAlg concatenated with the digest of this structure using nameAlg.
/// </summary>
TpmStructureBase* TPMT_PUBLIC::Clone() const
{
    TPMT_PUBLIC* _x = new TPMT_PUBLIC(*this);
    return _x;
};
void* TPMT_PUBLIC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&type);
            case 1: return (void*) (&nameAlg);
            case 2: return (void*) (&objectAttributes);
            case 3: return (void*) (&authPolicySize);
            case 4: { if(newArraySize != -1)authPolicy.resize(newArraySize); arraySize = (int)authPolicy.size(); return (void*)(&authPolicy); }
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(parameters); return (void*) (&parameters);
            case 6: pStruct = dynamic_cast<TpmStructureBase*>(unique); return (void*) (&unique);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 4: return (void*)(&authPolicy[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_PUBLIC::GetTypeId() const
{
    return TpmTypeId::TPM2B_PUBLIC_ID;
};
/// <summary>
/// This sized buffer is used to embed a TPMT_PUBLIC in a load command and in any response that returns a public area.
/// </summary>
TPM2B_PUBLIC::TPM2B_PUBLIC()
{
    return;
};
TPM2B_PUBLIC::TPM2B_PUBLIC
(
    const TPMT_PUBLIC& _publicArea
)
{
    publicArea= _publicArea;
};
/// <summary>
/// This sized buffer is used to embed a TPMT_PUBLIC in a load command and in any response that returns a public area.
/// </summary>
TPM2B_PUBLIC::~TPM2B_PUBLIC()
{
    return;
};
/// <summary>
/// This sized buffer is used to embed a TPMT_PUBLIC in a load command and in any response that returns a public area.
/// </summary>
TPM2B_PUBLIC& TPM2B_PUBLIC::operator=(const TPM2B_PUBLIC& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->publicArea = rhs.publicArea;
    return *this;
};
/// <summary>
/// This sized buffer is used to embed a TPMT_PUBLIC in a load command and in any response that returns a public area.
/// </summary>
TPM2B_PUBLIC::TPM2B_PUBLIC(const TPM2B_PUBLIC& r)
{
    this->size = r.size;
    this->publicArea = r.publicArea;
};
/// <summary>
/// This sized buffer is used to embed a TPMT_PUBLIC in a load command and in any response that returns a public area.
/// </summary>
TpmStructureBase* TPM2B_PUBLIC::Clone() const
{
    TPM2B_PUBLIC* _x = new TPM2B_PUBLIC(*this);
    return _x;
};
void* TPM2B_PUBLIC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&publicArea); return (void*) (&publicArea);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2B_TEMPLATE::GetTypeId() const
{
    return TpmTypeId::TPM2B_TEMPLATE_ID;
};
/// <summary>
/// This sized buffer is used to embed a TPMT_TEMPLATE for TPM2_CreateLoaded().
/// </summary>
TPM2B_TEMPLATE::TPM2B_TEMPLATE()
{
    return;
};
TPM2B_TEMPLATE::TPM2B_TEMPLATE
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// This sized buffer is used to embed a TPMT_TEMPLATE for TPM2_CreateLoaded().
/// </summary>
TPM2B_TEMPLATE::~TPM2B_TEMPLATE()
{
    return;
};
/// <summary>
/// This sized buffer is used to embed a TPMT_TEMPLATE for TPM2_CreateLoaded().
/// </summary>
TPM2B_TEMPLATE& TPM2B_TEMPLATE::operator=(const TPM2B_TEMPLATE& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This sized buffer is used to embed a TPMT_TEMPLATE for TPM2_CreateLoaded().
/// </summary>
TPM2B_TEMPLATE::TPM2B_TEMPLATE(const TPM2B_TEMPLATE& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// This sized buffer is used to embed a TPMT_TEMPLATE for TPM2_CreateLoaded().
/// </summary>
TpmStructureBase* TPM2B_TEMPLATE::Clone() const
{
    TPM2B_TEMPLATE* _x = new TPM2B_TEMPLATE(*this);
    return _x;
};
void* TPM2B_TEMPLATE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_PRIVATE_VENDOR_SPECIFIC::GetTypeId() const
{
    return TpmTypeId::TPM2B_PRIVATE_VENDOR_SPECIFIC_ID;
};
/// <summary>
/// This structure is defined for coding purposes. For IO to the TPM, the sensitive portion of the key will be in a canonical form. For an RSA key, this will be one of the prime factors of the public modulus. After loading, it is typical that other values will be computed so that computations using the private key will not need to start with just one prime factor. This structure can be used to store the results of such vendor-specific calculations.
/// </summary>
TPM2B_PRIVATE_VENDOR_SPECIFIC::TPM2B_PRIVATE_VENDOR_SPECIFIC()
{
    return;
};
TPM2B_PRIVATE_VENDOR_SPECIFIC::TPM2B_PRIVATE_VENDOR_SPECIFIC
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// This structure is defined for coding purposes. For IO to the TPM, the sensitive portion of the key will be in a canonical form. For an RSA key, this will be one of the prime factors of the public modulus. After loading, it is typical that other values will be computed so that computations using the private key will not need to start with just one prime factor. This structure can be used to store the results of such vendor-specific calculations.
/// </summary>
TPM2B_PRIVATE_VENDOR_SPECIFIC::~TPM2B_PRIVATE_VENDOR_SPECIFIC()
{
    return;
};
/// <summary>
/// This structure is defined for coding purposes. For IO to the TPM, the sensitive portion of the key will be in a canonical form. For an RSA key, this will be one of the prime factors of the public modulus. After loading, it is typical that other values will be computed so that computations using the private key will not need to start with just one prime factor. This structure can be used to store the results of such vendor-specific calculations.
/// </summary>
TPM2B_PRIVATE_VENDOR_SPECIFIC& TPM2B_PRIVATE_VENDOR_SPECIFIC::operator=(const TPM2B_PRIVATE_VENDOR_SPECIFIC& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This structure is defined for coding purposes. For IO to the TPM, the sensitive portion of the key will be in a canonical form. For an RSA key, this will be one of the prime factors of the public modulus. After loading, it is typical that other values will be computed so that computations using the private key will not need to start with just one prime factor. This structure can be used to store the results of such vendor-specific calculations.
/// </summary>
TPM2B_PRIVATE_VENDOR_SPECIFIC::TPM2B_PRIVATE_VENDOR_SPECIFIC(const TPM2B_PRIVATE_VENDOR_SPECIFIC& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// This structure is defined for coding purposes. For IO to the TPM, the sensitive portion of the key will be in a canonical form. For an RSA key, this will be one of the prime factors of the public modulus. After loading, it is typical that other values will be computed so that computations using the private key will not need to start with just one prime factor. This structure can be used to store the results of such vendor-specific calculations.
/// </summary>
TpmStructureBase* TPM2B_PRIVATE_VENDOR_SPECIFIC::Clone() const
{
    TPM2B_PRIVATE_VENDOR_SPECIFIC* _x = new TPM2B_PRIVATE_VENDOR_SPECIFIC(*this);
    return _x;
};
void* TPM2B_PRIVATE_VENDOR_SPECIFIC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMT_SENSITIVE::GetTypeId() const
{
    return TpmTypeId::TPMT_SENSITIVE_ID;
};
/// <summary>
/// authValue shall not be larger than the size of the digest produced by the nameAlg of the object. seedValue shall be the size of the digest produced by the nameAlg of the object.
/// </summary>
TPMT_SENSITIVE::TPMT_SENSITIVE()
{
    sensitive = NULL;
    return;
};
TPMT_SENSITIVE::TPMT_SENSITIVE
(
    const std::vector<BYTE>& _authValue,
    const std::vector<BYTE>& _seedValue,
    const TPMU_SENSITIVE_COMPOSITE& _sensitive
)
{
    authValue= _authValue;
    seedValue= _seedValue;
    sensitive = dynamic_cast<TPMU_SENSITIVE_COMPOSITE*> (_sensitive.Clone());
};
/// <summary>
/// authValue shall not be larger than the size of the digest produced by the nameAlg of the object. seedValue shall be the size of the digest produced by the nameAlg of the object.
/// </summary>
TPMT_SENSITIVE::~TPMT_SENSITIVE()
{
    if(sensitive != NULL) { delete sensitive;sensitive=NULL; }
    return;
};
/// <summary>
/// authValue shall not be larger than the size of the digest produced by the nameAlg of the object. seedValue shall be the size of the digest produced by the nameAlg of the object.
/// </summary>
TPMT_SENSITIVE& TPMT_SENSITIVE::operator=(const TPMT_SENSITIVE& rhs)
{
    if(this == &rhs) return *this;
    this->sensitiveType = rhs.sensitiveType;
    this->authValueSize = rhs.authValueSize;
    this->authValue = rhs.authValue;
    this->seedValueSize = rhs.seedValueSize;
    this->seedValue = rhs.seedValue;
    if(sensitive != NULL) delete sensitive;
    if(rhs.sensitive != NULL)sensitive = dynamic_cast<TPMU_SENSITIVE_COMPOSITE*>(rhs.sensitive->Clone());
    TPMT_SENSITIVE_CUSTOM_CLONE(this, rhs)
    return *this;
};
/// <summary>
/// authValue shall not be larger than the size of the digest produced by the nameAlg of the object. seedValue shall be the size of the digest produced by the nameAlg of the object.
/// </summary>
TPMT_SENSITIVE::TPMT_SENSITIVE(const TPMT_SENSITIVE& r)
{
    this->sensitiveType = r.sensitiveType;
    this->authValueSize = r.authValueSize;
    this->authValue = r.authValue;
    this->seedValueSize = r.seedValueSize;
    this->seedValue = r.seedValue;
    if(r.sensitive != NULL)sensitive = dynamic_cast<TPMU_SENSITIVE_COMPOSITE*>(r.sensitive->Clone());
    TPMT_SENSITIVE_CUSTOM_CLONE(this, r)
};
/// <summary>
/// authValue shall not be larger than the size of the digest produced by the nameAlg of the object. seedValue shall be the size of the digest produced by the nameAlg of the object.
/// </summary>
TpmStructureBase* TPMT_SENSITIVE::Clone() const
{
    TPMT_SENSITIVE* _x = new TPMT_SENSITIVE(*this);
    return _x;
};
void* TPMT_SENSITIVE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&sensitiveType);
            case 1: return (void*) (&authValueSize);
            case 2: { if(newArraySize != -1)authValue.resize(newArraySize); arraySize = (int)authValue.size(); return (void*)(&authValue); }
            case 3: return (void*) (&seedValueSize);
            case 4: { if(newArraySize != -1)seedValue.resize(newArraySize); arraySize = (int)seedValue.size(); return (void*)(&seedValue); }
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(sensitive); return (void*) (&sensitive);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&authValue[arrayIndex]);
            case 4: return (void*)(&seedValue[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_SENSITIVE::GetTypeId() const
{
    return TpmTypeId::TPM2B_SENSITIVE_ID;
};
/// <summary>
/// The TPM2B_SENSITIVE structure is used as a parameter in TPM2_LoadExternal(). It is an unencrypted sensitive area but it may be encrypted using parameter encryption.
/// </summary>
TPM2B_SENSITIVE::TPM2B_SENSITIVE()
{
    return;
};
TPM2B_SENSITIVE::TPM2B_SENSITIVE
(
    const TPMT_SENSITIVE& _sensitiveArea
)
{
    sensitiveArea= _sensitiveArea;
};
/// <summary>
/// The TPM2B_SENSITIVE structure is used as a parameter in TPM2_LoadExternal(). It is an unencrypted sensitive area but it may be encrypted using parameter encryption.
/// </summary>
TPM2B_SENSITIVE::~TPM2B_SENSITIVE()
{
    return;
};
/// <summary>
/// The TPM2B_SENSITIVE structure is used as a parameter in TPM2_LoadExternal(). It is an unencrypted sensitive area but it may be encrypted using parameter encryption.
/// </summary>
TPM2B_SENSITIVE& TPM2B_SENSITIVE::operator=(const TPM2B_SENSITIVE& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->sensitiveArea = rhs.sensitiveArea;
    return *this;
};
/// <summary>
/// The TPM2B_SENSITIVE structure is used as a parameter in TPM2_LoadExternal(). It is an unencrypted sensitive area but it may be encrypted using parameter encryption.
/// </summary>
TPM2B_SENSITIVE::TPM2B_SENSITIVE(const TPM2B_SENSITIVE& r)
{
    this->size = r.size;
    this->sensitiveArea = r.sensitiveArea;
};
/// <summary>
/// The TPM2B_SENSITIVE structure is used as a parameter in TPM2_LoadExternal(). It is an unencrypted sensitive area but it may be encrypted using parameter encryption.
/// </summary>
TpmStructureBase* TPM2B_SENSITIVE::Clone() const
{
    TPM2B_SENSITIVE* _x = new TPM2B_SENSITIVE(*this);
    return _x;
};
void* TPM2B_SENSITIVE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&sensitiveArea); return (void*) (&sensitiveArea);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId _PRIVATE::GetTypeId() const
{
    return TpmTypeId::_PRIVATE_ID;
};
/// <summary>
/// This structure is defined to size the contents of a TPM2B_PRIVATE. This structure is not directly marshaled or unmarshaled.
/// </summary>
_PRIVATE::_PRIVATE()
{
    return;
};
_PRIVATE::_PRIVATE
(
    const std::vector<BYTE>& _integrityOuter,
    const std::vector<BYTE>& _integrityInner,
    const TPMT_SENSITIVE& _sensitive
)
{
    integrityOuter= _integrityOuter;
    integrityInner= _integrityInner;
    sensitive= _sensitive;
};
/// <summary>
/// This structure is defined to size the contents of a TPM2B_PRIVATE. This structure is not directly marshaled or unmarshaled.
/// </summary>
_PRIVATE::~_PRIVATE()
{
    return;
};
/// <summary>
/// This structure is defined to size the contents of a TPM2B_PRIVATE. This structure is not directly marshaled or unmarshaled.
/// </summary>
_PRIVATE& _PRIVATE::operator=(const _PRIVATE& rhs)
{
    if(this == &rhs) return *this;
    this->integrityOuterSize = rhs.integrityOuterSize;
    this->integrityOuter = rhs.integrityOuter;
    this->integrityInnerSize = rhs.integrityInnerSize;
    this->integrityInner = rhs.integrityInner;
    this->sensitiveSize = rhs.sensitiveSize;
    this->sensitive = rhs.sensitive;
    return *this;
};
/// <summary>
/// This structure is defined to size the contents of a TPM2B_PRIVATE. This structure is not directly marshaled or unmarshaled.
/// </summary>
_PRIVATE::_PRIVATE(const _PRIVATE& r)
{
    this->integrityOuterSize = r.integrityOuterSize;
    this->integrityOuter = r.integrityOuter;
    this->integrityInnerSize = r.integrityInnerSize;
    this->integrityInner = r.integrityInner;
    this->sensitiveSize = r.sensitiveSize;
    this->sensitive = r.sensitive;
};
/// <summary>
/// This structure is defined to size the contents of a TPM2B_PRIVATE. This structure is not directly marshaled or unmarshaled.
/// </summary>
TpmStructureBase* _PRIVATE::Clone() const
{
    _PRIVATE* _x = new _PRIVATE(*this);
    return _x;
};
void* _PRIVATE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&integrityOuterSize);
            case 1: { if(newArraySize != -1)integrityOuter.resize(newArraySize); arraySize = (int)integrityOuter.size(); return (void*)(&integrityOuter); }
            case 2: return (void*) (&integrityInnerSize);
            case 3: { if(newArraySize != -1)integrityInner.resize(newArraySize); arraySize = (int)integrityInner.size(); return (void*)(&integrityInner); }
            case 4: return (void*) (&sensitiveSize);
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&sensitive); return (void*) (&sensitive);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&integrityOuter[arrayIndex]);
            case 3: return (void*)(&integrityInner[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_PRIVATE::GetTypeId() const
{
    return TpmTypeId::TPM2B_PRIVATE_ID;
};
/// <summary>
/// The TPM2B_PRIVATE structure is used as a parameter in multiple commands that create, load, and modify the sensitive area of an object.
/// </summary>
TPM2B_PRIVATE::TPM2B_PRIVATE()
{
    return;
};
TPM2B_PRIVATE::TPM2B_PRIVATE
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// The TPM2B_PRIVATE structure is used as a parameter in multiple commands that create, load, and modify the sensitive area of an object.
/// </summary>
TPM2B_PRIVATE::~TPM2B_PRIVATE()
{
    return;
};
/// <summary>
/// The TPM2B_PRIVATE structure is used as a parameter in multiple commands that create, load, and modify the sensitive area of an object.
/// </summary>
TPM2B_PRIVATE& TPM2B_PRIVATE::operator=(const TPM2B_PRIVATE& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// The TPM2B_PRIVATE structure is used as a parameter in multiple commands that create, load, and modify the sensitive area of an object.
/// </summary>
TPM2B_PRIVATE::TPM2B_PRIVATE(const TPM2B_PRIVATE& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// The TPM2B_PRIVATE structure is used as a parameter in multiple commands that create, load, and modify the sensitive area of an object.
/// </summary>
TpmStructureBase* TPM2B_PRIVATE::Clone() const
{
    TPM2B_PRIVATE* _x = new TPM2B_PRIVATE(*this);
    return _x;
};
void* TPM2B_PRIVATE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_ID_OBJECT::GetTypeId() const
{
    return TpmTypeId::TPMS_ID_OBJECT_ID;
};
/// <summary>
/// This structure is used for sizing the TPM2B_ID_OBJECT.
/// </summary>
TPMS_ID_OBJECT::TPMS_ID_OBJECT()
{
    return;
};
TPMS_ID_OBJECT::TPMS_ID_OBJECT
(
    const std::vector<BYTE>& _integrityHMAC,
    const std::vector<BYTE>& _encIdentity
)
{
    integrityHMAC= _integrityHMAC;
    encIdentity= _encIdentity;
};
/// <summary>
/// This structure is used for sizing the TPM2B_ID_OBJECT.
/// </summary>
TPMS_ID_OBJECT::~TPMS_ID_OBJECT()
{
    return;
};
/// <summary>
/// This structure is used for sizing the TPM2B_ID_OBJECT.
/// </summary>
TPMS_ID_OBJECT& TPMS_ID_OBJECT::operator=(const TPMS_ID_OBJECT& rhs)
{
    if(this == &rhs) return *this;
    this->integrityHMACSize = rhs.integrityHMACSize;
    this->integrityHMAC = rhs.integrityHMAC;
    this->encIdentity = rhs.encIdentity;
    return *this;
};
/// <summary>
/// This structure is used for sizing the TPM2B_ID_OBJECT.
/// </summary>
TPMS_ID_OBJECT::TPMS_ID_OBJECT(const TPMS_ID_OBJECT& r)
{
    this->integrityHMACSize = r.integrityHMACSize;
    this->integrityHMAC = r.integrityHMAC;
    this->encIdentity = r.encIdentity;
};
/// <summary>
/// This structure is used for sizing the TPM2B_ID_OBJECT.
/// </summary>
TpmStructureBase* TPMS_ID_OBJECT::Clone() const
{
    TPMS_ID_OBJECT* _x = new TPMS_ID_OBJECT(*this);
    return _x;
};
void* TPMS_ID_OBJECT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&integrityHMACSize);
            case 1: { if(newArraySize != -1)integrityHMAC.resize(newArraySize); arraySize = (int)integrityHMAC.size(); return (void*)(&integrityHMAC); }
            case 2: { if(newArraySize != -1)encIdentity.resize(newArraySize); arraySize = (int)encIdentity.size(); return (void*)(&encIdentity); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&integrityHMAC[arrayIndex]);
            case 2: return (void*)(&encIdentity[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_ID_OBJECT::GetTypeId() const
{
    return TpmTypeId::TPM2B_ID_OBJECT_ID;
};
/// <summary>
/// This structure is an output from TPM2_MakeCredential() and is an input to TPM2_ActivateCredential().
/// </summary>
TPM2B_ID_OBJECT::TPM2B_ID_OBJECT()
{
    return;
};
TPM2B_ID_OBJECT::TPM2B_ID_OBJECT
(
    const TPMS_ID_OBJECT& _credential
)
{
    credential= _credential;
};
/// <summary>
/// This structure is an output from TPM2_MakeCredential() and is an input to TPM2_ActivateCredential().
/// </summary>
TPM2B_ID_OBJECT::~TPM2B_ID_OBJECT()
{
    return;
};
/// <summary>
/// This structure is an output from TPM2_MakeCredential() and is an input to TPM2_ActivateCredential().
/// </summary>
TPM2B_ID_OBJECT& TPM2B_ID_OBJECT::operator=(const TPM2B_ID_OBJECT& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->credential = rhs.credential;
    return *this;
};
/// <summary>
/// This structure is an output from TPM2_MakeCredential() and is an input to TPM2_ActivateCredential().
/// </summary>
TPM2B_ID_OBJECT::TPM2B_ID_OBJECT(const TPM2B_ID_OBJECT& r)
{
    this->size = r.size;
    this->credential = r.credential;
};
/// <summary>
/// This structure is an output from TPM2_MakeCredential() and is an input to TPM2_ActivateCredential().
/// </summary>
TpmStructureBase* TPM2B_ID_OBJECT::Clone() const
{
    TPM2B_ID_OBJECT* _x = new TPM2B_ID_OBJECT(*this);
    return _x;
};
void* TPM2B_ID_OBJECT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&credential); return (void*) (&credential);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_NV_PIN_COUNTER_PARAMETERS::GetTypeId() const
{
    return TpmTypeId::TPMS_NV_PIN_COUNTER_PARAMETERS_ID;
};
/// <summary>
/// This is the data that can be written to and read from a TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL non-volatile index. pinCount is the most significant octets. pinLimit is the least significant octets.
/// </summary>
TPMS_NV_PIN_COUNTER_PARAMETERS::TPMS_NV_PIN_COUNTER_PARAMETERS()
{
    return;
};
TPMS_NV_PIN_COUNTER_PARAMETERS::TPMS_NV_PIN_COUNTER_PARAMETERS
(
    const UINT32& _pinCount,
    const UINT32& _pinLimit
)
{
    pinCount= _pinCount;
    pinLimit= _pinLimit;
};
/// <summary>
/// This is the data that can be written to and read from a TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL non-volatile index. pinCount is the most significant octets. pinLimit is the least significant octets.
/// </summary>
TPMS_NV_PIN_COUNTER_PARAMETERS::~TPMS_NV_PIN_COUNTER_PARAMETERS()
{
    return;
};
/// <summary>
/// This is the data that can be written to and read from a TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL non-volatile index. pinCount is the most significant octets. pinLimit is the least significant octets.
/// </summary>
TPMS_NV_PIN_COUNTER_PARAMETERS& TPMS_NV_PIN_COUNTER_PARAMETERS::operator=(const TPMS_NV_PIN_COUNTER_PARAMETERS& rhs)
{
    if(this == &rhs) return *this;
    this->pinCount = rhs.pinCount;
    this->pinLimit = rhs.pinLimit;
    return *this;
};
/// <summary>
/// This is the data that can be written to and read from a TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL non-volatile index. pinCount is the most significant octets. pinLimit is the least significant octets.
/// </summary>
TPMS_NV_PIN_COUNTER_PARAMETERS::TPMS_NV_PIN_COUNTER_PARAMETERS(const TPMS_NV_PIN_COUNTER_PARAMETERS& r)
{
    this->pinCount = r.pinCount;
    this->pinLimit = r.pinLimit;
};
/// <summary>
/// This is the data that can be written to and read from a TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL non-volatile index. pinCount is the most significant octets. pinLimit is the least significant octets.
/// </summary>
TpmStructureBase* TPMS_NV_PIN_COUNTER_PARAMETERS::Clone() const
{
    TPMS_NV_PIN_COUNTER_PARAMETERS* _x = new TPMS_NV_PIN_COUNTER_PARAMETERS(*this);
    return _x;
};
void* TPMS_NV_PIN_COUNTER_PARAMETERS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&pinCount);
            case 1: return (void*) (&pinLimit);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_NV_PUBLIC::GetTypeId() const
{
    return TpmTypeId::TPMS_NV_PUBLIC_ID;
};
/// <summary>
/// This structure describes an NV Index.
/// </summary>
TPMS_NV_PUBLIC::TPMS_NV_PUBLIC()
{
    return;
};
TPMS_NV_PUBLIC::TPMS_NV_PUBLIC
(
    const TPM_HANDLE& _nvIndex,
    const TPM_ALG_ID& _nameAlg,
    const TPMA_NV& _attributes,
    const std::vector<BYTE>& _authPolicy,
    const UINT16& _dataSize
)
{
    nvIndex= _nvIndex;
    nameAlg= _nameAlg;
    attributes= _attributes;
    authPolicy= _authPolicy;
    dataSize= _dataSize;
};
/// <summary>
/// This structure describes an NV Index.
/// </summary>
TPMS_NV_PUBLIC::~TPMS_NV_PUBLIC()
{
    return;
};
/// <summary>
/// This structure describes an NV Index.
/// </summary>
TPMS_NV_PUBLIC& TPMS_NV_PUBLIC::operator=(const TPMS_NV_PUBLIC& rhs)
{
    if(this == &rhs) return *this;
    this->nvIndex = rhs.nvIndex;
    this->nameAlg = rhs.nameAlg;
    this->attributes = rhs.attributes;
    this->authPolicySize = rhs.authPolicySize;
    this->authPolicy = rhs.authPolicy;
    this->dataSize = rhs.dataSize;
    return *this;
};
/// <summary>
/// This structure describes an NV Index.
/// </summary>
TPMS_NV_PUBLIC::TPMS_NV_PUBLIC(const TPMS_NV_PUBLIC& r)
{
    this->nvIndex = r.nvIndex;
    this->nameAlg = r.nameAlg;
    this->attributes = r.attributes;
    this->authPolicySize = r.authPolicySize;
    this->authPolicy = r.authPolicy;
    this->dataSize = r.dataSize;
};
/// <summary>
/// This structure describes an NV Index.
/// </summary>
TpmStructureBase* TPMS_NV_PUBLIC::Clone() const
{
    TPMS_NV_PUBLIC* _x = new TPMS_NV_PUBLIC(*this);
    return _x;
};
void* TPMS_NV_PUBLIC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return (void*) (&nvIndex);
            case 1: return (void*) (&nameAlg);
            case 2: return (void*) (&attributes);
            case 3: return (void*) (&authPolicySize);
            case 4: { if(newArraySize != -1)authPolicy.resize(newArraySize); arraySize = (int)authPolicy.size(); return (void*)(&authPolicy); }
            case 5: return (void*) (&dataSize);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 4: return (void*)(&authPolicy[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_NV_PUBLIC::GetTypeId() const
{
    return TpmTypeId::TPM2B_NV_PUBLIC_ID;
};
/// <summary>
/// This structure is used when a TPMS_NV_PUBLIC is sent on the TPM interface.
/// </summary>
TPM2B_NV_PUBLIC::TPM2B_NV_PUBLIC()
{
    return;
};
TPM2B_NV_PUBLIC::TPM2B_NV_PUBLIC
(
    const TPMS_NV_PUBLIC& _nvPublic
)
{
    nvPublic= _nvPublic;
};
/// <summary>
/// This structure is used when a TPMS_NV_PUBLIC is sent on the TPM interface.
/// </summary>
TPM2B_NV_PUBLIC::~TPM2B_NV_PUBLIC()
{
    return;
};
/// <summary>
/// This structure is used when a TPMS_NV_PUBLIC is sent on the TPM interface.
/// </summary>
TPM2B_NV_PUBLIC& TPM2B_NV_PUBLIC::operator=(const TPM2B_NV_PUBLIC& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->nvPublic = rhs.nvPublic;
    return *this;
};
/// <summary>
/// This structure is used when a TPMS_NV_PUBLIC is sent on the TPM interface.
/// </summary>
TPM2B_NV_PUBLIC::TPM2B_NV_PUBLIC(const TPM2B_NV_PUBLIC& r)
{
    this->size = r.size;
    this->nvPublic = r.nvPublic;
};
/// <summary>
/// This structure is used when a TPMS_NV_PUBLIC is sent on the TPM interface.
/// </summary>
TpmStructureBase* TPM2B_NV_PUBLIC::Clone() const
{
    TPM2B_NV_PUBLIC* _x = new TPM2B_NV_PUBLIC(*this);
    return _x;
};
void* TPM2B_NV_PUBLIC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvPublic); return (void*) (&nvPublic);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2B_CONTEXT_SENSITIVE::GetTypeId() const
{
    return TpmTypeId::TPM2B_CONTEXT_SENSITIVE_ID;
};
/// <summary>
/// This structure holds the object or session context data. When saved, the full structure is encrypted.
/// </summary>
TPM2B_CONTEXT_SENSITIVE::TPM2B_CONTEXT_SENSITIVE()
{
    return;
};
TPM2B_CONTEXT_SENSITIVE::TPM2B_CONTEXT_SENSITIVE
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// This structure holds the object or session context data. When saved, the full structure is encrypted.
/// </summary>
TPM2B_CONTEXT_SENSITIVE::~TPM2B_CONTEXT_SENSITIVE()
{
    return;
};
/// <summary>
/// This structure holds the object or session context data. When saved, the full structure is encrypted.
/// </summary>
TPM2B_CONTEXT_SENSITIVE& TPM2B_CONTEXT_SENSITIVE::operator=(const TPM2B_CONTEXT_SENSITIVE& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This structure holds the object or session context data. When saved, the full structure is encrypted.
/// </summary>
TPM2B_CONTEXT_SENSITIVE::TPM2B_CONTEXT_SENSITIVE(const TPM2B_CONTEXT_SENSITIVE& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// This structure holds the object or session context data. When saved, the full structure is encrypted.
/// </summary>
TpmStructureBase* TPM2B_CONTEXT_SENSITIVE::Clone() const
{
    TPM2B_CONTEXT_SENSITIVE* _x = new TPM2B_CONTEXT_SENSITIVE(*this);
    return _x;
};
void* TPM2B_CONTEXT_SENSITIVE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPMS_CONTEXT_DATA::GetTypeId() const
{
    return TpmTypeId::TPMS_CONTEXT_DATA_ID;
};
/// <summary>
/// This structure holds the integrity value and the encrypted data for a context.
/// </summary>
TPMS_CONTEXT_DATA::TPMS_CONTEXT_DATA()
{
    return;
};
TPMS_CONTEXT_DATA::TPMS_CONTEXT_DATA
(
    const std::vector<BYTE>& _integrity,
    const std::vector<BYTE>& _encrypted
)
{
    integrity= _integrity;
    encrypted= _encrypted;
};
/// <summary>
/// This structure holds the integrity value and the encrypted data for a context.
/// </summary>
TPMS_CONTEXT_DATA::~TPMS_CONTEXT_DATA()
{
    return;
};
/// <summary>
/// This structure holds the integrity value and the encrypted data for a context.
/// </summary>
TPMS_CONTEXT_DATA& TPMS_CONTEXT_DATA::operator=(const TPMS_CONTEXT_DATA& rhs)
{
    if(this == &rhs) return *this;
    this->integritySize = rhs.integritySize;
    this->integrity = rhs.integrity;
    this->encrypted = rhs.encrypted;
    return *this;
};
/// <summary>
/// This structure holds the integrity value and the encrypted data for a context.
/// </summary>
TPMS_CONTEXT_DATA::TPMS_CONTEXT_DATA(const TPMS_CONTEXT_DATA& r)
{
    this->integritySize = r.integritySize;
    this->integrity = r.integrity;
    this->encrypted = r.encrypted;
};
/// <summary>
/// This structure holds the integrity value and the encrypted data for a context.
/// </summary>
TpmStructureBase* TPMS_CONTEXT_DATA::Clone() const
{
    TPMS_CONTEXT_DATA* _x = new TPMS_CONTEXT_DATA(*this);
    return _x;
};
void* TPMS_CONTEXT_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&integritySize);
            case 1: { if(newArraySize != -1)integrity.resize(newArraySize); arraySize = (int)integrity.size(); return (void*)(&integrity); }
            case 2: { if(newArraySize != -1)encrypted.resize(newArraySize); arraySize = (int)encrypted.size(); return (void*)(&encrypted); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&integrity[arrayIndex]);
            case 2: return (void*)(&encrypted[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_CONTEXT_DATA::GetTypeId() const
{
    return TpmTypeId::TPM2B_CONTEXT_DATA_ID;
};
/// <summary>
/// This structure is used in a TPMS_CONTEXT.
/// </summary>
TPM2B_CONTEXT_DATA::TPM2B_CONTEXT_DATA()
{
    return;
};
TPM2B_CONTEXT_DATA::TPM2B_CONTEXT_DATA
(
    const TPMS_CONTEXT_DATA& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// This structure is used in a TPMS_CONTEXT.
/// </summary>
TPM2B_CONTEXT_DATA::~TPM2B_CONTEXT_DATA()
{
    return;
};
/// <summary>
/// This structure is used in a TPMS_CONTEXT.
/// </summary>
TPM2B_CONTEXT_DATA& TPM2B_CONTEXT_DATA::operator=(const TPM2B_CONTEXT_DATA& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This structure is used in a TPMS_CONTEXT.
/// </summary>
TPM2B_CONTEXT_DATA::TPM2B_CONTEXT_DATA(const TPM2B_CONTEXT_DATA& r)
{
    this->size = r.size;
    this->buffer = r.buffer;
};
/// <summary>
/// This structure is used in a TPMS_CONTEXT.
/// </summary>
TpmStructureBase* TPM2B_CONTEXT_DATA::Clone() const
{
    TPM2B_CONTEXT_DATA* _x = new TPM2B_CONTEXT_DATA(*this);
    return _x;
};
void* TPM2B_CONTEXT_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&buffer); return (void*) (&buffer);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_CONTEXT::GetTypeId() const
{
    return TpmTypeId::TPMS_CONTEXT_ID;
};
/// <summary>
/// This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when the context was saved (TPM2_ContextSave()), then the TPM shall not load the context.
/// </summary>
TPMS_CONTEXT::TPMS_CONTEXT()
{
    return;
};
TPMS_CONTEXT::TPMS_CONTEXT
(
    const UINT64& _sequence,
    const TPM_HANDLE& _savedHandle,
    const TPM_HANDLE& _hierarchy,
    const TPMS_CONTEXT_DATA& _contextBlob
)
{
    sequence= _sequence;
    savedHandle= _savedHandle;
    hierarchy= _hierarchy;
    contextBlob= _contextBlob;
};
/// <summary>
/// This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when the context was saved (TPM2_ContextSave()), then the TPM shall not load the context.
/// </summary>
TPMS_CONTEXT::~TPMS_CONTEXT()
{
    return;
};
/// <summary>
/// This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when the context was saved (TPM2_ContextSave()), then the TPM shall not load the context.
/// </summary>
TPMS_CONTEXT& TPMS_CONTEXT::operator=(const TPMS_CONTEXT& rhs)
{
    if(this == &rhs) return *this;
    this->sequence = rhs.sequence;
    this->savedHandle = rhs.savedHandle;
    this->hierarchy = rhs.hierarchy;
    this->contextBlobSize = rhs.contextBlobSize;
    this->contextBlob = rhs.contextBlob;
    return *this;
};
/// <summary>
/// This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when the context was saved (TPM2_ContextSave()), then the TPM shall not load the context.
/// </summary>
TPMS_CONTEXT::TPMS_CONTEXT(const TPMS_CONTEXT& r)
{
    this->sequence = r.sequence;
    this->savedHandle = r.savedHandle;
    this->hierarchy = r.hierarchy;
    this->contextBlobSize = r.contextBlobSize;
    this->contextBlob = r.contextBlob;
};
/// <summary>
/// This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when the context was saved (TPM2_ContextSave()), then the TPM shall not load the context.
/// </summary>
TpmStructureBase* TPMS_CONTEXT::Clone() const
{
    TPMS_CONTEXT* _x = new TPMS_CONTEXT(*this);
    return _x;
};
void* TPMS_CONTEXT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&sequence);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&savedHandle); return (void*) (&savedHandle);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return (void*) (&hierarchy);
            case 3: return (void*) (&contextBlobSize);
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&contextBlob); return (void*) (&contextBlob);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_CREATION_DATA::GetTypeId() const
{
    return TpmTypeId::TPMS_CREATION_DATA_ID;
};
/// <summary>
/// This structure provides information relating to the creation environment for the object. The creation data includes the parent Name, parent Qualified Name, and the digest of selected PCR. These values represent the environment in which the object was created. Creation data allows a relying party to determine if an object was created when some appropriate protections were present.
/// </summary>
TPMS_CREATION_DATA::TPMS_CREATION_DATA()
{
    return;
};
TPMS_CREATION_DATA::TPMS_CREATION_DATA
(
    const std::vector<TPMS_PCR_SELECTION>& _pcrSelect,
    const std::vector<BYTE>& _pcrDigest,
    const TPMA_LOCALITY& _locality,
    const TPM_ALG_ID& _parentNameAlg,
    const std::vector<BYTE>& _parentName,
    const std::vector<BYTE>& _parentQualifiedName,
    const std::vector<BYTE>& _outsideInfo
)
{
    pcrSelect= _pcrSelect;
    pcrDigest= _pcrDigest;
    locality= _locality;
    parentNameAlg= _parentNameAlg;
    parentName= _parentName;
    parentQualifiedName= _parentQualifiedName;
    outsideInfo= _outsideInfo;
};
/// <summary>
/// This structure provides information relating to the creation environment for the object. The creation data includes the parent Name, parent Qualified Name, and the digest of selected PCR. These values represent the environment in which the object was created. Creation data allows a relying party to determine if an object was created when some appropriate protections were present.
/// </summary>
TPMS_CREATION_DATA::~TPMS_CREATION_DATA()
{
    return;
};
/// <summary>
/// This structure provides information relating to the creation environment for the object. The creation data includes the parent Name, parent Qualified Name, and the digest of selected PCR. These values represent the environment in which the object was created. Creation data allows a relying party to determine if an object was created when some appropriate protections were present.
/// </summary>
TPMS_CREATION_DATA& TPMS_CREATION_DATA::operator=(const TPMS_CREATION_DATA& rhs)
{
    if(this == &rhs) return *this;
    this->pcrSelectCount = rhs.pcrSelectCount;
    this->pcrSelect = rhs.pcrSelect;
    this->pcrDigestSize = rhs.pcrDigestSize;
    this->pcrDigest = rhs.pcrDigest;
    this->locality = rhs.locality;
    this->parentNameAlg = rhs.parentNameAlg;
    this->parentNameSize = rhs.parentNameSize;
    this->parentName = rhs.parentName;
    this->parentQualifiedNameSize = rhs.parentQualifiedNameSize;
    this->parentQualifiedName = rhs.parentQualifiedName;
    this->outsideInfoSize = rhs.outsideInfoSize;
    this->outsideInfo = rhs.outsideInfo;
    return *this;
};
/// <summary>
/// This structure provides information relating to the creation environment for the object. The creation data includes the parent Name, parent Qualified Name, and the digest of selected PCR. These values represent the environment in which the object was created. Creation data allows a relying party to determine if an object was created when some appropriate protections were present.
/// </summary>
TPMS_CREATION_DATA::TPMS_CREATION_DATA(const TPMS_CREATION_DATA& r)
{
    this->pcrSelectCount = r.pcrSelectCount;
    this->pcrSelect = r.pcrSelect;
    this->pcrDigestSize = r.pcrDigestSize;
    this->pcrDigest = r.pcrDigest;
    this->locality = r.locality;
    this->parentNameAlg = r.parentNameAlg;
    this->parentNameSize = r.parentNameSize;
    this->parentName = r.parentName;
    this->parentQualifiedNameSize = r.parentQualifiedNameSize;
    this->parentQualifiedName = r.parentQualifiedName;
    this->outsideInfoSize = r.outsideInfoSize;
    this->outsideInfo = r.outsideInfo;
};
/// <summary>
/// This structure provides information relating to the creation environment for the object. The creation data includes the parent Name, parent Qualified Name, and the digest of selected PCR. These values represent the environment in which the object was created. Creation data allows a relying party to determine if an object was created when some appropriate protections were present.
/// </summary>
TpmStructureBase* TPMS_CREATION_DATA::Clone() const
{
    TPMS_CREATION_DATA* _x = new TPMS_CREATION_DATA(*this);
    return _x;
};
void* TPMS_CREATION_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&pcrSelectCount);
            case 1: { if(newArraySize != -1)pcrSelect.resize(newArraySize); arraySize = (int)pcrSelect.size(); return (void*)(&pcrSelect); }
            case 2: return (void*) (&pcrDigestSize);
            case 3: { if(newArraySize != -1)pcrDigest.resize(newArraySize); arraySize = (int)pcrDigest.size(); return (void*)(&pcrDigest); }
            case 4: return (void*) (&locality);
            case 5: return (void*) (&parentNameAlg);
            case 6: return (void*) (&parentNameSize);
            case 7: { if(newArraySize != -1)parentName.resize(newArraySize); arraySize = (int)parentName.size(); return (void*)(&parentName); }
            case 8: return (void*) (&parentQualifiedNameSize);
            case 9: { if(newArraySize != -1)parentQualifiedName.resize(newArraySize); arraySize = (int)parentQualifiedName.size(); return (void*)(&parentQualifiedName); }
            case 10: return (void*) (&outsideInfoSize);
            case 11: { if(newArraySize != -1)outsideInfo.resize(newArraySize); arraySize = (int)outsideInfo.size(); return (void*)(&outsideInfo); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&pcrSelect[arrayIndex]);return (void*)(&pcrSelect[arrayIndex]);
            case 3: return (void*)(&pcrDigest[arrayIndex]);
            case 7: return (void*)(&parentName[arrayIndex]);
            case 9: return (void*)(&parentQualifiedName[arrayIndex]);
            case 11: return (void*)(&outsideInfo[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_CREATION_DATA::GetTypeId() const
{
    return TpmTypeId::TPM2B_CREATION_DATA_ID;
};
/// <summary>
/// This structure is created by TPM2_Create() and TPM2_CreatePrimary(). It is never entered into the TPM and never has a size of zero.
/// </summary>
TPM2B_CREATION_DATA::TPM2B_CREATION_DATA()
{
    return;
};
TPM2B_CREATION_DATA::TPM2B_CREATION_DATA
(
    const TPMS_CREATION_DATA& _creationData
)
{
    creationData= _creationData;
};
/// <summary>
/// This structure is created by TPM2_Create() and TPM2_CreatePrimary(). It is never entered into the TPM and never has a size of zero.
/// </summary>
TPM2B_CREATION_DATA::~TPM2B_CREATION_DATA()
{
    return;
};
/// <summary>
/// This structure is created by TPM2_Create() and TPM2_CreatePrimary(). It is never entered into the TPM and never has a size of zero.
/// </summary>
TPM2B_CREATION_DATA& TPM2B_CREATION_DATA::operator=(const TPM2B_CREATION_DATA& rhs)
{
    if(this == &rhs) return *this;
    this->size = rhs.size;
    this->creationData = rhs.creationData;
    return *this;
};
/// <summary>
/// This structure is created by TPM2_Create() and TPM2_CreatePrimary(). It is never entered into the TPM and never has a size of zero.
/// </summary>
TPM2B_CREATION_DATA::TPM2B_CREATION_DATA(const TPM2B_CREATION_DATA& r)
{
    this->size = r.size;
    this->creationData = r.creationData;
};
/// <summary>
/// This structure is created by TPM2_Create() and TPM2_CreatePrimary(). It is never entered into the TPM and never has a size of zero.
/// </summary>
TpmStructureBase* TPM2B_CREATION_DATA::Clone() const
{
    TPM2B_CREATION_DATA* _x = new TPM2B_CREATION_DATA(*this);
    return _x;
};
void* TPM2B_CREATION_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&creationData); return (void*) (&creationData);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPMS_AC_OUTPUT::GetTypeId() const
{
    return TpmTypeId::TPMS_AC_OUTPUT_ID;
};
/// <summary>
/// TPMS_AC_OUTPUT is used to return information about an AC. The tag structure parameter indicates the type of the data value.
/// </summary>
TPMS_AC_OUTPUT::TPMS_AC_OUTPUT()
{
    return;
};
TPMS_AC_OUTPUT::TPMS_AC_OUTPUT
(
    const TPM_AT& _tag,
    const UINT32& _data
)
{
    tag= _tag;
    data= _data;
};
/// <summary>
/// TPMS_AC_OUTPUT is used to return information about an AC. The tag structure parameter indicates the type of the data value.
/// </summary>
TPMS_AC_OUTPUT::~TPMS_AC_OUTPUT()
{
    return;
};
/// <summary>
/// TPMS_AC_OUTPUT is used to return information about an AC. The tag structure parameter indicates the type of the data value.
/// </summary>
TPMS_AC_OUTPUT& TPMS_AC_OUTPUT::operator=(const TPMS_AC_OUTPUT& rhs)
{
    if(this == &rhs) return *this;
    this->tag = rhs.tag;
    this->data = rhs.data;
    return *this;
};
/// <summary>
/// TPMS_AC_OUTPUT is used to return information about an AC. The tag structure parameter indicates the type of the data value.
/// </summary>
TPMS_AC_OUTPUT::TPMS_AC_OUTPUT(const TPMS_AC_OUTPUT& r)
{
    this->tag = r.tag;
    this->data = r.data;
};
/// <summary>
/// TPMS_AC_OUTPUT is used to return information about an AC. The tag structure parameter indicates the type of the data value.
/// </summary>
TpmStructureBase* TPMS_AC_OUTPUT::Clone() const
{
    TPMS_AC_OUTPUT* _x = new TPMS_AC_OUTPUT(*this);
    return _x;
};
void* TPMS_AC_OUTPUT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&tag);
            case 1: return (void*) (&data);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPML_AC_CAPABILITIES::GetTypeId() const
{
    return TpmTypeId::TPML_AC_CAPABILITIES_ID;
};
/// <summary>
/// This list is only used in TPM2_AC_GetCapability().
/// </summary>
TPML_AC_CAPABILITIES::TPML_AC_CAPABILITIES()
{
    return;
};
TPML_AC_CAPABILITIES::TPML_AC_CAPABILITIES
(
    const std::vector<TPMS_AC_OUTPUT>& _acCapabilities
)
{
    acCapabilities= _acCapabilities;
};
/// <summary>
/// This list is only used in TPM2_AC_GetCapability().
/// </summary>
TPML_AC_CAPABILITIES::~TPML_AC_CAPABILITIES()
{
    return;
};
/// <summary>
/// This list is only used in TPM2_AC_GetCapability().
/// </summary>
TPML_AC_CAPABILITIES& TPML_AC_CAPABILITIES::operator=(const TPML_AC_CAPABILITIES& rhs)
{
    if(this == &rhs) return *this;
    this->count = rhs.count;
    this->acCapabilities = rhs.acCapabilities;
    return *this;
};
/// <summary>
/// This list is only used in TPM2_AC_GetCapability().
/// </summary>
TPML_AC_CAPABILITIES::TPML_AC_CAPABILITIES(const TPML_AC_CAPABILITIES& r)
{
    this->count = r.count;
    this->acCapabilities = r.acCapabilities;
};
/// <summary>
/// This list is only used in TPM2_AC_GetCapability().
/// </summary>
TpmStructureBase* TPML_AC_CAPABILITIES::Clone() const
{
    TPML_AC_CAPABILITIES* _x = new TPML_AC_CAPABILITIES(*this);
    return _x;
};
void* TPML_AC_CAPABILITIES::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&count);
            case 1: { if(newArraySize != -1)acCapabilities.resize(newArraySize); arraySize = (int)acCapabilities.size(); return (void*)(&acCapabilities); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&acCapabilities[arrayIndex]);return (void*)(&acCapabilities[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_Startup_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Startup_REQUEST_ID;
};
/// <summary>
/// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
/// </summary>
TPM2_Startup_REQUEST::TPM2_Startup_REQUEST()
{
    return;
};
TPM2_Startup_REQUEST::TPM2_Startup_REQUEST
(
    const TPM_SU& _startupType
)
{
    startupType= _startupType;
};
/// <summary>
/// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
/// </summary>
TPM2_Startup_REQUEST::~TPM2_Startup_REQUEST()
{
    return;
};
/// <summary>
/// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
/// </summary>
TPM2_Startup_REQUEST& TPM2_Startup_REQUEST::operator=(const TPM2_Startup_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->startupType = rhs.startupType;
    return *this;
};
/// <summary>
/// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
/// </summary>
TPM2_Startup_REQUEST::TPM2_Startup_REQUEST(const TPM2_Startup_REQUEST& r)
{
    this->startupType = r.startupType;
};
/// <summary>
/// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
/// </summary>
TpmStructureBase* TPM2_Startup_REQUEST::Clone() const
{
    TPM2_Startup_REQUEST* _x = new TPM2_Startup_REQUEST(*this);
    return _x;
};
void* TPM2_Startup_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&startupType);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId StartupResponse::GetTypeId() const
{
    return TpmTypeId::StartupResponse_ID;
};
/// <summary>
/// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
/// </summary>
StartupResponse::StartupResponse()
{
    return;
};
/// <summary>
/// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
/// </summary>
StartupResponse::~StartupResponse()
{
    return;
};
/// <summary>
/// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
/// </summary>
StartupResponse& StartupResponse::operator=(const StartupResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
/// </summary>
StartupResponse::StartupResponse(const StartupResponse& r)
{
};
/// <summary>
/// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
/// </summary>
TpmStructureBase* StartupResponse::Clone() const
{
    StartupResponse* _x = new StartupResponse(*this);
    return _x;
};
void* StartupResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_Shutdown_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Shutdown_REQUEST_ID;
};
/// <summary>
/// This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
/// </summary>
TPM2_Shutdown_REQUEST::TPM2_Shutdown_REQUEST()
{
    return;
};
TPM2_Shutdown_REQUEST::TPM2_Shutdown_REQUEST
(
    const TPM_SU& _shutdownType
)
{
    shutdownType= _shutdownType;
};
/// <summary>
/// This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
/// </summary>
TPM2_Shutdown_REQUEST::~TPM2_Shutdown_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
/// </summary>
TPM2_Shutdown_REQUEST& TPM2_Shutdown_REQUEST::operator=(const TPM2_Shutdown_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->shutdownType = rhs.shutdownType;
    return *this;
};
/// <summary>
/// This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
/// </summary>
TPM2_Shutdown_REQUEST::TPM2_Shutdown_REQUEST(const TPM2_Shutdown_REQUEST& r)
{
    this->shutdownType = r.shutdownType;
};
/// <summary>
/// This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
/// </summary>
TpmStructureBase* TPM2_Shutdown_REQUEST::Clone() const
{
    TPM2_Shutdown_REQUEST* _x = new TPM2_Shutdown_REQUEST(*this);
    return _x;
};
void* TPM2_Shutdown_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&shutdownType);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId ShutdownResponse::GetTypeId() const
{
    return TpmTypeId::ShutdownResponse_ID;
};
/// <summary>
/// This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
/// </summary>
ShutdownResponse::ShutdownResponse()
{
    return;
};
/// <summary>
/// This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
/// </summary>
ShutdownResponse::~ShutdownResponse()
{
    return;
};
/// <summary>
/// This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
/// </summary>
ShutdownResponse& ShutdownResponse::operator=(const ShutdownResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
/// </summary>
ShutdownResponse::ShutdownResponse(const ShutdownResponse& r)
{
};
/// <summary>
/// This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
/// </summary>
TpmStructureBase* ShutdownResponse::Clone() const
{
    ShutdownResponse* _x = new ShutdownResponse(*this);
    return _x;
};
void* ShutdownResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_SelfTest_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_SelfTest_REQUEST_ID;
};
/// <summary>
/// This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
/// </summary>
TPM2_SelfTest_REQUEST::TPM2_SelfTest_REQUEST()
{
    return;
};
TPM2_SelfTest_REQUEST::TPM2_SelfTest_REQUEST
(
    const BYTE& _fullTest
)
{
    fullTest= _fullTest;
};
/// <summary>
/// This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
/// </summary>
TPM2_SelfTest_REQUEST::~TPM2_SelfTest_REQUEST()
{
    return;
};
/// <summary>
/// This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
/// </summary>
TPM2_SelfTest_REQUEST& TPM2_SelfTest_REQUEST::operator=(const TPM2_SelfTest_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->fullTest = rhs.fullTest;
    return *this;
};
/// <summary>
/// This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
/// </summary>
TPM2_SelfTest_REQUEST::TPM2_SelfTest_REQUEST(const TPM2_SelfTest_REQUEST& r)
{
    this->fullTest = r.fullTest;
};
/// <summary>
/// This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
/// </summary>
TpmStructureBase* TPM2_SelfTest_REQUEST::Clone() const
{
    TPM2_SelfTest_REQUEST* _x = new TPM2_SelfTest_REQUEST(*this);
    return _x;
};
void* TPM2_SelfTest_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&fullTest);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId SelfTestResponse::GetTypeId() const
{
    return TpmTypeId::SelfTestResponse_ID;
};
/// <summary>
/// This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
/// </summary>
SelfTestResponse::SelfTestResponse()
{
    return;
};
/// <summary>
/// This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
/// </summary>
SelfTestResponse::~SelfTestResponse()
{
    return;
};
/// <summary>
/// This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
/// </summary>
SelfTestResponse& SelfTestResponse::operator=(const SelfTestResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
/// </summary>
SelfTestResponse::SelfTestResponse(const SelfTestResponse& r)
{
};
/// <summary>
/// This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
/// </summary>
TpmStructureBase* SelfTestResponse::Clone() const
{
    SelfTestResponse* _x = new SelfTestResponse(*this);
    return _x;
};
void* SelfTestResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_IncrementalSelfTest_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_IncrementalSelfTest_REQUEST_ID;
};
/// <summary>
/// This command causes the TPM to perform a test of the selected algorithms.
/// </summary>
TPM2_IncrementalSelfTest_REQUEST::TPM2_IncrementalSelfTest_REQUEST()
{
    return;
};
TPM2_IncrementalSelfTest_REQUEST::TPM2_IncrementalSelfTest_REQUEST
(
    const std::vector<TPM_ALG_ID>& _toTest
)
{
    toTest= _toTest;
};
/// <summary>
/// This command causes the TPM to perform a test of the selected algorithms.
/// </summary>
TPM2_IncrementalSelfTest_REQUEST::~TPM2_IncrementalSelfTest_REQUEST()
{
    return;
};
/// <summary>
/// This command causes the TPM to perform a test of the selected algorithms.
/// </summary>
TPM2_IncrementalSelfTest_REQUEST& TPM2_IncrementalSelfTest_REQUEST::operator=(const TPM2_IncrementalSelfTest_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->toTestCount = rhs.toTestCount;
    this->toTest = rhs.toTest;
    return *this;
};
/// <summary>
/// This command causes the TPM to perform a test of the selected algorithms.
/// </summary>
TPM2_IncrementalSelfTest_REQUEST::TPM2_IncrementalSelfTest_REQUEST(const TPM2_IncrementalSelfTest_REQUEST& r)
{
    this->toTestCount = r.toTestCount;
    this->toTest = r.toTest;
};
/// <summary>
/// This command causes the TPM to perform a test of the selected algorithms.
/// </summary>
TpmStructureBase* TPM2_IncrementalSelfTest_REQUEST::Clone() const
{
    TPM2_IncrementalSelfTest_REQUEST* _x = new TPM2_IncrementalSelfTest_REQUEST(*this);
    return _x;
};
void* TPM2_IncrementalSelfTest_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&toTestCount);
            case 1: { if(newArraySize != -1)toTest.resize(newArraySize); arraySize = (int)toTest.size(); return (void*)(&toTest); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&toTest[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId IncrementalSelfTestResponse::GetTypeId() const
{
    return TpmTypeId::IncrementalSelfTestResponse_ID;
};
/// <summary>
/// This command causes the TPM to perform a test of the selected algorithms.
/// </summary>
IncrementalSelfTestResponse::IncrementalSelfTestResponse()
{
    return;
};
IncrementalSelfTestResponse::IncrementalSelfTestResponse
(
    const std::vector<TPM_ALG_ID>& _toDoList
)
{
    toDoList= _toDoList;
};
/// <summary>
/// This command causes the TPM to perform a test of the selected algorithms.
/// </summary>
IncrementalSelfTestResponse::~IncrementalSelfTestResponse()
{
    return;
};
/// <summary>
/// This command causes the TPM to perform a test of the selected algorithms.
/// </summary>
IncrementalSelfTestResponse& IncrementalSelfTestResponse::operator=(const IncrementalSelfTestResponse& rhs)
{
    if(this == &rhs) return *this;
    this->toDoListCount = rhs.toDoListCount;
    this->toDoList = rhs.toDoList;
    return *this;
};
/// <summary>
/// This command causes the TPM to perform a test of the selected algorithms.
/// </summary>
IncrementalSelfTestResponse::IncrementalSelfTestResponse(const IncrementalSelfTestResponse& r)
{
    this->toDoListCount = r.toDoListCount;
    this->toDoList = r.toDoList;
};
/// <summary>
/// This command causes the TPM to perform a test of the selected algorithms.
/// </summary>
TpmStructureBase* IncrementalSelfTestResponse::Clone() const
{
    IncrementalSelfTestResponse* _x = new IncrementalSelfTestResponse(*this);
    return _x;
};
void* IncrementalSelfTestResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&toDoListCount);
            case 1: { if(newArraySize != -1)toDoList.resize(newArraySize); arraySize = (int)toDoList.size(); return (void*)(&toDoList); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&toDoList[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_GetTestResult_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_GetTestResult_REQUEST_ID;
};
/// <summary>
/// This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
/// </summary>
TPM2_GetTestResult_REQUEST::TPM2_GetTestResult_REQUEST()
{
    return;
};
/// <summary>
/// This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
/// </summary>
TPM2_GetTestResult_REQUEST::~TPM2_GetTestResult_REQUEST()
{
    return;
};
/// <summary>
/// This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
/// </summary>
TPM2_GetTestResult_REQUEST& TPM2_GetTestResult_REQUEST::operator=(const TPM2_GetTestResult_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
/// </summary>
TPM2_GetTestResult_REQUEST::TPM2_GetTestResult_REQUEST(const TPM2_GetTestResult_REQUEST& r)
{
};
/// <summary>
/// This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
/// </summary>
TpmStructureBase* TPM2_GetTestResult_REQUEST::Clone() const
{
    TPM2_GetTestResult_REQUEST* _x = new TPM2_GetTestResult_REQUEST(*this);
    return _x;
};
void* TPM2_GetTestResult_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId GetTestResultResponse::GetTypeId() const
{
    return TpmTypeId::GetTestResultResponse_ID;
};
/// <summary>
/// This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
/// </summary>
GetTestResultResponse::GetTestResultResponse()
{
    return;
};
GetTestResultResponse::GetTestResultResponse
(
    const std::vector<BYTE>& _outData,
    const TPM_RC& _testResult
)
{
    outData= _outData;
    testResult= _testResult;
};
/// <summary>
/// This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
/// </summary>
GetTestResultResponse::~GetTestResultResponse()
{
    return;
};
/// <summary>
/// This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
/// </summary>
GetTestResultResponse& GetTestResultResponse::operator=(const GetTestResultResponse& rhs)
{
    if(this == &rhs) return *this;
    this->outDataSize = rhs.outDataSize;
    this->outData = rhs.outData;
    this->testResult = rhs.testResult;
    return *this;
};
/// <summary>
/// This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
/// </summary>
GetTestResultResponse::GetTestResultResponse(const GetTestResultResponse& r)
{
    this->outDataSize = r.outDataSize;
    this->outData = r.outData;
    this->testResult = r.testResult;
};
/// <summary>
/// This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
/// </summary>
TpmStructureBase* GetTestResultResponse::Clone() const
{
    GetTestResultResponse* _x = new GetTestResultResponse(*this);
    return _x;
};
void* GetTestResultResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&outDataSize);
            case 1: { if(newArraySize != -1)outData.resize(newArraySize); arraySize = (int)outData.size(); return (void*)(&outData); }
            case 2: return (void*) (&testResult);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&outData[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_StartAuthSession_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
};
/// <summary>
/// This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
/// </summary>
TPM2_StartAuthSession_REQUEST::TPM2_StartAuthSession_REQUEST()
{
    return;
};
TPM2_StartAuthSession_REQUEST::TPM2_StartAuthSession_REQUEST
(
    const TPM_HANDLE& _tpmKey,
    const TPM_HANDLE& _bind,
    const std::vector<BYTE>& _nonceCaller,
    const std::vector<BYTE>& _encryptedSalt,
    const TPM_SE& _sessionType,
    const TPMT_SYM_DEF& _symmetric,
    const TPM_ALG_ID& _authHash
)
{
    tpmKey= _tpmKey;
    bind= _bind;
    nonceCaller= _nonceCaller;
    encryptedSalt= _encryptedSalt;
    sessionType= _sessionType;
    symmetric= _symmetric;
    authHash= _authHash;
};
/// <summary>
/// This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
/// </summary>
TPM2_StartAuthSession_REQUEST::~TPM2_StartAuthSession_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
/// </summary>
TPM2_StartAuthSession_REQUEST& TPM2_StartAuthSession_REQUEST::operator=(const TPM2_StartAuthSession_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->tpmKey = rhs.tpmKey;
    this->bind = rhs.bind;
    this->nonceCallerSize = rhs.nonceCallerSize;
    this->nonceCaller = rhs.nonceCaller;
    this->encryptedSaltSize = rhs.encryptedSaltSize;
    this->encryptedSalt = rhs.encryptedSalt;
    this->sessionType = rhs.sessionType;
    this->symmetric = rhs.symmetric;
    this->authHash = rhs.authHash;
    return *this;
};
/// <summary>
/// This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
/// </summary>
TPM2_StartAuthSession_REQUEST::TPM2_StartAuthSession_REQUEST(const TPM2_StartAuthSession_REQUEST& r)
{
    this->tpmKey = r.tpmKey;
    this->bind = r.bind;
    this->nonceCallerSize = r.nonceCallerSize;
    this->nonceCaller = r.nonceCaller;
    this->encryptedSaltSize = r.encryptedSaltSize;
    this->encryptedSalt = r.encryptedSalt;
    this->sessionType = r.sessionType;
    this->symmetric = r.symmetric;
    this->authHash = r.authHash;
};
/// <summary>
/// This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
/// </summary>
TpmStructureBase* TPM2_StartAuthSession_REQUEST::Clone() const
{
    TPM2_StartAuthSession_REQUEST* _x = new TPM2_StartAuthSession_REQUEST(*this);
    return _x;
};
void* TPM2_StartAuthSession_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&tpmKey); return (void*) (&tpmKey);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&bind); return (void*) (&bind);
            case 2: return (void*) (&nonceCallerSize);
            case 3: { if(newArraySize != -1)nonceCaller.resize(newArraySize); arraySize = (int)nonceCaller.size(); return (void*)(&nonceCaller); }
            case 4: return (void*) (&encryptedSaltSize);
            case 5: { if(newArraySize != -1)encryptedSalt.resize(newArraySize); arraySize = (int)encryptedSalt.size(); return (void*)(&encryptedSalt); }
            case 6: return (void*) (&sessionType);
            case 7: pStruct = dynamic_cast<TpmStructureBase*>(&symmetric); return (void*) (&symmetric);
            case 8: return (void*) (&authHash);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&nonceCaller[arrayIndex]);
            case 5: return (void*)(&encryptedSalt[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId StartAuthSessionResponse::GetTypeId() const
{
    return TpmTypeId::StartAuthSessionResponse_ID;
};
/// <summary>
/// This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
/// </summary>
StartAuthSessionResponse::StartAuthSessionResponse()
{
    return;
};
StartAuthSessionResponse::StartAuthSessionResponse
(
    const TPM_HANDLE& _handle,
    const std::vector<BYTE>& _nonceTPM
)
{
    handle= _handle;
    nonceTPM= _nonceTPM;
};
/// <summary>
/// This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
/// </summary>
StartAuthSessionResponse::~StartAuthSessionResponse()
{
    return;
};
/// <summary>
/// This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
/// </summary>
StartAuthSessionResponse& StartAuthSessionResponse::operator=(const StartAuthSessionResponse& rhs)
{
    if(this == &rhs) return *this;
    this->handle = rhs.handle;
    this->nonceTPMSize = rhs.nonceTPMSize;
    this->nonceTPM = rhs.nonceTPM;
    return *this;
};
/// <summary>
/// This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
/// </summary>
StartAuthSessionResponse::StartAuthSessionResponse(const StartAuthSessionResponse& r)
{
    this->handle = r.handle;
    this->nonceTPMSize = r.nonceTPMSize;
    this->nonceTPM = r.nonceTPM;
};
/// <summary>
/// This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
/// </summary>
TpmStructureBase* StartAuthSessionResponse::Clone() const
{
    StartAuthSessionResponse* _x = new StartAuthSessionResponse(*this);
    return _x;
};
void* StartAuthSessionResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return (void*) (&handle);
            case 1: return (void*) (&nonceTPMSize);
            case 2: { if(newArraySize != -1)nonceTPM.resize(newArraySize); arraySize = (int)nonceTPM.size(); return (void*)(&nonceTPM); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&nonceTPM[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_PolicyRestart_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyRestart_REQUEST_ID;
};
/// <summary>
/// This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
/// </summary>
TPM2_PolicyRestart_REQUEST::TPM2_PolicyRestart_REQUEST()
{
    return;
};
TPM2_PolicyRestart_REQUEST::TPM2_PolicyRestart_REQUEST
(
    const TPM_HANDLE& _sessionHandle
)
{
    sessionHandle= _sessionHandle;
};
/// <summary>
/// This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
/// </summary>
TPM2_PolicyRestart_REQUEST::~TPM2_PolicyRestart_REQUEST()
{
    return;
};
/// <summary>
/// This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
/// </summary>
TPM2_PolicyRestart_REQUEST& TPM2_PolicyRestart_REQUEST::operator=(const TPM2_PolicyRestart_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->sessionHandle = rhs.sessionHandle;
    return *this;
};
/// <summary>
/// This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
/// </summary>
TPM2_PolicyRestart_REQUEST::TPM2_PolicyRestart_REQUEST(const TPM2_PolicyRestart_REQUEST& r)
{
    this->sessionHandle = r.sessionHandle;
};
/// <summary>
/// This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
/// </summary>
TpmStructureBase* TPM2_PolicyRestart_REQUEST::Clone() const
{
    TPM2_PolicyRestart_REQUEST* _x = new TPM2_PolicyRestart_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyRestart_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&sessionHandle); return (void*) (&sessionHandle);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId PolicyRestartResponse::GetTypeId() const
{
    return TpmTypeId::PolicyRestartResponse_ID;
};
/// <summary>
/// This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
/// </summary>
PolicyRestartResponse::PolicyRestartResponse()
{
    return;
};
/// <summary>
/// This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
/// </summary>
PolicyRestartResponse::~PolicyRestartResponse()
{
    return;
};
/// <summary>
/// This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
/// </summary>
PolicyRestartResponse& PolicyRestartResponse::operator=(const PolicyRestartResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
/// </summary>
PolicyRestartResponse::PolicyRestartResponse(const PolicyRestartResponse& r)
{
};
/// <summary>
/// This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
/// </summary>
TpmStructureBase* PolicyRestartResponse::Clone() const
{
    PolicyRestartResponse* _x = new PolicyRestartResponse(*this);
    return _x;
};
void* PolicyRestartResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_Create_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Create_REQUEST_ID;
};
/// <summary>
/// This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
/// </summary>
TPM2_Create_REQUEST::TPM2_Create_REQUEST()
{
    return;
};
TPM2_Create_REQUEST::TPM2_Create_REQUEST
(
    const TPM_HANDLE& _parentHandle,
    const TPMS_SENSITIVE_CREATE& _inSensitive,
    const TPMT_PUBLIC& _inPublic,
    const std::vector<BYTE>& _outsideInfo,
    const std::vector<TPMS_PCR_SELECTION>& _creationPCR
)
{
    parentHandle= _parentHandle;
    inSensitive= _inSensitive;
    inPublic= _inPublic;
    outsideInfo= _outsideInfo;
    creationPCR= _creationPCR;
};
/// <summary>
/// This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
/// </summary>
TPM2_Create_REQUEST::~TPM2_Create_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
/// </summary>
TPM2_Create_REQUEST& TPM2_Create_REQUEST::operator=(const TPM2_Create_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->parentHandle = rhs.parentHandle;
    this->inSensitiveSize = rhs.inSensitiveSize;
    this->inSensitive = rhs.inSensitive;
    this->inPublicSize = rhs.inPublicSize;
    this->inPublic = rhs.inPublic;
    this->outsideInfoSize = rhs.outsideInfoSize;
    this->outsideInfo = rhs.outsideInfo;
    this->creationPCRCount = rhs.creationPCRCount;
    this->creationPCR = rhs.creationPCR;
    return *this;
};
/// <summary>
/// This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
/// </summary>
TPM2_Create_REQUEST::TPM2_Create_REQUEST(const TPM2_Create_REQUEST& r)
{
    this->parentHandle = r.parentHandle;
    this->inSensitiveSize = r.inSensitiveSize;
    this->inSensitive = r.inSensitive;
    this->inPublicSize = r.inPublicSize;
    this->inPublic = r.inPublic;
    this->outsideInfoSize = r.outsideInfoSize;
    this->outsideInfo = r.outsideInfo;
    this->creationPCRCount = r.creationPCRCount;
    this->creationPCR = r.creationPCR;
};
/// <summary>
/// This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
/// </summary>
TpmStructureBase* TPM2_Create_REQUEST::Clone() const
{
    TPM2_Create_REQUEST* _x = new TPM2_Create_REQUEST(*this);
    return _x;
};
void* TPM2_Create_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&parentHandle); return (void*) (&parentHandle);
            case 1: return (void*) (&inSensitiveSize);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&inSensitive); return (void*) (&inSensitive);
            case 3: return (void*) (&inPublicSize);
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&inPublic); return (void*) (&inPublic);
            case 5: return (void*) (&outsideInfoSize);
            case 6: { if(newArraySize != -1)outsideInfo.resize(newArraySize); arraySize = (int)outsideInfo.size(); return (void*)(&outsideInfo); }
            case 7: return (void*) (&creationPCRCount);
            case 8: { if(newArraySize != -1)creationPCR.resize(newArraySize); arraySize = (int)creationPCR.size(); return (void*)(&creationPCR); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 6: return (void*)(&outsideInfo[arrayIndex]);
            case 8: pStruct = dynamic_cast<TpmStructureBase*>(&creationPCR[arrayIndex]);return (void*)(&creationPCR[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId CreateResponse::GetTypeId() const
{
    return TpmTypeId::CreateResponse_ID;
};
/// <summary>
/// This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
/// </summary>
CreateResponse::CreateResponse()
{
    return;
};
CreateResponse::CreateResponse
(
    const TPM2B_PRIVATE& _outPrivate,
    const TPMT_PUBLIC& _outPublic,
    const TPMS_CREATION_DATA& _creationData,
    const std::vector<BYTE>& _creationHash,
    const TPMT_TK_CREATION& _creationTicket
)
{
    outPrivate= _outPrivate;
    outPublic= _outPublic;
    creationData= _creationData;
    creationHash= _creationHash;
    creationTicket= _creationTicket;
};
/// <summary>
/// This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
/// </summary>
CreateResponse::~CreateResponse()
{
    return;
};
/// <summary>
/// This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
/// </summary>
CreateResponse& CreateResponse::operator=(const CreateResponse& rhs)
{
    if(this == &rhs) return *this;
    this->outPrivate = rhs.outPrivate;
    this->outPublicSize = rhs.outPublicSize;
    this->outPublic = rhs.outPublic;
    this->creationDataSize = rhs.creationDataSize;
    this->creationData = rhs.creationData;
    this->creationHashSize = rhs.creationHashSize;
    this->creationHash = rhs.creationHash;
    this->creationTicket = rhs.creationTicket;
    return *this;
};
/// <summary>
/// This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
/// </summary>
CreateResponse::CreateResponse(const CreateResponse& r)
{
    this->outPrivate = r.outPrivate;
    this->outPublicSize = r.outPublicSize;
    this->outPublic = r.outPublic;
    this->creationDataSize = r.creationDataSize;
    this->creationData = r.creationData;
    this->creationHashSize = r.creationHashSize;
    this->creationHash = r.creationHash;
    this->creationTicket = r.creationTicket;
};
/// <summary>
/// This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
/// </summary>
TpmStructureBase* CreateResponse::Clone() const
{
    CreateResponse* _x = new CreateResponse(*this);
    return _x;
};
void* CreateResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&outPrivate); return (void*) (&outPrivate);
            case 1: return (void*) (&outPublicSize);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&outPublic); return (void*) (&outPublic);
            case 3: return (void*) (&creationDataSize);
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&creationData); return (void*) (&creationData);
            case 5: return (void*) (&creationHashSize);
            case 6: { if(newArraySize != -1)creationHash.resize(newArraySize); arraySize = (int)creationHash.size(); return (void*)(&creationHash); }
            case 7: pStruct = dynamic_cast<TpmStructureBase*>(&creationTicket); return (void*) (&creationTicket);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 6: return (void*)(&creationHash[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_Load_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Load_REQUEST_ID;
};
/// <summary>
/// This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
/// </summary>
TPM2_Load_REQUEST::TPM2_Load_REQUEST()
{
    return;
};
TPM2_Load_REQUEST::TPM2_Load_REQUEST
(
    const TPM_HANDLE& _parentHandle,
    const TPM2B_PRIVATE& _inPrivate,
    const TPMT_PUBLIC& _inPublic
)
{
    parentHandle= _parentHandle;
    inPrivate= _inPrivate;
    inPublic= _inPublic;
};
/// <summary>
/// This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
/// </summary>
TPM2_Load_REQUEST::~TPM2_Load_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
/// </summary>
TPM2_Load_REQUEST& TPM2_Load_REQUEST::operator=(const TPM2_Load_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->parentHandle = rhs.parentHandle;
    this->inPrivate = rhs.inPrivate;
    this->inPublicSize = rhs.inPublicSize;
    this->inPublic = rhs.inPublic;
    return *this;
};
/// <summary>
/// This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
/// </summary>
TPM2_Load_REQUEST::TPM2_Load_REQUEST(const TPM2_Load_REQUEST& r)
{
    this->parentHandle = r.parentHandle;
    this->inPrivate = r.inPrivate;
    this->inPublicSize = r.inPublicSize;
    this->inPublic = r.inPublic;
};
/// <summary>
/// This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
/// </summary>
TpmStructureBase* TPM2_Load_REQUEST::Clone() const
{
    TPM2_Load_REQUEST* _x = new TPM2_Load_REQUEST(*this);
    return _x;
};
void* TPM2_Load_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&parentHandle); return (void*) (&parentHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&inPrivate); return (void*) (&inPrivate);
            case 2: return (void*) (&inPublicSize);
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&inPublic); return (void*) (&inPublic);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId LoadResponse::GetTypeId() const
{
    return TpmTypeId::LoadResponse_ID;
};
/// <summary>
/// This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
/// </summary>
LoadResponse::LoadResponse()
{
    return;
};
LoadResponse::LoadResponse
(
    const TPM_HANDLE& _handle,
    const std::vector<BYTE>& _name
)
{
    handle= _handle;
    name= _name;
};
/// <summary>
/// This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
/// </summary>
LoadResponse::~LoadResponse()
{
    return;
};
/// <summary>
/// This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
/// </summary>
LoadResponse& LoadResponse::operator=(const LoadResponse& rhs)
{
    if(this == &rhs) return *this;
    this->handle = rhs.handle;
    this->nameSize = rhs.nameSize;
    this->name = rhs.name;
    return *this;
};
/// <summary>
/// This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
/// </summary>
LoadResponse::LoadResponse(const LoadResponse& r)
{
    this->handle = r.handle;
    this->nameSize = r.nameSize;
    this->name = r.name;
};
/// <summary>
/// This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
/// </summary>
TpmStructureBase* LoadResponse::Clone() const
{
    LoadResponse* _x = new LoadResponse(*this);
    return _x;
};
void* LoadResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return (void*) (&handle);
            case 1: return (void*) (&nameSize);
            case 2: { if(newArraySize != -1)name.resize(newArraySize); arraySize = (int)name.size(); return (void*)(&name); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&name[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_LoadExternal_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_LoadExternal_REQUEST_ID;
};
/// <summary>
/// This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
/// </summary>
TPM2_LoadExternal_REQUEST::TPM2_LoadExternal_REQUEST()
{
    return;
};
TPM2_LoadExternal_REQUEST::TPM2_LoadExternal_REQUEST
(
    const TPMT_SENSITIVE& _inPrivate,
    const TPMT_PUBLIC& _inPublic,
    const TPM_HANDLE& _hierarchy
)
{
    inPrivate= _inPrivate;
    inPublic= _inPublic;
    hierarchy= _hierarchy;
};
/// <summary>
/// This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
/// </summary>
TPM2_LoadExternal_REQUEST::~TPM2_LoadExternal_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
/// </summary>
TPM2_LoadExternal_REQUEST& TPM2_LoadExternal_REQUEST::operator=(const TPM2_LoadExternal_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->inPrivateSize = rhs.inPrivateSize;
    this->inPrivate = rhs.inPrivate;
    this->inPublicSize = rhs.inPublicSize;
    this->inPublic = rhs.inPublic;
    this->hierarchy = rhs.hierarchy;
    return *this;
};
/// <summary>
/// This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
/// </summary>
TPM2_LoadExternal_REQUEST::TPM2_LoadExternal_REQUEST(const TPM2_LoadExternal_REQUEST& r)
{
    this->inPrivateSize = r.inPrivateSize;
    this->inPrivate = r.inPrivate;
    this->inPublicSize = r.inPublicSize;
    this->inPublic = r.inPublic;
    this->hierarchy = r.hierarchy;
};
/// <summary>
/// This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
/// </summary>
TpmStructureBase* TPM2_LoadExternal_REQUEST::Clone() const
{
    TPM2_LoadExternal_REQUEST* _x = new TPM2_LoadExternal_REQUEST(*this);
    return _x;
};
void* TPM2_LoadExternal_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&inPrivateSize);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&inPrivate); return (void*) (&inPrivate);
            case 2: return (void*) (&inPublicSize);
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&inPublic); return (void*) (&inPublic);
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return (void*) (&hierarchy);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId LoadExternalResponse::GetTypeId() const
{
    return TpmTypeId::LoadExternalResponse_ID;
};
/// <summary>
/// This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
/// </summary>
LoadExternalResponse::LoadExternalResponse()
{
    return;
};
LoadExternalResponse::LoadExternalResponse
(
    const TPM_HANDLE& _handle,
    const std::vector<BYTE>& _name
)
{
    handle= _handle;
    name= _name;
};
/// <summary>
/// This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
/// </summary>
LoadExternalResponse::~LoadExternalResponse()
{
    return;
};
/// <summary>
/// This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
/// </summary>
LoadExternalResponse& LoadExternalResponse::operator=(const LoadExternalResponse& rhs)
{
    if(this == &rhs) return *this;
    this->handle = rhs.handle;
    this->nameSize = rhs.nameSize;
    this->name = rhs.name;
    return *this;
};
/// <summary>
/// This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
/// </summary>
LoadExternalResponse::LoadExternalResponse(const LoadExternalResponse& r)
{
    this->handle = r.handle;
    this->nameSize = r.nameSize;
    this->name = r.name;
};
/// <summary>
/// This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
/// </summary>
TpmStructureBase* LoadExternalResponse::Clone() const
{
    LoadExternalResponse* _x = new LoadExternalResponse(*this);
    return _x;
};
void* LoadExternalResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return (void*) (&handle);
            case 1: return (void*) (&nameSize);
            case 2: { if(newArraySize != -1)name.resize(newArraySize); arraySize = (int)name.size(); return (void*)(&name); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&name[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_ReadPublic_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ReadPublic_REQUEST_ID;
};
/// <summary>
/// This command allows access to the public area of a loaded object.
/// </summary>
TPM2_ReadPublic_REQUEST::TPM2_ReadPublic_REQUEST()
{
    return;
};
TPM2_ReadPublic_REQUEST::TPM2_ReadPublic_REQUEST
(
    const TPM_HANDLE& _objectHandle
)
{
    objectHandle= _objectHandle;
};
/// <summary>
/// This command allows access to the public area of a loaded object.
/// </summary>
TPM2_ReadPublic_REQUEST::~TPM2_ReadPublic_REQUEST()
{
    return;
};
/// <summary>
/// This command allows access to the public area of a loaded object.
/// </summary>
TPM2_ReadPublic_REQUEST& TPM2_ReadPublic_REQUEST::operator=(const TPM2_ReadPublic_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->objectHandle = rhs.objectHandle;
    return *this;
};
/// <summary>
/// This command allows access to the public area of a loaded object.
/// </summary>
TPM2_ReadPublic_REQUEST::TPM2_ReadPublic_REQUEST(const TPM2_ReadPublic_REQUEST& r)
{
    this->objectHandle = r.objectHandle;
};
/// <summary>
/// This command allows access to the public area of a loaded object.
/// </summary>
TpmStructureBase* TPM2_ReadPublic_REQUEST::Clone() const
{
    TPM2_ReadPublic_REQUEST* _x = new TPM2_ReadPublic_REQUEST(*this);
    return _x;
};
void* TPM2_ReadPublic_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return (void*) (&objectHandle);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId ReadPublicResponse::GetTypeId() const
{
    return TpmTypeId::ReadPublicResponse_ID;
};
/// <summary>
/// This command allows access to the public area of a loaded object.
/// </summary>
ReadPublicResponse::ReadPublicResponse()
{
    return;
};
ReadPublicResponse::ReadPublicResponse
(
    const TPMT_PUBLIC& _outPublic,
    const std::vector<BYTE>& _name,
    const std::vector<BYTE>& _qualifiedName
)
{
    outPublic= _outPublic;
    name= _name;
    qualifiedName= _qualifiedName;
};
/// <summary>
/// This command allows access to the public area of a loaded object.
/// </summary>
ReadPublicResponse::~ReadPublicResponse()
{
    return;
};
/// <summary>
/// This command allows access to the public area of a loaded object.
/// </summary>
ReadPublicResponse& ReadPublicResponse::operator=(const ReadPublicResponse& rhs)
{
    if(this == &rhs) return *this;
    this->outPublicSize = rhs.outPublicSize;
    this->outPublic = rhs.outPublic;
    this->nameSize = rhs.nameSize;
    this->name = rhs.name;
    this->qualifiedNameSize = rhs.qualifiedNameSize;
    this->qualifiedName = rhs.qualifiedName;
    return *this;
};
/// <summary>
/// This command allows access to the public area of a loaded object.
/// </summary>
ReadPublicResponse::ReadPublicResponse(const ReadPublicResponse& r)
{
    this->outPublicSize = r.outPublicSize;
    this->outPublic = r.outPublic;
    this->nameSize = r.nameSize;
    this->name = r.name;
    this->qualifiedNameSize = r.qualifiedNameSize;
    this->qualifiedName = r.qualifiedName;
};
/// <summary>
/// This command allows access to the public area of a loaded object.
/// </summary>
TpmStructureBase* ReadPublicResponse::Clone() const
{
    ReadPublicResponse* _x = new ReadPublicResponse(*this);
    return _x;
};
void* ReadPublicResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&outPublicSize);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&outPublic); return (void*) (&outPublic);
            case 2: return (void*) (&nameSize);
            case 3: { if(newArraySize != -1)name.resize(newArraySize); arraySize = (int)name.size(); return (void*)(&name); }
            case 4: return (void*) (&qualifiedNameSize);
            case 5: { if(newArraySize != -1)qualifiedName.resize(newArraySize); arraySize = (int)qualifiedName.size(); return (void*)(&qualifiedName); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&name[arrayIndex]);
            case 5: return (void*)(&qualifiedName[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_ActivateCredential_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
};
/// <summary>
/// This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
/// </summary>
TPM2_ActivateCredential_REQUEST::TPM2_ActivateCredential_REQUEST()
{
    return;
};
TPM2_ActivateCredential_REQUEST::TPM2_ActivateCredential_REQUEST
(
    const TPM_HANDLE& _activateHandle,
    const TPM_HANDLE& _keyHandle,
    const TPMS_ID_OBJECT& _credentialBlob,
    const std::vector<BYTE>& _secret
)
{
    activateHandle= _activateHandle;
    keyHandle= _keyHandle;
    credentialBlob= _credentialBlob;
    secret= _secret;
};
/// <summary>
/// This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
/// </summary>
TPM2_ActivateCredential_REQUEST::~TPM2_ActivateCredential_REQUEST()
{
    return;
};
/// <summary>
/// This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
/// </summary>
TPM2_ActivateCredential_REQUEST& TPM2_ActivateCredential_REQUEST::operator=(const TPM2_ActivateCredential_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->activateHandle = rhs.activateHandle;
    this->keyHandle = rhs.keyHandle;
    this->credentialBlobSize = rhs.credentialBlobSize;
    this->credentialBlob = rhs.credentialBlob;
    this->secretSize = rhs.secretSize;
    this->secret = rhs.secret;
    return *this;
};
/// <summary>
/// This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
/// </summary>
TPM2_ActivateCredential_REQUEST::TPM2_ActivateCredential_REQUEST(const TPM2_ActivateCredential_REQUEST& r)
{
    this->activateHandle = r.activateHandle;
    this->keyHandle = r.keyHandle;
    this->credentialBlobSize = r.credentialBlobSize;
    this->credentialBlob = r.credentialBlob;
    this->secretSize = r.secretSize;
    this->secret = r.secret;
};
/// <summary>
/// This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
/// </summary>
TpmStructureBase* TPM2_ActivateCredential_REQUEST::Clone() const
{
    TPM2_ActivateCredential_REQUEST* _x = new TPM2_ActivateCredential_REQUEST(*this);
    return _x;
};
void* TPM2_ActivateCredential_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&activateHandle); return (void*) (&activateHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return (void*) (&keyHandle);
            case 2: return (void*) (&credentialBlobSize);
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&credentialBlob); return (void*) (&credentialBlob);
            case 4: return (void*) (&secretSize);
            case 5: { if(newArraySize != -1)secret.resize(newArraySize); arraySize = (int)secret.size(); return (void*)(&secret); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 5: return (void*)(&secret[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId ActivateCredentialResponse::GetTypeId() const
{
    return TpmTypeId::ActivateCredentialResponse_ID;
};
/// <summary>
/// This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
/// </summary>
ActivateCredentialResponse::ActivateCredentialResponse()
{
    return;
};
ActivateCredentialResponse::ActivateCredentialResponse
(
    const std::vector<BYTE>& _certInfo
)
{
    certInfo= _certInfo;
};
/// <summary>
/// This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
/// </summary>
ActivateCredentialResponse::~ActivateCredentialResponse()
{
    return;
};
/// <summary>
/// This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
/// </summary>
ActivateCredentialResponse& ActivateCredentialResponse::operator=(const ActivateCredentialResponse& rhs)
{
    if(this == &rhs) return *this;
    this->certInfoSize = rhs.certInfoSize;
    this->certInfo = rhs.certInfo;
    return *this;
};
/// <summary>
/// This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
/// </summary>
ActivateCredentialResponse::ActivateCredentialResponse(const ActivateCredentialResponse& r)
{
    this->certInfoSize = r.certInfoSize;
    this->certInfo = r.certInfo;
};
/// <summary>
/// This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
/// </summary>
TpmStructureBase* ActivateCredentialResponse::Clone() const
{
    ActivateCredentialResponse* _x = new ActivateCredentialResponse(*this);
    return _x;
};
void* ActivateCredentialResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&certInfoSize);
            case 1: { if(newArraySize != -1)certInfo.resize(newArraySize); arraySize = (int)certInfo.size(); return (void*)(&certInfo); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&certInfo[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_MakeCredential_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_MakeCredential_REQUEST_ID;
};
/// <summary>
/// This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
/// </summary>
TPM2_MakeCredential_REQUEST::TPM2_MakeCredential_REQUEST()
{
    return;
};
TPM2_MakeCredential_REQUEST::TPM2_MakeCredential_REQUEST
(
    const TPM_HANDLE& _handle,
    const std::vector<BYTE>& _credential,
    const std::vector<BYTE>& _objectName
)
{
    handle= _handle;
    credential= _credential;
    objectName= _objectName;
};
/// <summary>
/// This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
/// </summary>
TPM2_MakeCredential_REQUEST::~TPM2_MakeCredential_REQUEST()
{
    return;
};
/// <summary>
/// This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
/// </summary>
TPM2_MakeCredential_REQUEST& TPM2_MakeCredential_REQUEST::operator=(const TPM2_MakeCredential_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->handle = rhs.handle;
    this->credentialSize = rhs.credentialSize;
    this->credential = rhs.credential;
    this->objectNameSize = rhs.objectNameSize;
    this->objectName = rhs.objectName;
    return *this;
};
/// <summary>
/// This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
/// </summary>
TPM2_MakeCredential_REQUEST::TPM2_MakeCredential_REQUEST(const TPM2_MakeCredential_REQUEST& r)
{
    this->handle = r.handle;
    this->credentialSize = r.credentialSize;
    this->credential = r.credential;
    this->objectNameSize = r.objectNameSize;
    this->objectName = r.objectName;
};
/// <summary>
/// This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
/// </summary>
TpmStructureBase* TPM2_MakeCredential_REQUEST::Clone() const
{
    TPM2_MakeCredential_REQUEST* _x = new TPM2_MakeCredential_REQUEST(*this);
    return _x;
};
void* TPM2_MakeCredential_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return (void*) (&handle);
            case 1: return (void*) (&credentialSize);
            case 2: { if(newArraySize != -1)credential.resize(newArraySize); arraySize = (int)credential.size(); return (void*)(&credential); }
            case 3: return (void*) (&objectNameSize);
            case 4: { if(newArraySize != -1)objectName.resize(newArraySize); arraySize = (int)objectName.size(); return (void*)(&objectName); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&credential[arrayIndex]);
            case 4: return (void*)(&objectName[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId MakeCredentialResponse::GetTypeId() const
{
    return TpmTypeId::MakeCredentialResponse_ID;
};
/// <summary>
/// This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
/// </summary>
MakeCredentialResponse::MakeCredentialResponse()
{
    return;
};
MakeCredentialResponse::MakeCredentialResponse
(
    const TPMS_ID_OBJECT& _credentialBlob,
    const std::vector<BYTE>& _secret
)
{
    credentialBlob= _credentialBlob;
    secret= _secret;
};
/// <summary>
/// This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
/// </summary>
MakeCredentialResponse::~MakeCredentialResponse()
{
    return;
};
/// <summary>
/// This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
/// </summary>
MakeCredentialResponse& MakeCredentialResponse::operator=(const MakeCredentialResponse& rhs)
{
    if(this == &rhs) return *this;
    this->credentialBlobSize = rhs.credentialBlobSize;
    this->credentialBlob = rhs.credentialBlob;
    this->secretSize = rhs.secretSize;
    this->secret = rhs.secret;
    return *this;
};
/// <summary>
/// This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
/// </summary>
MakeCredentialResponse::MakeCredentialResponse(const MakeCredentialResponse& r)
{
    this->credentialBlobSize = r.credentialBlobSize;
    this->credentialBlob = r.credentialBlob;
    this->secretSize = r.secretSize;
    this->secret = r.secret;
};
/// <summary>
/// This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
/// </summary>
TpmStructureBase* MakeCredentialResponse::Clone() const
{
    MakeCredentialResponse* _x = new MakeCredentialResponse(*this);
    return _x;
};
void* MakeCredentialResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&credentialBlobSize);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&credentialBlob); return (void*) (&credentialBlob);
            case 2: return (void*) (&secretSize);
            case 3: { if(newArraySize != -1)secret.resize(newArraySize); arraySize = (int)secret.size(); return (void*)(&secret); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&secret[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_Unseal_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Unseal_REQUEST_ID;
};
/// <summary>
/// This command returns the data in a loaded Sealed Data Object.
/// </summary>
TPM2_Unseal_REQUEST::TPM2_Unseal_REQUEST()
{
    return;
};
TPM2_Unseal_REQUEST::TPM2_Unseal_REQUEST
(
    const TPM_HANDLE& _itemHandle
)
{
    itemHandle= _itemHandle;
};
/// <summary>
/// This command returns the data in a loaded Sealed Data Object.
/// </summary>
TPM2_Unseal_REQUEST::~TPM2_Unseal_REQUEST()
{
    return;
};
/// <summary>
/// This command returns the data in a loaded Sealed Data Object.
/// </summary>
TPM2_Unseal_REQUEST& TPM2_Unseal_REQUEST::operator=(const TPM2_Unseal_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->itemHandle = rhs.itemHandle;
    return *this;
};
/// <summary>
/// This command returns the data in a loaded Sealed Data Object.
/// </summary>
TPM2_Unseal_REQUEST::TPM2_Unseal_REQUEST(const TPM2_Unseal_REQUEST& r)
{
    this->itemHandle = r.itemHandle;
};
/// <summary>
/// This command returns the data in a loaded Sealed Data Object.
/// </summary>
TpmStructureBase* TPM2_Unseal_REQUEST::Clone() const
{
    TPM2_Unseal_REQUEST* _x = new TPM2_Unseal_REQUEST(*this);
    return _x;
};
void* TPM2_Unseal_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&itemHandle); return (void*) (&itemHandle);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId UnsealResponse::GetTypeId() const
{
    return TpmTypeId::UnsealResponse_ID;
};
/// <summary>
/// This command returns the data in a loaded Sealed Data Object.
/// </summary>
UnsealResponse::UnsealResponse()
{
    return;
};
UnsealResponse::UnsealResponse
(
    const std::vector<BYTE>& _outData
)
{
    outData= _outData;
};
/// <summary>
/// This command returns the data in a loaded Sealed Data Object.
/// </summary>
UnsealResponse::~UnsealResponse()
{
    return;
};
/// <summary>
/// This command returns the data in a loaded Sealed Data Object.
/// </summary>
UnsealResponse& UnsealResponse::operator=(const UnsealResponse& rhs)
{
    if(this == &rhs) return *this;
    this->outDataSize = rhs.outDataSize;
    this->outData = rhs.outData;
    return *this;
};
/// <summary>
/// This command returns the data in a loaded Sealed Data Object.
/// </summary>
UnsealResponse::UnsealResponse(const UnsealResponse& r)
{
    this->outDataSize = r.outDataSize;
    this->outData = r.outData;
};
/// <summary>
/// This command returns the data in a loaded Sealed Data Object.
/// </summary>
TpmStructureBase* UnsealResponse::Clone() const
{
    UnsealResponse* _x = new UnsealResponse(*this);
    return _x;
};
void* UnsealResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&outDataSize);
            case 1: { if(newArraySize != -1)outData.resize(newArraySize); arraySize = (int)outData.size(); return (void*)(&outData); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&outData[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_ObjectChangeAuth_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID;
};
/// <summary>
/// This command is used to change the authorization secret for a TPM-resident object.
/// </summary>
TPM2_ObjectChangeAuth_REQUEST::TPM2_ObjectChangeAuth_REQUEST()
{
    return;
};
TPM2_ObjectChangeAuth_REQUEST::TPM2_ObjectChangeAuth_REQUEST
(
    const TPM_HANDLE& _objectHandle,
    const TPM_HANDLE& _parentHandle,
    const std::vector<BYTE>& _newAuth
)
{
    objectHandle= _objectHandle;
    parentHandle= _parentHandle;
    newAuth= _newAuth;
};
/// <summary>
/// This command is used to change the authorization secret for a TPM-resident object.
/// </summary>
TPM2_ObjectChangeAuth_REQUEST::~TPM2_ObjectChangeAuth_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to change the authorization secret for a TPM-resident object.
/// </summary>
TPM2_ObjectChangeAuth_REQUEST& TPM2_ObjectChangeAuth_REQUEST::operator=(const TPM2_ObjectChangeAuth_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->objectHandle = rhs.objectHandle;
    this->parentHandle = rhs.parentHandle;
    this->newAuthSize = rhs.newAuthSize;
    this->newAuth = rhs.newAuth;
    return *this;
};
/// <summary>
/// This command is used to change the authorization secret for a TPM-resident object.
/// </summary>
TPM2_ObjectChangeAuth_REQUEST::TPM2_ObjectChangeAuth_REQUEST(const TPM2_ObjectChangeAuth_REQUEST& r)
{
    this->objectHandle = r.objectHandle;
    this->parentHandle = r.parentHandle;
    this->newAuthSize = r.newAuthSize;
    this->newAuth = r.newAuth;
};
/// <summary>
/// This command is used to change the authorization secret for a TPM-resident object.
/// </summary>
TpmStructureBase* TPM2_ObjectChangeAuth_REQUEST::Clone() const
{
    TPM2_ObjectChangeAuth_REQUEST* _x = new TPM2_ObjectChangeAuth_REQUEST(*this);
    return _x;
};
void* TPM2_ObjectChangeAuth_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return (void*) (&objectHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&parentHandle); return (void*) (&parentHandle);
            case 2: return (void*) (&newAuthSize);
            case 3: { if(newArraySize != -1)newAuth.resize(newArraySize); arraySize = (int)newAuth.size(); return (void*)(&newAuth); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&newAuth[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId ObjectChangeAuthResponse::GetTypeId() const
{
    return TpmTypeId::ObjectChangeAuthResponse_ID;
};
/// <summary>
/// This command is used to change the authorization secret for a TPM-resident object.
/// </summary>
ObjectChangeAuthResponse::ObjectChangeAuthResponse()
{
    return;
};
ObjectChangeAuthResponse::ObjectChangeAuthResponse
(
    const TPM2B_PRIVATE& _outPrivate
)
{
    outPrivate= _outPrivate;
};
/// <summary>
/// This command is used to change the authorization secret for a TPM-resident object.
/// </summary>
ObjectChangeAuthResponse::~ObjectChangeAuthResponse()
{
    return;
};
/// <summary>
/// This command is used to change the authorization secret for a TPM-resident object.
/// </summary>
ObjectChangeAuthResponse& ObjectChangeAuthResponse::operator=(const ObjectChangeAuthResponse& rhs)
{
    if(this == &rhs) return *this;
    this->outPrivate = rhs.outPrivate;
    return *this;
};
/// <summary>
/// This command is used to change the authorization secret for a TPM-resident object.
/// </summary>
ObjectChangeAuthResponse::ObjectChangeAuthResponse(const ObjectChangeAuthResponse& r)
{
    this->outPrivate = r.outPrivate;
};
/// <summary>
/// This command is used to change the authorization secret for a TPM-resident object.
/// </summary>
TpmStructureBase* ObjectChangeAuthResponse::Clone() const
{
    ObjectChangeAuthResponse* _x = new ObjectChangeAuthResponse(*this);
    return _x;
};
void* ObjectChangeAuthResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&outPrivate); return (void*) (&outPrivate);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_CreateLoaded_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_CreateLoaded_REQUEST_ID;
};
/// <summary>
/// This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
/// </summary>
TPM2_CreateLoaded_REQUEST::TPM2_CreateLoaded_REQUEST()
{
    return;
};
TPM2_CreateLoaded_REQUEST::TPM2_CreateLoaded_REQUEST
(
    const TPM_HANDLE& _parentHandle,
    const TPMS_SENSITIVE_CREATE& _inSensitive,
    const std::vector<BYTE>& _inPublic
)
{
    parentHandle= _parentHandle;
    inSensitive= _inSensitive;
    inPublic= _inPublic;
};
/// <summary>
/// This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
/// </summary>
TPM2_CreateLoaded_REQUEST::~TPM2_CreateLoaded_REQUEST()
{
    return;
};
/// <summary>
/// This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
/// </summary>
TPM2_CreateLoaded_REQUEST& TPM2_CreateLoaded_REQUEST::operator=(const TPM2_CreateLoaded_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->parentHandle = rhs.parentHandle;
    this->inSensitiveSize = rhs.inSensitiveSize;
    this->inSensitive = rhs.inSensitive;
    this->inPublicSize = rhs.inPublicSize;
    this->inPublic = rhs.inPublic;
    return *this;
};
/// <summary>
/// This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
/// </summary>
TPM2_CreateLoaded_REQUEST::TPM2_CreateLoaded_REQUEST(const TPM2_CreateLoaded_REQUEST& r)
{
    this->parentHandle = r.parentHandle;
    this->inSensitiveSize = r.inSensitiveSize;
    this->inSensitive = r.inSensitive;
    this->inPublicSize = r.inPublicSize;
    this->inPublic = r.inPublic;
};
/// <summary>
/// This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
/// </summary>
TpmStructureBase* TPM2_CreateLoaded_REQUEST::Clone() const
{
    TPM2_CreateLoaded_REQUEST* _x = new TPM2_CreateLoaded_REQUEST(*this);
    return _x;
};
void* TPM2_CreateLoaded_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&parentHandle); return (void*) (&parentHandle);
            case 1: return (void*) (&inSensitiveSize);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&inSensitive); return (void*) (&inSensitive);
            case 3: return (void*) (&inPublicSize);
            case 4: { if(newArraySize != -1)inPublic.resize(newArraySize); arraySize = (int)inPublic.size(); return (void*)(&inPublic); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 4: return (void*)(&inPublic[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId CreateLoadedResponse::GetTypeId() const
{
    return TpmTypeId::CreateLoadedResponse_ID;
};
/// <summary>
/// This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
/// </summary>
CreateLoadedResponse::CreateLoadedResponse()
{
    return;
};
CreateLoadedResponse::CreateLoadedResponse
(
    const TPM_HANDLE& _handle,
    const TPM2B_PRIVATE& _outPrivate,
    const TPMT_PUBLIC& _outPublic,
    const std::vector<BYTE>& _name
)
{
    handle= _handle;
    outPrivate= _outPrivate;
    outPublic= _outPublic;
    name= _name;
};
/// <summary>
/// This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
/// </summary>
CreateLoadedResponse::~CreateLoadedResponse()
{
    return;
};
/// <summary>
/// This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
/// </summary>
CreateLoadedResponse& CreateLoadedResponse::operator=(const CreateLoadedResponse& rhs)
{
    if(this == &rhs) return *this;
    this->handle = rhs.handle;
    this->outPrivate = rhs.outPrivate;
    this->outPublicSize = rhs.outPublicSize;
    this->outPublic = rhs.outPublic;
    this->nameSize = rhs.nameSize;
    this->name = rhs.name;
    return *this;
};
/// <summary>
/// This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
/// </summary>
CreateLoadedResponse::CreateLoadedResponse(const CreateLoadedResponse& r)
{
    this->handle = r.handle;
    this->outPrivate = r.outPrivate;
    this->outPublicSize = r.outPublicSize;
    this->outPublic = r.outPublic;
    this->nameSize = r.nameSize;
    this->name = r.name;
};
/// <summary>
/// This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
/// </summary>
TpmStructureBase* CreateLoadedResponse::Clone() const
{
    CreateLoadedResponse* _x = new CreateLoadedResponse(*this);
    return _x;
};
void* CreateLoadedResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return (void*) (&handle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&outPrivate); return (void*) (&outPrivate);
            case 2: return (void*) (&outPublicSize);
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&outPublic); return (void*) (&outPublic);
            case 4: return (void*) (&nameSize);
            case 5: { if(newArraySize != -1)name.resize(newArraySize); arraySize = (int)name.size(); return (void*)(&name); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 5: return (void*)(&name[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_Duplicate_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Duplicate_REQUEST_ID;
};
/// <summary>
/// This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
/// </summary>
TPM2_Duplicate_REQUEST::TPM2_Duplicate_REQUEST()
{
    return;
};
TPM2_Duplicate_REQUEST::TPM2_Duplicate_REQUEST
(
    const TPM_HANDLE& _objectHandle,
    const TPM_HANDLE& _newParentHandle,
    const std::vector<BYTE>& _encryptionKeyIn,
    const TPMT_SYM_DEF_OBJECT& _symmetricAlg
)
{
    objectHandle= _objectHandle;
    newParentHandle= _newParentHandle;
    encryptionKeyIn= _encryptionKeyIn;
    symmetricAlg= _symmetricAlg;
};
/// <summary>
/// This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
/// </summary>
TPM2_Duplicate_REQUEST::~TPM2_Duplicate_REQUEST()
{
    return;
};
/// <summary>
/// This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
/// </summary>
TPM2_Duplicate_REQUEST& TPM2_Duplicate_REQUEST::operator=(const TPM2_Duplicate_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->objectHandle = rhs.objectHandle;
    this->newParentHandle = rhs.newParentHandle;
    this->encryptionKeyInSize = rhs.encryptionKeyInSize;
    this->encryptionKeyIn = rhs.encryptionKeyIn;
    this->symmetricAlg = rhs.symmetricAlg;
    return *this;
};
/// <summary>
/// This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
/// </summary>
TPM2_Duplicate_REQUEST::TPM2_Duplicate_REQUEST(const TPM2_Duplicate_REQUEST& r)
{
    this->objectHandle = r.objectHandle;
    this->newParentHandle = r.newParentHandle;
    this->encryptionKeyInSize = r.encryptionKeyInSize;
    this->encryptionKeyIn = r.encryptionKeyIn;
    this->symmetricAlg = r.symmetricAlg;
};
/// <summary>
/// This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
/// </summary>
TpmStructureBase* TPM2_Duplicate_REQUEST::Clone() const
{
    TPM2_Duplicate_REQUEST* _x = new TPM2_Duplicate_REQUEST(*this);
    return _x;
};
void* TPM2_Duplicate_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return (void*) (&objectHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&newParentHandle); return (void*) (&newParentHandle);
            case 2: return (void*) (&encryptionKeyInSize);
            case 3: { if(newArraySize != -1)encryptionKeyIn.resize(newArraySize); arraySize = (int)encryptionKeyIn.size(); return (void*)(&encryptionKeyIn); }
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&symmetricAlg); return (void*) (&symmetricAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&encryptionKeyIn[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId DuplicateResponse::GetTypeId() const
{
    return TpmTypeId::DuplicateResponse_ID;
};
/// <summary>
/// This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
/// </summary>
DuplicateResponse::DuplicateResponse()
{
    return;
};
DuplicateResponse::DuplicateResponse
(
    const std::vector<BYTE>& _encryptionKeyOut,
    const TPM2B_PRIVATE& _duplicate,
    const std::vector<BYTE>& _outSymSeed
)
{
    encryptionKeyOut= _encryptionKeyOut;
    duplicate= _duplicate;
    outSymSeed= _outSymSeed;
};
/// <summary>
/// This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
/// </summary>
DuplicateResponse::~DuplicateResponse()
{
    return;
};
/// <summary>
/// This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
/// </summary>
DuplicateResponse& DuplicateResponse::operator=(const DuplicateResponse& rhs)
{
    if(this == &rhs) return *this;
    this->encryptionKeyOutSize = rhs.encryptionKeyOutSize;
    this->encryptionKeyOut = rhs.encryptionKeyOut;
    this->duplicate = rhs.duplicate;
    this->outSymSeedSize = rhs.outSymSeedSize;
    this->outSymSeed = rhs.outSymSeed;
    return *this;
};
/// <summary>
/// This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
/// </summary>
DuplicateResponse::DuplicateResponse(const DuplicateResponse& r)
{
    this->encryptionKeyOutSize = r.encryptionKeyOutSize;
    this->encryptionKeyOut = r.encryptionKeyOut;
    this->duplicate = r.duplicate;
    this->outSymSeedSize = r.outSymSeedSize;
    this->outSymSeed = r.outSymSeed;
};
/// <summary>
/// This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
/// </summary>
TpmStructureBase* DuplicateResponse::Clone() const
{
    DuplicateResponse* _x = new DuplicateResponse(*this);
    return _x;
};
void* DuplicateResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&encryptionKeyOutSize);
            case 1: { if(newArraySize != -1)encryptionKeyOut.resize(newArraySize); arraySize = (int)encryptionKeyOut.size(); return (void*)(&encryptionKeyOut); }
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&duplicate); return (void*) (&duplicate);
            case 3: return (void*) (&outSymSeedSize);
            case 4: { if(newArraySize != -1)outSymSeed.resize(newArraySize); arraySize = (int)outSymSeed.size(); return (void*)(&outSymSeed); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&encryptionKeyOut[arrayIndex]);
            case 4: return (void*)(&outSymSeed[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_Rewrap_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Rewrap_REQUEST_ID;
};
/// <summary>
/// This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
/// </summary>
TPM2_Rewrap_REQUEST::TPM2_Rewrap_REQUEST()
{
    return;
};
TPM2_Rewrap_REQUEST::TPM2_Rewrap_REQUEST
(
    const TPM_HANDLE& _oldParent,
    const TPM_HANDLE& _newParent,
    const TPM2B_PRIVATE& _inDuplicate,
    const std::vector<BYTE>& _name,
    const std::vector<BYTE>& _inSymSeed
)
{
    oldParent= _oldParent;
    newParent= _newParent;
    inDuplicate= _inDuplicate;
    name= _name;
    inSymSeed= _inSymSeed;
};
/// <summary>
/// This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
/// </summary>
TPM2_Rewrap_REQUEST::~TPM2_Rewrap_REQUEST()
{
    return;
};
/// <summary>
/// This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
/// </summary>
TPM2_Rewrap_REQUEST& TPM2_Rewrap_REQUEST::operator=(const TPM2_Rewrap_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->oldParent = rhs.oldParent;
    this->newParent = rhs.newParent;
    this->inDuplicate = rhs.inDuplicate;
    this->nameSize = rhs.nameSize;
    this->name = rhs.name;
    this->inSymSeedSize = rhs.inSymSeedSize;
    this->inSymSeed = rhs.inSymSeed;
    return *this;
};
/// <summary>
/// This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
/// </summary>
TPM2_Rewrap_REQUEST::TPM2_Rewrap_REQUEST(const TPM2_Rewrap_REQUEST& r)
{
    this->oldParent = r.oldParent;
    this->newParent = r.newParent;
    this->inDuplicate = r.inDuplicate;
    this->nameSize = r.nameSize;
    this->name = r.name;
    this->inSymSeedSize = r.inSymSeedSize;
    this->inSymSeed = r.inSymSeed;
};
/// <summary>
/// This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
/// </summary>
TpmStructureBase* TPM2_Rewrap_REQUEST::Clone() const
{
    TPM2_Rewrap_REQUEST* _x = new TPM2_Rewrap_REQUEST(*this);
    return _x;
};
void* TPM2_Rewrap_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&oldParent); return (void*) (&oldParent);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&newParent); return (void*) (&newParent);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&inDuplicate); return (void*) (&inDuplicate);
            case 3: return (void*) (&nameSize);
            case 4: { if(newArraySize != -1)name.resize(newArraySize); arraySize = (int)name.size(); return (void*)(&name); }
            case 5: return (void*) (&inSymSeedSize);
            case 6: { if(newArraySize != -1)inSymSeed.resize(newArraySize); arraySize = (int)inSymSeed.size(); return (void*)(&inSymSeed); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 4: return (void*)(&name[arrayIndex]);
            case 6: return (void*)(&inSymSeed[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId RewrapResponse::GetTypeId() const
{
    return TpmTypeId::RewrapResponse_ID;
};
/// <summary>
/// This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
/// </summary>
RewrapResponse::RewrapResponse()
{
    return;
};
RewrapResponse::RewrapResponse
(
    const TPM2B_PRIVATE& _outDuplicate,
    const std::vector<BYTE>& _outSymSeed
)
{
    outDuplicate= _outDuplicate;
    outSymSeed= _outSymSeed;
};
/// <summary>
/// This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
/// </summary>
RewrapResponse::~RewrapResponse()
{
    return;
};
/// <summary>
/// This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
/// </summary>
RewrapResponse& RewrapResponse::operator=(const RewrapResponse& rhs)
{
    if(this == &rhs) return *this;
    this->outDuplicate = rhs.outDuplicate;
    this->outSymSeedSize = rhs.outSymSeedSize;
    this->outSymSeed = rhs.outSymSeed;
    return *this;
};
/// <summary>
/// This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
/// </summary>
RewrapResponse::RewrapResponse(const RewrapResponse& r)
{
    this->outDuplicate = r.outDuplicate;
    this->outSymSeedSize = r.outSymSeedSize;
    this->outSymSeed = r.outSymSeed;
};
/// <summary>
/// This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
/// </summary>
TpmStructureBase* RewrapResponse::Clone() const
{
    RewrapResponse* _x = new RewrapResponse(*this);
    return _x;
};
void* RewrapResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&outDuplicate); return (void*) (&outDuplicate);
            case 1: return (void*) (&outSymSeedSize);
            case 2: { if(newArraySize != -1)outSymSeed.resize(newArraySize); arraySize = (int)outSymSeed.size(); return (void*)(&outSymSeed); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&outSymSeed[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_Import_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Import_REQUEST_ID;
};
/// <summary>
/// This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
/// </summary>
TPM2_Import_REQUEST::TPM2_Import_REQUEST()
{
    return;
};
TPM2_Import_REQUEST::TPM2_Import_REQUEST
(
    const TPM_HANDLE& _parentHandle,
    const std::vector<BYTE>& _encryptionKey,
    const TPMT_PUBLIC& _objectPublic,
    const TPM2B_PRIVATE& _duplicate,
    const std::vector<BYTE>& _inSymSeed,
    const TPMT_SYM_DEF_OBJECT& _symmetricAlg
)
{
    parentHandle= _parentHandle;
    encryptionKey= _encryptionKey;
    objectPublic= _objectPublic;
    duplicate= _duplicate;
    inSymSeed= _inSymSeed;
    symmetricAlg= _symmetricAlg;
};
/// <summary>
/// This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
/// </summary>
TPM2_Import_REQUEST::~TPM2_Import_REQUEST()
{
    return;
};
/// <summary>
/// This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
/// </summary>
TPM2_Import_REQUEST& TPM2_Import_REQUEST::operator=(const TPM2_Import_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->parentHandle = rhs.parentHandle;
    this->encryptionKeySize = rhs.encryptionKeySize;
    this->encryptionKey = rhs.encryptionKey;
    this->objectPublicSize = rhs.objectPublicSize;
    this->objectPublic = rhs.objectPublic;
    this->duplicate = rhs.duplicate;
    this->inSymSeedSize = rhs.inSymSeedSize;
    this->inSymSeed = rhs.inSymSeed;
    this->symmetricAlg = rhs.symmetricAlg;
    return *this;
};
/// <summary>
/// This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
/// </summary>
TPM2_Import_REQUEST::TPM2_Import_REQUEST(const TPM2_Import_REQUEST& r)
{
    this->parentHandle = r.parentHandle;
    this->encryptionKeySize = r.encryptionKeySize;
    this->encryptionKey = r.encryptionKey;
    this->objectPublicSize = r.objectPublicSize;
    this->objectPublic = r.objectPublic;
    this->duplicate = r.duplicate;
    this->inSymSeedSize = r.inSymSeedSize;
    this->inSymSeed = r.inSymSeed;
    this->symmetricAlg = r.symmetricAlg;
};
/// <summary>
/// This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
/// </summary>
TpmStructureBase* TPM2_Import_REQUEST::Clone() const
{
    TPM2_Import_REQUEST* _x = new TPM2_Import_REQUEST(*this);
    return _x;
};
void* TPM2_Import_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&parentHandle); return (void*) (&parentHandle);
            case 1: return (void*) (&encryptionKeySize);
            case 2: { if(newArraySize != -1)encryptionKey.resize(newArraySize); arraySize = (int)encryptionKey.size(); return (void*)(&encryptionKey); }
            case 3: return (void*) (&objectPublicSize);
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&objectPublic); return (void*) (&objectPublic);
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&duplicate); return (void*) (&duplicate);
            case 6: return (void*) (&inSymSeedSize);
            case 7: { if(newArraySize != -1)inSymSeed.resize(newArraySize); arraySize = (int)inSymSeed.size(); return (void*)(&inSymSeed); }
            case 8: pStruct = dynamic_cast<TpmStructureBase*>(&symmetricAlg); return (void*) (&symmetricAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&encryptionKey[arrayIndex]);
            case 7: return (void*)(&inSymSeed[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId ImportResponse::GetTypeId() const
{
    return TpmTypeId::ImportResponse_ID;
};
/// <summary>
/// This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
/// </summary>
ImportResponse::ImportResponse()
{
    return;
};
ImportResponse::ImportResponse
(
    const TPM2B_PRIVATE& _outPrivate
)
{
    outPrivate= _outPrivate;
};
/// <summary>
/// This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
/// </summary>
ImportResponse::~ImportResponse()
{
    return;
};
/// <summary>
/// This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
/// </summary>
ImportResponse& ImportResponse::operator=(const ImportResponse& rhs)
{
    if(this == &rhs) return *this;
    this->outPrivate = rhs.outPrivate;
    return *this;
};
/// <summary>
/// This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
/// </summary>
ImportResponse::ImportResponse(const ImportResponse& r)
{
    this->outPrivate = r.outPrivate;
};
/// <summary>
/// This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
/// </summary>
TpmStructureBase* ImportResponse::Clone() const
{
    ImportResponse* _x = new ImportResponse(*this);
    return _x;
};
void* ImportResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&outPrivate); return (void*) (&outPrivate);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_RSA_Encrypt_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
};
/// <summary>
/// This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
/// </summary>
TPM2_RSA_Encrypt_REQUEST::TPM2_RSA_Encrypt_REQUEST()
{
    inScheme = NULL;
    return;
};
TPM2_RSA_Encrypt_REQUEST::TPM2_RSA_Encrypt_REQUEST
(
    const TPM_HANDLE& _keyHandle,
    const std::vector<BYTE>& _message,
    const TPMU_ASYM_SCHEME& _inScheme,
    const std::vector<BYTE>& _label
)
{
    keyHandle= _keyHandle;
    message= _message;
    inScheme = dynamic_cast<TPMU_ASYM_SCHEME*> (_inScheme.Clone());
    label= _label;
};
/// <summary>
/// This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
/// </summary>
TPM2_RSA_Encrypt_REQUEST::~TPM2_RSA_Encrypt_REQUEST()
{
    if(inScheme != NULL) { delete inScheme;inScheme=NULL; }
    return;
};
/// <summary>
/// This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
/// </summary>
TPM2_RSA_Encrypt_REQUEST& TPM2_RSA_Encrypt_REQUEST::operator=(const TPM2_RSA_Encrypt_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->keyHandle = rhs.keyHandle;
    this->messageSize = rhs.messageSize;
    this->message = rhs.message;
    this->inSchemeScheme = rhs.inSchemeScheme;
    if(inScheme != NULL) delete inScheme;
    if(rhs.inScheme != NULL)inScheme = dynamic_cast<TPMU_ASYM_SCHEME*>(rhs.inScheme->Clone());
    this->labelSize = rhs.labelSize;
    this->label = rhs.label;
    return *this;
};
/// <summary>
/// This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
/// </summary>
TPM2_RSA_Encrypt_REQUEST::TPM2_RSA_Encrypt_REQUEST(const TPM2_RSA_Encrypt_REQUEST& r)
{
    this->keyHandle = r.keyHandle;
    this->messageSize = r.messageSize;
    this->message = r.message;
    this->inSchemeScheme = r.inSchemeScheme;
    if(r.inScheme != NULL)inScheme = dynamic_cast<TPMU_ASYM_SCHEME*>(r.inScheme->Clone());
    this->labelSize = r.labelSize;
    this->label = r.label;
};
/// <summary>
/// This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
/// </summary>
TpmStructureBase* TPM2_RSA_Encrypt_REQUEST::Clone() const
{
    TPM2_RSA_Encrypt_REQUEST* _x = new TPM2_RSA_Encrypt_REQUEST(*this);
    return _x;
};
void* TPM2_RSA_Encrypt_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return (void*) (&keyHandle);
            case 1: return (void*) (&messageSize);
            case 2: { if(newArraySize != -1)message.resize(newArraySize); arraySize = (int)message.size(); return (void*)(&message); }
            case 3: return (void*) (&inSchemeScheme);
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(inScheme); return (void*) (&inScheme);
            case 5: return (void*) (&labelSize);
            case 6: { if(newArraySize != -1)label.resize(newArraySize); arraySize = (int)label.size(); return (void*)(&label); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&message[arrayIndex]);
            case 6: return (void*)(&label[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId RSA_EncryptResponse::GetTypeId() const
{
    return TpmTypeId::RSA_EncryptResponse_ID;
};
/// <summary>
/// This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
/// </summary>
RSA_EncryptResponse::RSA_EncryptResponse()
{
    return;
};
RSA_EncryptResponse::RSA_EncryptResponse
(
    const std::vector<BYTE>& _outData
)
{
    outData= _outData;
};
/// <summary>
/// This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
/// </summary>
RSA_EncryptResponse::~RSA_EncryptResponse()
{
    return;
};
/// <summary>
/// This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
/// </summary>
RSA_EncryptResponse& RSA_EncryptResponse::operator=(const RSA_EncryptResponse& rhs)
{
    if(this == &rhs) return *this;
    this->outDataSize = rhs.outDataSize;
    this->outData = rhs.outData;
    return *this;
};
/// <summary>
/// This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
/// </summary>
RSA_EncryptResponse::RSA_EncryptResponse(const RSA_EncryptResponse& r)
{
    this->outDataSize = r.outDataSize;
    this->outData = r.outData;
};
/// <summary>
/// This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
/// </summary>
TpmStructureBase* RSA_EncryptResponse::Clone() const
{
    RSA_EncryptResponse* _x = new RSA_EncryptResponse(*this);
    return _x;
};
void* RSA_EncryptResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&outDataSize);
            case 1: { if(newArraySize != -1)outData.resize(newArraySize); arraySize = (int)outData.size(); return (void*)(&outData); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&outData[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_RSA_Decrypt_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
};
/// <summary>
/// This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
/// </summary>
TPM2_RSA_Decrypt_REQUEST::TPM2_RSA_Decrypt_REQUEST()
{
    inScheme = NULL;
    return;
};
TPM2_RSA_Decrypt_REQUEST::TPM2_RSA_Decrypt_REQUEST
(
    const TPM_HANDLE& _keyHandle,
    const std::vector<BYTE>& _cipherText,
    const TPMU_ASYM_SCHEME& _inScheme,
    const std::vector<BYTE>& _label
)
{
    keyHandle= _keyHandle;
    cipherText= _cipherText;
    inScheme = dynamic_cast<TPMU_ASYM_SCHEME*> (_inScheme.Clone());
    label= _label;
};
/// <summary>
/// This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
/// </summary>
TPM2_RSA_Decrypt_REQUEST::~TPM2_RSA_Decrypt_REQUEST()
{
    if(inScheme != NULL) { delete inScheme;inScheme=NULL; }
    return;
};
/// <summary>
/// This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
/// </summary>
TPM2_RSA_Decrypt_REQUEST& TPM2_RSA_Decrypt_REQUEST::operator=(const TPM2_RSA_Decrypt_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->keyHandle = rhs.keyHandle;
    this->cipherTextSize = rhs.cipherTextSize;
    this->cipherText = rhs.cipherText;
    this->inSchemeScheme = rhs.inSchemeScheme;
    if(inScheme != NULL) delete inScheme;
    if(rhs.inScheme != NULL)inScheme = dynamic_cast<TPMU_ASYM_SCHEME*>(rhs.inScheme->Clone());
    this->labelSize = rhs.labelSize;
    this->label = rhs.label;
    return *this;
};
/// <summary>
/// This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
/// </summary>
TPM2_RSA_Decrypt_REQUEST::TPM2_RSA_Decrypt_REQUEST(const TPM2_RSA_Decrypt_REQUEST& r)
{
    this->keyHandle = r.keyHandle;
    this->cipherTextSize = r.cipherTextSize;
    this->cipherText = r.cipherText;
    this->inSchemeScheme = r.inSchemeScheme;
    if(r.inScheme != NULL)inScheme = dynamic_cast<TPMU_ASYM_SCHEME*>(r.inScheme->Clone());
    this->labelSize = r.labelSize;
    this->label = r.label;
};
/// <summary>
/// This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
/// </summary>
TpmStructureBase* TPM2_RSA_Decrypt_REQUEST::Clone() const
{
    TPM2_RSA_Decrypt_REQUEST* _x = new TPM2_RSA_Decrypt_REQUEST(*this);
    return _x;
};
void* TPM2_RSA_Decrypt_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return (void*) (&keyHandle);
            case 1: return (void*) (&cipherTextSize);
            case 2: { if(newArraySize != -1)cipherText.resize(newArraySize); arraySize = (int)cipherText.size(); return (void*)(&cipherText); }
            case 3: return (void*) (&inSchemeScheme);
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(inScheme); return (void*) (&inScheme);
            case 5: return (void*) (&labelSize);
            case 6: { if(newArraySize != -1)label.resize(newArraySize); arraySize = (int)label.size(); return (void*)(&label); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&cipherText[arrayIndex]);
            case 6: return (void*)(&label[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId RSA_DecryptResponse::GetTypeId() const
{
    return TpmTypeId::RSA_DecryptResponse_ID;
};
/// <summary>
/// This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
/// </summary>
RSA_DecryptResponse::RSA_DecryptResponse()
{
    return;
};
RSA_DecryptResponse::RSA_DecryptResponse
(
    const std::vector<BYTE>& _message
)
{
    message= _message;
};
/// <summary>
/// This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
/// </summary>
RSA_DecryptResponse::~RSA_DecryptResponse()
{
    return;
};
/// <summary>
/// This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
/// </summary>
RSA_DecryptResponse& RSA_DecryptResponse::operator=(const RSA_DecryptResponse& rhs)
{
    if(this == &rhs) return *this;
    this->messageSize = rhs.messageSize;
    this->message = rhs.message;
    return *this;
};
/// <summary>
/// This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
/// </summary>
RSA_DecryptResponse::RSA_DecryptResponse(const RSA_DecryptResponse& r)
{
    this->messageSize = r.messageSize;
    this->message = r.message;
};
/// <summary>
/// This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
/// </summary>
TpmStructureBase* RSA_DecryptResponse::Clone() const
{
    RSA_DecryptResponse* _x = new RSA_DecryptResponse(*this);
    return _x;
};
void* RSA_DecryptResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&messageSize);
            case 1: { if(newArraySize != -1)message.resize(newArraySize); arraySize = (int)message.size(); return (void*)(&message); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&message[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_ECDH_KeyGen_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ECDH_KeyGen_REQUEST_ID;
};
/// <summary>
/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS).
/// </summary>
TPM2_ECDH_KeyGen_REQUEST::TPM2_ECDH_KeyGen_REQUEST()
{
    return;
};
TPM2_ECDH_KeyGen_REQUEST::TPM2_ECDH_KeyGen_REQUEST
(
    const TPM_HANDLE& _keyHandle
)
{
    keyHandle= _keyHandle;
};
/// <summary>
/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS).
/// </summary>
TPM2_ECDH_KeyGen_REQUEST::~TPM2_ECDH_KeyGen_REQUEST()
{
    return;
};
/// <summary>
/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS).
/// </summary>
TPM2_ECDH_KeyGen_REQUEST& TPM2_ECDH_KeyGen_REQUEST::operator=(const TPM2_ECDH_KeyGen_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->keyHandle = rhs.keyHandle;
    return *this;
};
/// <summary>
/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS).
/// </summary>
TPM2_ECDH_KeyGen_REQUEST::TPM2_ECDH_KeyGen_REQUEST(const TPM2_ECDH_KeyGen_REQUEST& r)
{
    this->keyHandle = r.keyHandle;
};
/// <summary>
/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS).
/// </summary>
TpmStructureBase* TPM2_ECDH_KeyGen_REQUEST::Clone() const
{
    TPM2_ECDH_KeyGen_REQUEST* _x = new TPM2_ECDH_KeyGen_REQUEST(*this);
    return _x;
};
void* TPM2_ECDH_KeyGen_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return (void*) (&keyHandle);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId ECDH_KeyGenResponse::GetTypeId() const
{
    return TpmTypeId::ECDH_KeyGenResponse_ID;
};
/// <summary>
/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS).
/// </summary>
ECDH_KeyGenResponse::ECDH_KeyGenResponse()
{
    return;
};
ECDH_KeyGenResponse::ECDH_KeyGenResponse
(
    const TPMS_ECC_POINT& _zPoint,
    const TPMS_ECC_POINT& _pubPoint
)
{
    zPoint= _zPoint;
    pubPoint= _pubPoint;
};
/// <summary>
/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS).
/// </summary>
ECDH_KeyGenResponse::~ECDH_KeyGenResponse()
{
    return;
};
/// <summary>
/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS).
/// </summary>
ECDH_KeyGenResponse& ECDH_KeyGenResponse::operator=(const ECDH_KeyGenResponse& rhs)
{
    if(this == &rhs) return *this;
    this->zPointSize = rhs.zPointSize;
    this->zPoint = rhs.zPoint;
    this->pubPointSize = rhs.pubPointSize;
    this->pubPoint = rhs.pubPoint;
    return *this;
};
/// <summary>
/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS).
/// </summary>
ECDH_KeyGenResponse::ECDH_KeyGenResponse(const ECDH_KeyGenResponse& r)
{
    this->zPointSize = r.zPointSize;
    this->zPoint = r.zPoint;
    this->pubPointSize = r.pubPointSize;
    this->pubPoint = r.pubPoint;
};
/// <summary>
/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS).
/// </summary>
TpmStructureBase* ECDH_KeyGenResponse::Clone() const
{
    ECDH_KeyGenResponse* _x = new ECDH_KeyGenResponse(*this);
    return _x;
};
void* ECDH_KeyGenResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&zPointSize);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&zPoint); return (void*) (&zPoint);
            case 2: return (void*) (&pubPointSize);
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&pubPoint); return (void*) (&pubPoint);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_ECDH_ZGen_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ECDH_ZGen_REQUEST_ID;
};
/// <summary>
/// This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve).
/// </summary>
TPM2_ECDH_ZGen_REQUEST::TPM2_ECDH_ZGen_REQUEST()
{
    return;
};
TPM2_ECDH_ZGen_REQUEST::TPM2_ECDH_ZGen_REQUEST
(
    const TPM_HANDLE& _keyHandle,
    const TPMS_ECC_POINT& _inPoint
)
{
    keyHandle= _keyHandle;
    inPoint= _inPoint;
};
/// <summary>
/// This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve).
/// </summary>
TPM2_ECDH_ZGen_REQUEST::~TPM2_ECDH_ZGen_REQUEST()
{
    return;
};
/// <summary>
/// This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve).
/// </summary>
TPM2_ECDH_ZGen_REQUEST& TPM2_ECDH_ZGen_REQUEST::operator=(const TPM2_ECDH_ZGen_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->keyHandle = rhs.keyHandle;
    this->inPointSize = rhs.inPointSize;
    this->inPoint = rhs.inPoint;
    return *this;
};
/// <summary>
/// This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve).
/// </summary>
TPM2_ECDH_ZGen_REQUEST::TPM2_ECDH_ZGen_REQUEST(const TPM2_ECDH_ZGen_REQUEST& r)
{
    this->keyHandle = r.keyHandle;
    this->inPointSize = r.inPointSize;
    this->inPoint = r.inPoint;
};
/// <summary>
/// This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve).
/// </summary>
TpmStructureBase* TPM2_ECDH_ZGen_REQUEST::Clone() const
{
    TPM2_ECDH_ZGen_REQUEST* _x = new TPM2_ECDH_ZGen_REQUEST(*this);
    return _x;
};
void* TPM2_ECDH_ZGen_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return (void*) (&keyHandle);
            case 1: return (void*) (&inPointSize);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&inPoint); return (void*) (&inPoint);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId ECDH_ZGenResponse::GetTypeId() const
{
    return TpmTypeId::ECDH_ZGenResponse_ID;
};
/// <summary>
/// This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve).
/// </summary>
ECDH_ZGenResponse::ECDH_ZGenResponse()
{
    return;
};
ECDH_ZGenResponse::ECDH_ZGenResponse
(
    const TPMS_ECC_POINT& _outPoint
)
{
    outPoint= _outPoint;
};
/// <summary>
/// This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve).
/// </summary>
ECDH_ZGenResponse::~ECDH_ZGenResponse()
{
    return;
};
/// <summary>
/// This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve).
/// </summary>
ECDH_ZGenResponse& ECDH_ZGenResponse::operator=(const ECDH_ZGenResponse& rhs)
{
    if(this == &rhs) return *this;
    this->outPointSize = rhs.outPointSize;
    this->outPoint = rhs.outPoint;
    return *this;
};
/// <summary>
/// This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve).
/// </summary>
ECDH_ZGenResponse::ECDH_ZGenResponse(const ECDH_ZGenResponse& r)
{
    this->outPointSize = r.outPointSize;
    this->outPoint = r.outPoint;
};
/// <summary>
/// This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve).
/// </summary>
TpmStructureBase* ECDH_ZGenResponse::Clone() const
{
    ECDH_ZGenResponse* _x = new ECDH_ZGenResponse(*this);
    return _x;
};
void* ECDH_ZGenResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&outPointSize);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&outPoint); return (void*) (&outPoint);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_ECC_Parameters_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ECC_Parameters_REQUEST_ID;
};
/// <summary>
/// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
/// </summary>
TPM2_ECC_Parameters_REQUEST::TPM2_ECC_Parameters_REQUEST()
{
    return;
};
TPM2_ECC_Parameters_REQUEST::TPM2_ECC_Parameters_REQUEST
(
    const TPM_ECC_CURVE& _curveID
)
{
    curveID= _curveID;
};
/// <summary>
/// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
/// </summary>
TPM2_ECC_Parameters_REQUEST::~TPM2_ECC_Parameters_REQUEST()
{
    return;
};
/// <summary>
/// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
/// </summary>
TPM2_ECC_Parameters_REQUEST& TPM2_ECC_Parameters_REQUEST::operator=(const TPM2_ECC_Parameters_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->curveID = rhs.curveID;
    return *this;
};
/// <summary>
/// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
/// </summary>
TPM2_ECC_Parameters_REQUEST::TPM2_ECC_Parameters_REQUEST(const TPM2_ECC_Parameters_REQUEST& r)
{
    this->curveID = r.curveID;
};
/// <summary>
/// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
/// </summary>
TpmStructureBase* TPM2_ECC_Parameters_REQUEST::Clone() const
{
    TPM2_ECC_Parameters_REQUEST* _x = new TPM2_ECC_Parameters_REQUEST(*this);
    return _x;
};
void* TPM2_ECC_Parameters_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&curveID);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId ECC_ParametersResponse::GetTypeId() const
{
    return TpmTypeId::ECC_ParametersResponse_ID;
};
/// <summary>
/// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
/// </summary>
ECC_ParametersResponse::ECC_ParametersResponse()
{
    return;
};
ECC_ParametersResponse::ECC_ParametersResponse
(
    const TPMS_ALGORITHM_DETAIL_ECC& _parameters
)
{
    parameters= _parameters;
};
/// <summary>
/// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
/// </summary>
ECC_ParametersResponse::~ECC_ParametersResponse()
{
    return;
};
/// <summary>
/// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
/// </summary>
ECC_ParametersResponse& ECC_ParametersResponse::operator=(const ECC_ParametersResponse& rhs)
{
    if(this == &rhs) return *this;
    this->parameters = rhs.parameters;
    return *this;
};
/// <summary>
/// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
/// </summary>
ECC_ParametersResponse::ECC_ParametersResponse(const ECC_ParametersResponse& r)
{
    this->parameters = r.parameters;
};
/// <summary>
/// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
/// </summary>
TpmStructureBase* ECC_ParametersResponse::Clone() const
{
    ECC_ParametersResponse* _x = new ECC_ParametersResponse(*this);
    return _x;
};
void* ECC_ParametersResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&parameters); return (void*) (&parameters);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_ZGen_2Phase_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
};
/// <summary>
/// This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
/// </summary>
TPM2_ZGen_2Phase_REQUEST::TPM2_ZGen_2Phase_REQUEST()
{
    return;
};
TPM2_ZGen_2Phase_REQUEST::TPM2_ZGen_2Phase_REQUEST
(
    const TPM_HANDLE& _keyA,
    const TPMS_ECC_POINT& _inQsB,
    const TPMS_ECC_POINT& _inQeB,
    const TPM_ALG_ID& _inScheme,
    const UINT16& _counter
)
{
    keyA= _keyA;
    inQsB= _inQsB;
    inQeB= _inQeB;
    inScheme= _inScheme;
    counter= _counter;
};
/// <summary>
/// This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
/// </summary>
TPM2_ZGen_2Phase_REQUEST::~TPM2_ZGen_2Phase_REQUEST()
{
    return;
};
/// <summary>
/// This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
/// </summary>
TPM2_ZGen_2Phase_REQUEST& TPM2_ZGen_2Phase_REQUEST::operator=(const TPM2_ZGen_2Phase_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->keyA = rhs.keyA;
    this->inQsBSize = rhs.inQsBSize;
    this->inQsB = rhs.inQsB;
    this->inQeBSize = rhs.inQeBSize;
    this->inQeB = rhs.inQeB;
    this->inScheme = rhs.inScheme;
    this->counter = rhs.counter;
    return *this;
};
/// <summary>
/// This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
/// </summary>
TPM2_ZGen_2Phase_REQUEST::TPM2_ZGen_2Phase_REQUEST(const TPM2_ZGen_2Phase_REQUEST& r)
{
    this->keyA = r.keyA;
    this->inQsBSize = r.inQsBSize;
    this->inQsB = r.inQsB;
    this->inQeBSize = r.inQeBSize;
    this->inQeB = r.inQeB;
    this->inScheme = r.inScheme;
    this->counter = r.counter;
};
/// <summary>
/// This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
/// </summary>
TpmStructureBase* TPM2_ZGen_2Phase_REQUEST::Clone() const
{
    TPM2_ZGen_2Phase_REQUEST* _x = new TPM2_ZGen_2Phase_REQUEST(*this);
    return _x;
};
void* TPM2_ZGen_2Phase_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyA); return (void*) (&keyA);
            case 1: return (void*) (&inQsBSize);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&inQsB); return (void*) (&inQsB);
            case 3: return (void*) (&inQeBSize);
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&inQeB); return (void*) (&inQeB);
            case 5: return (void*) (&inScheme);
            case 6: return (void*) (&counter);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId ZGen_2PhaseResponse::GetTypeId() const
{
    return TpmTypeId::ZGen_2PhaseResponse_ID;
};
/// <summary>
/// This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
/// </summary>
ZGen_2PhaseResponse::ZGen_2PhaseResponse()
{
    return;
};
ZGen_2PhaseResponse::ZGen_2PhaseResponse
(
    const TPMS_ECC_POINT& _outZ1,
    const TPMS_ECC_POINT& _outZ2
)
{
    outZ1= _outZ1;
    outZ2= _outZ2;
};
/// <summary>
/// This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
/// </summary>
ZGen_2PhaseResponse::~ZGen_2PhaseResponse()
{
    return;
};
/// <summary>
/// This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
/// </summary>
ZGen_2PhaseResponse& ZGen_2PhaseResponse::operator=(const ZGen_2PhaseResponse& rhs)
{
    if(this == &rhs) return *this;
    this->outZ1Size = rhs.outZ1Size;
    this->outZ1 = rhs.outZ1;
    this->outZ2Size = rhs.outZ2Size;
    this->outZ2 = rhs.outZ2;
    return *this;
};
/// <summary>
/// This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
/// </summary>
ZGen_2PhaseResponse::ZGen_2PhaseResponse(const ZGen_2PhaseResponse& r)
{
    this->outZ1Size = r.outZ1Size;
    this->outZ1 = r.outZ1;
    this->outZ2Size = r.outZ2Size;
    this->outZ2 = r.outZ2;
};
/// <summary>
/// This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
/// </summary>
TpmStructureBase* ZGen_2PhaseResponse::Clone() const
{
    ZGen_2PhaseResponse* _x = new ZGen_2PhaseResponse(*this);
    return _x;
};
void* ZGen_2PhaseResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&outZ1Size);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&outZ1); return (void*) (&outZ1);
            case 2: return (void*) (&outZ2Size);
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&outZ2); return (void*) (&outZ2);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_EncryptDecrypt_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
};
/// <summary>
/// NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
/// </summary>
TPM2_EncryptDecrypt_REQUEST::TPM2_EncryptDecrypt_REQUEST()
{
    return;
};
TPM2_EncryptDecrypt_REQUEST::TPM2_EncryptDecrypt_REQUEST
(
    const TPM_HANDLE& _keyHandle,
    const BYTE& _decrypt,
    const TPM_ALG_ID& _mode,
    const std::vector<BYTE>& _ivIn,
    const std::vector<BYTE>& _inData
)
{
    keyHandle= _keyHandle;
    decrypt= _decrypt;
    mode= _mode;
    ivIn= _ivIn;
    inData= _inData;
};
/// <summary>
/// NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
/// </summary>
TPM2_EncryptDecrypt_REQUEST::~TPM2_EncryptDecrypt_REQUEST()
{
    return;
};
/// <summary>
/// NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
/// </summary>
TPM2_EncryptDecrypt_REQUEST& TPM2_EncryptDecrypt_REQUEST::operator=(const TPM2_EncryptDecrypt_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->keyHandle = rhs.keyHandle;
    this->decrypt = rhs.decrypt;
    this->mode = rhs.mode;
    this->ivInSize = rhs.ivInSize;
    this->ivIn = rhs.ivIn;
    this->inDataSize = rhs.inDataSize;
    this->inData = rhs.inData;
    return *this;
};
/// <summary>
/// NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
/// </summary>
TPM2_EncryptDecrypt_REQUEST::TPM2_EncryptDecrypt_REQUEST(const TPM2_EncryptDecrypt_REQUEST& r)
{
    this->keyHandle = r.keyHandle;
    this->decrypt = r.decrypt;
    this->mode = r.mode;
    this->ivInSize = r.ivInSize;
    this->ivIn = r.ivIn;
    this->inDataSize = r.inDataSize;
    this->inData = r.inData;
};
/// <summary>
/// NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
/// </summary>
TpmStructureBase* TPM2_EncryptDecrypt_REQUEST::Clone() const
{
    TPM2_EncryptDecrypt_REQUEST* _x = new TPM2_EncryptDecrypt_REQUEST(*this);
    return _x;
};
void* TPM2_EncryptDecrypt_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return (void*) (&keyHandle);
            case 1: return (void*) (&decrypt);
            case 2: return (void*) (&mode);
            case 3: return (void*) (&ivInSize);
            case 4: { if(newArraySize != -1)ivIn.resize(newArraySize); arraySize = (int)ivIn.size(); return (void*)(&ivIn); }
            case 5: return (void*) (&inDataSize);
            case 6: { if(newArraySize != -1)inData.resize(newArraySize); arraySize = (int)inData.size(); return (void*)(&inData); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 4: return (void*)(&ivIn[arrayIndex]);
            case 6: return (void*)(&inData[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId EncryptDecryptResponse::GetTypeId() const
{
    return TpmTypeId::EncryptDecryptResponse_ID;
};
/// <summary>
/// NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
/// </summary>
EncryptDecryptResponse::EncryptDecryptResponse()
{
    return;
};
EncryptDecryptResponse::EncryptDecryptResponse
(
    const std::vector<BYTE>& _outData,
    const std::vector<BYTE>& _ivOut
)
{
    outData= _outData;
    ivOut= _ivOut;
};
/// <summary>
/// NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
/// </summary>
EncryptDecryptResponse::~EncryptDecryptResponse()
{
    return;
};
/// <summary>
/// NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
/// </summary>
EncryptDecryptResponse& EncryptDecryptResponse::operator=(const EncryptDecryptResponse& rhs)
{
    if(this == &rhs) return *this;
    this->outDataSize = rhs.outDataSize;
    this->outData = rhs.outData;
    this->ivOutSize = rhs.ivOutSize;
    this->ivOut = rhs.ivOut;
    return *this;
};
/// <summary>
/// NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
/// </summary>
EncryptDecryptResponse::EncryptDecryptResponse(const EncryptDecryptResponse& r)
{
    this->outDataSize = r.outDataSize;
    this->outData = r.outData;
    this->ivOutSize = r.ivOutSize;
    this->ivOut = r.ivOut;
};
/// <summary>
/// NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
/// </summary>
TpmStructureBase* EncryptDecryptResponse::Clone() const
{
    EncryptDecryptResponse* _x = new EncryptDecryptResponse(*this);
    return _x;
};
void* EncryptDecryptResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&outDataSize);
            case 1: { if(newArraySize != -1)outData.resize(newArraySize); arraySize = (int)outData.size(); return (void*)(&outData); }
            case 2: return (void*) (&ivOutSize);
            case 3: { if(newArraySize != -1)ivOut.resize(newArraySize); arraySize = (int)ivOut.size(); return (void*)(&ivOut); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&outData[arrayIndex]);
            case 3: return (void*)(&ivOut[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_EncryptDecrypt2_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
};
/// <summary>
/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
/// </summary>
TPM2_EncryptDecrypt2_REQUEST::TPM2_EncryptDecrypt2_REQUEST()
{
    return;
};
TPM2_EncryptDecrypt2_REQUEST::TPM2_EncryptDecrypt2_REQUEST
(
    const TPM_HANDLE& _keyHandle,
    const std::vector<BYTE>& _inData,
    const BYTE& _decrypt,
    const TPM_ALG_ID& _mode,
    const std::vector<BYTE>& _ivIn
)
{
    keyHandle= _keyHandle;
    inData= _inData;
    decrypt= _decrypt;
    mode= _mode;
    ivIn= _ivIn;
};
/// <summary>
/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
/// </summary>
TPM2_EncryptDecrypt2_REQUEST::~TPM2_EncryptDecrypt2_REQUEST()
{
    return;
};
/// <summary>
/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
/// </summary>
TPM2_EncryptDecrypt2_REQUEST& TPM2_EncryptDecrypt2_REQUEST::operator=(const TPM2_EncryptDecrypt2_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->keyHandle = rhs.keyHandle;
    this->inDataSize = rhs.inDataSize;
    this->inData = rhs.inData;
    this->decrypt = rhs.decrypt;
    this->mode = rhs.mode;
    this->ivInSize = rhs.ivInSize;
    this->ivIn = rhs.ivIn;
    return *this;
};
/// <summary>
/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
/// </summary>
TPM2_EncryptDecrypt2_REQUEST::TPM2_EncryptDecrypt2_REQUEST(const TPM2_EncryptDecrypt2_REQUEST& r)
{
    this->keyHandle = r.keyHandle;
    this->inDataSize = r.inDataSize;
    this->inData = r.inData;
    this->decrypt = r.decrypt;
    this->mode = r.mode;
    this->ivInSize = r.ivInSize;
    this->ivIn = r.ivIn;
};
/// <summary>
/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
/// </summary>
TpmStructureBase* TPM2_EncryptDecrypt2_REQUEST::Clone() const
{
    TPM2_EncryptDecrypt2_REQUEST* _x = new TPM2_EncryptDecrypt2_REQUEST(*this);
    return _x;
};
void* TPM2_EncryptDecrypt2_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return (void*) (&keyHandle);
            case 1: return (void*) (&inDataSize);
            case 2: { if(newArraySize != -1)inData.resize(newArraySize); arraySize = (int)inData.size(); return (void*)(&inData); }
            case 3: return (void*) (&decrypt);
            case 4: return (void*) (&mode);
            case 5: return (void*) (&ivInSize);
            case 6: { if(newArraySize != -1)ivIn.resize(newArraySize); arraySize = (int)ivIn.size(); return (void*)(&ivIn); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&inData[arrayIndex]);
            case 6: return (void*)(&ivIn[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId EncryptDecrypt2Response::GetTypeId() const
{
    return TpmTypeId::EncryptDecrypt2Response_ID;
};
/// <summary>
/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
/// </summary>
EncryptDecrypt2Response::EncryptDecrypt2Response()
{
    return;
};
EncryptDecrypt2Response::EncryptDecrypt2Response
(
    const std::vector<BYTE>& _outData,
    const std::vector<BYTE>& _ivOut
)
{
    outData= _outData;
    ivOut= _ivOut;
};
/// <summary>
/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
/// </summary>
EncryptDecrypt2Response::~EncryptDecrypt2Response()
{
    return;
};
/// <summary>
/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
/// </summary>
EncryptDecrypt2Response& EncryptDecrypt2Response::operator=(const EncryptDecrypt2Response& rhs)
{
    if(this == &rhs) return *this;
    this->outDataSize = rhs.outDataSize;
    this->outData = rhs.outData;
    this->ivOutSize = rhs.ivOutSize;
    this->ivOut = rhs.ivOut;
    return *this;
};
/// <summary>
/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
/// </summary>
EncryptDecrypt2Response::EncryptDecrypt2Response(const EncryptDecrypt2Response& r)
{
    this->outDataSize = r.outDataSize;
    this->outData = r.outData;
    this->ivOutSize = r.ivOutSize;
    this->ivOut = r.ivOut;
};
/// <summary>
/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
/// </summary>
TpmStructureBase* EncryptDecrypt2Response::Clone() const
{
    EncryptDecrypt2Response* _x = new EncryptDecrypt2Response(*this);
    return _x;
};
void* EncryptDecrypt2Response::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&outDataSize);
            case 1: { if(newArraySize != -1)outData.resize(newArraySize); arraySize = (int)outData.size(); return (void*)(&outData); }
            case 2: return (void*) (&ivOutSize);
            case 3: { if(newArraySize != -1)ivOut.resize(newArraySize); arraySize = (int)ivOut.size(); return (void*)(&ivOut); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&outData[arrayIndex]);
            case 3: return (void*)(&ivOut[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_Hash_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Hash_REQUEST_ID;
};
/// <summary>
/// This command performs a hash operation on a data buffer and returns the results.
/// </summary>
TPM2_Hash_REQUEST::TPM2_Hash_REQUEST()
{
    return;
};
TPM2_Hash_REQUEST::TPM2_Hash_REQUEST
(
    const std::vector<BYTE>& _data,
    const TPM_ALG_ID& _hashAlg,
    const TPM_HANDLE& _hierarchy
)
{
    data= _data;
    hashAlg= _hashAlg;
    hierarchy= _hierarchy;
};
/// <summary>
/// This command performs a hash operation on a data buffer and returns the results.
/// </summary>
TPM2_Hash_REQUEST::~TPM2_Hash_REQUEST()
{
    return;
};
/// <summary>
/// This command performs a hash operation on a data buffer and returns the results.
/// </summary>
TPM2_Hash_REQUEST& TPM2_Hash_REQUEST::operator=(const TPM2_Hash_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->dataSize = rhs.dataSize;
    this->data = rhs.data;
    this->hashAlg = rhs.hashAlg;
    this->hierarchy = rhs.hierarchy;
    return *this;
};
/// <summary>
/// This command performs a hash operation on a data buffer and returns the results.
/// </summary>
TPM2_Hash_REQUEST::TPM2_Hash_REQUEST(const TPM2_Hash_REQUEST& r)
{
    this->dataSize = r.dataSize;
    this->data = r.data;
    this->hashAlg = r.hashAlg;
    this->hierarchy = r.hierarchy;
};
/// <summary>
/// This command performs a hash operation on a data buffer and returns the results.
/// </summary>
TpmStructureBase* TPM2_Hash_REQUEST::Clone() const
{
    TPM2_Hash_REQUEST* _x = new TPM2_Hash_REQUEST(*this);
    return _x;
};
void* TPM2_Hash_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&dataSize);
            case 1: { if(newArraySize != -1)data.resize(newArraySize); arraySize = (int)data.size(); return (void*)(&data); }
            case 2: return (void*) (&hashAlg);
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return (void*) (&hierarchy);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&data[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId HashResponse::GetTypeId() const
{
    return TpmTypeId::HashResponse_ID;
};
/// <summary>
/// This command performs a hash operation on a data buffer and returns the results.
/// </summary>
HashResponse::HashResponse()
{
    return;
};
HashResponse::HashResponse
(
    const std::vector<BYTE>& _outHash,
    const TPMT_TK_HASHCHECK& _validation
)
{
    outHash= _outHash;
    validation= _validation;
};
/// <summary>
/// This command performs a hash operation on a data buffer and returns the results.
/// </summary>
HashResponse::~HashResponse()
{
    return;
};
/// <summary>
/// This command performs a hash operation on a data buffer and returns the results.
/// </summary>
HashResponse& HashResponse::operator=(const HashResponse& rhs)
{
    if(this == &rhs) return *this;
    this->outHashSize = rhs.outHashSize;
    this->outHash = rhs.outHash;
    this->validation = rhs.validation;
    return *this;
};
/// <summary>
/// This command performs a hash operation on a data buffer and returns the results.
/// </summary>
HashResponse::HashResponse(const HashResponse& r)
{
    this->outHashSize = r.outHashSize;
    this->outHash = r.outHash;
    this->validation = r.validation;
};
/// <summary>
/// This command performs a hash operation on a data buffer and returns the results.
/// </summary>
TpmStructureBase* HashResponse::Clone() const
{
    HashResponse* _x = new HashResponse(*this);
    return _x;
};
void* HashResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&outHashSize);
            case 1: { if(newArraySize != -1)outHash.resize(newArraySize); arraySize = (int)outHash.size(); return (void*)(&outHash); }
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&validation); return (void*) (&validation);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&outHash[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_HMAC_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_HMAC_REQUEST_ID;
};
/// <summary>
/// This command performs an HMAC on the supplied data using the indicated hash algorithm.
/// </summary>
TPM2_HMAC_REQUEST::TPM2_HMAC_REQUEST()
{
    return;
};
TPM2_HMAC_REQUEST::TPM2_HMAC_REQUEST
(
    const TPM_HANDLE& _handle,
    const std::vector<BYTE>& _buffer,
    const TPM_ALG_ID& _hashAlg
)
{
    handle= _handle;
    buffer= _buffer;
    hashAlg= _hashAlg;
};
/// <summary>
/// This command performs an HMAC on the supplied data using the indicated hash algorithm.
/// </summary>
TPM2_HMAC_REQUEST::~TPM2_HMAC_REQUEST()
{
    return;
};
/// <summary>
/// This command performs an HMAC on the supplied data using the indicated hash algorithm.
/// </summary>
TPM2_HMAC_REQUEST& TPM2_HMAC_REQUEST::operator=(const TPM2_HMAC_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->handle = rhs.handle;
    this->bufferSize = rhs.bufferSize;
    this->buffer = rhs.buffer;
    this->hashAlg = rhs.hashAlg;
    return *this;
};
/// <summary>
/// This command performs an HMAC on the supplied data using the indicated hash algorithm.
/// </summary>
TPM2_HMAC_REQUEST::TPM2_HMAC_REQUEST(const TPM2_HMAC_REQUEST& r)
{
    this->handle = r.handle;
    this->bufferSize = r.bufferSize;
    this->buffer = r.buffer;
    this->hashAlg = r.hashAlg;
};
/// <summary>
/// This command performs an HMAC on the supplied data using the indicated hash algorithm.
/// </summary>
TpmStructureBase* TPM2_HMAC_REQUEST::Clone() const
{
    TPM2_HMAC_REQUEST* _x = new TPM2_HMAC_REQUEST(*this);
    return _x;
};
void* TPM2_HMAC_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return (void*) (&handle);
            case 1: return (void*) (&bufferSize);
            case 2: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            case 3: return (void*) (&hashAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId HMACResponse::GetTypeId() const
{
    return TpmTypeId::HMACResponse_ID;
};
/// <summary>
/// This command performs an HMAC on the supplied data using the indicated hash algorithm.
/// </summary>
HMACResponse::HMACResponse()
{
    return;
};
HMACResponse::HMACResponse
(
    const std::vector<BYTE>& _outHMAC
)
{
    outHMAC= _outHMAC;
};
/// <summary>
/// This command performs an HMAC on the supplied data using the indicated hash algorithm.
/// </summary>
HMACResponse::~HMACResponse()
{
    return;
};
/// <summary>
/// This command performs an HMAC on the supplied data using the indicated hash algorithm.
/// </summary>
HMACResponse& HMACResponse::operator=(const HMACResponse& rhs)
{
    if(this == &rhs) return *this;
    this->outHMACSize = rhs.outHMACSize;
    this->outHMAC = rhs.outHMAC;
    return *this;
};
/// <summary>
/// This command performs an HMAC on the supplied data using the indicated hash algorithm.
/// </summary>
HMACResponse::HMACResponse(const HMACResponse& r)
{
    this->outHMACSize = r.outHMACSize;
    this->outHMAC = r.outHMAC;
};
/// <summary>
/// This command performs an HMAC on the supplied data using the indicated hash algorithm.
/// </summary>
TpmStructureBase* HMACResponse::Clone() const
{
    HMACResponse* _x = new HMACResponse(*this);
    return _x;
};
void* HMACResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&outHMACSize);
            case 1: { if(newArraySize != -1)outHMAC.resize(newArraySize); arraySize = (int)outHMAC.size(); return (void*)(&outHMAC); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&outHMAC[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_MAC_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_MAC_REQUEST_ID;
};
/// <summary>
/// This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
/// </summary>
TPM2_MAC_REQUEST::TPM2_MAC_REQUEST()
{
    return;
};
TPM2_MAC_REQUEST::TPM2_MAC_REQUEST
(
    const TPM_HANDLE& _handle,
    const std::vector<BYTE>& _buffer,
    const TPM_ALG_ID& _inScheme
)
{
    handle= _handle;
    buffer= _buffer;
    inScheme= _inScheme;
};
/// <summary>
/// This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
/// </summary>
TPM2_MAC_REQUEST::~TPM2_MAC_REQUEST()
{
    return;
};
/// <summary>
/// This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
/// </summary>
TPM2_MAC_REQUEST& TPM2_MAC_REQUEST::operator=(const TPM2_MAC_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->handle = rhs.handle;
    this->bufferSize = rhs.bufferSize;
    this->buffer = rhs.buffer;
    this->inScheme = rhs.inScheme;
    return *this;
};
/// <summary>
/// This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
/// </summary>
TPM2_MAC_REQUEST::TPM2_MAC_REQUEST(const TPM2_MAC_REQUEST& r)
{
    this->handle = r.handle;
    this->bufferSize = r.bufferSize;
    this->buffer = r.buffer;
    this->inScheme = r.inScheme;
};
/// <summary>
/// This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
/// </summary>
TpmStructureBase* TPM2_MAC_REQUEST::Clone() const
{
    TPM2_MAC_REQUEST* _x = new TPM2_MAC_REQUEST(*this);
    return _x;
};
void* TPM2_MAC_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return (void*) (&handle);
            case 1: return (void*) (&bufferSize);
            case 2: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            case 3: return (void*) (&inScheme);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId MACResponse::GetTypeId() const
{
    return TpmTypeId::MACResponse_ID;
};
/// <summary>
/// This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
/// </summary>
MACResponse::MACResponse()
{
    return;
};
MACResponse::MACResponse
(
    const std::vector<BYTE>& _outMAC
)
{
    outMAC= _outMAC;
};
/// <summary>
/// This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
/// </summary>
MACResponse::~MACResponse()
{
    return;
};
/// <summary>
/// This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
/// </summary>
MACResponse& MACResponse::operator=(const MACResponse& rhs)
{
    if(this == &rhs) return *this;
    this->outMACSize = rhs.outMACSize;
    this->outMAC = rhs.outMAC;
    return *this;
};
/// <summary>
/// This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
/// </summary>
MACResponse::MACResponse(const MACResponse& r)
{
    this->outMACSize = r.outMACSize;
    this->outMAC = r.outMAC;
};
/// <summary>
/// This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
/// </summary>
TpmStructureBase* MACResponse::Clone() const
{
    MACResponse* _x = new MACResponse(*this);
    return _x;
};
void* MACResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&outMACSize);
            case 1: { if(newArraySize != -1)outMAC.resize(newArraySize); arraySize = (int)outMAC.size(); return (void*)(&outMAC); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&outMAC[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_GetRandom_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_GetRandom_REQUEST_ID;
};
/// <summary>
/// This command returns the next bytesRequested octets from the random number generator (RNG).
/// </summary>
TPM2_GetRandom_REQUEST::TPM2_GetRandom_REQUEST()
{
    return;
};
TPM2_GetRandom_REQUEST::TPM2_GetRandom_REQUEST
(
    const UINT16& _bytesRequested
)
{
    bytesRequested= _bytesRequested;
};
/// <summary>
/// This command returns the next bytesRequested octets from the random number generator (RNG).
/// </summary>
TPM2_GetRandom_REQUEST::~TPM2_GetRandom_REQUEST()
{
    return;
};
/// <summary>
/// This command returns the next bytesRequested octets from the random number generator (RNG).
/// </summary>
TPM2_GetRandom_REQUEST& TPM2_GetRandom_REQUEST::operator=(const TPM2_GetRandom_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->bytesRequested = rhs.bytesRequested;
    return *this;
};
/// <summary>
/// This command returns the next bytesRequested octets from the random number generator (RNG).
/// </summary>
TPM2_GetRandom_REQUEST::TPM2_GetRandom_REQUEST(const TPM2_GetRandom_REQUEST& r)
{
    this->bytesRequested = r.bytesRequested;
};
/// <summary>
/// This command returns the next bytesRequested octets from the random number generator (RNG).
/// </summary>
TpmStructureBase* TPM2_GetRandom_REQUEST::Clone() const
{
    TPM2_GetRandom_REQUEST* _x = new TPM2_GetRandom_REQUEST(*this);
    return _x;
};
void* TPM2_GetRandom_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&bytesRequested);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId GetRandomResponse::GetTypeId() const
{
    return TpmTypeId::GetRandomResponse_ID;
};
/// <summary>
/// This command returns the next bytesRequested octets from the random number generator (RNG).
/// </summary>
GetRandomResponse::GetRandomResponse()
{
    return;
};
GetRandomResponse::GetRandomResponse
(
    const std::vector<BYTE>& _randomBytes
)
{
    randomBytes= _randomBytes;
};
/// <summary>
/// This command returns the next bytesRequested octets from the random number generator (RNG).
/// </summary>
GetRandomResponse::~GetRandomResponse()
{
    return;
};
/// <summary>
/// This command returns the next bytesRequested octets from the random number generator (RNG).
/// </summary>
GetRandomResponse& GetRandomResponse::operator=(const GetRandomResponse& rhs)
{
    if(this == &rhs) return *this;
    this->randomBytesSize = rhs.randomBytesSize;
    this->randomBytes = rhs.randomBytes;
    return *this;
};
/// <summary>
/// This command returns the next bytesRequested octets from the random number generator (RNG).
/// </summary>
GetRandomResponse::GetRandomResponse(const GetRandomResponse& r)
{
    this->randomBytesSize = r.randomBytesSize;
    this->randomBytes = r.randomBytes;
};
/// <summary>
/// This command returns the next bytesRequested octets from the random number generator (RNG).
/// </summary>
TpmStructureBase* GetRandomResponse::Clone() const
{
    GetRandomResponse* _x = new GetRandomResponse(*this);
    return _x;
};
void* GetRandomResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&randomBytesSize);
            case 1: { if(newArraySize != -1)randomBytes.resize(newArraySize); arraySize = (int)randomBytes.size(); return (void*)(&randomBytes); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&randomBytes[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_StirRandom_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_StirRandom_REQUEST_ID;
};
/// <summary>
/// This command is used to add "additional information" to the RNG state.
/// </summary>
TPM2_StirRandom_REQUEST::TPM2_StirRandom_REQUEST()
{
    return;
};
TPM2_StirRandom_REQUEST::TPM2_StirRandom_REQUEST
(
    const std::vector<BYTE>& _inData
)
{
    inData= _inData;
};
/// <summary>
/// This command is used to add "additional information" to the RNG state.
/// </summary>
TPM2_StirRandom_REQUEST::~TPM2_StirRandom_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to add "additional information" to the RNG state.
/// </summary>
TPM2_StirRandom_REQUEST& TPM2_StirRandom_REQUEST::operator=(const TPM2_StirRandom_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->inDataSize = rhs.inDataSize;
    this->inData = rhs.inData;
    return *this;
};
/// <summary>
/// This command is used to add "additional information" to the RNG state.
/// </summary>
TPM2_StirRandom_REQUEST::TPM2_StirRandom_REQUEST(const TPM2_StirRandom_REQUEST& r)
{
    this->inDataSize = r.inDataSize;
    this->inData = r.inData;
};
/// <summary>
/// This command is used to add "additional information" to the RNG state.
/// </summary>
TpmStructureBase* TPM2_StirRandom_REQUEST::Clone() const
{
    TPM2_StirRandom_REQUEST* _x = new TPM2_StirRandom_REQUEST(*this);
    return _x;
};
void* TPM2_StirRandom_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&inDataSize);
            case 1: { if(newArraySize != -1)inData.resize(newArraySize); arraySize = (int)inData.size(); return (void*)(&inData); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&inData[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId StirRandomResponse::GetTypeId() const
{
    return TpmTypeId::StirRandomResponse_ID;
};
/// <summary>
/// This command is used to add "additional information" to the RNG state.
/// </summary>
StirRandomResponse::StirRandomResponse()
{
    return;
};
/// <summary>
/// This command is used to add "additional information" to the RNG state.
/// </summary>
StirRandomResponse::~StirRandomResponse()
{
    return;
};
/// <summary>
/// This command is used to add "additional information" to the RNG state.
/// </summary>
StirRandomResponse& StirRandomResponse::operator=(const StirRandomResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command is used to add "additional information" to the RNG state.
/// </summary>
StirRandomResponse::StirRandomResponse(const StirRandomResponse& r)
{
};
/// <summary>
/// This command is used to add "additional information" to the RNG state.
/// </summary>
TpmStructureBase* StirRandomResponse::Clone() const
{
    StirRandomResponse* _x = new StirRandomResponse(*this);
    return _x;
};
void* StirRandomResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_HMAC_Start_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_HMAC_Start_REQUEST_ID;
};
/// <summary>
/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
TPM2_HMAC_Start_REQUEST::TPM2_HMAC_Start_REQUEST()
{
    return;
};
TPM2_HMAC_Start_REQUEST::TPM2_HMAC_Start_REQUEST
(
    const TPM_HANDLE& _handle,
    const std::vector<BYTE>& _auth,
    const TPM_ALG_ID& _hashAlg
)
{
    handle= _handle;
    auth= _auth;
    hashAlg= _hashAlg;
};
/// <summary>
/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
TPM2_HMAC_Start_REQUEST::~TPM2_HMAC_Start_REQUEST()
{
    return;
};
/// <summary>
/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
TPM2_HMAC_Start_REQUEST& TPM2_HMAC_Start_REQUEST::operator=(const TPM2_HMAC_Start_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->handle = rhs.handle;
    this->authSize = rhs.authSize;
    this->auth = rhs.auth;
    this->hashAlg = rhs.hashAlg;
    return *this;
};
/// <summary>
/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
TPM2_HMAC_Start_REQUEST::TPM2_HMAC_Start_REQUEST(const TPM2_HMAC_Start_REQUEST& r)
{
    this->handle = r.handle;
    this->authSize = r.authSize;
    this->auth = r.auth;
    this->hashAlg = r.hashAlg;
};
/// <summary>
/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
TpmStructureBase* TPM2_HMAC_Start_REQUEST::Clone() const
{
    TPM2_HMAC_Start_REQUEST* _x = new TPM2_HMAC_Start_REQUEST(*this);
    return _x;
};
void* TPM2_HMAC_Start_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return (void*) (&handle);
            case 1: return (void*) (&authSize);
            case 2: { if(newArraySize != -1)auth.resize(newArraySize); arraySize = (int)auth.size(); return (void*)(&auth); }
            case 3: return (void*) (&hashAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&auth[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId HMAC_StartResponse::GetTypeId() const
{
    return TpmTypeId::HMAC_StartResponse_ID;
};
/// <summary>
/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
HMAC_StartResponse::HMAC_StartResponse()
{
    return;
};
HMAC_StartResponse::HMAC_StartResponse
(
    const TPM_HANDLE& _handle
)
{
    handle= _handle;
};
/// <summary>
/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
HMAC_StartResponse::~HMAC_StartResponse()
{
    return;
};
/// <summary>
/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
HMAC_StartResponse& HMAC_StartResponse::operator=(const HMAC_StartResponse& rhs)
{
    if(this == &rhs) return *this;
    this->handle = rhs.handle;
    return *this;
};
/// <summary>
/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
HMAC_StartResponse::HMAC_StartResponse(const HMAC_StartResponse& r)
{
    this->handle = r.handle;
};
/// <summary>
/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
TpmStructureBase* HMAC_StartResponse::Clone() const
{
    HMAC_StartResponse* _x = new HMAC_StartResponse(*this);
    return _x;
};
void* HMAC_StartResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return (void*) (&handle);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_MAC_Start_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_MAC_Start_REQUEST_ID;
};
/// <summary>
/// This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
TPM2_MAC_Start_REQUEST::TPM2_MAC_Start_REQUEST()
{
    return;
};
TPM2_MAC_Start_REQUEST::TPM2_MAC_Start_REQUEST
(
    const TPM_HANDLE& _handle,
    const std::vector<BYTE>& _auth,
    const TPM_ALG_ID& _inScheme
)
{
    handle= _handle;
    auth= _auth;
    inScheme= _inScheme;
};
/// <summary>
/// This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
TPM2_MAC_Start_REQUEST::~TPM2_MAC_Start_REQUEST()
{
    return;
};
/// <summary>
/// This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
TPM2_MAC_Start_REQUEST& TPM2_MAC_Start_REQUEST::operator=(const TPM2_MAC_Start_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->handle = rhs.handle;
    this->authSize = rhs.authSize;
    this->auth = rhs.auth;
    this->inScheme = rhs.inScheme;
    return *this;
};
/// <summary>
/// This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
TPM2_MAC_Start_REQUEST::TPM2_MAC_Start_REQUEST(const TPM2_MAC_Start_REQUEST& r)
{
    this->handle = r.handle;
    this->authSize = r.authSize;
    this->auth = r.auth;
    this->inScheme = r.inScheme;
};
/// <summary>
/// This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
TpmStructureBase* TPM2_MAC_Start_REQUEST::Clone() const
{
    TPM2_MAC_Start_REQUEST* _x = new TPM2_MAC_Start_REQUEST(*this);
    return _x;
};
void* TPM2_MAC_Start_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return (void*) (&handle);
            case 1: return (void*) (&authSize);
            case 2: { if(newArraySize != -1)auth.resize(newArraySize); arraySize = (int)auth.size(); return (void*)(&auth); }
            case 3: return (void*) (&inScheme);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&auth[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId MAC_StartResponse::GetTypeId() const
{
    return TpmTypeId::MAC_StartResponse_ID;
};
/// <summary>
/// This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
MAC_StartResponse::MAC_StartResponse()
{
    return;
};
MAC_StartResponse::MAC_StartResponse
(
    const TPM_HANDLE& _handle
)
{
    handle= _handle;
};
/// <summary>
/// This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
MAC_StartResponse::~MAC_StartResponse()
{
    return;
};
/// <summary>
/// This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
MAC_StartResponse& MAC_StartResponse::operator=(const MAC_StartResponse& rhs)
{
    if(this == &rhs) return *this;
    this->handle = rhs.handle;
    return *this;
};
/// <summary>
/// This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
MAC_StartResponse::MAC_StartResponse(const MAC_StartResponse& r)
{
    this->handle = r.handle;
};
/// <summary>
/// This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
/// </summary>
TpmStructureBase* MAC_StartResponse::Clone() const
{
    MAC_StartResponse* _x = new MAC_StartResponse(*this);
    return _x;
};
void* MAC_StartResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return (void*) (&handle);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_HashSequenceStart_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_HashSequenceStart_REQUEST_ID;
};
/// <summary>
/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
/// </summary>
TPM2_HashSequenceStart_REQUEST::TPM2_HashSequenceStart_REQUEST()
{
    return;
};
TPM2_HashSequenceStart_REQUEST::TPM2_HashSequenceStart_REQUEST
(
    const std::vector<BYTE>& _auth,
    const TPM_ALG_ID& _hashAlg
)
{
    auth= _auth;
    hashAlg= _hashAlg;
};
/// <summary>
/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
/// </summary>
TPM2_HashSequenceStart_REQUEST::~TPM2_HashSequenceStart_REQUEST()
{
    return;
};
/// <summary>
/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
/// </summary>
TPM2_HashSequenceStart_REQUEST& TPM2_HashSequenceStart_REQUEST::operator=(const TPM2_HashSequenceStart_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authSize = rhs.authSize;
    this->auth = rhs.auth;
    this->hashAlg = rhs.hashAlg;
    return *this;
};
/// <summary>
/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
/// </summary>
TPM2_HashSequenceStart_REQUEST::TPM2_HashSequenceStart_REQUEST(const TPM2_HashSequenceStart_REQUEST& r)
{
    this->authSize = r.authSize;
    this->auth = r.auth;
    this->hashAlg = r.hashAlg;
};
/// <summary>
/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
/// </summary>
TpmStructureBase* TPM2_HashSequenceStart_REQUEST::Clone() const
{
    TPM2_HashSequenceStart_REQUEST* _x = new TPM2_HashSequenceStart_REQUEST(*this);
    return _x;
};
void* TPM2_HashSequenceStart_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&authSize);
            case 1: { if(newArraySize != -1)auth.resize(newArraySize); arraySize = (int)auth.size(); return (void*)(&auth); }
            case 2: return (void*) (&hashAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&auth[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId HashSequenceStartResponse::GetTypeId() const
{
    return TpmTypeId::HashSequenceStartResponse_ID;
};
/// <summary>
/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
/// </summary>
HashSequenceStartResponse::HashSequenceStartResponse()
{
    return;
};
HashSequenceStartResponse::HashSequenceStartResponse
(
    const TPM_HANDLE& _handle
)
{
    handle= _handle;
};
/// <summary>
/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
/// </summary>
HashSequenceStartResponse::~HashSequenceStartResponse()
{
    return;
};
/// <summary>
/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
/// </summary>
HashSequenceStartResponse& HashSequenceStartResponse::operator=(const HashSequenceStartResponse& rhs)
{
    if(this == &rhs) return *this;
    this->handle = rhs.handle;
    return *this;
};
/// <summary>
/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
/// </summary>
HashSequenceStartResponse::HashSequenceStartResponse(const HashSequenceStartResponse& r)
{
    this->handle = r.handle;
};
/// <summary>
/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
/// </summary>
TpmStructureBase* HashSequenceStartResponse::Clone() const
{
    HashSequenceStartResponse* _x = new HashSequenceStartResponse(*this);
    return _x;
};
void* HashSequenceStartResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return (void*) (&handle);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_SequenceUpdate_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_SequenceUpdate_REQUEST_ID;
};
/// <summary>
/// This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
/// </summary>
TPM2_SequenceUpdate_REQUEST::TPM2_SequenceUpdate_REQUEST()
{
    return;
};
TPM2_SequenceUpdate_REQUEST::TPM2_SequenceUpdate_REQUEST
(
    const TPM_HANDLE& _sequenceHandle,
    const std::vector<BYTE>& _buffer
)
{
    sequenceHandle= _sequenceHandle;
    buffer= _buffer;
};
/// <summary>
/// This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
/// </summary>
TPM2_SequenceUpdate_REQUEST::~TPM2_SequenceUpdate_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
/// </summary>
TPM2_SequenceUpdate_REQUEST& TPM2_SequenceUpdate_REQUEST::operator=(const TPM2_SequenceUpdate_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->sequenceHandle = rhs.sequenceHandle;
    this->bufferSize = rhs.bufferSize;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
/// </summary>
TPM2_SequenceUpdate_REQUEST::TPM2_SequenceUpdate_REQUEST(const TPM2_SequenceUpdate_REQUEST& r)
{
    this->sequenceHandle = r.sequenceHandle;
    this->bufferSize = r.bufferSize;
    this->buffer = r.buffer;
};
/// <summary>
/// This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
/// </summary>
TpmStructureBase* TPM2_SequenceUpdate_REQUEST::Clone() const
{
    TPM2_SequenceUpdate_REQUEST* _x = new TPM2_SequenceUpdate_REQUEST(*this);
    return _x;
};
void* TPM2_SequenceUpdate_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&sequenceHandle); return (void*) (&sequenceHandle);
            case 1: return (void*) (&bufferSize);
            case 2: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId SequenceUpdateResponse::GetTypeId() const
{
    return TpmTypeId::SequenceUpdateResponse_ID;
};
/// <summary>
/// This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
/// </summary>
SequenceUpdateResponse::SequenceUpdateResponse()
{
    return;
};
/// <summary>
/// This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
/// </summary>
SequenceUpdateResponse::~SequenceUpdateResponse()
{
    return;
};
/// <summary>
/// This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
/// </summary>
SequenceUpdateResponse& SequenceUpdateResponse::operator=(const SequenceUpdateResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
/// </summary>
SequenceUpdateResponse::SequenceUpdateResponse(const SequenceUpdateResponse& r)
{
};
/// <summary>
/// This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
/// </summary>
TpmStructureBase* SequenceUpdateResponse::Clone() const
{
    SequenceUpdateResponse* _x = new SequenceUpdateResponse(*this);
    return _x;
};
void* SequenceUpdateResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_SequenceComplete_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_SequenceComplete_REQUEST_ID;
};
/// <summary>
/// This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
/// </summary>
TPM2_SequenceComplete_REQUEST::TPM2_SequenceComplete_REQUEST()
{
    return;
};
TPM2_SequenceComplete_REQUEST::TPM2_SequenceComplete_REQUEST
(
    const TPM_HANDLE& _sequenceHandle,
    const std::vector<BYTE>& _buffer,
    const TPM_HANDLE& _hierarchy
)
{
    sequenceHandle= _sequenceHandle;
    buffer= _buffer;
    hierarchy= _hierarchy;
};
/// <summary>
/// This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
/// </summary>
TPM2_SequenceComplete_REQUEST::~TPM2_SequenceComplete_REQUEST()
{
    return;
};
/// <summary>
/// This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
/// </summary>
TPM2_SequenceComplete_REQUEST& TPM2_SequenceComplete_REQUEST::operator=(const TPM2_SequenceComplete_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->sequenceHandle = rhs.sequenceHandle;
    this->bufferSize = rhs.bufferSize;
    this->buffer = rhs.buffer;
    this->hierarchy = rhs.hierarchy;
    return *this;
};
/// <summary>
/// This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
/// </summary>
TPM2_SequenceComplete_REQUEST::TPM2_SequenceComplete_REQUEST(const TPM2_SequenceComplete_REQUEST& r)
{
    this->sequenceHandle = r.sequenceHandle;
    this->bufferSize = r.bufferSize;
    this->buffer = r.buffer;
    this->hierarchy = r.hierarchy;
};
/// <summary>
/// This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
/// </summary>
TpmStructureBase* TPM2_SequenceComplete_REQUEST::Clone() const
{
    TPM2_SequenceComplete_REQUEST* _x = new TPM2_SequenceComplete_REQUEST(*this);
    return _x;
};
void* TPM2_SequenceComplete_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&sequenceHandle); return (void*) (&sequenceHandle);
            case 1: return (void*) (&bufferSize);
            case 2: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return (void*) (&hierarchy);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId SequenceCompleteResponse::GetTypeId() const
{
    return TpmTypeId::SequenceCompleteResponse_ID;
};
/// <summary>
/// This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
/// </summary>
SequenceCompleteResponse::SequenceCompleteResponse()
{
    return;
};
SequenceCompleteResponse::SequenceCompleteResponse
(
    const std::vector<BYTE>& _result,
    const TPMT_TK_HASHCHECK& _validation
)
{
    result= _result;
    validation= _validation;
};
/// <summary>
/// This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
/// </summary>
SequenceCompleteResponse::~SequenceCompleteResponse()
{
    return;
};
/// <summary>
/// This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
/// </summary>
SequenceCompleteResponse& SequenceCompleteResponse::operator=(const SequenceCompleteResponse& rhs)
{
    if(this == &rhs) return *this;
    this->resultSize = rhs.resultSize;
    this->result = rhs.result;
    this->validation = rhs.validation;
    return *this;
};
/// <summary>
/// This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
/// </summary>
SequenceCompleteResponse::SequenceCompleteResponse(const SequenceCompleteResponse& r)
{
    this->resultSize = r.resultSize;
    this->result = r.result;
    this->validation = r.validation;
};
/// <summary>
/// This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
/// </summary>
TpmStructureBase* SequenceCompleteResponse::Clone() const
{
    SequenceCompleteResponse* _x = new SequenceCompleteResponse(*this);
    return _x;
};
void* SequenceCompleteResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&resultSize);
            case 1: { if(newArraySize != -1)result.resize(newArraySize); arraySize = (int)result.size(); return (void*)(&result); }
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&validation); return (void*) (&validation);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&result[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_EventSequenceComplete_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID;
};
/// <summary>
/// This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
/// </summary>
TPM2_EventSequenceComplete_REQUEST::TPM2_EventSequenceComplete_REQUEST()
{
    return;
};
TPM2_EventSequenceComplete_REQUEST::TPM2_EventSequenceComplete_REQUEST
(
    const TPM_HANDLE& _pcrHandle,
    const TPM_HANDLE& _sequenceHandle,
    const std::vector<BYTE>& _buffer
)
{
    pcrHandle= _pcrHandle;
    sequenceHandle= _sequenceHandle;
    buffer= _buffer;
};
/// <summary>
/// This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
/// </summary>
TPM2_EventSequenceComplete_REQUEST::~TPM2_EventSequenceComplete_REQUEST()
{
    return;
};
/// <summary>
/// This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
/// </summary>
TPM2_EventSequenceComplete_REQUEST& TPM2_EventSequenceComplete_REQUEST::operator=(const TPM2_EventSequenceComplete_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->pcrHandle = rhs.pcrHandle;
    this->sequenceHandle = rhs.sequenceHandle;
    this->bufferSize = rhs.bufferSize;
    this->buffer = rhs.buffer;
    return *this;
};
/// <summary>
/// This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
/// </summary>
TPM2_EventSequenceComplete_REQUEST::TPM2_EventSequenceComplete_REQUEST(const TPM2_EventSequenceComplete_REQUEST& r)
{
    this->pcrHandle = r.pcrHandle;
    this->sequenceHandle = r.sequenceHandle;
    this->bufferSize = r.bufferSize;
    this->buffer = r.buffer;
};
/// <summary>
/// This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
/// </summary>
TpmStructureBase* TPM2_EventSequenceComplete_REQUEST::Clone() const
{
    TPM2_EventSequenceComplete_REQUEST* _x = new TPM2_EventSequenceComplete_REQUEST(*this);
    return _x;
};
void* TPM2_EventSequenceComplete_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&pcrHandle); return (void*) (&pcrHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&sequenceHandle); return (void*) (&sequenceHandle);
            case 2: return (void*) (&bufferSize);
            case 3: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId EventSequenceCompleteResponse::GetTypeId() const
{
    return TpmTypeId::EventSequenceCompleteResponse_ID;
};
/// <summary>
/// This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
/// </summary>
EventSequenceCompleteResponse::EventSequenceCompleteResponse()
{
    return;
};
EventSequenceCompleteResponse::EventSequenceCompleteResponse
(
    const std::vector<TPMT_HA>& _results
)
{
    results= _results;
};
/// <summary>
/// This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
/// </summary>
EventSequenceCompleteResponse::~EventSequenceCompleteResponse()
{
    return;
};
/// <summary>
/// This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
/// </summary>
EventSequenceCompleteResponse& EventSequenceCompleteResponse::operator=(const EventSequenceCompleteResponse& rhs)
{
    if(this == &rhs) return *this;
    this->resultsCount = rhs.resultsCount;
    this->results = rhs.results;
    return *this;
};
/// <summary>
/// This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
/// </summary>
EventSequenceCompleteResponse::EventSequenceCompleteResponse(const EventSequenceCompleteResponse& r)
{
    this->resultsCount = r.resultsCount;
    this->results = r.results;
};
/// <summary>
/// This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
/// </summary>
TpmStructureBase* EventSequenceCompleteResponse::Clone() const
{
    EventSequenceCompleteResponse* _x = new EventSequenceCompleteResponse(*this);
    return _x;
};
void* EventSequenceCompleteResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&resultsCount);
            case 1: { if(newArraySize != -1)results.resize(newArraySize); arraySize = (int)results.size(); return (void*)(&results); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&results[arrayIndex]);return (void*)(&results[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_Certify_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Certify_REQUEST_ID;
};
/// <summary>
/// The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
/// </summary>
TPM2_Certify_REQUEST::TPM2_Certify_REQUEST()
{
    inScheme = NULL;
    return;
};
TPM2_Certify_REQUEST::TPM2_Certify_REQUEST
(
    const TPM_HANDLE& _objectHandle,
    const TPM_HANDLE& _signHandle,
    const std::vector<BYTE>& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme
)
{
    objectHandle= _objectHandle;
    signHandle= _signHandle;
    qualifyingData= _qualifyingData;
    inScheme = dynamic_cast<TPMU_SIG_SCHEME*> (_inScheme.Clone());
};
/// <summary>
/// The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
/// </summary>
TPM2_Certify_REQUEST::~TPM2_Certify_REQUEST()
{
    if(inScheme != NULL) { delete inScheme;inScheme=NULL; }
    return;
};
/// <summary>
/// The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
/// </summary>
TPM2_Certify_REQUEST& TPM2_Certify_REQUEST::operator=(const TPM2_Certify_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->objectHandle = rhs.objectHandle;
    this->signHandle = rhs.signHandle;
    this->qualifyingDataSize = rhs.qualifyingDataSize;
    this->qualifyingData = rhs.qualifyingData;
    this->inSchemeScheme = rhs.inSchemeScheme;
    if(inScheme != NULL) delete inScheme;
    if(rhs.inScheme != NULL)inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(rhs.inScheme->Clone());
    return *this;
};
/// <summary>
/// The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
/// </summary>
TPM2_Certify_REQUEST::TPM2_Certify_REQUEST(const TPM2_Certify_REQUEST& r)
{
    this->objectHandle = r.objectHandle;
    this->signHandle = r.signHandle;
    this->qualifyingDataSize = r.qualifyingDataSize;
    this->qualifyingData = r.qualifyingData;
    this->inSchemeScheme = r.inSchemeScheme;
    if(r.inScheme != NULL)inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(r.inScheme->Clone());
};
/// <summary>
/// The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
/// </summary>
TpmStructureBase* TPM2_Certify_REQUEST::Clone() const
{
    TPM2_Certify_REQUEST* _x = new TPM2_Certify_REQUEST(*this);
    return _x;
};
void* TPM2_Certify_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return (void*) (&objectHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return (void*) (&signHandle);
            case 2: return (void*) (&qualifyingDataSize);
            case 3: { if(newArraySize != -1)qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return (void*)(&qualifyingData); }
            case 4: return (void*) (&inSchemeScheme);
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(inScheme); return (void*) (&inScheme);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&qualifyingData[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId CertifyResponse::GetTypeId() const
{
    return TpmTypeId::CertifyResponse_ID;
};
/// <summary>
/// The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
/// </summary>
CertifyResponse::CertifyResponse()
{
    signature = NULL;
    return;
};
CertifyResponse::CertifyResponse
(
    const TPMS_ATTEST& _certifyInfo,
    const TPMU_SIGNATURE& _signature
)
{
    certifyInfo= _certifyInfo;
    signature = dynamic_cast<TPMU_SIGNATURE*> (_signature.Clone());
};
/// <summary>
/// The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
/// </summary>
CertifyResponse::~CertifyResponse()
{
    if(signature != NULL) { delete signature;signature=NULL; }
    return;
};
/// <summary>
/// The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
/// </summary>
CertifyResponse& CertifyResponse::operator=(const CertifyResponse& rhs)
{
    if(this == &rhs) return *this;
    this->certifyInfoSize = rhs.certifyInfoSize;
    this->certifyInfo = rhs.certifyInfo;
    this->signatureSigAlg = rhs.signatureSigAlg;
    if(signature != NULL) delete signature;
    if(rhs.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(rhs.signature->Clone());
    return *this;
};
/// <summary>
/// The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
/// </summary>
CertifyResponse::CertifyResponse(const CertifyResponse& r)
{
    this->certifyInfoSize = r.certifyInfoSize;
    this->certifyInfo = r.certifyInfo;
    this->signatureSigAlg = r.signatureSigAlg;
    if(r.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(r.signature->Clone());
};
/// <summary>
/// The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
/// </summary>
TpmStructureBase* CertifyResponse::Clone() const
{
    CertifyResponse* _x = new CertifyResponse(*this);
    return _x;
};
void* CertifyResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&certifyInfoSize);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&certifyInfo); return (void*) (&certifyInfo);
            case 2: return (void*) (&signatureSigAlg);
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(signature); return (void*) (&signature);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_CertifyCreation_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
};
/// <summary>
/// This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
/// </summary>
TPM2_CertifyCreation_REQUEST::TPM2_CertifyCreation_REQUEST()
{
    inScheme = NULL;
    return;
};
TPM2_CertifyCreation_REQUEST::TPM2_CertifyCreation_REQUEST
(
    const TPM_HANDLE& _signHandle,
    const TPM_HANDLE& _objectHandle,
    const std::vector<BYTE>& _qualifyingData,
    const std::vector<BYTE>& _creationHash,
    const TPMU_SIG_SCHEME& _inScheme,
    const TPMT_TK_CREATION& _creationTicket
)
{
    signHandle= _signHandle;
    objectHandle= _objectHandle;
    qualifyingData= _qualifyingData;
    creationHash= _creationHash;
    inScheme = dynamic_cast<TPMU_SIG_SCHEME*> (_inScheme.Clone());
    creationTicket= _creationTicket;
};
/// <summary>
/// This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
/// </summary>
TPM2_CertifyCreation_REQUEST::~TPM2_CertifyCreation_REQUEST()
{
    if(inScheme != NULL) { delete inScheme;inScheme=NULL; }
    return;
};
/// <summary>
/// This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
/// </summary>
TPM2_CertifyCreation_REQUEST& TPM2_CertifyCreation_REQUEST::operator=(const TPM2_CertifyCreation_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->signHandle = rhs.signHandle;
    this->objectHandle = rhs.objectHandle;
    this->qualifyingDataSize = rhs.qualifyingDataSize;
    this->qualifyingData = rhs.qualifyingData;
    this->creationHashSize = rhs.creationHashSize;
    this->creationHash = rhs.creationHash;
    this->inSchemeScheme = rhs.inSchemeScheme;
    if(inScheme != NULL) delete inScheme;
    if(rhs.inScheme != NULL)inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(rhs.inScheme->Clone());
    this->creationTicket = rhs.creationTicket;
    return *this;
};
/// <summary>
/// This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
/// </summary>
TPM2_CertifyCreation_REQUEST::TPM2_CertifyCreation_REQUEST(const TPM2_CertifyCreation_REQUEST& r)
{
    this->signHandle = r.signHandle;
    this->objectHandle = r.objectHandle;
    this->qualifyingDataSize = r.qualifyingDataSize;
    this->qualifyingData = r.qualifyingData;
    this->creationHashSize = r.creationHashSize;
    this->creationHash = r.creationHash;
    this->inSchemeScheme = r.inSchemeScheme;
    if(r.inScheme != NULL)inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(r.inScheme->Clone());
    this->creationTicket = r.creationTicket;
};
/// <summary>
/// This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
/// </summary>
TpmStructureBase* TPM2_CertifyCreation_REQUEST::Clone() const
{
    TPM2_CertifyCreation_REQUEST* _x = new TPM2_CertifyCreation_REQUEST(*this);
    return _x;
};
void* TPM2_CertifyCreation_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return (void*) (&signHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return (void*) (&objectHandle);
            case 2: return (void*) (&qualifyingDataSize);
            case 3: { if(newArraySize != -1)qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return (void*)(&qualifyingData); }
            case 4: return (void*) (&creationHashSize);
            case 5: { if(newArraySize != -1)creationHash.resize(newArraySize); arraySize = (int)creationHash.size(); return (void*)(&creationHash); }
            case 6: return (void*) (&inSchemeScheme);
            case 7: pStruct = dynamic_cast<TpmStructureBase*>(inScheme); return (void*) (&inScheme);
            case 8: pStruct = dynamic_cast<TpmStructureBase*>(&creationTicket); return (void*) (&creationTicket);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&qualifyingData[arrayIndex]);
            case 5: return (void*)(&creationHash[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId CertifyCreationResponse::GetTypeId() const
{
    return TpmTypeId::CertifyCreationResponse_ID;
};
/// <summary>
/// This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
/// </summary>
CertifyCreationResponse::CertifyCreationResponse()
{
    signature = NULL;
    return;
};
CertifyCreationResponse::CertifyCreationResponse
(
    const TPMS_ATTEST& _certifyInfo,
    const TPMU_SIGNATURE& _signature
)
{
    certifyInfo= _certifyInfo;
    signature = dynamic_cast<TPMU_SIGNATURE*> (_signature.Clone());
};
/// <summary>
/// This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
/// </summary>
CertifyCreationResponse::~CertifyCreationResponse()
{
    if(signature != NULL) { delete signature;signature=NULL; }
    return;
};
/// <summary>
/// This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
/// </summary>
CertifyCreationResponse& CertifyCreationResponse::operator=(const CertifyCreationResponse& rhs)
{
    if(this == &rhs) return *this;
    this->certifyInfoSize = rhs.certifyInfoSize;
    this->certifyInfo = rhs.certifyInfo;
    this->signatureSigAlg = rhs.signatureSigAlg;
    if(signature != NULL) delete signature;
    if(rhs.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(rhs.signature->Clone());
    return *this;
};
/// <summary>
/// This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
/// </summary>
CertifyCreationResponse::CertifyCreationResponse(const CertifyCreationResponse& r)
{
    this->certifyInfoSize = r.certifyInfoSize;
    this->certifyInfo = r.certifyInfo;
    this->signatureSigAlg = r.signatureSigAlg;
    if(r.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(r.signature->Clone());
};
/// <summary>
/// This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
/// </summary>
TpmStructureBase* CertifyCreationResponse::Clone() const
{
    CertifyCreationResponse* _x = new CertifyCreationResponse(*this);
    return _x;
};
void* CertifyCreationResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&certifyInfoSize);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&certifyInfo); return (void*) (&certifyInfo);
            case 2: return (void*) (&signatureSigAlg);
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(signature); return (void*) (&signature);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_Quote_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Quote_REQUEST_ID;
};
/// <summary>
/// This command is used to quote PCR values.
/// </summary>
TPM2_Quote_REQUEST::TPM2_Quote_REQUEST()
{
    inScheme = NULL;
    return;
};
TPM2_Quote_REQUEST::TPM2_Quote_REQUEST
(
    const TPM_HANDLE& _signHandle,
    const std::vector<BYTE>& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme,
    const std::vector<TPMS_PCR_SELECTION>& _PCRselect
)
{
    signHandle= _signHandle;
    qualifyingData= _qualifyingData;
    inScheme = dynamic_cast<TPMU_SIG_SCHEME*> (_inScheme.Clone());
    PCRselect= _PCRselect;
};
/// <summary>
/// This command is used to quote PCR values.
/// </summary>
TPM2_Quote_REQUEST::~TPM2_Quote_REQUEST()
{
    if(inScheme != NULL) { delete inScheme;inScheme=NULL; }
    return;
};
/// <summary>
/// This command is used to quote PCR values.
/// </summary>
TPM2_Quote_REQUEST& TPM2_Quote_REQUEST::operator=(const TPM2_Quote_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->signHandle = rhs.signHandle;
    this->qualifyingDataSize = rhs.qualifyingDataSize;
    this->qualifyingData = rhs.qualifyingData;
    this->inSchemeScheme = rhs.inSchemeScheme;
    if(inScheme != NULL) delete inScheme;
    if(rhs.inScheme != NULL)inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(rhs.inScheme->Clone());
    this->PCRselectCount = rhs.PCRselectCount;
    this->PCRselect = rhs.PCRselect;
    return *this;
};
/// <summary>
/// This command is used to quote PCR values.
/// </summary>
TPM2_Quote_REQUEST::TPM2_Quote_REQUEST(const TPM2_Quote_REQUEST& r)
{
    this->signHandle = r.signHandle;
    this->qualifyingDataSize = r.qualifyingDataSize;
    this->qualifyingData = r.qualifyingData;
    this->inSchemeScheme = r.inSchemeScheme;
    if(r.inScheme != NULL)inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(r.inScheme->Clone());
    this->PCRselectCount = r.PCRselectCount;
    this->PCRselect = r.PCRselect;
};
/// <summary>
/// This command is used to quote PCR values.
/// </summary>
TpmStructureBase* TPM2_Quote_REQUEST::Clone() const
{
    TPM2_Quote_REQUEST* _x = new TPM2_Quote_REQUEST(*this);
    return _x;
};
void* TPM2_Quote_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return (void*) (&signHandle);
            case 1: return (void*) (&qualifyingDataSize);
            case 2: { if(newArraySize != -1)qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return (void*)(&qualifyingData); }
            case 3: return (void*) (&inSchemeScheme);
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(inScheme); return (void*) (&inScheme);
            case 5: return (void*) (&PCRselectCount);
            case 6: { if(newArraySize != -1)PCRselect.resize(newArraySize); arraySize = (int)PCRselect.size(); return (void*)(&PCRselect); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&qualifyingData[arrayIndex]);
            case 6: pStruct = dynamic_cast<TpmStructureBase*>(&PCRselect[arrayIndex]);return (void*)(&PCRselect[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId QuoteResponse::GetTypeId() const
{
    return TpmTypeId::QuoteResponse_ID;
};
/// <summary>
/// This command is used to quote PCR values.
/// </summary>
QuoteResponse::QuoteResponse()
{
    signature = NULL;
    return;
};
QuoteResponse::QuoteResponse
(
    const TPMS_ATTEST& _quoted,
    const TPMU_SIGNATURE& _signature
)
{
    quoted= _quoted;
    signature = dynamic_cast<TPMU_SIGNATURE*> (_signature.Clone());
};
/// <summary>
/// This command is used to quote PCR values.
/// </summary>
QuoteResponse::~QuoteResponse()
{
    if(signature != NULL) { delete signature;signature=NULL; }
    return;
};
/// <summary>
/// This command is used to quote PCR values.
/// </summary>
QuoteResponse& QuoteResponse::operator=(const QuoteResponse& rhs)
{
    if(this == &rhs) return *this;
    this->quotedSize = rhs.quotedSize;
    this->quoted = rhs.quoted;
    this->signatureSigAlg = rhs.signatureSigAlg;
    if(signature != NULL) delete signature;
    if(rhs.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(rhs.signature->Clone());
    return *this;
};
/// <summary>
/// This command is used to quote PCR values.
/// </summary>
QuoteResponse::QuoteResponse(const QuoteResponse& r)
{
    this->quotedSize = r.quotedSize;
    this->quoted = r.quoted;
    this->signatureSigAlg = r.signatureSigAlg;
    if(r.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(r.signature->Clone());
};
/// <summary>
/// This command is used to quote PCR values.
/// </summary>
TpmStructureBase* QuoteResponse::Clone() const
{
    QuoteResponse* _x = new QuoteResponse(*this);
    return _x;
};
void* QuoteResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&quotedSize);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&quoted); return (void*) (&quoted);
            case 2: return (void*) (&signatureSigAlg);
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(signature); return (void*) (&signature);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_GetSessionAuditDigest_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
};
/// <summary>
/// This command returns a digital signature of the audit session digest.
/// </summary>
TPM2_GetSessionAuditDigest_REQUEST::TPM2_GetSessionAuditDigest_REQUEST()
{
    inScheme = NULL;
    return;
};
TPM2_GetSessionAuditDigest_REQUEST::TPM2_GetSessionAuditDigest_REQUEST
(
    const TPM_HANDLE& _privacyAdminHandle,
    const TPM_HANDLE& _signHandle,
    const TPM_HANDLE& _sessionHandle,
    const std::vector<BYTE>& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme
)
{
    privacyAdminHandle= _privacyAdminHandle;
    signHandle= _signHandle;
    sessionHandle= _sessionHandle;
    qualifyingData= _qualifyingData;
    inScheme = dynamic_cast<TPMU_SIG_SCHEME*> (_inScheme.Clone());
};
/// <summary>
/// This command returns a digital signature of the audit session digest.
/// </summary>
TPM2_GetSessionAuditDigest_REQUEST::~TPM2_GetSessionAuditDigest_REQUEST()
{
    if(inScheme != NULL) { delete inScheme;inScheme=NULL; }
    return;
};
/// <summary>
/// This command returns a digital signature of the audit session digest.
/// </summary>
TPM2_GetSessionAuditDigest_REQUEST& TPM2_GetSessionAuditDigest_REQUEST::operator=(const TPM2_GetSessionAuditDigest_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->privacyAdminHandle = rhs.privacyAdminHandle;
    this->signHandle = rhs.signHandle;
    this->sessionHandle = rhs.sessionHandle;
    this->qualifyingDataSize = rhs.qualifyingDataSize;
    this->qualifyingData = rhs.qualifyingData;
    this->inSchemeScheme = rhs.inSchemeScheme;
    if(inScheme != NULL) delete inScheme;
    if(rhs.inScheme != NULL)inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(rhs.inScheme->Clone());
    return *this;
};
/// <summary>
/// This command returns a digital signature of the audit session digest.
/// </summary>
TPM2_GetSessionAuditDigest_REQUEST::TPM2_GetSessionAuditDigest_REQUEST(const TPM2_GetSessionAuditDigest_REQUEST& r)
{
    this->privacyAdminHandle = r.privacyAdminHandle;
    this->signHandle = r.signHandle;
    this->sessionHandle = r.sessionHandle;
    this->qualifyingDataSize = r.qualifyingDataSize;
    this->qualifyingData = r.qualifyingData;
    this->inSchemeScheme = r.inSchemeScheme;
    if(r.inScheme != NULL)inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(r.inScheme->Clone());
};
/// <summary>
/// This command returns a digital signature of the audit session digest.
/// </summary>
TpmStructureBase* TPM2_GetSessionAuditDigest_REQUEST::Clone() const
{
    TPM2_GetSessionAuditDigest_REQUEST* _x = new TPM2_GetSessionAuditDigest_REQUEST(*this);
    return _x;
};
void* TPM2_GetSessionAuditDigest_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&privacyAdminHandle); return (void*) (&privacyAdminHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return (void*) (&signHandle);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&sessionHandle); return (void*) (&sessionHandle);
            case 3: return (void*) (&qualifyingDataSize);
            case 4: { if(newArraySize != -1)qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return (void*)(&qualifyingData); }
            case 5: return (void*) (&inSchemeScheme);
            case 6: pStruct = dynamic_cast<TpmStructureBase*>(inScheme); return (void*) (&inScheme);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 4: return (void*)(&qualifyingData[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId GetSessionAuditDigestResponse::GetTypeId() const
{
    return TpmTypeId::GetSessionAuditDigestResponse_ID;
};
/// <summary>
/// This command returns a digital signature of the audit session digest.
/// </summary>
GetSessionAuditDigestResponse::GetSessionAuditDigestResponse()
{
    signature = NULL;
    return;
};
GetSessionAuditDigestResponse::GetSessionAuditDigestResponse
(
    const TPMS_ATTEST& _auditInfo,
    const TPMU_SIGNATURE& _signature
)
{
    auditInfo= _auditInfo;
    signature = dynamic_cast<TPMU_SIGNATURE*> (_signature.Clone());
};
/// <summary>
/// This command returns a digital signature of the audit session digest.
/// </summary>
GetSessionAuditDigestResponse::~GetSessionAuditDigestResponse()
{
    if(signature != NULL) { delete signature;signature=NULL; }
    return;
};
/// <summary>
/// This command returns a digital signature of the audit session digest.
/// </summary>
GetSessionAuditDigestResponse& GetSessionAuditDigestResponse::operator=(const GetSessionAuditDigestResponse& rhs)
{
    if(this == &rhs) return *this;
    this->auditInfoSize = rhs.auditInfoSize;
    this->auditInfo = rhs.auditInfo;
    this->signatureSigAlg = rhs.signatureSigAlg;
    if(signature != NULL) delete signature;
    if(rhs.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(rhs.signature->Clone());
    return *this;
};
/// <summary>
/// This command returns a digital signature of the audit session digest.
/// </summary>
GetSessionAuditDigestResponse::GetSessionAuditDigestResponse(const GetSessionAuditDigestResponse& r)
{
    this->auditInfoSize = r.auditInfoSize;
    this->auditInfo = r.auditInfo;
    this->signatureSigAlg = r.signatureSigAlg;
    if(r.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(r.signature->Clone());
};
/// <summary>
/// This command returns a digital signature of the audit session digest.
/// </summary>
TpmStructureBase* GetSessionAuditDigestResponse::Clone() const
{
    GetSessionAuditDigestResponse* _x = new GetSessionAuditDigestResponse(*this);
    return _x;
};
void* GetSessionAuditDigestResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&auditInfoSize);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&auditInfo); return (void*) (&auditInfo);
            case 2: return (void*) (&signatureSigAlg);
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(signature); return (void*) (&signature);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_GetCommandAuditDigest_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
};
/// <summary>
/// This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
/// </summary>
TPM2_GetCommandAuditDigest_REQUEST::TPM2_GetCommandAuditDigest_REQUEST()
{
    inScheme = NULL;
    return;
};
TPM2_GetCommandAuditDigest_REQUEST::TPM2_GetCommandAuditDigest_REQUEST
(
    const TPM_HANDLE& _privacyHandle,
    const TPM_HANDLE& _signHandle,
    const std::vector<BYTE>& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme
)
{
    privacyHandle= _privacyHandle;
    signHandle= _signHandle;
    qualifyingData= _qualifyingData;
    inScheme = dynamic_cast<TPMU_SIG_SCHEME*> (_inScheme.Clone());
};
/// <summary>
/// This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
/// </summary>
TPM2_GetCommandAuditDigest_REQUEST::~TPM2_GetCommandAuditDigest_REQUEST()
{
    if(inScheme != NULL) { delete inScheme;inScheme=NULL; }
    return;
};
/// <summary>
/// This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
/// </summary>
TPM2_GetCommandAuditDigest_REQUEST& TPM2_GetCommandAuditDigest_REQUEST::operator=(const TPM2_GetCommandAuditDigest_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->privacyHandle = rhs.privacyHandle;
    this->signHandle = rhs.signHandle;
    this->qualifyingDataSize = rhs.qualifyingDataSize;
    this->qualifyingData = rhs.qualifyingData;
    this->inSchemeScheme = rhs.inSchemeScheme;
    if(inScheme != NULL) delete inScheme;
    if(rhs.inScheme != NULL)inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(rhs.inScheme->Clone());
    return *this;
};
/// <summary>
/// This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
/// </summary>
TPM2_GetCommandAuditDigest_REQUEST::TPM2_GetCommandAuditDigest_REQUEST(const TPM2_GetCommandAuditDigest_REQUEST& r)
{
    this->privacyHandle = r.privacyHandle;
    this->signHandle = r.signHandle;
    this->qualifyingDataSize = r.qualifyingDataSize;
    this->qualifyingData = r.qualifyingData;
    this->inSchemeScheme = r.inSchemeScheme;
    if(r.inScheme != NULL)inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(r.inScheme->Clone());
};
/// <summary>
/// This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
/// </summary>
TpmStructureBase* TPM2_GetCommandAuditDigest_REQUEST::Clone() const
{
    TPM2_GetCommandAuditDigest_REQUEST* _x = new TPM2_GetCommandAuditDigest_REQUEST(*this);
    return _x;
};
void* TPM2_GetCommandAuditDigest_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&privacyHandle); return (void*) (&privacyHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return (void*) (&signHandle);
            case 2: return (void*) (&qualifyingDataSize);
            case 3: { if(newArraySize != -1)qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return (void*)(&qualifyingData); }
            case 4: return (void*) (&inSchemeScheme);
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(inScheme); return (void*) (&inScheme);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&qualifyingData[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId GetCommandAuditDigestResponse::GetTypeId() const
{
    return TpmTypeId::GetCommandAuditDigestResponse_ID;
};
/// <summary>
/// This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
/// </summary>
GetCommandAuditDigestResponse::GetCommandAuditDigestResponse()
{
    signature = NULL;
    return;
};
GetCommandAuditDigestResponse::GetCommandAuditDigestResponse
(
    const TPMS_ATTEST& _auditInfo,
    const TPMU_SIGNATURE& _signature
)
{
    auditInfo= _auditInfo;
    signature = dynamic_cast<TPMU_SIGNATURE*> (_signature.Clone());
};
/// <summary>
/// This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
/// </summary>
GetCommandAuditDigestResponse::~GetCommandAuditDigestResponse()
{
    if(signature != NULL) { delete signature;signature=NULL; }
    return;
};
/// <summary>
/// This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
/// </summary>
GetCommandAuditDigestResponse& GetCommandAuditDigestResponse::operator=(const GetCommandAuditDigestResponse& rhs)
{
    if(this == &rhs) return *this;
    this->auditInfoSize = rhs.auditInfoSize;
    this->auditInfo = rhs.auditInfo;
    this->signatureSigAlg = rhs.signatureSigAlg;
    if(signature != NULL) delete signature;
    if(rhs.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(rhs.signature->Clone());
    return *this;
};
/// <summary>
/// This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
/// </summary>
GetCommandAuditDigestResponse::GetCommandAuditDigestResponse(const GetCommandAuditDigestResponse& r)
{
    this->auditInfoSize = r.auditInfoSize;
    this->auditInfo = r.auditInfo;
    this->signatureSigAlg = r.signatureSigAlg;
    if(r.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(r.signature->Clone());
};
/// <summary>
/// This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
/// </summary>
TpmStructureBase* GetCommandAuditDigestResponse::Clone() const
{
    GetCommandAuditDigestResponse* _x = new GetCommandAuditDigestResponse(*this);
    return _x;
};
void* GetCommandAuditDigestResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&auditInfoSize);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&auditInfo); return (void*) (&auditInfo);
            case 2: return (void*) (&signatureSigAlg);
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(signature); return (void*) (&signature);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_GetTime_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_GetTime_REQUEST_ID;
};
/// <summary>
/// This command returns the current values of Time and Clock.
/// </summary>
TPM2_GetTime_REQUEST::TPM2_GetTime_REQUEST()
{
    inScheme = NULL;
    return;
};
TPM2_GetTime_REQUEST::TPM2_GetTime_REQUEST
(
    const TPM_HANDLE& _privacyAdminHandle,
    const TPM_HANDLE& _signHandle,
    const std::vector<BYTE>& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme
)
{
    privacyAdminHandle= _privacyAdminHandle;
    signHandle= _signHandle;
    qualifyingData= _qualifyingData;
    inScheme = dynamic_cast<TPMU_SIG_SCHEME*> (_inScheme.Clone());
};
/// <summary>
/// This command returns the current values of Time and Clock.
/// </summary>
TPM2_GetTime_REQUEST::~TPM2_GetTime_REQUEST()
{
    if(inScheme != NULL) { delete inScheme;inScheme=NULL; }
    return;
};
/// <summary>
/// This command returns the current values of Time and Clock.
/// </summary>
TPM2_GetTime_REQUEST& TPM2_GetTime_REQUEST::operator=(const TPM2_GetTime_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->privacyAdminHandle = rhs.privacyAdminHandle;
    this->signHandle = rhs.signHandle;
    this->qualifyingDataSize = rhs.qualifyingDataSize;
    this->qualifyingData = rhs.qualifyingData;
    this->inSchemeScheme = rhs.inSchemeScheme;
    if(inScheme != NULL) delete inScheme;
    if(rhs.inScheme != NULL)inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(rhs.inScheme->Clone());
    return *this;
};
/// <summary>
/// This command returns the current values of Time and Clock.
/// </summary>
TPM2_GetTime_REQUEST::TPM2_GetTime_REQUEST(const TPM2_GetTime_REQUEST& r)
{
    this->privacyAdminHandle = r.privacyAdminHandle;
    this->signHandle = r.signHandle;
    this->qualifyingDataSize = r.qualifyingDataSize;
    this->qualifyingData = r.qualifyingData;
    this->inSchemeScheme = r.inSchemeScheme;
    if(r.inScheme != NULL)inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(r.inScheme->Clone());
};
/// <summary>
/// This command returns the current values of Time and Clock.
/// </summary>
TpmStructureBase* TPM2_GetTime_REQUEST::Clone() const
{
    TPM2_GetTime_REQUEST* _x = new TPM2_GetTime_REQUEST(*this);
    return _x;
};
void* TPM2_GetTime_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&privacyAdminHandle); return (void*) (&privacyAdminHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return (void*) (&signHandle);
            case 2: return (void*) (&qualifyingDataSize);
            case 3: { if(newArraySize != -1)qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return (void*)(&qualifyingData); }
            case 4: return (void*) (&inSchemeScheme);
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(inScheme); return (void*) (&inScheme);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&qualifyingData[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId GetTimeResponse::GetTypeId() const
{
    return TpmTypeId::GetTimeResponse_ID;
};
/// <summary>
/// This command returns the current values of Time and Clock.
/// </summary>
GetTimeResponse::GetTimeResponse()
{
    signature = NULL;
    return;
};
GetTimeResponse::GetTimeResponse
(
    const TPMS_ATTEST& _timeInfo,
    const TPMU_SIGNATURE& _signature
)
{
    timeInfo= _timeInfo;
    signature = dynamic_cast<TPMU_SIGNATURE*> (_signature.Clone());
};
/// <summary>
/// This command returns the current values of Time and Clock.
/// </summary>
GetTimeResponse::~GetTimeResponse()
{
    if(signature != NULL) { delete signature;signature=NULL; }
    return;
};
/// <summary>
/// This command returns the current values of Time and Clock.
/// </summary>
GetTimeResponse& GetTimeResponse::operator=(const GetTimeResponse& rhs)
{
    if(this == &rhs) return *this;
    this->timeInfoSize = rhs.timeInfoSize;
    this->timeInfo = rhs.timeInfo;
    this->signatureSigAlg = rhs.signatureSigAlg;
    if(signature != NULL) delete signature;
    if(rhs.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(rhs.signature->Clone());
    return *this;
};
/// <summary>
/// This command returns the current values of Time and Clock.
/// </summary>
GetTimeResponse::GetTimeResponse(const GetTimeResponse& r)
{
    this->timeInfoSize = r.timeInfoSize;
    this->timeInfo = r.timeInfo;
    this->signatureSigAlg = r.signatureSigAlg;
    if(r.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(r.signature->Clone());
};
/// <summary>
/// This command returns the current values of Time and Clock.
/// </summary>
TpmStructureBase* GetTimeResponse::Clone() const
{
    GetTimeResponse* _x = new GetTimeResponse(*this);
    return _x;
};
void* GetTimeResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&timeInfoSize);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&timeInfo); return (void*) (&timeInfo);
            case 2: return (void*) (&signatureSigAlg);
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(signature); return (void*) (&signature);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_CertifyX509_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
};
/// <summary>
/// The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
/// </summary>
TPM2_CertifyX509_REQUEST::TPM2_CertifyX509_REQUEST()
{
    inScheme = NULL;
    return;
};
TPM2_CertifyX509_REQUEST::TPM2_CertifyX509_REQUEST
(
    const TPM_HANDLE& _objectHandle,
    const TPM_HANDLE& _signHandle,
    const std::vector<BYTE>& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme,
    const std::vector<BYTE>& _partialCertificate
)
{
    objectHandle= _objectHandle;
    signHandle= _signHandle;
    qualifyingData= _qualifyingData;
    inScheme = dynamic_cast<TPMU_SIG_SCHEME*> (_inScheme.Clone());
    partialCertificate= _partialCertificate;
};
/// <summary>
/// The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
/// </summary>
TPM2_CertifyX509_REQUEST::~TPM2_CertifyX509_REQUEST()
{
    if(inScheme != NULL) { delete inScheme;inScheme=NULL; }
    return;
};
/// <summary>
/// The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
/// </summary>
TPM2_CertifyX509_REQUEST& TPM2_CertifyX509_REQUEST::operator=(const TPM2_CertifyX509_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->objectHandle = rhs.objectHandle;
    this->signHandle = rhs.signHandle;
    this->qualifyingDataSize = rhs.qualifyingDataSize;
    this->qualifyingData = rhs.qualifyingData;
    this->inSchemeScheme = rhs.inSchemeScheme;
    if(inScheme != NULL) delete inScheme;
    if(rhs.inScheme != NULL)inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(rhs.inScheme->Clone());
    this->partialCertificateSize = rhs.partialCertificateSize;
    this->partialCertificate = rhs.partialCertificate;
    return *this;
};
/// <summary>
/// The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
/// </summary>
TPM2_CertifyX509_REQUEST::TPM2_CertifyX509_REQUEST(const TPM2_CertifyX509_REQUEST& r)
{
    this->objectHandle = r.objectHandle;
    this->signHandle = r.signHandle;
    this->qualifyingDataSize = r.qualifyingDataSize;
    this->qualifyingData = r.qualifyingData;
    this->inSchemeScheme = r.inSchemeScheme;
    if(r.inScheme != NULL)inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(r.inScheme->Clone());
    this->partialCertificateSize = r.partialCertificateSize;
    this->partialCertificate = r.partialCertificate;
};
/// <summary>
/// The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
/// </summary>
TpmStructureBase* TPM2_CertifyX509_REQUEST::Clone() const
{
    TPM2_CertifyX509_REQUEST* _x = new TPM2_CertifyX509_REQUEST(*this);
    return _x;
};
void* TPM2_CertifyX509_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return (void*) (&objectHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return (void*) (&signHandle);
            case 2: return (void*) (&qualifyingDataSize);
            case 3: { if(newArraySize != -1)qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return (void*)(&qualifyingData); }
            case 4: return (void*) (&inSchemeScheme);
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(inScheme); return (void*) (&inScheme);
            case 6: return (void*) (&partialCertificateSize);
            case 7: { if(newArraySize != -1)partialCertificate.resize(newArraySize); arraySize = (int)partialCertificate.size(); return (void*)(&partialCertificate); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&qualifyingData[arrayIndex]);
            case 7: return (void*)(&partialCertificate[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId CertifyX509Response::GetTypeId() const
{
    return TpmTypeId::CertifyX509Response_ID;
};
/// <summary>
/// The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
/// </summary>
CertifyX509Response::CertifyX509Response()
{
    signature = NULL;
    return;
};
CertifyX509Response::CertifyX509Response
(
    const std::vector<BYTE>& _addedToCertificate,
    const std::vector<BYTE>& _tbsDigest,
    const TPMU_SIGNATURE& _signature
)
{
    addedToCertificate= _addedToCertificate;
    tbsDigest= _tbsDigest;
    signature = dynamic_cast<TPMU_SIGNATURE*> (_signature.Clone());
};
/// <summary>
/// The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
/// </summary>
CertifyX509Response::~CertifyX509Response()
{
    if(signature != NULL) { delete signature;signature=NULL; }
    return;
};
/// <summary>
/// The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
/// </summary>
CertifyX509Response& CertifyX509Response::operator=(const CertifyX509Response& rhs)
{
    if(this == &rhs) return *this;
    this->addedToCertificateSize = rhs.addedToCertificateSize;
    this->addedToCertificate = rhs.addedToCertificate;
    this->tbsDigestSize = rhs.tbsDigestSize;
    this->tbsDigest = rhs.tbsDigest;
    this->signatureSigAlg = rhs.signatureSigAlg;
    if(signature != NULL) delete signature;
    if(rhs.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(rhs.signature->Clone());
    return *this;
};
/// <summary>
/// The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
/// </summary>
CertifyX509Response::CertifyX509Response(const CertifyX509Response& r)
{
    this->addedToCertificateSize = r.addedToCertificateSize;
    this->addedToCertificate = r.addedToCertificate;
    this->tbsDigestSize = r.tbsDigestSize;
    this->tbsDigest = r.tbsDigest;
    this->signatureSigAlg = r.signatureSigAlg;
    if(r.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(r.signature->Clone());
};
/// <summary>
/// The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
/// </summary>
TpmStructureBase* CertifyX509Response::Clone() const
{
    CertifyX509Response* _x = new CertifyX509Response(*this);
    return _x;
};
void* CertifyX509Response::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&addedToCertificateSize);
            case 1: { if(newArraySize != -1)addedToCertificate.resize(newArraySize); arraySize = (int)addedToCertificate.size(); return (void*)(&addedToCertificate); }
            case 2: return (void*) (&tbsDigestSize);
            case 3: { if(newArraySize != -1)tbsDigest.resize(newArraySize); arraySize = (int)tbsDigest.size(); return (void*)(&tbsDigest); }
            case 4: return (void*) (&signatureSigAlg);
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(signature); return (void*) (&signature);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&addedToCertificate[arrayIndex]);
            case 3: return (void*)(&tbsDigest[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_Commit_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Commit_REQUEST_ID;
};
/// <summary>
/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
/// </summary>
TPM2_Commit_REQUEST::TPM2_Commit_REQUEST()
{
    return;
};
TPM2_Commit_REQUEST::TPM2_Commit_REQUEST
(
    const TPM_HANDLE& _signHandle,
    const TPMS_ECC_POINT& _P1,
    const std::vector<BYTE>& _s2,
    const std::vector<BYTE>& _y2
)
{
    signHandle= _signHandle;
    P1= _P1;
    s2= _s2;
    y2= _y2;
};
/// <summary>
/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
/// </summary>
TPM2_Commit_REQUEST::~TPM2_Commit_REQUEST()
{
    return;
};
/// <summary>
/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
/// </summary>
TPM2_Commit_REQUEST& TPM2_Commit_REQUEST::operator=(const TPM2_Commit_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->signHandle = rhs.signHandle;
    this->P1Size = rhs.P1Size;
    this->P1 = rhs.P1;
    this->s2Size = rhs.s2Size;
    this->s2 = rhs.s2;
    this->y2Size = rhs.y2Size;
    this->y2 = rhs.y2;
    return *this;
};
/// <summary>
/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
/// </summary>
TPM2_Commit_REQUEST::TPM2_Commit_REQUEST(const TPM2_Commit_REQUEST& r)
{
    this->signHandle = r.signHandle;
    this->P1Size = r.P1Size;
    this->P1 = r.P1;
    this->s2Size = r.s2Size;
    this->s2 = r.s2;
    this->y2Size = r.y2Size;
    this->y2 = r.y2;
};
/// <summary>
/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
/// </summary>
TpmStructureBase* TPM2_Commit_REQUEST::Clone() const
{
    TPM2_Commit_REQUEST* _x = new TPM2_Commit_REQUEST(*this);
    return _x;
};
void* TPM2_Commit_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return (void*) (&signHandle);
            case 1: return (void*) (&P1Size);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&P1); return (void*) (&P1);
            case 3: return (void*) (&s2Size);
            case 4: { if(newArraySize != -1)s2.resize(newArraySize); arraySize = (int)s2.size(); return (void*)(&s2); }
            case 5: return (void*) (&y2Size);
            case 6: { if(newArraySize != -1)y2.resize(newArraySize); arraySize = (int)y2.size(); return (void*)(&y2); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 4: return (void*)(&s2[arrayIndex]);
            case 6: return (void*)(&y2[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId CommitResponse::GetTypeId() const
{
    return TpmTypeId::CommitResponse_ID;
};
/// <summary>
/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
/// </summary>
CommitResponse::CommitResponse()
{
    return;
};
CommitResponse::CommitResponse
(
    const TPMS_ECC_POINT& _K,
    const TPMS_ECC_POINT& _L,
    const TPMS_ECC_POINT& _E,
    const UINT16& _counter
)
{
    K= _K;
    L= _L;
    E= _E;
    counter= _counter;
};
/// <summary>
/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
/// </summary>
CommitResponse::~CommitResponse()
{
    return;
};
/// <summary>
/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
/// </summary>
CommitResponse& CommitResponse::operator=(const CommitResponse& rhs)
{
    if(this == &rhs) return *this;
    this->KSize = rhs.KSize;
    this->K = rhs.K;
    this->LSize = rhs.LSize;
    this->L = rhs.L;
    this->ESize = rhs.ESize;
    this->E = rhs.E;
    this->counter = rhs.counter;
    return *this;
};
/// <summary>
/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
/// </summary>
CommitResponse::CommitResponse(const CommitResponse& r)
{
    this->KSize = r.KSize;
    this->K = r.K;
    this->LSize = r.LSize;
    this->L = r.L;
    this->ESize = r.ESize;
    this->E = r.E;
    this->counter = r.counter;
};
/// <summary>
/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
/// </summary>
TpmStructureBase* CommitResponse::Clone() const
{
    CommitResponse* _x = new CommitResponse(*this);
    return _x;
};
void* CommitResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&KSize);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&K); return (void*) (&K);
            case 2: return (void*) (&LSize);
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&L); return (void*) (&L);
            case 4: return (void*) (&ESize);
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&E); return (void*) (&E);
            case 6: return (void*) (&counter);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_EC_Ephemeral_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_EC_Ephemeral_REQUEST_ID;
};
/// <summary>
/// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
/// </summary>
TPM2_EC_Ephemeral_REQUEST::TPM2_EC_Ephemeral_REQUEST()
{
    return;
};
TPM2_EC_Ephemeral_REQUEST::TPM2_EC_Ephemeral_REQUEST
(
    const TPM_ECC_CURVE& _curveID
)
{
    curveID= _curveID;
};
/// <summary>
/// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
/// </summary>
TPM2_EC_Ephemeral_REQUEST::~TPM2_EC_Ephemeral_REQUEST()
{
    return;
};
/// <summary>
/// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
/// </summary>
TPM2_EC_Ephemeral_REQUEST& TPM2_EC_Ephemeral_REQUEST::operator=(const TPM2_EC_Ephemeral_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->curveID = rhs.curveID;
    return *this;
};
/// <summary>
/// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
/// </summary>
TPM2_EC_Ephemeral_REQUEST::TPM2_EC_Ephemeral_REQUEST(const TPM2_EC_Ephemeral_REQUEST& r)
{
    this->curveID = r.curveID;
};
/// <summary>
/// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
/// </summary>
TpmStructureBase* TPM2_EC_Ephemeral_REQUEST::Clone() const
{
    TPM2_EC_Ephemeral_REQUEST* _x = new TPM2_EC_Ephemeral_REQUEST(*this);
    return _x;
};
void* TPM2_EC_Ephemeral_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&curveID);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId EC_EphemeralResponse::GetTypeId() const
{
    return TpmTypeId::EC_EphemeralResponse_ID;
};
/// <summary>
/// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
/// </summary>
EC_EphemeralResponse::EC_EphemeralResponse()
{
    return;
};
EC_EphemeralResponse::EC_EphemeralResponse
(
    const TPMS_ECC_POINT& _Q,
    const UINT16& _counter
)
{
    Q= _Q;
    counter= _counter;
};
/// <summary>
/// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
/// </summary>
EC_EphemeralResponse::~EC_EphemeralResponse()
{
    return;
};
/// <summary>
/// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
/// </summary>
EC_EphemeralResponse& EC_EphemeralResponse::operator=(const EC_EphemeralResponse& rhs)
{
    if(this == &rhs) return *this;
    this->QSize = rhs.QSize;
    this->Q = rhs.Q;
    this->counter = rhs.counter;
    return *this;
};
/// <summary>
/// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
/// </summary>
EC_EphemeralResponse::EC_EphemeralResponse(const EC_EphemeralResponse& r)
{
    this->QSize = r.QSize;
    this->Q = r.Q;
    this->counter = r.counter;
};
/// <summary>
/// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
/// </summary>
TpmStructureBase* EC_EphemeralResponse::Clone() const
{
    EC_EphemeralResponse* _x = new EC_EphemeralResponse(*this);
    return _x;
};
void* EC_EphemeralResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&QSize);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&Q); return (void*) (&Q);
            case 2: return (void*) (&counter);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_VerifySignature_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_VerifySignature_REQUEST_ID;
};
/// <summary>
/// This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
/// </summary>
TPM2_VerifySignature_REQUEST::TPM2_VerifySignature_REQUEST()
{
    signature = NULL;
    return;
};
TPM2_VerifySignature_REQUEST::TPM2_VerifySignature_REQUEST
(
    const TPM_HANDLE& _keyHandle,
    const std::vector<BYTE>& _digest,
    const TPMU_SIGNATURE& _signature
)
{
    keyHandle= _keyHandle;
    digest= _digest;
    signature = dynamic_cast<TPMU_SIGNATURE*> (_signature.Clone());
};
/// <summary>
/// This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
/// </summary>
TPM2_VerifySignature_REQUEST::~TPM2_VerifySignature_REQUEST()
{
    if(signature != NULL) { delete signature;signature=NULL; }
    return;
};
/// <summary>
/// This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
/// </summary>
TPM2_VerifySignature_REQUEST& TPM2_VerifySignature_REQUEST::operator=(const TPM2_VerifySignature_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->keyHandle = rhs.keyHandle;
    this->digestSize = rhs.digestSize;
    this->digest = rhs.digest;
    this->signatureSigAlg = rhs.signatureSigAlg;
    if(signature != NULL) delete signature;
    if(rhs.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(rhs.signature->Clone());
    return *this;
};
/// <summary>
/// This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
/// </summary>
TPM2_VerifySignature_REQUEST::TPM2_VerifySignature_REQUEST(const TPM2_VerifySignature_REQUEST& r)
{
    this->keyHandle = r.keyHandle;
    this->digestSize = r.digestSize;
    this->digest = r.digest;
    this->signatureSigAlg = r.signatureSigAlg;
    if(r.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(r.signature->Clone());
};
/// <summary>
/// This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
/// </summary>
TpmStructureBase* TPM2_VerifySignature_REQUEST::Clone() const
{
    TPM2_VerifySignature_REQUEST* _x = new TPM2_VerifySignature_REQUEST(*this);
    return _x;
};
void* TPM2_VerifySignature_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return (void*) (&keyHandle);
            case 1: return (void*) (&digestSize);
            case 2: { if(newArraySize != -1)digest.resize(newArraySize); arraySize = (int)digest.size(); return (void*)(&digest); }
            case 3: return (void*) (&signatureSigAlg);
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(signature); return (void*) (&signature);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&digest[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId VerifySignatureResponse::GetTypeId() const
{
    return TpmTypeId::VerifySignatureResponse_ID;
};
/// <summary>
/// This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
/// </summary>
VerifySignatureResponse::VerifySignatureResponse()
{
    return;
};
VerifySignatureResponse::VerifySignatureResponse
(
    const TPMT_TK_VERIFIED& _validation
)
{
    validation= _validation;
};
/// <summary>
/// This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
/// </summary>
VerifySignatureResponse::~VerifySignatureResponse()
{
    return;
};
/// <summary>
/// This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
/// </summary>
VerifySignatureResponse& VerifySignatureResponse::operator=(const VerifySignatureResponse& rhs)
{
    if(this == &rhs) return *this;
    this->validation = rhs.validation;
    return *this;
};
/// <summary>
/// This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
/// </summary>
VerifySignatureResponse::VerifySignatureResponse(const VerifySignatureResponse& r)
{
    this->validation = r.validation;
};
/// <summary>
/// This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
/// </summary>
TpmStructureBase* VerifySignatureResponse::Clone() const
{
    VerifySignatureResponse* _x = new VerifySignatureResponse(*this);
    return _x;
};
void* VerifySignatureResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&validation); return (void*) (&validation);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_Sign_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Sign_REQUEST_ID;
};
/// <summary>
/// This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
/// </summary>
TPM2_Sign_REQUEST::TPM2_Sign_REQUEST()
{
    inScheme = NULL;
    return;
};
TPM2_Sign_REQUEST::TPM2_Sign_REQUEST
(
    const TPM_HANDLE& _keyHandle,
    const std::vector<BYTE>& _digest,
    const TPMU_SIG_SCHEME& _inScheme,
    const TPMT_TK_HASHCHECK& _validation
)
{
    keyHandle= _keyHandle;
    digest= _digest;
    inScheme = dynamic_cast<TPMU_SIG_SCHEME*> (_inScheme.Clone());
    validation= _validation;
};
/// <summary>
/// This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
/// </summary>
TPM2_Sign_REQUEST::~TPM2_Sign_REQUEST()
{
    if(inScheme != NULL) { delete inScheme;inScheme=NULL; }
    return;
};
/// <summary>
/// This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
/// </summary>
TPM2_Sign_REQUEST& TPM2_Sign_REQUEST::operator=(const TPM2_Sign_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->keyHandle = rhs.keyHandle;
    this->digestSize = rhs.digestSize;
    this->digest = rhs.digest;
    this->inSchemeScheme = rhs.inSchemeScheme;
    if(inScheme != NULL) delete inScheme;
    if(rhs.inScheme != NULL)inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(rhs.inScheme->Clone());
    this->validation = rhs.validation;
    return *this;
};
/// <summary>
/// This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
/// </summary>
TPM2_Sign_REQUEST::TPM2_Sign_REQUEST(const TPM2_Sign_REQUEST& r)
{
    this->keyHandle = r.keyHandle;
    this->digestSize = r.digestSize;
    this->digest = r.digest;
    this->inSchemeScheme = r.inSchemeScheme;
    if(r.inScheme != NULL)inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(r.inScheme->Clone());
    this->validation = r.validation;
};
/// <summary>
/// This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
/// </summary>
TpmStructureBase* TPM2_Sign_REQUEST::Clone() const
{
    TPM2_Sign_REQUEST* _x = new TPM2_Sign_REQUEST(*this);
    return _x;
};
void* TPM2_Sign_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return (void*) (&keyHandle);
            case 1: return (void*) (&digestSize);
            case 2: { if(newArraySize != -1)digest.resize(newArraySize); arraySize = (int)digest.size(); return (void*)(&digest); }
            case 3: return (void*) (&inSchemeScheme);
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(inScheme); return (void*) (&inScheme);
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&validation); return (void*) (&validation);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&digest[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId SignResponse::GetTypeId() const
{
    return TpmTypeId::SignResponse_ID;
};
/// <summary>
/// This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
/// </summary>
SignResponse::SignResponse()
{
    signature = NULL;
    return;
};
SignResponse::SignResponse
(
    const TPMU_SIGNATURE& _signature
)
{
    signature = dynamic_cast<TPMU_SIGNATURE*> (_signature.Clone());
};
/// <summary>
/// This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
/// </summary>
SignResponse::~SignResponse()
{
    if(signature != NULL) { delete signature;signature=NULL; }
    return;
};
/// <summary>
/// This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
/// </summary>
SignResponse& SignResponse::operator=(const SignResponse& rhs)
{
    if(this == &rhs) return *this;
    this->signatureSigAlg = rhs.signatureSigAlg;
    if(signature != NULL) delete signature;
    if(rhs.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(rhs.signature->Clone());
    return *this;
};
/// <summary>
/// This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
/// </summary>
SignResponse::SignResponse(const SignResponse& r)
{
    this->signatureSigAlg = r.signatureSigAlg;
    if(r.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(r.signature->Clone());
};
/// <summary>
/// This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
/// </summary>
TpmStructureBase* SignResponse::Clone() const
{
    SignResponse* _x = new SignResponse(*this);
    return _x;
};
void* SignResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&signatureSigAlg);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(signature); return (void*) (&signature);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_SetCommandCodeAuditStatus_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
};
/// <summary>
/// This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
/// </summary>
TPM2_SetCommandCodeAuditStatus_REQUEST::TPM2_SetCommandCodeAuditStatus_REQUEST()
{
    return;
};
TPM2_SetCommandCodeAuditStatus_REQUEST::TPM2_SetCommandCodeAuditStatus_REQUEST
(
    const TPM_HANDLE& _auth,
    const TPM_ALG_ID& _auditAlg,
    const std::vector<TPM_CC>& _setList,
    const std::vector<TPM_CC>& _clearList
)
{
    auth= _auth;
    auditAlg= _auditAlg;
    setList= _setList;
    clearList= _clearList;
};
/// <summary>
/// This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
/// </summary>
TPM2_SetCommandCodeAuditStatus_REQUEST::~TPM2_SetCommandCodeAuditStatus_REQUEST()
{
    return;
};
/// <summary>
/// This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
/// </summary>
TPM2_SetCommandCodeAuditStatus_REQUEST& TPM2_SetCommandCodeAuditStatus_REQUEST::operator=(const TPM2_SetCommandCodeAuditStatus_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->auth = rhs.auth;
    this->auditAlg = rhs.auditAlg;
    this->setListCount = rhs.setListCount;
    this->setList = rhs.setList;
    this->clearListCount = rhs.clearListCount;
    this->clearList = rhs.clearList;
    return *this;
};
/// <summary>
/// This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
/// </summary>
TPM2_SetCommandCodeAuditStatus_REQUEST::TPM2_SetCommandCodeAuditStatus_REQUEST(const TPM2_SetCommandCodeAuditStatus_REQUEST& r)
{
    this->auth = r.auth;
    this->auditAlg = r.auditAlg;
    this->setListCount = r.setListCount;
    this->setList = r.setList;
    this->clearListCount = r.clearListCount;
    this->clearList = r.clearList;
};
/// <summary>
/// This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
/// </summary>
TpmStructureBase* TPM2_SetCommandCodeAuditStatus_REQUEST::Clone() const
{
    TPM2_SetCommandCodeAuditStatus_REQUEST* _x = new TPM2_SetCommandCodeAuditStatus_REQUEST(*this);
    return _x;
};
void* TPM2_SetCommandCodeAuditStatus_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&auth); return (void*) (&auth);
            case 1: return (void*) (&auditAlg);
            case 2: return (void*) (&setListCount);
            case 3: { if(newArraySize != -1)setList.resize(newArraySize); arraySize = (int)setList.size(); return (void*)(&setList); }
            case 4: return (void*) (&clearListCount);
            case 5: { if(newArraySize != -1)clearList.resize(newArraySize); arraySize = (int)clearList.size(); return (void*)(&clearList); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&setList[arrayIndex]);
            case 5: return (void*)(&clearList[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId SetCommandCodeAuditStatusResponse::GetTypeId() const
{
    return TpmTypeId::SetCommandCodeAuditStatusResponse_ID;
};
/// <summary>
/// This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
/// </summary>
SetCommandCodeAuditStatusResponse::SetCommandCodeAuditStatusResponse()
{
    return;
};
/// <summary>
/// This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
/// </summary>
SetCommandCodeAuditStatusResponse::~SetCommandCodeAuditStatusResponse()
{
    return;
};
/// <summary>
/// This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
/// </summary>
SetCommandCodeAuditStatusResponse& SetCommandCodeAuditStatusResponse::operator=(const SetCommandCodeAuditStatusResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
/// </summary>
SetCommandCodeAuditStatusResponse::SetCommandCodeAuditStatusResponse(const SetCommandCodeAuditStatusResponse& r)
{
};
/// <summary>
/// This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
/// </summary>
TpmStructureBase* SetCommandCodeAuditStatusResponse::Clone() const
{
    SetCommandCodeAuditStatusResponse* _x = new SetCommandCodeAuditStatusResponse(*this);
    return _x;
};
void* SetCommandCodeAuditStatusResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PCR_Extend_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_Extend_REQUEST_ID;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
/// </summary>
TPM2_PCR_Extend_REQUEST::TPM2_PCR_Extend_REQUEST()
{
    return;
};
TPM2_PCR_Extend_REQUEST::TPM2_PCR_Extend_REQUEST
(
    const TPM_HANDLE& _pcrHandle,
    const std::vector<TPMT_HA>& _digests
)
{
    pcrHandle= _pcrHandle;
    digests= _digests;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
/// </summary>
TPM2_PCR_Extend_REQUEST::~TPM2_PCR_Extend_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
/// </summary>
TPM2_PCR_Extend_REQUEST& TPM2_PCR_Extend_REQUEST::operator=(const TPM2_PCR_Extend_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->pcrHandle = rhs.pcrHandle;
    this->digestsCount = rhs.digestsCount;
    this->digests = rhs.digests;
    return *this;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
/// </summary>
TPM2_PCR_Extend_REQUEST::TPM2_PCR_Extend_REQUEST(const TPM2_PCR_Extend_REQUEST& r)
{
    this->pcrHandle = r.pcrHandle;
    this->digestsCount = r.digestsCount;
    this->digests = r.digests;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
/// </summary>
TpmStructureBase* TPM2_PCR_Extend_REQUEST::Clone() const
{
    TPM2_PCR_Extend_REQUEST* _x = new TPM2_PCR_Extend_REQUEST(*this);
    return _x;
};
void* TPM2_PCR_Extend_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&pcrHandle); return (void*) (&pcrHandle);
            case 1: return (void*) (&digestsCount);
            case 2: { if(newArraySize != -1)digests.resize(newArraySize); arraySize = (int)digests.size(); return (void*)(&digests); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&digests[arrayIndex]);return (void*)(&digests[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PCR_ExtendResponse::GetTypeId() const
{
    return TpmTypeId::PCR_ExtendResponse_ID;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
/// </summary>
PCR_ExtendResponse::PCR_ExtendResponse()
{
    return;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
/// </summary>
PCR_ExtendResponse::~PCR_ExtendResponse()
{
    return;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
/// </summary>
PCR_ExtendResponse& PCR_ExtendResponse::operator=(const PCR_ExtendResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
/// </summary>
PCR_ExtendResponse::PCR_ExtendResponse(const PCR_ExtendResponse& r)
{
};
/// <summary>
/// This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
/// </summary>
TpmStructureBase* PCR_ExtendResponse::Clone() const
{
    PCR_ExtendResponse* _x = new PCR_ExtendResponse(*this);
    return _x;
};
void* PCR_ExtendResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PCR_Event_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_Event_REQUEST_ID;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR.
/// </summary>
TPM2_PCR_Event_REQUEST::TPM2_PCR_Event_REQUEST()
{
    return;
};
TPM2_PCR_Event_REQUEST::TPM2_PCR_Event_REQUEST
(
    const TPM_HANDLE& _pcrHandle,
    const std::vector<BYTE>& _eventData
)
{
    pcrHandle= _pcrHandle;
    eventData= _eventData;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR.
/// </summary>
TPM2_PCR_Event_REQUEST::~TPM2_PCR_Event_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR.
/// </summary>
TPM2_PCR_Event_REQUEST& TPM2_PCR_Event_REQUEST::operator=(const TPM2_PCR_Event_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->pcrHandle = rhs.pcrHandle;
    this->eventDataSize = rhs.eventDataSize;
    this->eventData = rhs.eventData;
    return *this;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR.
/// </summary>
TPM2_PCR_Event_REQUEST::TPM2_PCR_Event_REQUEST(const TPM2_PCR_Event_REQUEST& r)
{
    this->pcrHandle = r.pcrHandle;
    this->eventDataSize = r.eventDataSize;
    this->eventData = r.eventData;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR.
/// </summary>
TpmStructureBase* TPM2_PCR_Event_REQUEST::Clone() const
{
    TPM2_PCR_Event_REQUEST* _x = new TPM2_PCR_Event_REQUEST(*this);
    return _x;
};
void* TPM2_PCR_Event_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&pcrHandle); return (void*) (&pcrHandle);
            case 1: return (void*) (&eventDataSize);
            case 2: { if(newArraySize != -1)eventData.resize(newArraySize); arraySize = (int)eventData.size(); return (void*)(&eventData); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&eventData[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PCR_EventResponse::GetTypeId() const
{
    return TpmTypeId::PCR_EventResponse_ID;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR.
/// </summary>
PCR_EventResponse::PCR_EventResponse()
{
    return;
};
PCR_EventResponse::PCR_EventResponse
(
    const std::vector<TPMT_HA>& _digests
)
{
    digests= _digests;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR.
/// </summary>
PCR_EventResponse::~PCR_EventResponse()
{
    return;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR.
/// </summary>
PCR_EventResponse& PCR_EventResponse::operator=(const PCR_EventResponse& rhs)
{
    if(this == &rhs) return *this;
    this->digestsCount = rhs.digestsCount;
    this->digests = rhs.digests;
    return *this;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR.
/// </summary>
PCR_EventResponse::PCR_EventResponse(const PCR_EventResponse& r)
{
    this->digestsCount = r.digestsCount;
    this->digests = r.digests;
};
/// <summary>
/// This command is used to cause an update to the indicated PCR.
/// </summary>
TpmStructureBase* PCR_EventResponse::Clone() const
{
    PCR_EventResponse* _x = new PCR_EventResponse(*this);
    return _x;
};
void* PCR_EventResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&digestsCount);
            case 1: { if(newArraySize != -1)digests.resize(newArraySize); arraySize = (int)digests.size(); return (void*)(&digests); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&digests[arrayIndex]);return (void*)(&digests[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_PCR_Read_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_Read_REQUEST_ID;
};
/// <summary>
/// This command returns the values of all PCR specified in pcrSelectionIn.
/// </summary>
TPM2_PCR_Read_REQUEST::TPM2_PCR_Read_REQUEST()
{
    return;
};
TPM2_PCR_Read_REQUEST::TPM2_PCR_Read_REQUEST
(
    const std::vector<TPMS_PCR_SELECTION>& _pcrSelectionIn
)
{
    pcrSelectionIn= _pcrSelectionIn;
};
/// <summary>
/// This command returns the values of all PCR specified in pcrSelectionIn.
/// </summary>
TPM2_PCR_Read_REQUEST::~TPM2_PCR_Read_REQUEST()
{
    return;
};
/// <summary>
/// This command returns the values of all PCR specified in pcrSelectionIn.
/// </summary>
TPM2_PCR_Read_REQUEST& TPM2_PCR_Read_REQUEST::operator=(const TPM2_PCR_Read_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->pcrSelectionInCount = rhs.pcrSelectionInCount;
    this->pcrSelectionIn = rhs.pcrSelectionIn;
    return *this;
};
/// <summary>
/// This command returns the values of all PCR specified in pcrSelectionIn.
/// </summary>
TPM2_PCR_Read_REQUEST::TPM2_PCR_Read_REQUEST(const TPM2_PCR_Read_REQUEST& r)
{
    this->pcrSelectionInCount = r.pcrSelectionInCount;
    this->pcrSelectionIn = r.pcrSelectionIn;
};
/// <summary>
/// This command returns the values of all PCR specified in pcrSelectionIn.
/// </summary>
TpmStructureBase* TPM2_PCR_Read_REQUEST::Clone() const
{
    TPM2_PCR_Read_REQUEST* _x = new TPM2_PCR_Read_REQUEST(*this);
    return _x;
};
void* TPM2_PCR_Read_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&pcrSelectionInCount);
            case 1: { if(newArraySize != -1)pcrSelectionIn.resize(newArraySize); arraySize = (int)pcrSelectionIn.size(); return (void*)(&pcrSelectionIn); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&pcrSelectionIn[arrayIndex]);return (void*)(&pcrSelectionIn[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PCR_ReadResponse::GetTypeId() const
{
    return TpmTypeId::PCR_ReadResponse_ID;
};
/// <summary>
/// This command returns the values of all PCR specified in pcrSelectionIn.
/// </summary>
PCR_ReadResponse::PCR_ReadResponse()
{
    return;
};
PCR_ReadResponse::PCR_ReadResponse
(
    const UINT32& _pcrUpdateCounter,
    const std::vector<TPMS_PCR_SELECTION>& _pcrSelectionOut,
    const std::vector<TPM2B_DIGEST>& _pcrValues
)
{
    pcrUpdateCounter= _pcrUpdateCounter;
    pcrSelectionOut= _pcrSelectionOut;
    pcrValues= _pcrValues;
};
/// <summary>
/// This command returns the values of all PCR specified in pcrSelectionIn.
/// </summary>
PCR_ReadResponse::~PCR_ReadResponse()
{
    return;
};
/// <summary>
/// This command returns the values of all PCR specified in pcrSelectionIn.
/// </summary>
PCR_ReadResponse& PCR_ReadResponse::operator=(const PCR_ReadResponse& rhs)
{
    if(this == &rhs) return *this;
    this->pcrUpdateCounter = rhs.pcrUpdateCounter;
    this->pcrSelectionOutCount = rhs.pcrSelectionOutCount;
    this->pcrSelectionOut = rhs.pcrSelectionOut;
    this->pcrValuesCount = rhs.pcrValuesCount;
    this->pcrValues = rhs.pcrValues;
    return *this;
};
/// <summary>
/// This command returns the values of all PCR specified in pcrSelectionIn.
/// </summary>
PCR_ReadResponse::PCR_ReadResponse(const PCR_ReadResponse& r)
{
    this->pcrUpdateCounter = r.pcrUpdateCounter;
    this->pcrSelectionOutCount = r.pcrSelectionOutCount;
    this->pcrSelectionOut = r.pcrSelectionOut;
    this->pcrValuesCount = r.pcrValuesCount;
    this->pcrValues = r.pcrValues;
};
/// <summary>
/// This command returns the values of all PCR specified in pcrSelectionIn.
/// </summary>
TpmStructureBase* PCR_ReadResponse::Clone() const
{
    PCR_ReadResponse* _x = new PCR_ReadResponse(*this);
    return _x;
};
void* PCR_ReadResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&pcrUpdateCounter);
            case 1: return (void*) (&pcrSelectionOutCount);
            case 2: { if(newArraySize != -1)pcrSelectionOut.resize(newArraySize); arraySize = (int)pcrSelectionOut.size(); return (void*)(&pcrSelectionOut); }
            case 3: return (void*) (&pcrValuesCount);
            case 4: { if(newArraySize != -1)pcrValues.resize(newArraySize); arraySize = (int)pcrValues.size(); return (void*)(&pcrValues); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&pcrSelectionOut[arrayIndex]);return (void*)(&pcrSelectionOut[arrayIndex]);
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&pcrValues[arrayIndex]);return (void*)(&pcrValues[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_PCR_Allocate_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_Allocate_REQUEST_ID;
};
/// <summary>
/// This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
/// </summary>
TPM2_PCR_Allocate_REQUEST::TPM2_PCR_Allocate_REQUEST()
{
    return;
};
TPM2_PCR_Allocate_REQUEST::TPM2_PCR_Allocate_REQUEST
(
    const TPM_HANDLE& _authHandle,
    const std::vector<TPMS_PCR_SELECTION>& _pcrAllocation
)
{
    authHandle= _authHandle;
    pcrAllocation= _pcrAllocation;
};
/// <summary>
/// This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
/// </summary>
TPM2_PCR_Allocate_REQUEST::~TPM2_PCR_Allocate_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
/// </summary>
TPM2_PCR_Allocate_REQUEST& TPM2_PCR_Allocate_REQUEST::operator=(const TPM2_PCR_Allocate_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    this->pcrAllocationCount = rhs.pcrAllocationCount;
    this->pcrAllocation = rhs.pcrAllocation;
    return *this;
};
/// <summary>
/// This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
/// </summary>
TPM2_PCR_Allocate_REQUEST::TPM2_PCR_Allocate_REQUEST(const TPM2_PCR_Allocate_REQUEST& r)
{
    this->authHandle = r.authHandle;
    this->pcrAllocationCount = r.pcrAllocationCount;
    this->pcrAllocation = r.pcrAllocation;
};
/// <summary>
/// This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
/// </summary>
TpmStructureBase* TPM2_PCR_Allocate_REQUEST::Clone() const
{
    TPM2_PCR_Allocate_REQUEST* _x = new TPM2_PCR_Allocate_REQUEST(*this);
    return _x;
};
void* TPM2_PCR_Allocate_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 1: return (void*) (&pcrAllocationCount);
            case 2: { if(newArraySize != -1)pcrAllocation.resize(newArraySize); arraySize = (int)pcrAllocation.size(); return (void*)(&pcrAllocation); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&pcrAllocation[arrayIndex]);return (void*)(&pcrAllocation[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PCR_AllocateResponse::GetTypeId() const
{
    return TpmTypeId::PCR_AllocateResponse_ID;
};
/// <summary>
/// This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
/// </summary>
PCR_AllocateResponse::PCR_AllocateResponse()
{
    return;
};
PCR_AllocateResponse::PCR_AllocateResponse
(
    const BYTE& _allocationSuccess,
    const UINT32& _maxPCR,
    const UINT32& _sizeNeeded,
    const UINT32& _sizeAvailable
)
{
    allocationSuccess= _allocationSuccess;
    maxPCR= _maxPCR;
    sizeNeeded= _sizeNeeded;
    sizeAvailable= _sizeAvailable;
};
/// <summary>
/// This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
/// </summary>
PCR_AllocateResponse::~PCR_AllocateResponse()
{
    return;
};
/// <summary>
/// This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
/// </summary>
PCR_AllocateResponse& PCR_AllocateResponse::operator=(const PCR_AllocateResponse& rhs)
{
    if(this == &rhs) return *this;
    this->allocationSuccess = rhs.allocationSuccess;
    this->maxPCR = rhs.maxPCR;
    this->sizeNeeded = rhs.sizeNeeded;
    this->sizeAvailable = rhs.sizeAvailable;
    return *this;
};
/// <summary>
/// This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
/// </summary>
PCR_AllocateResponse::PCR_AllocateResponse(const PCR_AllocateResponse& r)
{
    this->allocationSuccess = r.allocationSuccess;
    this->maxPCR = r.maxPCR;
    this->sizeNeeded = r.sizeNeeded;
    this->sizeAvailable = r.sizeAvailable;
};
/// <summary>
/// This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
/// </summary>
TpmStructureBase* PCR_AllocateResponse::Clone() const
{
    PCR_AllocateResponse* _x = new PCR_AllocateResponse(*this);
    return _x;
};
void* PCR_AllocateResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&allocationSuccess);
            case 1: return (void*) (&maxPCR);
            case 2: return (void*) (&sizeNeeded);
            case 3: return (void*) (&sizeAvailable);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_PCR_SetAuthPolicy_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID;
};
/// <summary>
/// This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
/// </summary>
TPM2_PCR_SetAuthPolicy_REQUEST::TPM2_PCR_SetAuthPolicy_REQUEST()
{
    return;
};
TPM2_PCR_SetAuthPolicy_REQUEST::TPM2_PCR_SetAuthPolicy_REQUEST
(
    const TPM_HANDLE& _authHandle,
    const std::vector<BYTE>& _authPolicy,
    const TPM_ALG_ID& _hashAlg,
    const TPM_HANDLE& _pcrNum
)
{
    authHandle= _authHandle;
    authPolicy= _authPolicy;
    hashAlg= _hashAlg;
    pcrNum= _pcrNum;
};
/// <summary>
/// This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
/// </summary>
TPM2_PCR_SetAuthPolicy_REQUEST::~TPM2_PCR_SetAuthPolicy_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
/// </summary>
TPM2_PCR_SetAuthPolicy_REQUEST& TPM2_PCR_SetAuthPolicy_REQUEST::operator=(const TPM2_PCR_SetAuthPolicy_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    this->authPolicySize = rhs.authPolicySize;
    this->authPolicy = rhs.authPolicy;
    this->hashAlg = rhs.hashAlg;
    this->pcrNum = rhs.pcrNum;
    return *this;
};
/// <summary>
/// This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
/// </summary>
TPM2_PCR_SetAuthPolicy_REQUEST::TPM2_PCR_SetAuthPolicy_REQUEST(const TPM2_PCR_SetAuthPolicy_REQUEST& r)
{
    this->authHandle = r.authHandle;
    this->authPolicySize = r.authPolicySize;
    this->authPolicy = r.authPolicy;
    this->hashAlg = r.hashAlg;
    this->pcrNum = r.pcrNum;
};
/// <summary>
/// This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
/// </summary>
TpmStructureBase* TPM2_PCR_SetAuthPolicy_REQUEST::Clone() const
{
    TPM2_PCR_SetAuthPolicy_REQUEST* _x = new TPM2_PCR_SetAuthPolicy_REQUEST(*this);
    return _x;
};
void* TPM2_PCR_SetAuthPolicy_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 1: return (void*) (&authPolicySize);
            case 2: { if(newArraySize != -1)authPolicy.resize(newArraySize); arraySize = (int)authPolicy.size(); return (void*)(&authPolicy); }
            case 3: return (void*) (&hashAlg);
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&pcrNum); return (void*) (&pcrNum);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&authPolicy[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PCR_SetAuthPolicyResponse::GetTypeId() const
{
    return TpmTypeId::PCR_SetAuthPolicyResponse_ID;
};
/// <summary>
/// This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
/// </summary>
PCR_SetAuthPolicyResponse::PCR_SetAuthPolicyResponse()
{
    return;
};
/// <summary>
/// This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
/// </summary>
PCR_SetAuthPolicyResponse::~PCR_SetAuthPolicyResponse()
{
    return;
};
/// <summary>
/// This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
/// </summary>
PCR_SetAuthPolicyResponse& PCR_SetAuthPolicyResponse::operator=(const PCR_SetAuthPolicyResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
/// </summary>
PCR_SetAuthPolicyResponse::PCR_SetAuthPolicyResponse(const PCR_SetAuthPolicyResponse& r)
{
};
/// <summary>
/// This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
/// </summary>
TpmStructureBase* PCR_SetAuthPolicyResponse::Clone() const
{
    PCR_SetAuthPolicyResponse* _x = new PCR_SetAuthPolicyResponse(*this);
    return _x;
};
void* PCR_SetAuthPolicyResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PCR_SetAuthValue_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_SetAuthValue_REQUEST_ID;
};
/// <summary>
/// This command changes the authValue of a PCR or group of PCR.
/// </summary>
TPM2_PCR_SetAuthValue_REQUEST::TPM2_PCR_SetAuthValue_REQUEST()
{
    return;
};
TPM2_PCR_SetAuthValue_REQUEST::TPM2_PCR_SetAuthValue_REQUEST
(
    const TPM_HANDLE& _pcrHandle,
    const std::vector<BYTE>& _auth
)
{
    pcrHandle= _pcrHandle;
    auth= _auth;
};
/// <summary>
/// This command changes the authValue of a PCR or group of PCR.
/// </summary>
TPM2_PCR_SetAuthValue_REQUEST::~TPM2_PCR_SetAuthValue_REQUEST()
{
    return;
};
/// <summary>
/// This command changes the authValue of a PCR or group of PCR.
/// </summary>
TPM2_PCR_SetAuthValue_REQUEST& TPM2_PCR_SetAuthValue_REQUEST::operator=(const TPM2_PCR_SetAuthValue_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->pcrHandle = rhs.pcrHandle;
    this->authSize = rhs.authSize;
    this->auth = rhs.auth;
    return *this;
};
/// <summary>
/// This command changes the authValue of a PCR or group of PCR.
/// </summary>
TPM2_PCR_SetAuthValue_REQUEST::TPM2_PCR_SetAuthValue_REQUEST(const TPM2_PCR_SetAuthValue_REQUEST& r)
{
    this->pcrHandle = r.pcrHandle;
    this->authSize = r.authSize;
    this->auth = r.auth;
};
/// <summary>
/// This command changes the authValue of a PCR or group of PCR.
/// </summary>
TpmStructureBase* TPM2_PCR_SetAuthValue_REQUEST::Clone() const
{
    TPM2_PCR_SetAuthValue_REQUEST* _x = new TPM2_PCR_SetAuthValue_REQUEST(*this);
    return _x;
};
void* TPM2_PCR_SetAuthValue_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&pcrHandle); return (void*) (&pcrHandle);
            case 1: return (void*) (&authSize);
            case 2: { if(newArraySize != -1)auth.resize(newArraySize); arraySize = (int)auth.size(); return (void*)(&auth); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&auth[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PCR_SetAuthValueResponse::GetTypeId() const
{
    return TpmTypeId::PCR_SetAuthValueResponse_ID;
};
/// <summary>
/// This command changes the authValue of a PCR or group of PCR.
/// </summary>
PCR_SetAuthValueResponse::PCR_SetAuthValueResponse()
{
    return;
};
/// <summary>
/// This command changes the authValue of a PCR or group of PCR.
/// </summary>
PCR_SetAuthValueResponse::~PCR_SetAuthValueResponse()
{
    return;
};
/// <summary>
/// This command changes the authValue of a PCR or group of PCR.
/// </summary>
PCR_SetAuthValueResponse& PCR_SetAuthValueResponse::operator=(const PCR_SetAuthValueResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command changes the authValue of a PCR or group of PCR.
/// </summary>
PCR_SetAuthValueResponse::PCR_SetAuthValueResponse(const PCR_SetAuthValueResponse& r)
{
};
/// <summary>
/// This command changes the authValue of a PCR or group of PCR.
/// </summary>
TpmStructureBase* PCR_SetAuthValueResponse::Clone() const
{
    PCR_SetAuthValueResponse* _x = new PCR_SetAuthValueResponse(*this);
    return _x;
};
void* PCR_SetAuthValueResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PCR_Reset_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_Reset_REQUEST_ID;
};
/// <summary>
/// If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
/// </summary>
TPM2_PCR_Reset_REQUEST::TPM2_PCR_Reset_REQUEST()
{
    return;
};
TPM2_PCR_Reset_REQUEST::TPM2_PCR_Reset_REQUEST
(
    const TPM_HANDLE& _pcrHandle
)
{
    pcrHandle= _pcrHandle;
};
/// <summary>
/// If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
/// </summary>
TPM2_PCR_Reset_REQUEST::~TPM2_PCR_Reset_REQUEST()
{
    return;
};
/// <summary>
/// If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
/// </summary>
TPM2_PCR_Reset_REQUEST& TPM2_PCR_Reset_REQUEST::operator=(const TPM2_PCR_Reset_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->pcrHandle = rhs.pcrHandle;
    return *this;
};
/// <summary>
/// If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
/// </summary>
TPM2_PCR_Reset_REQUEST::TPM2_PCR_Reset_REQUEST(const TPM2_PCR_Reset_REQUEST& r)
{
    this->pcrHandle = r.pcrHandle;
};
/// <summary>
/// If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
/// </summary>
TpmStructureBase* TPM2_PCR_Reset_REQUEST::Clone() const
{
    TPM2_PCR_Reset_REQUEST* _x = new TPM2_PCR_Reset_REQUEST(*this);
    return _x;
};
void* TPM2_PCR_Reset_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&pcrHandle); return (void*) (&pcrHandle);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId PCR_ResetResponse::GetTypeId() const
{
    return TpmTypeId::PCR_ResetResponse_ID;
};
/// <summary>
/// If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
/// </summary>
PCR_ResetResponse::PCR_ResetResponse()
{
    return;
};
/// <summary>
/// If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
/// </summary>
PCR_ResetResponse::~PCR_ResetResponse()
{
    return;
};
/// <summary>
/// If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
/// </summary>
PCR_ResetResponse& PCR_ResetResponse::operator=(const PCR_ResetResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
/// </summary>
PCR_ResetResponse::PCR_ResetResponse(const PCR_ResetResponse& r)
{
};
/// <summary>
/// If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
/// </summary>
TpmStructureBase* PCR_ResetResponse::Clone() const
{
    PCR_ResetResponse* _x = new PCR_ResetResponse(*this);
    return _x;
};
void* PCR_ResetResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PolicySigned_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
};
/// <summary>
/// This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
/// </summary>
TPM2_PolicySigned_REQUEST::TPM2_PolicySigned_REQUEST()
{
    auth = NULL;
    return;
};
TPM2_PolicySigned_REQUEST::TPM2_PolicySigned_REQUEST
(
    const TPM_HANDLE& _authObject,
    const TPM_HANDLE& _policySession,
    const std::vector<BYTE>& _nonceTPM,
    const std::vector<BYTE>& _cpHashA,
    const std::vector<BYTE>& _policyRef,
    const INT32& _expiration,
    const TPMU_SIGNATURE& _auth
)
{
    authObject= _authObject;
    policySession= _policySession;
    nonceTPM= _nonceTPM;
    cpHashA= _cpHashA;
    policyRef= _policyRef;
    expiration= _expiration;
    auth = dynamic_cast<TPMU_SIGNATURE*> (_auth.Clone());
};
/// <summary>
/// This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
/// </summary>
TPM2_PolicySigned_REQUEST::~TPM2_PolicySigned_REQUEST()
{
    if(auth != NULL) { delete auth;auth=NULL; }
    return;
};
/// <summary>
/// This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
/// </summary>
TPM2_PolicySigned_REQUEST& TPM2_PolicySigned_REQUEST::operator=(const TPM2_PolicySigned_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authObject = rhs.authObject;
    this->policySession = rhs.policySession;
    this->nonceTPMSize = rhs.nonceTPMSize;
    this->nonceTPM = rhs.nonceTPM;
    this->cpHashASize = rhs.cpHashASize;
    this->cpHashA = rhs.cpHashA;
    this->policyRefSize = rhs.policyRefSize;
    this->policyRef = rhs.policyRef;
    this->expiration = rhs.expiration;
    this->authSigAlg = rhs.authSigAlg;
    if(auth != NULL) delete auth;
    if(rhs.auth != NULL)auth = dynamic_cast<TPMU_SIGNATURE*>(rhs.auth->Clone());
    return *this;
};
/// <summary>
/// This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
/// </summary>
TPM2_PolicySigned_REQUEST::TPM2_PolicySigned_REQUEST(const TPM2_PolicySigned_REQUEST& r)
{
    this->authObject = r.authObject;
    this->policySession = r.policySession;
    this->nonceTPMSize = r.nonceTPMSize;
    this->nonceTPM = r.nonceTPM;
    this->cpHashASize = r.cpHashASize;
    this->cpHashA = r.cpHashA;
    this->policyRefSize = r.policyRefSize;
    this->policyRef = r.policyRef;
    this->expiration = r.expiration;
    this->authSigAlg = r.authSigAlg;
    if(r.auth != NULL)auth = dynamic_cast<TPMU_SIGNATURE*>(r.auth->Clone());
};
/// <summary>
/// This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
/// </summary>
TpmStructureBase* TPM2_PolicySigned_REQUEST::Clone() const
{
    TPM2_PolicySigned_REQUEST* _x = new TPM2_PolicySigned_REQUEST(*this);
    return _x;
};
void* TPM2_PolicySigned_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authObject); return (void*) (&authObject);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            case 2: return (void*) (&nonceTPMSize);
            case 3: { if(newArraySize != -1)nonceTPM.resize(newArraySize); arraySize = (int)nonceTPM.size(); return (void*)(&nonceTPM); }
            case 4: return (void*) (&cpHashASize);
            case 5: { if(newArraySize != -1)cpHashA.resize(newArraySize); arraySize = (int)cpHashA.size(); return (void*)(&cpHashA); }
            case 6: return (void*) (&policyRefSize);
            case 7: { if(newArraySize != -1)policyRef.resize(newArraySize); arraySize = (int)policyRef.size(); return (void*)(&policyRef); }
            case 8: return (void*) (&expiration);
            case 9: return (void*) (&authSigAlg);
            case 10: pStruct = dynamic_cast<TpmStructureBase*>(auth); return (void*) (&auth);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&nonceTPM[arrayIndex]);
            case 5: return (void*)(&cpHashA[arrayIndex]);
            case 7: return (void*)(&policyRef[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PolicySignedResponse::GetTypeId() const
{
    return TpmTypeId::PolicySignedResponse_ID;
};
/// <summary>
/// This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
/// </summary>
PolicySignedResponse::PolicySignedResponse()
{
    return;
};
PolicySignedResponse::PolicySignedResponse
(
    const std::vector<BYTE>& _timeout,
    const TPMT_TK_AUTH& _policyTicket
)
{
    timeout= _timeout;
    policyTicket= _policyTicket;
};
/// <summary>
/// This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
/// </summary>
PolicySignedResponse::~PolicySignedResponse()
{
    return;
};
/// <summary>
/// This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
/// </summary>
PolicySignedResponse& PolicySignedResponse::operator=(const PolicySignedResponse& rhs)
{
    if(this == &rhs) return *this;
    this->timeoutSize = rhs.timeoutSize;
    this->timeout = rhs.timeout;
    this->policyTicket = rhs.policyTicket;
    return *this;
};
/// <summary>
/// This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
/// </summary>
PolicySignedResponse::PolicySignedResponse(const PolicySignedResponse& r)
{
    this->timeoutSize = r.timeoutSize;
    this->timeout = r.timeout;
    this->policyTicket = r.policyTicket;
};
/// <summary>
/// This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
/// </summary>
TpmStructureBase* PolicySignedResponse::Clone() const
{
    PolicySignedResponse* _x = new PolicySignedResponse(*this);
    return _x;
};
void* PolicySignedResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&timeoutSize);
            case 1: { if(newArraySize != -1)timeout.resize(newArraySize); arraySize = (int)timeout.size(); return (void*)(&timeout); }
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&policyTicket); return (void*) (&policyTicket);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&timeout[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_PolicySecret_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
};
/// <summary>
/// This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
/// </summary>
TPM2_PolicySecret_REQUEST::TPM2_PolicySecret_REQUEST()
{
    return;
};
TPM2_PolicySecret_REQUEST::TPM2_PolicySecret_REQUEST
(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _policySession,
    const std::vector<BYTE>& _nonceTPM,
    const std::vector<BYTE>& _cpHashA,
    const std::vector<BYTE>& _policyRef,
    const INT32& _expiration
)
{
    authHandle= _authHandle;
    policySession= _policySession;
    nonceTPM= _nonceTPM;
    cpHashA= _cpHashA;
    policyRef= _policyRef;
    expiration= _expiration;
};
/// <summary>
/// This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
/// </summary>
TPM2_PolicySecret_REQUEST::~TPM2_PolicySecret_REQUEST()
{
    return;
};
/// <summary>
/// This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
/// </summary>
TPM2_PolicySecret_REQUEST& TPM2_PolicySecret_REQUEST::operator=(const TPM2_PolicySecret_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    this->policySession = rhs.policySession;
    this->nonceTPMSize = rhs.nonceTPMSize;
    this->nonceTPM = rhs.nonceTPM;
    this->cpHashASize = rhs.cpHashASize;
    this->cpHashA = rhs.cpHashA;
    this->policyRefSize = rhs.policyRefSize;
    this->policyRef = rhs.policyRef;
    this->expiration = rhs.expiration;
    return *this;
};
/// <summary>
/// This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
/// </summary>
TPM2_PolicySecret_REQUEST::TPM2_PolicySecret_REQUEST(const TPM2_PolicySecret_REQUEST& r)
{
    this->authHandle = r.authHandle;
    this->policySession = r.policySession;
    this->nonceTPMSize = r.nonceTPMSize;
    this->nonceTPM = r.nonceTPM;
    this->cpHashASize = r.cpHashASize;
    this->cpHashA = r.cpHashA;
    this->policyRefSize = r.policyRefSize;
    this->policyRef = r.policyRef;
    this->expiration = r.expiration;
};
/// <summary>
/// This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
/// </summary>
TpmStructureBase* TPM2_PolicySecret_REQUEST::Clone() const
{
    TPM2_PolicySecret_REQUEST* _x = new TPM2_PolicySecret_REQUEST(*this);
    return _x;
};
void* TPM2_PolicySecret_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            case 2: return (void*) (&nonceTPMSize);
            case 3: { if(newArraySize != -1)nonceTPM.resize(newArraySize); arraySize = (int)nonceTPM.size(); return (void*)(&nonceTPM); }
            case 4: return (void*) (&cpHashASize);
            case 5: { if(newArraySize != -1)cpHashA.resize(newArraySize); arraySize = (int)cpHashA.size(); return (void*)(&cpHashA); }
            case 6: return (void*) (&policyRefSize);
            case 7: { if(newArraySize != -1)policyRef.resize(newArraySize); arraySize = (int)policyRef.size(); return (void*)(&policyRef); }
            case 8: return (void*) (&expiration);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&nonceTPM[arrayIndex]);
            case 5: return (void*)(&cpHashA[arrayIndex]);
            case 7: return (void*)(&policyRef[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PolicySecretResponse::GetTypeId() const
{
    return TpmTypeId::PolicySecretResponse_ID;
};
/// <summary>
/// This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
/// </summary>
PolicySecretResponse::PolicySecretResponse()
{
    return;
};
PolicySecretResponse::PolicySecretResponse
(
    const std::vector<BYTE>& _timeout,
    const TPMT_TK_AUTH& _policyTicket
)
{
    timeout= _timeout;
    policyTicket= _policyTicket;
};
/// <summary>
/// This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
/// </summary>
PolicySecretResponse::~PolicySecretResponse()
{
    return;
};
/// <summary>
/// This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
/// </summary>
PolicySecretResponse& PolicySecretResponse::operator=(const PolicySecretResponse& rhs)
{
    if(this == &rhs) return *this;
    this->timeoutSize = rhs.timeoutSize;
    this->timeout = rhs.timeout;
    this->policyTicket = rhs.policyTicket;
    return *this;
};
/// <summary>
/// This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
/// </summary>
PolicySecretResponse::PolicySecretResponse(const PolicySecretResponse& r)
{
    this->timeoutSize = r.timeoutSize;
    this->timeout = r.timeout;
    this->policyTicket = r.policyTicket;
};
/// <summary>
/// This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
/// </summary>
TpmStructureBase* PolicySecretResponse::Clone() const
{
    PolicySecretResponse* _x = new PolicySecretResponse(*this);
    return _x;
};
void* PolicySecretResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&timeoutSize);
            case 1: { if(newArraySize != -1)timeout.resize(newArraySize); arraySize = (int)timeout.size(); return (void*)(&timeout); }
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&policyTicket); return (void*) (&policyTicket);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&timeout[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_PolicyTicket_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
};
/// <summary>
/// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
/// </summary>
TPM2_PolicyTicket_REQUEST::TPM2_PolicyTicket_REQUEST()
{
    return;
};
TPM2_PolicyTicket_REQUEST::TPM2_PolicyTicket_REQUEST
(
    const TPM_HANDLE& _policySession,
    const std::vector<BYTE>& _timeout,
    const std::vector<BYTE>& _cpHashA,
    const std::vector<BYTE>& _policyRef,
    const std::vector<BYTE>& _authName,
    const TPMT_TK_AUTH& _ticket
)
{
    policySession= _policySession;
    timeout= _timeout;
    cpHashA= _cpHashA;
    policyRef= _policyRef;
    authName= _authName;
    ticket= _ticket;
};
/// <summary>
/// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
/// </summary>
TPM2_PolicyTicket_REQUEST::~TPM2_PolicyTicket_REQUEST()
{
    return;
};
/// <summary>
/// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
/// </summary>
TPM2_PolicyTicket_REQUEST& TPM2_PolicyTicket_REQUEST::operator=(const TPM2_PolicyTicket_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->policySession = rhs.policySession;
    this->timeoutSize = rhs.timeoutSize;
    this->timeout = rhs.timeout;
    this->cpHashASize = rhs.cpHashASize;
    this->cpHashA = rhs.cpHashA;
    this->policyRefSize = rhs.policyRefSize;
    this->policyRef = rhs.policyRef;
    this->authNameSize = rhs.authNameSize;
    this->authName = rhs.authName;
    this->ticket = rhs.ticket;
    return *this;
};
/// <summary>
/// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
/// </summary>
TPM2_PolicyTicket_REQUEST::TPM2_PolicyTicket_REQUEST(const TPM2_PolicyTicket_REQUEST& r)
{
    this->policySession = r.policySession;
    this->timeoutSize = r.timeoutSize;
    this->timeout = r.timeout;
    this->cpHashASize = r.cpHashASize;
    this->cpHashA = r.cpHashA;
    this->policyRefSize = r.policyRefSize;
    this->policyRef = r.policyRef;
    this->authNameSize = r.authNameSize;
    this->authName = r.authName;
    this->ticket = r.ticket;
};
/// <summary>
/// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
/// </summary>
TpmStructureBase* TPM2_PolicyTicket_REQUEST::Clone() const
{
    TPM2_PolicyTicket_REQUEST* _x = new TPM2_PolicyTicket_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyTicket_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            case 1: return (void*) (&timeoutSize);
            case 2: { if(newArraySize != -1)timeout.resize(newArraySize); arraySize = (int)timeout.size(); return (void*)(&timeout); }
            case 3: return (void*) (&cpHashASize);
            case 4: { if(newArraySize != -1)cpHashA.resize(newArraySize); arraySize = (int)cpHashA.size(); return (void*)(&cpHashA); }
            case 5: return (void*) (&policyRefSize);
            case 6: { if(newArraySize != -1)policyRef.resize(newArraySize); arraySize = (int)policyRef.size(); return (void*)(&policyRef); }
            case 7: return (void*) (&authNameSize);
            case 8: { if(newArraySize != -1)authName.resize(newArraySize); arraySize = (int)authName.size(); return (void*)(&authName); }
            case 9: pStruct = dynamic_cast<TpmStructureBase*>(&ticket); return (void*) (&ticket);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&timeout[arrayIndex]);
            case 4: return (void*)(&cpHashA[arrayIndex]);
            case 6: return (void*)(&policyRef[arrayIndex]);
            case 8: return (void*)(&authName[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PolicyTicketResponse::GetTypeId() const
{
    return TpmTypeId::PolicyTicketResponse_ID;
};
/// <summary>
/// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
/// </summary>
PolicyTicketResponse::PolicyTicketResponse()
{
    return;
};
/// <summary>
/// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
/// </summary>
PolicyTicketResponse::~PolicyTicketResponse()
{
    return;
};
/// <summary>
/// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
/// </summary>
PolicyTicketResponse& PolicyTicketResponse::operator=(const PolicyTicketResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
/// </summary>
PolicyTicketResponse::PolicyTicketResponse(const PolicyTicketResponse& r)
{
};
/// <summary>
/// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
/// </summary>
TpmStructureBase* PolicyTicketResponse::Clone() const
{
    PolicyTicketResponse* _x = new PolicyTicketResponse(*this);
    return _x;
};
void* PolicyTicketResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PolicyOR_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyOR_REQUEST_ID;
};
/// <summary>
/// This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
/// </summary>
TPM2_PolicyOR_REQUEST::TPM2_PolicyOR_REQUEST()
{
    return;
};
TPM2_PolicyOR_REQUEST::TPM2_PolicyOR_REQUEST
(
    const TPM_HANDLE& _policySession,
    const std::vector<TPM2B_DIGEST>& _pHashList
)
{
    policySession= _policySession;
    pHashList= _pHashList;
};
/// <summary>
/// This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
/// </summary>
TPM2_PolicyOR_REQUEST::~TPM2_PolicyOR_REQUEST()
{
    return;
};
/// <summary>
/// This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
/// </summary>
TPM2_PolicyOR_REQUEST& TPM2_PolicyOR_REQUEST::operator=(const TPM2_PolicyOR_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->policySession = rhs.policySession;
    this->pHashListCount = rhs.pHashListCount;
    this->pHashList = rhs.pHashList;
    return *this;
};
/// <summary>
/// This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
/// </summary>
TPM2_PolicyOR_REQUEST::TPM2_PolicyOR_REQUEST(const TPM2_PolicyOR_REQUEST& r)
{
    this->policySession = r.policySession;
    this->pHashListCount = r.pHashListCount;
    this->pHashList = r.pHashList;
};
/// <summary>
/// This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
/// </summary>
TpmStructureBase* TPM2_PolicyOR_REQUEST::Clone() const
{
    TPM2_PolicyOR_REQUEST* _x = new TPM2_PolicyOR_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyOR_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            case 1: return (void*) (&pHashListCount);
            case 2: { if(newArraySize != -1)pHashList.resize(newArraySize); arraySize = (int)pHashList.size(); return (void*)(&pHashList); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&pHashList[arrayIndex]);return (void*)(&pHashList[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PolicyORResponse::GetTypeId() const
{
    return TpmTypeId::PolicyORResponse_ID;
};
/// <summary>
/// This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
/// </summary>
PolicyORResponse::PolicyORResponse()
{
    return;
};
/// <summary>
/// This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
/// </summary>
PolicyORResponse::~PolicyORResponse()
{
    return;
};
/// <summary>
/// This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
/// </summary>
PolicyORResponse& PolicyORResponse::operator=(const PolicyORResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
/// </summary>
PolicyORResponse::PolicyORResponse(const PolicyORResponse& r)
{
};
/// <summary>
/// This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
/// </summary>
TpmStructureBase* PolicyORResponse::Clone() const
{
    PolicyORResponse* _x = new PolicyORResponse(*this);
    return _x;
};
void* PolicyORResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PolicyPCR_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyPCR_REQUEST_ID;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
/// </summary>
TPM2_PolicyPCR_REQUEST::TPM2_PolicyPCR_REQUEST()
{
    return;
};
TPM2_PolicyPCR_REQUEST::TPM2_PolicyPCR_REQUEST
(
    const TPM_HANDLE& _policySession,
    const std::vector<BYTE>& _pcrDigest,
    const std::vector<TPMS_PCR_SELECTION>& _pcrs
)
{
    policySession= _policySession;
    pcrDigest= _pcrDigest;
    pcrs= _pcrs;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
/// </summary>
TPM2_PolicyPCR_REQUEST::~TPM2_PolicyPCR_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
/// </summary>
TPM2_PolicyPCR_REQUEST& TPM2_PolicyPCR_REQUEST::operator=(const TPM2_PolicyPCR_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->policySession = rhs.policySession;
    this->pcrDigestSize = rhs.pcrDigestSize;
    this->pcrDigest = rhs.pcrDigest;
    this->pcrsCount = rhs.pcrsCount;
    this->pcrs = rhs.pcrs;
    return *this;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
/// </summary>
TPM2_PolicyPCR_REQUEST::TPM2_PolicyPCR_REQUEST(const TPM2_PolicyPCR_REQUEST& r)
{
    this->policySession = r.policySession;
    this->pcrDigestSize = r.pcrDigestSize;
    this->pcrDigest = r.pcrDigest;
    this->pcrsCount = r.pcrsCount;
    this->pcrs = r.pcrs;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
/// </summary>
TpmStructureBase* TPM2_PolicyPCR_REQUEST::Clone() const
{
    TPM2_PolicyPCR_REQUEST* _x = new TPM2_PolicyPCR_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyPCR_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            case 1: return (void*) (&pcrDigestSize);
            case 2: { if(newArraySize != -1)pcrDigest.resize(newArraySize); arraySize = (int)pcrDigest.size(); return (void*)(&pcrDigest); }
            case 3: return (void*) (&pcrsCount);
            case 4: { if(newArraySize != -1)pcrs.resize(newArraySize); arraySize = (int)pcrs.size(); return (void*)(&pcrs); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&pcrDigest[arrayIndex]);
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&pcrs[arrayIndex]);return (void*)(&pcrs[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PolicyPCRResponse::GetTypeId() const
{
    return TpmTypeId::PolicyPCRResponse_ID;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
/// </summary>
PolicyPCRResponse::PolicyPCRResponse()
{
    return;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
/// </summary>
PolicyPCRResponse::~PolicyPCRResponse()
{
    return;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
/// </summary>
PolicyPCRResponse& PolicyPCRResponse::operator=(const PolicyPCRResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
/// </summary>
PolicyPCRResponse::PolicyPCRResponse(const PolicyPCRResponse& r)
{
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
/// </summary>
TpmStructureBase* PolicyPCRResponse::Clone() const
{
    PolicyPCRResponse* _x = new PolicyPCRResponse(*this);
    return _x;
};
void* PolicyPCRResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PolicyLocality_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyLocality_REQUEST_ID;
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific locality.
/// </summary>
TPM2_PolicyLocality_REQUEST::TPM2_PolicyLocality_REQUEST()
{
    return;
};
TPM2_PolicyLocality_REQUEST::TPM2_PolicyLocality_REQUEST
(
    const TPM_HANDLE& _policySession,
    const TPMA_LOCALITY& _locality
)
{
    policySession= _policySession;
    locality= _locality;
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific locality.
/// </summary>
TPM2_PolicyLocality_REQUEST::~TPM2_PolicyLocality_REQUEST()
{
    return;
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific locality.
/// </summary>
TPM2_PolicyLocality_REQUEST& TPM2_PolicyLocality_REQUEST::operator=(const TPM2_PolicyLocality_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->policySession = rhs.policySession;
    this->locality = rhs.locality;
    return *this;
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific locality.
/// </summary>
TPM2_PolicyLocality_REQUEST::TPM2_PolicyLocality_REQUEST(const TPM2_PolicyLocality_REQUEST& r)
{
    this->policySession = r.policySession;
    this->locality = r.locality;
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific locality.
/// </summary>
TpmStructureBase* TPM2_PolicyLocality_REQUEST::Clone() const
{
    TPM2_PolicyLocality_REQUEST* _x = new TPM2_PolicyLocality_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyLocality_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            case 1: return (void*) (&locality);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId PolicyLocalityResponse::GetTypeId() const
{
    return TpmTypeId::PolicyLocalityResponse_ID;
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific locality.
/// </summary>
PolicyLocalityResponse::PolicyLocalityResponse()
{
    return;
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific locality.
/// </summary>
PolicyLocalityResponse::~PolicyLocalityResponse()
{
    return;
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific locality.
/// </summary>
PolicyLocalityResponse& PolicyLocalityResponse::operator=(const PolicyLocalityResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific locality.
/// </summary>
PolicyLocalityResponse::PolicyLocalityResponse(const PolicyLocalityResponse& r)
{
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific locality.
/// </summary>
TpmStructureBase* PolicyLocalityResponse::Clone() const
{
    PolicyLocalityResponse* _x = new PolicyLocalityResponse(*this);
    return _x;
};
void* PolicyLocalityResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PolicyNV_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
/// </summary>
TPM2_PolicyNV_REQUEST::TPM2_PolicyNV_REQUEST()
{
    return;
};
TPM2_PolicyNV_REQUEST::TPM2_PolicyNV_REQUEST
(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    const TPM_HANDLE& _policySession,
    const std::vector<BYTE>& _operandB,
    const UINT16& _offset,
    const TPM_EO& _operation
)
{
    authHandle= _authHandle;
    nvIndex= _nvIndex;
    policySession= _policySession;
    operandB= _operandB;
    offset= _offset;
    operation= _operation;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
/// </summary>
TPM2_PolicyNV_REQUEST::~TPM2_PolicyNV_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
/// </summary>
TPM2_PolicyNV_REQUEST& TPM2_PolicyNV_REQUEST::operator=(const TPM2_PolicyNV_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    this->nvIndex = rhs.nvIndex;
    this->policySession = rhs.policySession;
    this->operandBSize = rhs.operandBSize;
    this->operandB = rhs.operandB;
    this->offset = rhs.offset;
    this->operation = rhs.operation;
    return *this;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
/// </summary>
TPM2_PolicyNV_REQUEST::TPM2_PolicyNV_REQUEST(const TPM2_PolicyNV_REQUEST& r)
{
    this->authHandle = r.authHandle;
    this->nvIndex = r.nvIndex;
    this->policySession = r.policySession;
    this->operandBSize = r.operandBSize;
    this->operandB = r.operandB;
    this->offset = r.offset;
    this->operation = r.operation;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
/// </summary>
TpmStructureBase* TPM2_PolicyNV_REQUEST::Clone() const
{
    TPM2_PolicyNV_REQUEST* _x = new TPM2_PolicyNV_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyNV_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return (void*) (&nvIndex);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            case 3: return (void*) (&operandBSize);
            case 4: { if(newArraySize != -1)operandB.resize(newArraySize); arraySize = (int)operandB.size(); return (void*)(&operandB); }
            case 5: return (void*) (&offset);
            case 6: return (void*) (&operation);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 4: return (void*)(&operandB[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PolicyNVResponse::GetTypeId() const
{
    return TpmTypeId::PolicyNVResponse_ID;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
/// </summary>
PolicyNVResponse::PolicyNVResponse()
{
    return;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
/// </summary>
PolicyNVResponse::~PolicyNVResponse()
{
    return;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
/// </summary>
PolicyNVResponse& PolicyNVResponse::operator=(const PolicyNVResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
/// </summary>
PolicyNVResponse::PolicyNVResponse(const PolicyNVResponse& r)
{
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
/// </summary>
TpmStructureBase* PolicyNVResponse::Clone() const
{
    PolicyNVResponse* _x = new PolicyNVResponse(*this);
    return _x;
};
void* PolicyNVResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PolicyCounterTimer_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
/// </summary>
TPM2_PolicyCounterTimer_REQUEST::TPM2_PolicyCounterTimer_REQUEST()
{
    return;
};
TPM2_PolicyCounterTimer_REQUEST::TPM2_PolicyCounterTimer_REQUEST
(
    const TPM_HANDLE& _policySession,
    const std::vector<BYTE>& _operandB,
    const UINT16& _offset,
    const TPM_EO& _operation
)
{
    policySession= _policySession;
    operandB= _operandB;
    offset= _offset;
    operation= _operation;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
/// </summary>
TPM2_PolicyCounterTimer_REQUEST::~TPM2_PolicyCounterTimer_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
/// </summary>
TPM2_PolicyCounterTimer_REQUEST& TPM2_PolicyCounterTimer_REQUEST::operator=(const TPM2_PolicyCounterTimer_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->policySession = rhs.policySession;
    this->operandBSize = rhs.operandBSize;
    this->operandB = rhs.operandB;
    this->offset = rhs.offset;
    this->operation = rhs.operation;
    return *this;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
/// </summary>
TPM2_PolicyCounterTimer_REQUEST::TPM2_PolicyCounterTimer_REQUEST(const TPM2_PolicyCounterTimer_REQUEST& r)
{
    this->policySession = r.policySession;
    this->operandBSize = r.operandBSize;
    this->operandB = r.operandB;
    this->offset = r.offset;
    this->operation = r.operation;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
/// </summary>
TpmStructureBase* TPM2_PolicyCounterTimer_REQUEST::Clone() const
{
    TPM2_PolicyCounterTimer_REQUEST* _x = new TPM2_PolicyCounterTimer_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyCounterTimer_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            case 1: return (void*) (&operandBSize);
            case 2: { if(newArraySize != -1)operandB.resize(newArraySize); arraySize = (int)operandB.size(); return (void*)(&operandB); }
            case 3: return (void*) (&offset);
            case 4: return (void*) (&operation);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&operandB[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PolicyCounterTimerResponse::GetTypeId() const
{
    return TpmTypeId::PolicyCounterTimerResponse_ID;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
/// </summary>
PolicyCounterTimerResponse::PolicyCounterTimerResponse()
{
    return;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
/// </summary>
PolicyCounterTimerResponse::~PolicyCounterTimerResponse()
{
    return;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
/// </summary>
PolicyCounterTimerResponse& PolicyCounterTimerResponse::operator=(const PolicyCounterTimerResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
/// </summary>
PolicyCounterTimerResponse::PolicyCounterTimerResponse(const PolicyCounterTimerResponse& r)
{
};
/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
/// </summary>
TpmStructureBase* PolicyCounterTimerResponse::Clone() const
{
    PolicyCounterTimerResponse* _x = new PolicyCounterTimerResponse(*this);
    return _x;
};
void* PolicyCounterTimerResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PolicyCommandCode_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyCommandCode_REQUEST_ID;
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific command code.
/// </summary>
TPM2_PolicyCommandCode_REQUEST::TPM2_PolicyCommandCode_REQUEST()
{
    return;
};
TPM2_PolicyCommandCode_REQUEST::TPM2_PolicyCommandCode_REQUEST
(
    const TPM_HANDLE& _policySession,
    const TPM_CC& _code
)
{
    policySession= _policySession;
    code= _code;
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific command code.
/// </summary>
TPM2_PolicyCommandCode_REQUEST::~TPM2_PolicyCommandCode_REQUEST()
{
    return;
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific command code.
/// </summary>
TPM2_PolicyCommandCode_REQUEST& TPM2_PolicyCommandCode_REQUEST::operator=(const TPM2_PolicyCommandCode_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->policySession = rhs.policySession;
    this->code = rhs.code;
    return *this;
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific command code.
/// </summary>
TPM2_PolicyCommandCode_REQUEST::TPM2_PolicyCommandCode_REQUEST(const TPM2_PolicyCommandCode_REQUEST& r)
{
    this->policySession = r.policySession;
    this->code = r.code;
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific command code.
/// </summary>
TpmStructureBase* TPM2_PolicyCommandCode_REQUEST::Clone() const
{
    TPM2_PolicyCommandCode_REQUEST* _x = new TPM2_PolicyCommandCode_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyCommandCode_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            case 1: return (void*) (&code);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId PolicyCommandCodeResponse::GetTypeId() const
{
    return TpmTypeId::PolicyCommandCodeResponse_ID;
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific command code.
/// </summary>
PolicyCommandCodeResponse::PolicyCommandCodeResponse()
{
    return;
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific command code.
/// </summary>
PolicyCommandCodeResponse::~PolicyCommandCodeResponse()
{
    return;
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific command code.
/// </summary>
PolicyCommandCodeResponse& PolicyCommandCodeResponse::operator=(const PolicyCommandCodeResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific command code.
/// </summary>
PolicyCommandCodeResponse::PolicyCommandCodeResponse(const PolicyCommandCodeResponse& r)
{
};
/// <summary>
/// This command indicates that the authorization will be limited to a specific command code.
/// </summary>
TpmStructureBase* PolicyCommandCodeResponse::Clone() const
{
    PolicyCommandCodeResponse* _x = new PolicyCommandCodeResponse(*this);
    return _x;
};
void* PolicyCommandCodeResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PolicyPhysicalPresence_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyPhysicalPresence_REQUEST_ID;
};
/// <summary>
/// This command indicates that physical presence will need to be asserted at the time the authorization is performed.
/// </summary>
TPM2_PolicyPhysicalPresence_REQUEST::TPM2_PolicyPhysicalPresence_REQUEST()
{
    return;
};
TPM2_PolicyPhysicalPresence_REQUEST::TPM2_PolicyPhysicalPresence_REQUEST
(
    const TPM_HANDLE& _policySession
)
{
    policySession= _policySession;
};
/// <summary>
/// This command indicates that physical presence will need to be asserted at the time the authorization is performed.
/// </summary>
TPM2_PolicyPhysicalPresence_REQUEST::~TPM2_PolicyPhysicalPresence_REQUEST()
{
    return;
};
/// <summary>
/// This command indicates that physical presence will need to be asserted at the time the authorization is performed.
/// </summary>
TPM2_PolicyPhysicalPresence_REQUEST& TPM2_PolicyPhysicalPresence_REQUEST::operator=(const TPM2_PolicyPhysicalPresence_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->policySession = rhs.policySession;
    return *this;
};
/// <summary>
/// This command indicates that physical presence will need to be asserted at the time the authorization is performed.
/// </summary>
TPM2_PolicyPhysicalPresence_REQUEST::TPM2_PolicyPhysicalPresence_REQUEST(const TPM2_PolicyPhysicalPresence_REQUEST& r)
{
    this->policySession = r.policySession;
};
/// <summary>
/// This command indicates that physical presence will need to be asserted at the time the authorization is performed.
/// </summary>
TpmStructureBase* TPM2_PolicyPhysicalPresence_REQUEST::Clone() const
{
    TPM2_PolicyPhysicalPresence_REQUEST* _x = new TPM2_PolicyPhysicalPresence_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyPhysicalPresence_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId PolicyPhysicalPresenceResponse::GetTypeId() const
{
    return TpmTypeId::PolicyPhysicalPresenceResponse_ID;
};
/// <summary>
/// This command indicates that physical presence will need to be asserted at the time the authorization is performed.
/// </summary>
PolicyPhysicalPresenceResponse::PolicyPhysicalPresenceResponse()
{
    return;
};
/// <summary>
/// This command indicates that physical presence will need to be asserted at the time the authorization is performed.
/// </summary>
PolicyPhysicalPresenceResponse::~PolicyPhysicalPresenceResponse()
{
    return;
};
/// <summary>
/// This command indicates that physical presence will need to be asserted at the time the authorization is performed.
/// </summary>
PolicyPhysicalPresenceResponse& PolicyPhysicalPresenceResponse::operator=(const PolicyPhysicalPresenceResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command indicates that physical presence will need to be asserted at the time the authorization is performed.
/// </summary>
PolicyPhysicalPresenceResponse::PolicyPhysicalPresenceResponse(const PolicyPhysicalPresenceResponse& r)
{
};
/// <summary>
/// This command indicates that physical presence will need to be asserted at the time the authorization is performed.
/// </summary>
TpmStructureBase* PolicyPhysicalPresenceResponse::Clone() const
{
    PolicyPhysicalPresenceResponse* _x = new PolicyPhysicalPresenceResponse(*this);
    return _x;
};
void* PolicyPhysicalPresenceResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PolicyCpHash_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyCpHash_REQUEST_ID;
};
/// <summary>
/// This command is used to allow a policy to be bound to a specific command and command parameters.
/// </summary>
TPM2_PolicyCpHash_REQUEST::TPM2_PolicyCpHash_REQUEST()
{
    return;
};
TPM2_PolicyCpHash_REQUEST::TPM2_PolicyCpHash_REQUEST
(
    const TPM_HANDLE& _policySession,
    const std::vector<BYTE>& _cpHashA
)
{
    policySession= _policySession;
    cpHashA= _cpHashA;
};
/// <summary>
/// This command is used to allow a policy to be bound to a specific command and command parameters.
/// </summary>
TPM2_PolicyCpHash_REQUEST::~TPM2_PolicyCpHash_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to allow a policy to be bound to a specific command and command parameters.
/// </summary>
TPM2_PolicyCpHash_REQUEST& TPM2_PolicyCpHash_REQUEST::operator=(const TPM2_PolicyCpHash_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->policySession = rhs.policySession;
    this->cpHashASize = rhs.cpHashASize;
    this->cpHashA = rhs.cpHashA;
    return *this;
};
/// <summary>
/// This command is used to allow a policy to be bound to a specific command and command parameters.
/// </summary>
TPM2_PolicyCpHash_REQUEST::TPM2_PolicyCpHash_REQUEST(const TPM2_PolicyCpHash_REQUEST& r)
{
    this->policySession = r.policySession;
    this->cpHashASize = r.cpHashASize;
    this->cpHashA = r.cpHashA;
};
/// <summary>
/// This command is used to allow a policy to be bound to a specific command and command parameters.
/// </summary>
TpmStructureBase* TPM2_PolicyCpHash_REQUEST::Clone() const
{
    TPM2_PolicyCpHash_REQUEST* _x = new TPM2_PolicyCpHash_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyCpHash_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            case 1: return (void*) (&cpHashASize);
            case 2: { if(newArraySize != -1)cpHashA.resize(newArraySize); arraySize = (int)cpHashA.size(); return (void*)(&cpHashA); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&cpHashA[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PolicyCpHashResponse::GetTypeId() const
{
    return TpmTypeId::PolicyCpHashResponse_ID;
};
/// <summary>
/// This command is used to allow a policy to be bound to a specific command and command parameters.
/// </summary>
PolicyCpHashResponse::PolicyCpHashResponse()
{
    return;
};
/// <summary>
/// This command is used to allow a policy to be bound to a specific command and command parameters.
/// </summary>
PolicyCpHashResponse::~PolicyCpHashResponse()
{
    return;
};
/// <summary>
/// This command is used to allow a policy to be bound to a specific command and command parameters.
/// </summary>
PolicyCpHashResponse& PolicyCpHashResponse::operator=(const PolicyCpHashResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command is used to allow a policy to be bound to a specific command and command parameters.
/// </summary>
PolicyCpHashResponse::PolicyCpHashResponse(const PolicyCpHashResponse& r)
{
};
/// <summary>
/// This command is used to allow a policy to be bound to a specific command and command parameters.
/// </summary>
TpmStructureBase* PolicyCpHashResponse::Clone() const
{
    PolicyCpHashResponse* _x = new PolicyCpHashResponse(*this);
    return _x;
};
void* PolicyCpHashResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PolicyNameHash_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyNameHash_REQUEST_ID;
};
/// <summary>
/// This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
/// </summary>
TPM2_PolicyNameHash_REQUEST::TPM2_PolicyNameHash_REQUEST()
{
    return;
};
TPM2_PolicyNameHash_REQUEST::TPM2_PolicyNameHash_REQUEST
(
    const TPM_HANDLE& _policySession,
    const std::vector<BYTE>& _nameHash
)
{
    policySession= _policySession;
    nameHash= _nameHash;
};
/// <summary>
/// This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
/// </summary>
TPM2_PolicyNameHash_REQUEST::~TPM2_PolicyNameHash_REQUEST()
{
    return;
};
/// <summary>
/// This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
/// </summary>
TPM2_PolicyNameHash_REQUEST& TPM2_PolicyNameHash_REQUEST::operator=(const TPM2_PolicyNameHash_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->policySession = rhs.policySession;
    this->nameHashSize = rhs.nameHashSize;
    this->nameHash = rhs.nameHash;
    return *this;
};
/// <summary>
/// This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
/// </summary>
TPM2_PolicyNameHash_REQUEST::TPM2_PolicyNameHash_REQUEST(const TPM2_PolicyNameHash_REQUEST& r)
{
    this->policySession = r.policySession;
    this->nameHashSize = r.nameHashSize;
    this->nameHash = r.nameHash;
};
/// <summary>
/// This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
/// </summary>
TpmStructureBase* TPM2_PolicyNameHash_REQUEST::Clone() const
{
    TPM2_PolicyNameHash_REQUEST* _x = new TPM2_PolicyNameHash_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyNameHash_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            case 1: return (void*) (&nameHashSize);
            case 2: { if(newArraySize != -1)nameHash.resize(newArraySize); arraySize = (int)nameHash.size(); return (void*)(&nameHash); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&nameHash[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PolicyNameHashResponse::GetTypeId() const
{
    return TpmTypeId::PolicyNameHashResponse_ID;
};
/// <summary>
/// This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
/// </summary>
PolicyNameHashResponse::PolicyNameHashResponse()
{
    return;
};
/// <summary>
/// This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
/// </summary>
PolicyNameHashResponse::~PolicyNameHashResponse()
{
    return;
};
/// <summary>
/// This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
/// </summary>
PolicyNameHashResponse& PolicyNameHashResponse::operator=(const PolicyNameHashResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
/// </summary>
PolicyNameHashResponse::PolicyNameHashResponse(const PolicyNameHashResponse& r)
{
};
/// <summary>
/// This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
/// </summary>
TpmStructureBase* PolicyNameHashResponse::Clone() const
{
    PolicyNameHashResponse* _x = new PolicyNameHashResponse(*this);
    return _x;
};
void* PolicyNameHashResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PolicyDuplicationSelect_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
};
/// <summary>
/// This command allows qualification of duplication to allow duplication to a selected new parent.
/// </summary>
TPM2_PolicyDuplicationSelect_REQUEST::TPM2_PolicyDuplicationSelect_REQUEST()
{
    return;
};
TPM2_PolicyDuplicationSelect_REQUEST::TPM2_PolicyDuplicationSelect_REQUEST
(
    const TPM_HANDLE& _policySession,
    const std::vector<BYTE>& _objectName,
    const std::vector<BYTE>& _newParentName,
    const BYTE& _includeObject
)
{
    policySession= _policySession;
    objectName= _objectName;
    newParentName= _newParentName;
    includeObject= _includeObject;
};
/// <summary>
/// This command allows qualification of duplication to allow duplication to a selected new parent.
/// </summary>
TPM2_PolicyDuplicationSelect_REQUEST::~TPM2_PolicyDuplicationSelect_REQUEST()
{
    return;
};
/// <summary>
/// This command allows qualification of duplication to allow duplication to a selected new parent.
/// </summary>
TPM2_PolicyDuplicationSelect_REQUEST& TPM2_PolicyDuplicationSelect_REQUEST::operator=(const TPM2_PolicyDuplicationSelect_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->policySession = rhs.policySession;
    this->objectNameSize = rhs.objectNameSize;
    this->objectName = rhs.objectName;
    this->newParentNameSize = rhs.newParentNameSize;
    this->newParentName = rhs.newParentName;
    this->includeObject = rhs.includeObject;
    return *this;
};
/// <summary>
/// This command allows qualification of duplication to allow duplication to a selected new parent.
/// </summary>
TPM2_PolicyDuplicationSelect_REQUEST::TPM2_PolicyDuplicationSelect_REQUEST(const TPM2_PolicyDuplicationSelect_REQUEST& r)
{
    this->policySession = r.policySession;
    this->objectNameSize = r.objectNameSize;
    this->objectName = r.objectName;
    this->newParentNameSize = r.newParentNameSize;
    this->newParentName = r.newParentName;
    this->includeObject = r.includeObject;
};
/// <summary>
/// This command allows qualification of duplication to allow duplication to a selected new parent.
/// </summary>
TpmStructureBase* TPM2_PolicyDuplicationSelect_REQUEST::Clone() const
{
    TPM2_PolicyDuplicationSelect_REQUEST* _x = new TPM2_PolicyDuplicationSelect_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyDuplicationSelect_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            case 1: return (void*) (&objectNameSize);
            case 2: { if(newArraySize != -1)objectName.resize(newArraySize); arraySize = (int)objectName.size(); return (void*)(&objectName); }
            case 3: return (void*) (&newParentNameSize);
            case 4: { if(newArraySize != -1)newParentName.resize(newArraySize); arraySize = (int)newParentName.size(); return (void*)(&newParentName); }
            case 5: return (void*) (&includeObject);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&objectName[arrayIndex]);
            case 4: return (void*)(&newParentName[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PolicyDuplicationSelectResponse::GetTypeId() const
{
    return TpmTypeId::PolicyDuplicationSelectResponse_ID;
};
/// <summary>
/// This command allows qualification of duplication to allow duplication to a selected new parent.
/// </summary>
PolicyDuplicationSelectResponse::PolicyDuplicationSelectResponse()
{
    return;
};
/// <summary>
/// This command allows qualification of duplication to allow duplication to a selected new parent.
/// </summary>
PolicyDuplicationSelectResponse::~PolicyDuplicationSelectResponse()
{
    return;
};
/// <summary>
/// This command allows qualification of duplication to allow duplication to a selected new parent.
/// </summary>
PolicyDuplicationSelectResponse& PolicyDuplicationSelectResponse::operator=(const PolicyDuplicationSelectResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command allows qualification of duplication to allow duplication to a selected new parent.
/// </summary>
PolicyDuplicationSelectResponse::PolicyDuplicationSelectResponse(const PolicyDuplicationSelectResponse& r)
{
};
/// <summary>
/// This command allows qualification of duplication to allow duplication to a selected new parent.
/// </summary>
TpmStructureBase* PolicyDuplicationSelectResponse::Clone() const
{
    PolicyDuplicationSelectResponse* _x = new PolicyDuplicationSelectResponse(*this);
    return _x;
};
void* PolicyDuplicationSelectResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PolicyAuthorize_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
};
/// <summary>
/// This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
/// </summary>
TPM2_PolicyAuthorize_REQUEST::TPM2_PolicyAuthorize_REQUEST()
{
    return;
};
TPM2_PolicyAuthorize_REQUEST::TPM2_PolicyAuthorize_REQUEST
(
    const TPM_HANDLE& _policySession,
    const std::vector<BYTE>& _approvedPolicy,
    const std::vector<BYTE>& _policyRef,
    const std::vector<BYTE>& _keySign,
    const TPMT_TK_VERIFIED& _checkTicket
)
{
    policySession= _policySession;
    approvedPolicy= _approvedPolicy;
    policyRef= _policyRef;
    keySign= _keySign;
    checkTicket= _checkTicket;
};
/// <summary>
/// This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
/// </summary>
TPM2_PolicyAuthorize_REQUEST::~TPM2_PolicyAuthorize_REQUEST()
{
    return;
};
/// <summary>
/// This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
/// </summary>
TPM2_PolicyAuthorize_REQUEST& TPM2_PolicyAuthorize_REQUEST::operator=(const TPM2_PolicyAuthorize_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->policySession = rhs.policySession;
    this->approvedPolicySize = rhs.approvedPolicySize;
    this->approvedPolicy = rhs.approvedPolicy;
    this->policyRefSize = rhs.policyRefSize;
    this->policyRef = rhs.policyRef;
    this->keySignSize = rhs.keySignSize;
    this->keySign = rhs.keySign;
    this->checkTicket = rhs.checkTicket;
    return *this;
};
/// <summary>
/// This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
/// </summary>
TPM2_PolicyAuthorize_REQUEST::TPM2_PolicyAuthorize_REQUEST(const TPM2_PolicyAuthorize_REQUEST& r)
{
    this->policySession = r.policySession;
    this->approvedPolicySize = r.approvedPolicySize;
    this->approvedPolicy = r.approvedPolicy;
    this->policyRefSize = r.policyRefSize;
    this->policyRef = r.policyRef;
    this->keySignSize = r.keySignSize;
    this->keySign = r.keySign;
    this->checkTicket = r.checkTicket;
};
/// <summary>
/// This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
/// </summary>
TpmStructureBase* TPM2_PolicyAuthorize_REQUEST::Clone() const
{
    TPM2_PolicyAuthorize_REQUEST* _x = new TPM2_PolicyAuthorize_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyAuthorize_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            case 1: return (void*) (&approvedPolicySize);
            case 2: { if(newArraySize != -1)approvedPolicy.resize(newArraySize); arraySize = (int)approvedPolicy.size(); return (void*)(&approvedPolicy); }
            case 3: return (void*) (&policyRefSize);
            case 4: { if(newArraySize != -1)policyRef.resize(newArraySize); arraySize = (int)policyRef.size(); return (void*)(&policyRef); }
            case 5: return (void*) (&keySignSize);
            case 6: { if(newArraySize != -1)keySign.resize(newArraySize); arraySize = (int)keySign.size(); return (void*)(&keySign); }
            case 7: pStruct = dynamic_cast<TpmStructureBase*>(&checkTicket); return (void*) (&checkTicket);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&approvedPolicy[arrayIndex]);
            case 4: return (void*)(&policyRef[arrayIndex]);
            case 6: return (void*)(&keySign[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PolicyAuthorizeResponse::GetTypeId() const
{
    return TpmTypeId::PolicyAuthorizeResponse_ID;
};
/// <summary>
/// This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
/// </summary>
PolicyAuthorizeResponse::PolicyAuthorizeResponse()
{
    return;
};
/// <summary>
/// This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
/// </summary>
PolicyAuthorizeResponse::~PolicyAuthorizeResponse()
{
    return;
};
/// <summary>
/// This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
/// </summary>
PolicyAuthorizeResponse& PolicyAuthorizeResponse::operator=(const PolicyAuthorizeResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
/// </summary>
PolicyAuthorizeResponse::PolicyAuthorizeResponse(const PolicyAuthorizeResponse& r)
{
};
/// <summary>
/// This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
/// </summary>
TpmStructureBase* PolicyAuthorizeResponse::Clone() const
{
    PolicyAuthorizeResponse* _x = new PolicyAuthorizeResponse(*this);
    return _x;
};
void* PolicyAuthorizeResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PolicyAuthValue_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyAuthValue_REQUEST_ID;
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized entity.
/// </summary>
TPM2_PolicyAuthValue_REQUEST::TPM2_PolicyAuthValue_REQUEST()
{
    return;
};
TPM2_PolicyAuthValue_REQUEST::TPM2_PolicyAuthValue_REQUEST
(
    const TPM_HANDLE& _policySession
)
{
    policySession= _policySession;
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized entity.
/// </summary>
TPM2_PolicyAuthValue_REQUEST::~TPM2_PolicyAuthValue_REQUEST()
{
    return;
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized entity.
/// </summary>
TPM2_PolicyAuthValue_REQUEST& TPM2_PolicyAuthValue_REQUEST::operator=(const TPM2_PolicyAuthValue_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->policySession = rhs.policySession;
    return *this;
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized entity.
/// </summary>
TPM2_PolicyAuthValue_REQUEST::TPM2_PolicyAuthValue_REQUEST(const TPM2_PolicyAuthValue_REQUEST& r)
{
    this->policySession = r.policySession;
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized entity.
/// </summary>
TpmStructureBase* TPM2_PolicyAuthValue_REQUEST::Clone() const
{
    TPM2_PolicyAuthValue_REQUEST* _x = new TPM2_PolicyAuthValue_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyAuthValue_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId PolicyAuthValueResponse::GetTypeId() const
{
    return TpmTypeId::PolicyAuthValueResponse_ID;
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized entity.
/// </summary>
PolicyAuthValueResponse::PolicyAuthValueResponse()
{
    return;
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized entity.
/// </summary>
PolicyAuthValueResponse::~PolicyAuthValueResponse()
{
    return;
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized entity.
/// </summary>
PolicyAuthValueResponse& PolicyAuthValueResponse::operator=(const PolicyAuthValueResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized entity.
/// </summary>
PolicyAuthValueResponse::PolicyAuthValueResponse(const PolicyAuthValueResponse& r)
{
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized entity.
/// </summary>
TpmStructureBase* PolicyAuthValueResponse::Clone() const
{
    PolicyAuthValueResponse* _x = new PolicyAuthValueResponse(*this);
    return _x;
};
void* PolicyAuthValueResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PolicyPassword_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyPassword_REQUEST_ID;
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized object.
/// </summary>
TPM2_PolicyPassword_REQUEST::TPM2_PolicyPassword_REQUEST()
{
    return;
};
TPM2_PolicyPassword_REQUEST::TPM2_PolicyPassword_REQUEST
(
    const TPM_HANDLE& _policySession
)
{
    policySession= _policySession;
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized object.
/// </summary>
TPM2_PolicyPassword_REQUEST::~TPM2_PolicyPassword_REQUEST()
{
    return;
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized object.
/// </summary>
TPM2_PolicyPassword_REQUEST& TPM2_PolicyPassword_REQUEST::operator=(const TPM2_PolicyPassword_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->policySession = rhs.policySession;
    return *this;
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized object.
/// </summary>
TPM2_PolicyPassword_REQUEST::TPM2_PolicyPassword_REQUEST(const TPM2_PolicyPassword_REQUEST& r)
{
    this->policySession = r.policySession;
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized object.
/// </summary>
TpmStructureBase* TPM2_PolicyPassword_REQUEST::Clone() const
{
    TPM2_PolicyPassword_REQUEST* _x = new TPM2_PolicyPassword_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyPassword_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId PolicyPasswordResponse::GetTypeId() const
{
    return TpmTypeId::PolicyPasswordResponse_ID;
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized object.
/// </summary>
PolicyPasswordResponse::PolicyPasswordResponse()
{
    return;
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized object.
/// </summary>
PolicyPasswordResponse::~PolicyPasswordResponse()
{
    return;
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized object.
/// </summary>
PolicyPasswordResponse& PolicyPasswordResponse::operator=(const PolicyPasswordResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized object.
/// </summary>
PolicyPasswordResponse::PolicyPasswordResponse(const PolicyPasswordResponse& r)
{
};
/// <summary>
/// This command allows a policy to be bound to the authorization value of the authorized object.
/// </summary>
TpmStructureBase* PolicyPasswordResponse::Clone() const
{
    PolicyPasswordResponse* _x = new PolicyPasswordResponse(*this);
    return _x;
};
void* PolicyPasswordResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PolicyGetDigest_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyGetDigest_REQUEST_ID;
};
/// <summary>
/// This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
/// </summary>
TPM2_PolicyGetDigest_REQUEST::TPM2_PolicyGetDigest_REQUEST()
{
    return;
};
TPM2_PolicyGetDigest_REQUEST::TPM2_PolicyGetDigest_REQUEST
(
    const TPM_HANDLE& _policySession
)
{
    policySession= _policySession;
};
/// <summary>
/// This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
/// </summary>
TPM2_PolicyGetDigest_REQUEST::~TPM2_PolicyGetDigest_REQUEST()
{
    return;
};
/// <summary>
/// This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
/// </summary>
TPM2_PolicyGetDigest_REQUEST& TPM2_PolicyGetDigest_REQUEST::operator=(const TPM2_PolicyGetDigest_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->policySession = rhs.policySession;
    return *this;
};
/// <summary>
/// This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
/// </summary>
TPM2_PolicyGetDigest_REQUEST::TPM2_PolicyGetDigest_REQUEST(const TPM2_PolicyGetDigest_REQUEST& r)
{
    this->policySession = r.policySession;
};
/// <summary>
/// This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
/// </summary>
TpmStructureBase* TPM2_PolicyGetDigest_REQUEST::Clone() const
{
    TPM2_PolicyGetDigest_REQUEST* _x = new TPM2_PolicyGetDigest_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyGetDigest_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId PolicyGetDigestResponse::GetTypeId() const
{
    return TpmTypeId::PolicyGetDigestResponse_ID;
};
/// <summary>
/// This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
/// </summary>
PolicyGetDigestResponse::PolicyGetDigestResponse()
{
    return;
};
PolicyGetDigestResponse::PolicyGetDigestResponse
(
    const std::vector<BYTE>& _policyDigest
)
{
    policyDigest= _policyDigest;
};
/// <summary>
/// This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
/// </summary>
PolicyGetDigestResponse::~PolicyGetDigestResponse()
{
    return;
};
/// <summary>
/// This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
/// </summary>
PolicyGetDigestResponse& PolicyGetDigestResponse::operator=(const PolicyGetDigestResponse& rhs)
{
    if(this == &rhs) return *this;
    this->policyDigestSize = rhs.policyDigestSize;
    this->policyDigest = rhs.policyDigest;
    return *this;
};
/// <summary>
/// This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
/// </summary>
PolicyGetDigestResponse::PolicyGetDigestResponse(const PolicyGetDigestResponse& r)
{
    this->policyDigestSize = r.policyDigestSize;
    this->policyDigest = r.policyDigest;
};
/// <summary>
/// This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
/// </summary>
TpmStructureBase* PolicyGetDigestResponse::Clone() const
{
    PolicyGetDigestResponse* _x = new PolicyGetDigestResponse(*this);
    return _x;
};
void* PolicyGetDigestResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&policyDigestSize);
            case 1: { if(newArraySize != -1)policyDigest.resize(newArraySize); arraySize = (int)policyDigest.size(); return (void*)(&policyDigest); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&policyDigest[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_PolicyNvWritten_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyNvWritten_REQUEST_ID;
};
/// <summary>
/// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
/// </summary>
TPM2_PolicyNvWritten_REQUEST::TPM2_PolicyNvWritten_REQUEST()
{
    return;
};
TPM2_PolicyNvWritten_REQUEST::TPM2_PolicyNvWritten_REQUEST
(
    const TPM_HANDLE& _policySession,
    const BYTE& _writtenSet
)
{
    policySession= _policySession;
    writtenSet= _writtenSet;
};
/// <summary>
/// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
/// </summary>
TPM2_PolicyNvWritten_REQUEST::~TPM2_PolicyNvWritten_REQUEST()
{
    return;
};
/// <summary>
/// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
/// </summary>
TPM2_PolicyNvWritten_REQUEST& TPM2_PolicyNvWritten_REQUEST::operator=(const TPM2_PolicyNvWritten_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->policySession = rhs.policySession;
    this->writtenSet = rhs.writtenSet;
    return *this;
};
/// <summary>
/// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
/// </summary>
TPM2_PolicyNvWritten_REQUEST::TPM2_PolicyNvWritten_REQUEST(const TPM2_PolicyNvWritten_REQUEST& r)
{
    this->policySession = r.policySession;
    this->writtenSet = r.writtenSet;
};
/// <summary>
/// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
/// </summary>
TpmStructureBase* TPM2_PolicyNvWritten_REQUEST::Clone() const
{
    TPM2_PolicyNvWritten_REQUEST* _x = new TPM2_PolicyNvWritten_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyNvWritten_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            case 1: return (void*) (&writtenSet);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId PolicyNvWrittenResponse::GetTypeId() const
{
    return TpmTypeId::PolicyNvWrittenResponse_ID;
};
/// <summary>
/// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
/// </summary>
PolicyNvWrittenResponse::PolicyNvWrittenResponse()
{
    return;
};
/// <summary>
/// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
/// </summary>
PolicyNvWrittenResponse::~PolicyNvWrittenResponse()
{
    return;
};
/// <summary>
/// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
/// </summary>
PolicyNvWrittenResponse& PolicyNvWrittenResponse::operator=(const PolicyNvWrittenResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
/// </summary>
PolicyNvWrittenResponse::PolicyNvWrittenResponse(const PolicyNvWrittenResponse& r)
{
};
/// <summary>
/// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
/// </summary>
TpmStructureBase* PolicyNvWrittenResponse::Clone() const
{
    PolicyNvWrittenResponse* _x = new PolicyNvWrittenResponse(*this);
    return _x;
};
void* PolicyNvWrittenResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PolicyTemplate_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyTemplate_REQUEST_ID;
};
/// <summary>
/// This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
/// </summary>
TPM2_PolicyTemplate_REQUEST::TPM2_PolicyTemplate_REQUEST()
{
    return;
};
TPM2_PolicyTemplate_REQUEST::TPM2_PolicyTemplate_REQUEST
(
    const TPM_HANDLE& _policySession,
    const std::vector<BYTE>& _templateHash
)
{
    policySession= _policySession;
    templateHash= _templateHash;
};
/// <summary>
/// This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
/// </summary>
TPM2_PolicyTemplate_REQUEST::~TPM2_PolicyTemplate_REQUEST()
{
    return;
};
/// <summary>
/// This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
/// </summary>
TPM2_PolicyTemplate_REQUEST& TPM2_PolicyTemplate_REQUEST::operator=(const TPM2_PolicyTemplate_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->policySession = rhs.policySession;
    this->templateHashSize = rhs.templateHashSize;
    this->templateHash = rhs.templateHash;
    return *this;
};
/// <summary>
/// This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
/// </summary>
TPM2_PolicyTemplate_REQUEST::TPM2_PolicyTemplate_REQUEST(const TPM2_PolicyTemplate_REQUEST& r)
{
    this->policySession = r.policySession;
    this->templateHashSize = r.templateHashSize;
    this->templateHash = r.templateHash;
};
/// <summary>
/// This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
/// </summary>
TpmStructureBase* TPM2_PolicyTemplate_REQUEST::Clone() const
{
    TPM2_PolicyTemplate_REQUEST* _x = new TPM2_PolicyTemplate_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyTemplate_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            case 1: return (void*) (&templateHashSize);
            case 2: { if(newArraySize != -1)templateHash.resize(newArraySize); arraySize = (int)templateHash.size(); return (void*)(&templateHash); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&templateHash[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PolicyTemplateResponse::GetTypeId() const
{
    return TpmTypeId::PolicyTemplateResponse_ID;
};
/// <summary>
/// This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
/// </summary>
PolicyTemplateResponse::PolicyTemplateResponse()
{
    return;
};
/// <summary>
/// This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
/// </summary>
PolicyTemplateResponse::~PolicyTemplateResponse()
{
    return;
};
/// <summary>
/// This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
/// </summary>
PolicyTemplateResponse& PolicyTemplateResponse::operator=(const PolicyTemplateResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
/// </summary>
PolicyTemplateResponse::PolicyTemplateResponse(const PolicyTemplateResponse& r)
{
};
/// <summary>
/// This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
/// </summary>
TpmStructureBase* PolicyTemplateResponse::Clone() const
{
    PolicyTemplateResponse* _x = new PolicyTemplateResponse(*this);
    return _x;
};
void* PolicyTemplateResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PolicyAuthorizeNV_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyAuthorizeNV_REQUEST_ID;
};
/// <summary>
/// This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
/// </summary>
TPM2_PolicyAuthorizeNV_REQUEST::TPM2_PolicyAuthorizeNV_REQUEST()
{
    return;
};
TPM2_PolicyAuthorizeNV_REQUEST::TPM2_PolicyAuthorizeNV_REQUEST
(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    const TPM_HANDLE& _policySession
)
{
    authHandle= _authHandle;
    nvIndex= _nvIndex;
    policySession= _policySession;
};
/// <summary>
/// This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
/// </summary>
TPM2_PolicyAuthorizeNV_REQUEST::~TPM2_PolicyAuthorizeNV_REQUEST()
{
    return;
};
/// <summary>
/// This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
/// </summary>
TPM2_PolicyAuthorizeNV_REQUEST& TPM2_PolicyAuthorizeNV_REQUEST::operator=(const TPM2_PolicyAuthorizeNV_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    this->nvIndex = rhs.nvIndex;
    this->policySession = rhs.policySession;
    return *this;
};
/// <summary>
/// This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
/// </summary>
TPM2_PolicyAuthorizeNV_REQUEST::TPM2_PolicyAuthorizeNV_REQUEST(const TPM2_PolicyAuthorizeNV_REQUEST& r)
{
    this->authHandle = r.authHandle;
    this->nvIndex = r.nvIndex;
    this->policySession = r.policySession;
};
/// <summary>
/// This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
/// </summary>
TpmStructureBase* TPM2_PolicyAuthorizeNV_REQUEST::Clone() const
{
    TPM2_PolicyAuthorizeNV_REQUEST* _x = new TPM2_PolicyAuthorizeNV_REQUEST(*this);
    return _x;
};
void* TPM2_PolicyAuthorizeNV_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return (void*) (&nvIndex);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId PolicyAuthorizeNVResponse::GetTypeId() const
{
    return TpmTypeId::PolicyAuthorizeNVResponse_ID;
};
/// <summary>
/// This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
/// </summary>
PolicyAuthorizeNVResponse::PolicyAuthorizeNVResponse()
{
    return;
};
/// <summary>
/// This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
/// </summary>
PolicyAuthorizeNVResponse::~PolicyAuthorizeNVResponse()
{
    return;
};
/// <summary>
/// This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
/// </summary>
PolicyAuthorizeNVResponse& PolicyAuthorizeNVResponse::operator=(const PolicyAuthorizeNVResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
/// </summary>
PolicyAuthorizeNVResponse::PolicyAuthorizeNVResponse(const PolicyAuthorizeNVResponse& r)
{
};
/// <summary>
/// This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
/// </summary>
TpmStructureBase* PolicyAuthorizeNVResponse::Clone() const
{
    PolicyAuthorizeNVResponse* _x = new PolicyAuthorizeNVResponse(*this);
    return _x;
};
void* PolicyAuthorizeNVResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_CreatePrimary_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
};
/// <summary>
/// This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
/// </summary>
TPM2_CreatePrimary_REQUEST::TPM2_CreatePrimary_REQUEST()
{
    return;
};
TPM2_CreatePrimary_REQUEST::TPM2_CreatePrimary_REQUEST
(
    const TPM_HANDLE& _primaryHandle,
    const TPMS_SENSITIVE_CREATE& _inSensitive,
    const TPMT_PUBLIC& _inPublic,
    const std::vector<BYTE>& _outsideInfo,
    const std::vector<TPMS_PCR_SELECTION>& _creationPCR
)
{
    primaryHandle= _primaryHandle;
    inSensitive= _inSensitive;
    inPublic= _inPublic;
    outsideInfo= _outsideInfo;
    creationPCR= _creationPCR;
};
/// <summary>
/// This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
/// </summary>
TPM2_CreatePrimary_REQUEST::~TPM2_CreatePrimary_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
/// </summary>
TPM2_CreatePrimary_REQUEST& TPM2_CreatePrimary_REQUEST::operator=(const TPM2_CreatePrimary_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->primaryHandle = rhs.primaryHandle;
    this->inSensitiveSize = rhs.inSensitiveSize;
    this->inSensitive = rhs.inSensitive;
    this->inPublicSize = rhs.inPublicSize;
    this->inPublic = rhs.inPublic;
    this->outsideInfoSize = rhs.outsideInfoSize;
    this->outsideInfo = rhs.outsideInfo;
    this->creationPCRCount = rhs.creationPCRCount;
    this->creationPCR = rhs.creationPCR;
    return *this;
};
/// <summary>
/// This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
/// </summary>
TPM2_CreatePrimary_REQUEST::TPM2_CreatePrimary_REQUEST(const TPM2_CreatePrimary_REQUEST& r)
{
    this->primaryHandle = r.primaryHandle;
    this->inSensitiveSize = r.inSensitiveSize;
    this->inSensitive = r.inSensitive;
    this->inPublicSize = r.inPublicSize;
    this->inPublic = r.inPublic;
    this->outsideInfoSize = r.outsideInfoSize;
    this->outsideInfo = r.outsideInfo;
    this->creationPCRCount = r.creationPCRCount;
    this->creationPCR = r.creationPCR;
};
/// <summary>
/// This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
/// </summary>
TpmStructureBase* TPM2_CreatePrimary_REQUEST::Clone() const
{
    TPM2_CreatePrimary_REQUEST* _x = new TPM2_CreatePrimary_REQUEST(*this);
    return _x;
};
void* TPM2_CreatePrimary_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&primaryHandle); return (void*) (&primaryHandle);
            case 1: return (void*) (&inSensitiveSize);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&inSensitive); return (void*) (&inSensitive);
            case 3: return (void*) (&inPublicSize);
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&inPublic); return (void*) (&inPublic);
            case 5: return (void*) (&outsideInfoSize);
            case 6: { if(newArraySize != -1)outsideInfo.resize(newArraySize); arraySize = (int)outsideInfo.size(); return (void*)(&outsideInfo); }
            case 7: return (void*) (&creationPCRCount);
            case 8: { if(newArraySize != -1)creationPCR.resize(newArraySize); arraySize = (int)creationPCR.size(); return (void*)(&creationPCR); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 6: return (void*)(&outsideInfo[arrayIndex]);
            case 8: pStruct = dynamic_cast<TpmStructureBase*>(&creationPCR[arrayIndex]);return (void*)(&creationPCR[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId CreatePrimaryResponse::GetTypeId() const
{
    return TpmTypeId::CreatePrimaryResponse_ID;
};
/// <summary>
/// This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
/// </summary>
CreatePrimaryResponse::CreatePrimaryResponse()
{
    return;
};
CreatePrimaryResponse::CreatePrimaryResponse
(
    const TPM_HANDLE& _handle,
    const TPMT_PUBLIC& _outPublic,
    const TPMS_CREATION_DATA& _creationData,
    const std::vector<BYTE>& _creationHash,
    const TPMT_TK_CREATION& _creationTicket,
    const std::vector<BYTE>& _name
)
{
    handle= _handle;
    outPublic= _outPublic;
    creationData= _creationData;
    creationHash= _creationHash;
    creationTicket= _creationTicket;
    name= _name;
};
/// <summary>
/// This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
/// </summary>
CreatePrimaryResponse::~CreatePrimaryResponse()
{
    return;
};
/// <summary>
/// This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
/// </summary>
CreatePrimaryResponse& CreatePrimaryResponse::operator=(const CreatePrimaryResponse& rhs)
{
    if(this == &rhs) return *this;
    this->handle = rhs.handle;
    this->outPublicSize = rhs.outPublicSize;
    this->outPublic = rhs.outPublic;
    this->creationDataSize = rhs.creationDataSize;
    this->creationData = rhs.creationData;
    this->creationHashSize = rhs.creationHashSize;
    this->creationHash = rhs.creationHash;
    this->creationTicket = rhs.creationTicket;
    this->nameSize = rhs.nameSize;
    this->name = rhs.name;
    return *this;
};
/// <summary>
/// This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
/// </summary>
CreatePrimaryResponse::CreatePrimaryResponse(const CreatePrimaryResponse& r)
{
    this->handle = r.handle;
    this->outPublicSize = r.outPublicSize;
    this->outPublic = r.outPublic;
    this->creationDataSize = r.creationDataSize;
    this->creationData = r.creationData;
    this->creationHashSize = r.creationHashSize;
    this->creationHash = r.creationHash;
    this->creationTicket = r.creationTicket;
    this->nameSize = r.nameSize;
    this->name = r.name;
};
/// <summary>
/// This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
/// </summary>
TpmStructureBase* CreatePrimaryResponse::Clone() const
{
    CreatePrimaryResponse* _x = new CreatePrimaryResponse(*this);
    return _x;
};
void* CreatePrimaryResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return (void*) (&handle);
            case 1: return (void*) (&outPublicSize);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&outPublic); return (void*) (&outPublic);
            case 3: return (void*) (&creationDataSize);
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&creationData); return (void*) (&creationData);
            case 5: return (void*) (&creationHashSize);
            case 6: { if(newArraySize != -1)creationHash.resize(newArraySize); arraySize = (int)creationHash.size(); return (void*)(&creationHash); }
            case 7: pStruct = dynamic_cast<TpmStructureBase*>(&creationTicket); return (void*) (&creationTicket);
            case 8: return (void*) (&nameSize);
            case 9: { if(newArraySize != -1)name.resize(newArraySize); arraySize = (int)name.size(); return (void*)(&name); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 6: return (void*)(&creationHash[arrayIndex]);
            case 9: return (void*)(&name[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_HierarchyControl_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_HierarchyControl_REQUEST_ID;
};
/// <summary>
/// This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
/// </summary>
TPM2_HierarchyControl_REQUEST::TPM2_HierarchyControl_REQUEST()
{
    return;
};
TPM2_HierarchyControl_REQUEST::TPM2_HierarchyControl_REQUEST
(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _enable,
    const BYTE& _state
)
{
    authHandle= _authHandle;
    enable= _enable;
    state= _state;
};
/// <summary>
/// This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
/// </summary>
TPM2_HierarchyControl_REQUEST::~TPM2_HierarchyControl_REQUEST()
{
    return;
};
/// <summary>
/// This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
/// </summary>
TPM2_HierarchyControl_REQUEST& TPM2_HierarchyControl_REQUEST::operator=(const TPM2_HierarchyControl_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    this->enable = rhs.enable;
    this->state = rhs.state;
    return *this;
};
/// <summary>
/// This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
/// </summary>
TPM2_HierarchyControl_REQUEST::TPM2_HierarchyControl_REQUEST(const TPM2_HierarchyControl_REQUEST& r)
{
    this->authHandle = r.authHandle;
    this->enable = r.enable;
    this->state = r.state;
};
/// <summary>
/// This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
/// </summary>
TpmStructureBase* TPM2_HierarchyControl_REQUEST::Clone() const
{
    TPM2_HierarchyControl_REQUEST* _x = new TPM2_HierarchyControl_REQUEST(*this);
    return _x;
};
void* TPM2_HierarchyControl_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&enable); return (void*) (&enable);
            case 2: return (void*) (&state);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId HierarchyControlResponse::GetTypeId() const
{
    return TpmTypeId::HierarchyControlResponse_ID;
};
/// <summary>
/// This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
/// </summary>
HierarchyControlResponse::HierarchyControlResponse()
{
    return;
};
/// <summary>
/// This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
/// </summary>
HierarchyControlResponse::~HierarchyControlResponse()
{
    return;
};
/// <summary>
/// This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
/// </summary>
HierarchyControlResponse& HierarchyControlResponse::operator=(const HierarchyControlResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
/// </summary>
HierarchyControlResponse::HierarchyControlResponse(const HierarchyControlResponse& r)
{
};
/// <summary>
/// This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
/// </summary>
TpmStructureBase* HierarchyControlResponse::Clone() const
{
    HierarchyControlResponse* _x = new HierarchyControlResponse(*this);
    return _x;
};
void* HierarchyControlResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_SetPrimaryPolicy_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID;
};
/// <summary>
/// This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
/// </summary>
TPM2_SetPrimaryPolicy_REQUEST::TPM2_SetPrimaryPolicy_REQUEST()
{
    return;
};
TPM2_SetPrimaryPolicy_REQUEST::TPM2_SetPrimaryPolicy_REQUEST
(
    const TPM_HANDLE& _authHandle,
    const std::vector<BYTE>& _authPolicy,
    const TPM_ALG_ID& _hashAlg
)
{
    authHandle= _authHandle;
    authPolicy= _authPolicy;
    hashAlg= _hashAlg;
};
/// <summary>
/// This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
/// </summary>
TPM2_SetPrimaryPolicy_REQUEST::~TPM2_SetPrimaryPolicy_REQUEST()
{
    return;
};
/// <summary>
/// This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
/// </summary>
TPM2_SetPrimaryPolicy_REQUEST& TPM2_SetPrimaryPolicy_REQUEST::operator=(const TPM2_SetPrimaryPolicy_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    this->authPolicySize = rhs.authPolicySize;
    this->authPolicy = rhs.authPolicy;
    this->hashAlg = rhs.hashAlg;
    return *this;
};
/// <summary>
/// This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
/// </summary>
TPM2_SetPrimaryPolicy_REQUEST::TPM2_SetPrimaryPolicy_REQUEST(const TPM2_SetPrimaryPolicy_REQUEST& r)
{
    this->authHandle = r.authHandle;
    this->authPolicySize = r.authPolicySize;
    this->authPolicy = r.authPolicy;
    this->hashAlg = r.hashAlg;
};
/// <summary>
/// This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
/// </summary>
TpmStructureBase* TPM2_SetPrimaryPolicy_REQUEST::Clone() const
{
    TPM2_SetPrimaryPolicy_REQUEST* _x = new TPM2_SetPrimaryPolicy_REQUEST(*this);
    return _x;
};
void* TPM2_SetPrimaryPolicy_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 1: return (void*) (&authPolicySize);
            case 2: { if(newArraySize != -1)authPolicy.resize(newArraySize); arraySize = (int)authPolicy.size(); return (void*)(&authPolicy); }
            case 3: return (void*) (&hashAlg);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&authPolicy[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId SetPrimaryPolicyResponse::GetTypeId() const
{
    return TpmTypeId::SetPrimaryPolicyResponse_ID;
};
/// <summary>
/// This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
/// </summary>
SetPrimaryPolicyResponse::SetPrimaryPolicyResponse()
{
    return;
};
/// <summary>
/// This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
/// </summary>
SetPrimaryPolicyResponse::~SetPrimaryPolicyResponse()
{
    return;
};
/// <summary>
/// This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
/// </summary>
SetPrimaryPolicyResponse& SetPrimaryPolicyResponse::operator=(const SetPrimaryPolicyResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
/// </summary>
SetPrimaryPolicyResponse::SetPrimaryPolicyResponse(const SetPrimaryPolicyResponse& r)
{
};
/// <summary>
/// This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
/// </summary>
TpmStructureBase* SetPrimaryPolicyResponse::Clone() const
{
    SetPrimaryPolicyResponse* _x = new SetPrimaryPolicyResponse(*this);
    return _x;
};
void* SetPrimaryPolicyResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_ChangePPS_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ChangePPS_REQUEST_ID;
};
/// <summary>
/// This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
/// </summary>
TPM2_ChangePPS_REQUEST::TPM2_ChangePPS_REQUEST()
{
    return;
};
TPM2_ChangePPS_REQUEST::TPM2_ChangePPS_REQUEST
(
    const TPM_HANDLE& _authHandle
)
{
    authHandle= _authHandle;
};
/// <summary>
/// This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
/// </summary>
TPM2_ChangePPS_REQUEST::~TPM2_ChangePPS_REQUEST()
{
    return;
};
/// <summary>
/// This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
/// </summary>
TPM2_ChangePPS_REQUEST& TPM2_ChangePPS_REQUEST::operator=(const TPM2_ChangePPS_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    return *this;
};
/// <summary>
/// This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
/// </summary>
TPM2_ChangePPS_REQUEST::TPM2_ChangePPS_REQUEST(const TPM2_ChangePPS_REQUEST& r)
{
    this->authHandle = r.authHandle;
};
/// <summary>
/// This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
/// </summary>
TpmStructureBase* TPM2_ChangePPS_REQUEST::Clone() const
{
    TPM2_ChangePPS_REQUEST* _x = new TPM2_ChangePPS_REQUEST(*this);
    return _x;
};
void* TPM2_ChangePPS_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId ChangePPSResponse::GetTypeId() const
{
    return TpmTypeId::ChangePPSResponse_ID;
};
/// <summary>
/// This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
/// </summary>
ChangePPSResponse::ChangePPSResponse()
{
    return;
};
/// <summary>
/// This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
/// </summary>
ChangePPSResponse::~ChangePPSResponse()
{
    return;
};
/// <summary>
/// This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
/// </summary>
ChangePPSResponse& ChangePPSResponse::operator=(const ChangePPSResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
/// </summary>
ChangePPSResponse::ChangePPSResponse(const ChangePPSResponse& r)
{
};
/// <summary>
/// This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
/// </summary>
TpmStructureBase* ChangePPSResponse::Clone() const
{
    ChangePPSResponse* _x = new ChangePPSResponse(*this);
    return _x;
};
void* ChangePPSResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_ChangeEPS_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ChangeEPS_REQUEST_ID;
};
/// <summary>
/// This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
/// </summary>
TPM2_ChangeEPS_REQUEST::TPM2_ChangeEPS_REQUEST()
{
    return;
};
TPM2_ChangeEPS_REQUEST::TPM2_ChangeEPS_REQUEST
(
    const TPM_HANDLE& _authHandle
)
{
    authHandle= _authHandle;
};
/// <summary>
/// This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
/// </summary>
TPM2_ChangeEPS_REQUEST::~TPM2_ChangeEPS_REQUEST()
{
    return;
};
/// <summary>
/// This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
/// </summary>
TPM2_ChangeEPS_REQUEST& TPM2_ChangeEPS_REQUEST::operator=(const TPM2_ChangeEPS_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    return *this;
};
/// <summary>
/// This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
/// </summary>
TPM2_ChangeEPS_REQUEST::TPM2_ChangeEPS_REQUEST(const TPM2_ChangeEPS_REQUEST& r)
{
    this->authHandle = r.authHandle;
};
/// <summary>
/// This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
/// </summary>
TpmStructureBase* TPM2_ChangeEPS_REQUEST::Clone() const
{
    TPM2_ChangeEPS_REQUEST* _x = new TPM2_ChangeEPS_REQUEST(*this);
    return _x;
};
void* TPM2_ChangeEPS_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId ChangeEPSResponse::GetTypeId() const
{
    return TpmTypeId::ChangeEPSResponse_ID;
};
/// <summary>
/// This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
/// </summary>
ChangeEPSResponse::ChangeEPSResponse()
{
    return;
};
/// <summary>
/// This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
/// </summary>
ChangeEPSResponse::~ChangeEPSResponse()
{
    return;
};
/// <summary>
/// This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
/// </summary>
ChangeEPSResponse& ChangeEPSResponse::operator=(const ChangeEPSResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
/// </summary>
ChangeEPSResponse::ChangeEPSResponse(const ChangeEPSResponse& r)
{
};
/// <summary>
/// This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
/// </summary>
TpmStructureBase* ChangeEPSResponse::Clone() const
{
    ChangeEPSResponse* _x = new ChangeEPSResponse(*this);
    return _x;
};
void* ChangeEPSResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_Clear_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Clear_REQUEST_ID;
};
/// <summary>
/// This command removes all TPM context associated with a specific Owner.
/// </summary>
TPM2_Clear_REQUEST::TPM2_Clear_REQUEST()
{
    return;
};
TPM2_Clear_REQUEST::TPM2_Clear_REQUEST
(
    const TPM_HANDLE& _authHandle
)
{
    authHandle= _authHandle;
};
/// <summary>
/// This command removes all TPM context associated with a specific Owner.
/// </summary>
TPM2_Clear_REQUEST::~TPM2_Clear_REQUEST()
{
    return;
};
/// <summary>
/// This command removes all TPM context associated with a specific Owner.
/// </summary>
TPM2_Clear_REQUEST& TPM2_Clear_REQUEST::operator=(const TPM2_Clear_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    return *this;
};
/// <summary>
/// This command removes all TPM context associated with a specific Owner.
/// </summary>
TPM2_Clear_REQUEST::TPM2_Clear_REQUEST(const TPM2_Clear_REQUEST& r)
{
    this->authHandle = r.authHandle;
};
/// <summary>
/// This command removes all TPM context associated with a specific Owner.
/// </summary>
TpmStructureBase* TPM2_Clear_REQUEST::Clone() const
{
    TPM2_Clear_REQUEST* _x = new TPM2_Clear_REQUEST(*this);
    return _x;
};
void* TPM2_Clear_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId ClearResponse::GetTypeId() const
{
    return TpmTypeId::ClearResponse_ID;
};
/// <summary>
/// This command removes all TPM context associated with a specific Owner.
/// </summary>
ClearResponse::ClearResponse()
{
    return;
};
/// <summary>
/// This command removes all TPM context associated with a specific Owner.
/// </summary>
ClearResponse::~ClearResponse()
{
    return;
};
/// <summary>
/// This command removes all TPM context associated with a specific Owner.
/// </summary>
ClearResponse& ClearResponse::operator=(const ClearResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command removes all TPM context associated with a specific Owner.
/// </summary>
ClearResponse::ClearResponse(const ClearResponse& r)
{
};
/// <summary>
/// This command removes all TPM context associated with a specific Owner.
/// </summary>
TpmStructureBase* ClearResponse::Clone() const
{
    ClearResponse* _x = new ClearResponse(*this);
    return _x;
};
void* ClearResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_ClearControl_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ClearControl_REQUEST_ID;
};
/// <summary>
/// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
/// </summary>
TPM2_ClearControl_REQUEST::TPM2_ClearControl_REQUEST()
{
    return;
};
TPM2_ClearControl_REQUEST::TPM2_ClearControl_REQUEST
(
    const TPM_HANDLE& _auth,
    const BYTE& _disable
)
{
    auth= _auth;
    disable= _disable;
};
/// <summary>
/// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
/// </summary>
TPM2_ClearControl_REQUEST::~TPM2_ClearControl_REQUEST()
{
    return;
};
/// <summary>
/// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
/// </summary>
TPM2_ClearControl_REQUEST& TPM2_ClearControl_REQUEST::operator=(const TPM2_ClearControl_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->auth = rhs.auth;
    this->disable = rhs.disable;
    return *this;
};
/// <summary>
/// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
/// </summary>
TPM2_ClearControl_REQUEST::TPM2_ClearControl_REQUEST(const TPM2_ClearControl_REQUEST& r)
{
    this->auth = r.auth;
    this->disable = r.disable;
};
/// <summary>
/// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
/// </summary>
TpmStructureBase* TPM2_ClearControl_REQUEST::Clone() const
{
    TPM2_ClearControl_REQUEST* _x = new TPM2_ClearControl_REQUEST(*this);
    return _x;
};
void* TPM2_ClearControl_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&auth); return (void*) (&auth);
            case 1: return (void*) (&disable);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId ClearControlResponse::GetTypeId() const
{
    return TpmTypeId::ClearControlResponse_ID;
};
/// <summary>
/// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
/// </summary>
ClearControlResponse::ClearControlResponse()
{
    return;
};
/// <summary>
/// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
/// </summary>
ClearControlResponse::~ClearControlResponse()
{
    return;
};
/// <summary>
/// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
/// </summary>
ClearControlResponse& ClearControlResponse::operator=(const ClearControlResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
/// </summary>
ClearControlResponse::ClearControlResponse(const ClearControlResponse& r)
{
};
/// <summary>
/// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
/// </summary>
TpmStructureBase* ClearControlResponse::Clone() const
{
    ClearControlResponse* _x = new ClearControlResponse(*this);
    return _x;
};
void* ClearControlResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_HierarchyChangeAuth_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_HierarchyChangeAuth_REQUEST_ID;
};
/// <summary>
/// This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
/// </summary>
TPM2_HierarchyChangeAuth_REQUEST::TPM2_HierarchyChangeAuth_REQUEST()
{
    return;
};
TPM2_HierarchyChangeAuth_REQUEST::TPM2_HierarchyChangeAuth_REQUEST
(
    const TPM_HANDLE& _authHandle,
    const std::vector<BYTE>& _newAuth
)
{
    authHandle= _authHandle;
    newAuth= _newAuth;
};
/// <summary>
/// This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
/// </summary>
TPM2_HierarchyChangeAuth_REQUEST::~TPM2_HierarchyChangeAuth_REQUEST()
{
    return;
};
/// <summary>
/// This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
/// </summary>
TPM2_HierarchyChangeAuth_REQUEST& TPM2_HierarchyChangeAuth_REQUEST::operator=(const TPM2_HierarchyChangeAuth_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    this->newAuthSize = rhs.newAuthSize;
    this->newAuth = rhs.newAuth;
    return *this;
};
/// <summary>
/// This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
/// </summary>
TPM2_HierarchyChangeAuth_REQUEST::TPM2_HierarchyChangeAuth_REQUEST(const TPM2_HierarchyChangeAuth_REQUEST& r)
{
    this->authHandle = r.authHandle;
    this->newAuthSize = r.newAuthSize;
    this->newAuth = r.newAuth;
};
/// <summary>
/// This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
/// </summary>
TpmStructureBase* TPM2_HierarchyChangeAuth_REQUEST::Clone() const
{
    TPM2_HierarchyChangeAuth_REQUEST* _x = new TPM2_HierarchyChangeAuth_REQUEST(*this);
    return _x;
};
void* TPM2_HierarchyChangeAuth_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 1: return (void*) (&newAuthSize);
            case 2: { if(newArraySize != -1)newAuth.resize(newArraySize); arraySize = (int)newAuth.size(); return (void*)(&newAuth); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&newAuth[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId HierarchyChangeAuthResponse::GetTypeId() const
{
    return TpmTypeId::HierarchyChangeAuthResponse_ID;
};
/// <summary>
/// This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
/// </summary>
HierarchyChangeAuthResponse::HierarchyChangeAuthResponse()
{
    return;
};
/// <summary>
/// This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
/// </summary>
HierarchyChangeAuthResponse::~HierarchyChangeAuthResponse()
{
    return;
};
/// <summary>
/// This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
/// </summary>
HierarchyChangeAuthResponse& HierarchyChangeAuthResponse::operator=(const HierarchyChangeAuthResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
/// </summary>
HierarchyChangeAuthResponse::HierarchyChangeAuthResponse(const HierarchyChangeAuthResponse& r)
{
};
/// <summary>
/// This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
/// </summary>
TpmStructureBase* HierarchyChangeAuthResponse::Clone() const
{
    HierarchyChangeAuthResponse* _x = new HierarchyChangeAuthResponse(*this);
    return _x;
};
void* HierarchyChangeAuthResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_DictionaryAttackLockReset_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_DictionaryAttackLockReset_REQUEST_ID;
};
/// <summary>
/// This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
/// </summary>
TPM2_DictionaryAttackLockReset_REQUEST::TPM2_DictionaryAttackLockReset_REQUEST()
{
    return;
};
TPM2_DictionaryAttackLockReset_REQUEST::TPM2_DictionaryAttackLockReset_REQUEST
(
    const TPM_HANDLE& _lockHandle
)
{
    lockHandle= _lockHandle;
};
/// <summary>
/// This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
/// </summary>
TPM2_DictionaryAttackLockReset_REQUEST::~TPM2_DictionaryAttackLockReset_REQUEST()
{
    return;
};
/// <summary>
/// This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
/// </summary>
TPM2_DictionaryAttackLockReset_REQUEST& TPM2_DictionaryAttackLockReset_REQUEST::operator=(const TPM2_DictionaryAttackLockReset_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->lockHandle = rhs.lockHandle;
    return *this;
};
/// <summary>
/// This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
/// </summary>
TPM2_DictionaryAttackLockReset_REQUEST::TPM2_DictionaryAttackLockReset_REQUEST(const TPM2_DictionaryAttackLockReset_REQUEST& r)
{
    this->lockHandle = r.lockHandle;
};
/// <summary>
/// This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
/// </summary>
TpmStructureBase* TPM2_DictionaryAttackLockReset_REQUEST::Clone() const
{
    TPM2_DictionaryAttackLockReset_REQUEST* _x = new TPM2_DictionaryAttackLockReset_REQUEST(*this);
    return _x;
};
void* TPM2_DictionaryAttackLockReset_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&lockHandle); return (void*) (&lockHandle);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId DictionaryAttackLockResetResponse::GetTypeId() const
{
    return TpmTypeId::DictionaryAttackLockResetResponse_ID;
};
/// <summary>
/// This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
/// </summary>
DictionaryAttackLockResetResponse::DictionaryAttackLockResetResponse()
{
    return;
};
/// <summary>
/// This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
/// </summary>
DictionaryAttackLockResetResponse::~DictionaryAttackLockResetResponse()
{
    return;
};
/// <summary>
/// This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
/// </summary>
DictionaryAttackLockResetResponse& DictionaryAttackLockResetResponse::operator=(const DictionaryAttackLockResetResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
/// </summary>
DictionaryAttackLockResetResponse::DictionaryAttackLockResetResponse(const DictionaryAttackLockResetResponse& r)
{
};
/// <summary>
/// This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
/// </summary>
TpmStructureBase* DictionaryAttackLockResetResponse::Clone() const
{
    DictionaryAttackLockResetResponse* _x = new DictionaryAttackLockResetResponse(*this);
    return _x;
};
void* DictionaryAttackLockResetResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_DictionaryAttackParameters_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID;
};
/// <summary>
/// This command changes the lockout parameters.
/// </summary>
TPM2_DictionaryAttackParameters_REQUEST::TPM2_DictionaryAttackParameters_REQUEST()
{
    return;
};
TPM2_DictionaryAttackParameters_REQUEST::TPM2_DictionaryAttackParameters_REQUEST
(
    const TPM_HANDLE& _lockHandle,
    const UINT32& _newMaxTries,
    const UINT32& _newRecoveryTime,
    const UINT32& _lockoutRecovery
)
{
    lockHandle= _lockHandle;
    newMaxTries= _newMaxTries;
    newRecoveryTime= _newRecoveryTime;
    lockoutRecovery= _lockoutRecovery;
};
/// <summary>
/// This command changes the lockout parameters.
/// </summary>
TPM2_DictionaryAttackParameters_REQUEST::~TPM2_DictionaryAttackParameters_REQUEST()
{
    return;
};
/// <summary>
/// This command changes the lockout parameters.
/// </summary>
TPM2_DictionaryAttackParameters_REQUEST& TPM2_DictionaryAttackParameters_REQUEST::operator=(const TPM2_DictionaryAttackParameters_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->lockHandle = rhs.lockHandle;
    this->newMaxTries = rhs.newMaxTries;
    this->newRecoveryTime = rhs.newRecoveryTime;
    this->lockoutRecovery = rhs.lockoutRecovery;
    return *this;
};
/// <summary>
/// This command changes the lockout parameters.
/// </summary>
TPM2_DictionaryAttackParameters_REQUEST::TPM2_DictionaryAttackParameters_REQUEST(const TPM2_DictionaryAttackParameters_REQUEST& r)
{
    this->lockHandle = r.lockHandle;
    this->newMaxTries = r.newMaxTries;
    this->newRecoveryTime = r.newRecoveryTime;
    this->lockoutRecovery = r.lockoutRecovery;
};
/// <summary>
/// This command changes the lockout parameters.
/// </summary>
TpmStructureBase* TPM2_DictionaryAttackParameters_REQUEST::Clone() const
{
    TPM2_DictionaryAttackParameters_REQUEST* _x = new TPM2_DictionaryAttackParameters_REQUEST(*this);
    return _x;
};
void* TPM2_DictionaryAttackParameters_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&lockHandle); return (void*) (&lockHandle);
            case 1: return (void*) (&newMaxTries);
            case 2: return (void*) (&newRecoveryTime);
            case 3: return (void*) (&lockoutRecovery);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId DictionaryAttackParametersResponse::GetTypeId() const
{
    return TpmTypeId::DictionaryAttackParametersResponse_ID;
};
/// <summary>
/// This command changes the lockout parameters.
/// </summary>
DictionaryAttackParametersResponse::DictionaryAttackParametersResponse()
{
    return;
};
/// <summary>
/// This command changes the lockout parameters.
/// </summary>
DictionaryAttackParametersResponse::~DictionaryAttackParametersResponse()
{
    return;
};
/// <summary>
/// This command changes the lockout parameters.
/// </summary>
DictionaryAttackParametersResponse& DictionaryAttackParametersResponse::operator=(const DictionaryAttackParametersResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command changes the lockout parameters.
/// </summary>
DictionaryAttackParametersResponse::DictionaryAttackParametersResponse(const DictionaryAttackParametersResponse& r)
{
};
/// <summary>
/// This command changes the lockout parameters.
/// </summary>
TpmStructureBase* DictionaryAttackParametersResponse::Clone() const
{
    DictionaryAttackParametersResponse* _x = new DictionaryAttackParametersResponse(*this);
    return _x;
};
void* DictionaryAttackParametersResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_PP_Commands_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PP_Commands_REQUEST_ID;
};
/// <summary>
/// This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
/// </summary>
TPM2_PP_Commands_REQUEST::TPM2_PP_Commands_REQUEST()
{
    return;
};
TPM2_PP_Commands_REQUEST::TPM2_PP_Commands_REQUEST
(
    const TPM_HANDLE& _auth,
    const std::vector<TPM_CC>& _setList,
    const std::vector<TPM_CC>& _clearList
)
{
    auth= _auth;
    setList= _setList;
    clearList= _clearList;
};
/// <summary>
/// This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
/// </summary>
TPM2_PP_Commands_REQUEST::~TPM2_PP_Commands_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
/// </summary>
TPM2_PP_Commands_REQUEST& TPM2_PP_Commands_REQUEST::operator=(const TPM2_PP_Commands_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->auth = rhs.auth;
    this->setListCount = rhs.setListCount;
    this->setList = rhs.setList;
    this->clearListCount = rhs.clearListCount;
    this->clearList = rhs.clearList;
    return *this;
};
/// <summary>
/// This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
/// </summary>
TPM2_PP_Commands_REQUEST::TPM2_PP_Commands_REQUEST(const TPM2_PP_Commands_REQUEST& r)
{
    this->auth = r.auth;
    this->setListCount = r.setListCount;
    this->setList = r.setList;
    this->clearListCount = r.clearListCount;
    this->clearList = r.clearList;
};
/// <summary>
/// This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
/// </summary>
TpmStructureBase* TPM2_PP_Commands_REQUEST::Clone() const
{
    TPM2_PP_Commands_REQUEST* _x = new TPM2_PP_Commands_REQUEST(*this);
    return _x;
};
void* TPM2_PP_Commands_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&auth); return (void*) (&auth);
            case 1: return (void*) (&setListCount);
            case 2: { if(newArraySize != -1)setList.resize(newArraySize); arraySize = (int)setList.size(); return (void*)(&setList); }
            case 3: return (void*) (&clearListCount);
            case 4: { if(newArraySize != -1)clearList.resize(newArraySize); arraySize = (int)clearList.size(); return (void*)(&clearList); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&setList[arrayIndex]);
            case 4: return (void*)(&clearList[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId PP_CommandsResponse::GetTypeId() const
{
    return TpmTypeId::PP_CommandsResponse_ID;
};
/// <summary>
/// This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
/// </summary>
PP_CommandsResponse::PP_CommandsResponse()
{
    return;
};
/// <summary>
/// This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
/// </summary>
PP_CommandsResponse::~PP_CommandsResponse()
{
    return;
};
/// <summary>
/// This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
/// </summary>
PP_CommandsResponse& PP_CommandsResponse::operator=(const PP_CommandsResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
/// </summary>
PP_CommandsResponse::PP_CommandsResponse(const PP_CommandsResponse& r)
{
};
/// <summary>
/// This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
/// </summary>
TpmStructureBase* PP_CommandsResponse::Clone() const
{
    PP_CommandsResponse* _x = new PP_CommandsResponse(*this);
    return _x;
};
void* PP_CommandsResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_SetAlgorithmSet_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_SetAlgorithmSet_REQUEST_ID;
};
/// <summary>
/// This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
/// </summary>
TPM2_SetAlgorithmSet_REQUEST::TPM2_SetAlgorithmSet_REQUEST()
{
    return;
};
TPM2_SetAlgorithmSet_REQUEST::TPM2_SetAlgorithmSet_REQUEST
(
    const TPM_HANDLE& _authHandle,
    const UINT32& _algorithmSet
)
{
    authHandle= _authHandle;
    algorithmSet= _algorithmSet;
};
/// <summary>
/// This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
/// </summary>
TPM2_SetAlgorithmSet_REQUEST::~TPM2_SetAlgorithmSet_REQUEST()
{
    return;
};
/// <summary>
/// This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
/// </summary>
TPM2_SetAlgorithmSet_REQUEST& TPM2_SetAlgorithmSet_REQUEST::operator=(const TPM2_SetAlgorithmSet_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    this->algorithmSet = rhs.algorithmSet;
    return *this;
};
/// <summary>
/// This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
/// </summary>
TPM2_SetAlgorithmSet_REQUEST::TPM2_SetAlgorithmSet_REQUEST(const TPM2_SetAlgorithmSet_REQUEST& r)
{
    this->authHandle = r.authHandle;
    this->algorithmSet = r.algorithmSet;
};
/// <summary>
/// This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
/// </summary>
TpmStructureBase* TPM2_SetAlgorithmSet_REQUEST::Clone() const
{
    TPM2_SetAlgorithmSet_REQUEST* _x = new TPM2_SetAlgorithmSet_REQUEST(*this);
    return _x;
};
void* TPM2_SetAlgorithmSet_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 1: return (void*) (&algorithmSet);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId SetAlgorithmSetResponse::GetTypeId() const
{
    return TpmTypeId::SetAlgorithmSetResponse_ID;
};
/// <summary>
/// This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
/// </summary>
SetAlgorithmSetResponse::SetAlgorithmSetResponse()
{
    return;
};
/// <summary>
/// This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
/// </summary>
SetAlgorithmSetResponse::~SetAlgorithmSetResponse()
{
    return;
};
/// <summary>
/// This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
/// </summary>
SetAlgorithmSetResponse& SetAlgorithmSetResponse::operator=(const SetAlgorithmSetResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
/// </summary>
SetAlgorithmSetResponse::SetAlgorithmSetResponse(const SetAlgorithmSetResponse& r)
{
};
/// <summary>
/// This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
/// </summary>
TpmStructureBase* SetAlgorithmSetResponse::Clone() const
{
    SetAlgorithmSetResponse* _x = new SetAlgorithmSetResponse(*this);
    return _x;
};
void* SetAlgorithmSetResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_FieldUpgradeStart_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
};
/// <summary>
/// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
/// </summary>
TPM2_FieldUpgradeStart_REQUEST::TPM2_FieldUpgradeStart_REQUEST()
{
    manifestSignature = NULL;
    return;
};
TPM2_FieldUpgradeStart_REQUEST::TPM2_FieldUpgradeStart_REQUEST
(
    const TPM_HANDLE& _authorization,
    const TPM_HANDLE& _keyHandle,
    const std::vector<BYTE>& _fuDigest,
    const TPMU_SIGNATURE& _manifestSignature
)
{
    authorization= _authorization;
    keyHandle= _keyHandle;
    fuDigest= _fuDigest;
    manifestSignature = dynamic_cast<TPMU_SIGNATURE*> (_manifestSignature.Clone());
};
/// <summary>
/// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
/// </summary>
TPM2_FieldUpgradeStart_REQUEST::~TPM2_FieldUpgradeStart_REQUEST()
{
    if(manifestSignature != NULL) { delete manifestSignature;manifestSignature=NULL; }
    return;
};
/// <summary>
/// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
/// </summary>
TPM2_FieldUpgradeStart_REQUEST& TPM2_FieldUpgradeStart_REQUEST::operator=(const TPM2_FieldUpgradeStart_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authorization = rhs.authorization;
    this->keyHandle = rhs.keyHandle;
    this->fuDigestSize = rhs.fuDigestSize;
    this->fuDigest = rhs.fuDigest;
    this->manifestSignatureSigAlg = rhs.manifestSignatureSigAlg;
    if(manifestSignature != NULL) delete manifestSignature;
    if(rhs.manifestSignature != NULL)manifestSignature = dynamic_cast<TPMU_SIGNATURE*>(rhs.manifestSignature->Clone());
    return *this;
};
/// <summary>
/// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
/// </summary>
TPM2_FieldUpgradeStart_REQUEST::TPM2_FieldUpgradeStart_REQUEST(const TPM2_FieldUpgradeStart_REQUEST& r)
{
    this->authorization = r.authorization;
    this->keyHandle = r.keyHandle;
    this->fuDigestSize = r.fuDigestSize;
    this->fuDigest = r.fuDigest;
    this->manifestSignatureSigAlg = r.manifestSignatureSigAlg;
    if(r.manifestSignature != NULL)manifestSignature = dynamic_cast<TPMU_SIGNATURE*>(r.manifestSignature->Clone());
};
/// <summary>
/// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
/// </summary>
TpmStructureBase* TPM2_FieldUpgradeStart_REQUEST::Clone() const
{
    TPM2_FieldUpgradeStart_REQUEST* _x = new TPM2_FieldUpgradeStart_REQUEST(*this);
    return _x;
};
void* TPM2_FieldUpgradeStart_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authorization); return (void*) (&authorization);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return (void*) (&keyHandle);
            case 2: return (void*) (&fuDigestSize);
            case 3: { if(newArraySize != -1)fuDigest.resize(newArraySize); arraySize = (int)fuDigest.size(); return (void*)(&fuDigest); }
            case 4: return (void*) (&manifestSignatureSigAlg);
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(manifestSignature); return (void*) (&manifestSignature);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&fuDigest[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId FieldUpgradeStartResponse::GetTypeId() const
{
    return TpmTypeId::FieldUpgradeStartResponse_ID;
};
/// <summary>
/// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
/// </summary>
FieldUpgradeStartResponse::FieldUpgradeStartResponse()
{
    return;
};
/// <summary>
/// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
/// </summary>
FieldUpgradeStartResponse::~FieldUpgradeStartResponse()
{
    return;
};
/// <summary>
/// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
/// </summary>
FieldUpgradeStartResponse& FieldUpgradeStartResponse::operator=(const FieldUpgradeStartResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
/// </summary>
FieldUpgradeStartResponse::FieldUpgradeStartResponse(const FieldUpgradeStartResponse& r)
{
};
/// <summary>
/// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
/// </summary>
TpmStructureBase* FieldUpgradeStartResponse::Clone() const
{
    FieldUpgradeStartResponse* _x = new FieldUpgradeStartResponse(*this);
    return _x;
};
void* FieldUpgradeStartResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_FieldUpgradeData_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_FieldUpgradeData_REQUEST_ID;
};
/// <summary>
/// This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
/// </summary>
TPM2_FieldUpgradeData_REQUEST::TPM2_FieldUpgradeData_REQUEST()
{
    return;
};
TPM2_FieldUpgradeData_REQUEST::TPM2_FieldUpgradeData_REQUEST
(
    const std::vector<BYTE>& _fuData
)
{
    fuData= _fuData;
};
/// <summary>
/// This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
/// </summary>
TPM2_FieldUpgradeData_REQUEST::~TPM2_FieldUpgradeData_REQUEST()
{
    return;
};
/// <summary>
/// This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
/// </summary>
TPM2_FieldUpgradeData_REQUEST& TPM2_FieldUpgradeData_REQUEST::operator=(const TPM2_FieldUpgradeData_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->fuDataSize = rhs.fuDataSize;
    this->fuData = rhs.fuData;
    return *this;
};
/// <summary>
/// This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
/// </summary>
TPM2_FieldUpgradeData_REQUEST::TPM2_FieldUpgradeData_REQUEST(const TPM2_FieldUpgradeData_REQUEST& r)
{
    this->fuDataSize = r.fuDataSize;
    this->fuData = r.fuData;
};
/// <summary>
/// This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
/// </summary>
TpmStructureBase* TPM2_FieldUpgradeData_REQUEST::Clone() const
{
    TPM2_FieldUpgradeData_REQUEST* _x = new TPM2_FieldUpgradeData_REQUEST(*this);
    return _x;
};
void* TPM2_FieldUpgradeData_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&fuDataSize);
            case 1: { if(newArraySize != -1)fuData.resize(newArraySize); arraySize = (int)fuData.size(); return (void*)(&fuData); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&fuData[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId FieldUpgradeDataResponse::GetTypeId() const
{
    return TpmTypeId::FieldUpgradeDataResponse_ID;
};
/// <summary>
/// This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
/// </summary>
FieldUpgradeDataResponse::FieldUpgradeDataResponse()
{
    return;
};
FieldUpgradeDataResponse::FieldUpgradeDataResponse
(
    const TPMT_HA& _nextDigest,
    const TPMT_HA& _firstDigest
)
{
    nextDigest= _nextDigest;
    firstDigest= _firstDigest;
};
/// <summary>
/// This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
/// </summary>
FieldUpgradeDataResponse::~FieldUpgradeDataResponse()
{
    return;
};
/// <summary>
/// This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
/// </summary>
FieldUpgradeDataResponse& FieldUpgradeDataResponse::operator=(const FieldUpgradeDataResponse& rhs)
{
    if(this == &rhs) return *this;
    this->nextDigest = rhs.nextDigest;
    this->firstDigest = rhs.firstDigest;
    return *this;
};
/// <summary>
/// This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
/// </summary>
FieldUpgradeDataResponse::FieldUpgradeDataResponse(const FieldUpgradeDataResponse& r)
{
    this->nextDigest = r.nextDigest;
    this->firstDigest = r.firstDigest;
};
/// <summary>
/// This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
/// </summary>
TpmStructureBase* FieldUpgradeDataResponse::Clone() const
{
    FieldUpgradeDataResponse* _x = new FieldUpgradeDataResponse(*this);
    return _x;
};
void* FieldUpgradeDataResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&nextDigest); return (void*) (&nextDigest);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&firstDigest); return (void*) (&firstDigest);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_FirmwareRead_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_FirmwareRead_REQUEST_ID;
};
/// <summary>
/// This command is used to read a copy of the current firmware installed in the TPM.
/// </summary>
TPM2_FirmwareRead_REQUEST::TPM2_FirmwareRead_REQUEST()
{
    return;
};
TPM2_FirmwareRead_REQUEST::TPM2_FirmwareRead_REQUEST
(
    const UINT32& _sequenceNumber
)
{
    sequenceNumber= _sequenceNumber;
};
/// <summary>
/// This command is used to read a copy of the current firmware installed in the TPM.
/// </summary>
TPM2_FirmwareRead_REQUEST::~TPM2_FirmwareRead_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to read a copy of the current firmware installed in the TPM.
/// </summary>
TPM2_FirmwareRead_REQUEST& TPM2_FirmwareRead_REQUEST::operator=(const TPM2_FirmwareRead_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->sequenceNumber = rhs.sequenceNumber;
    return *this;
};
/// <summary>
/// This command is used to read a copy of the current firmware installed in the TPM.
/// </summary>
TPM2_FirmwareRead_REQUEST::TPM2_FirmwareRead_REQUEST(const TPM2_FirmwareRead_REQUEST& r)
{
    this->sequenceNumber = r.sequenceNumber;
};
/// <summary>
/// This command is used to read a copy of the current firmware installed in the TPM.
/// </summary>
TpmStructureBase* TPM2_FirmwareRead_REQUEST::Clone() const
{
    TPM2_FirmwareRead_REQUEST* _x = new TPM2_FirmwareRead_REQUEST(*this);
    return _x;
};
void* TPM2_FirmwareRead_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&sequenceNumber);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId FirmwareReadResponse::GetTypeId() const
{
    return TpmTypeId::FirmwareReadResponse_ID;
};
/// <summary>
/// This command is used to read a copy of the current firmware installed in the TPM.
/// </summary>
FirmwareReadResponse::FirmwareReadResponse()
{
    return;
};
FirmwareReadResponse::FirmwareReadResponse
(
    const std::vector<BYTE>& _fuData
)
{
    fuData= _fuData;
};
/// <summary>
/// This command is used to read a copy of the current firmware installed in the TPM.
/// </summary>
FirmwareReadResponse::~FirmwareReadResponse()
{
    return;
};
/// <summary>
/// This command is used to read a copy of the current firmware installed in the TPM.
/// </summary>
FirmwareReadResponse& FirmwareReadResponse::operator=(const FirmwareReadResponse& rhs)
{
    if(this == &rhs) return *this;
    this->fuDataSize = rhs.fuDataSize;
    this->fuData = rhs.fuData;
    return *this;
};
/// <summary>
/// This command is used to read a copy of the current firmware installed in the TPM.
/// </summary>
FirmwareReadResponse::FirmwareReadResponse(const FirmwareReadResponse& r)
{
    this->fuDataSize = r.fuDataSize;
    this->fuData = r.fuData;
};
/// <summary>
/// This command is used to read a copy of the current firmware installed in the TPM.
/// </summary>
TpmStructureBase* FirmwareReadResponse::Clone() const
{
    FirmwareReadResponse* _x = new FirmwareReadResponse(*this);
    return _x;
};
void* FirmwareReadResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&fuDataSize);
            case 1: { if(newArraySize != -1)fuData.resize(newArraySize); arraySize = (int)fuData.size(); return (void*)(&fuData); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&fuData[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_ContextSave_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ContextSave_REQUEST_ID;
};
/// <summary>
/// This command saves a session context, object context, or sequence object context outside the TPM.
/// </summary>
TPM2_ContextSave_REQUEST::TPM2_ContextSave_REQUEST()
{
    return;
};
TPM2_ContextSave_REQUEST::TPM2_ContextSave_REQUEST
(
    const TPM_HANDLE& _saveHandle
)
{
    saveHandle= _saveHandle;
};
/// <summary>
/// This command saves a session context, object context, or sequence object context outside the TPM.
/// </summary>
TPM2_ContextSave_REQUEST::~TPM2_ContextSave_REQUEST()
{
    return;
};
/// <summary>
/// This command saves a session context, object context, or sequence object context outside the TPM.
/// </summary>
TPM2_ContextSave_REQUEST& TPM2_ContextSave_REQUEST::operator=(const TPM2_ContextSave_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->saveHandle = rhs.saveHandle;
    return *this;
};
/// <summary>
/// This command saves a session context, object context, or sequence object context outside the TPM.
/// </summary>
TPM2_ContextSave_REQUEST::TPM2_ContextSave_REQUEST(const TPM2_ContextSave_REQUEST& r)
{
    this->saveHandle = r.saveHandle;
};
/// <summary>
/// This command saves a session context, object context, or sequence object context outside the TPM.
/// </summary>
TpmStructureBase* TPM2_ContextSave_REQUEST::Clone() const
{
    TPM2_ContextSave_REQUEST* _x = new TPM2_ContextSave_REQUEST(*this);
    return _x;
};
void* TPM2_ContextSave_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&saveHandle); return (void*) (&saveHandle);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId ContextSaveResponse::GetTypeId() const
{
    return TpmTypeId::ContextSaveResponse_ID;
};
/// <summary>
/// This command saves a session context, object context, or sequence object context outside the TPM.
/// </summary>
ContextSaveResponse::ContextSaveResponse()
{
    return;
};
ContextSaveResponse::ContextSaveResponse
(
    const TPMS_CONTEXT& _context
)
{
    context= _context;
};
/// <summary>
/// This command saves a session context, object context, or sequence object context outside the TPM.
/// </summary>
ContextSaveResponse::~ContextSaveResponse()
{
    return;
};
/// <summary>
/// This command saves a session context, object context, or sequence object context outside the TPM.
/// </summary>
ContextSaveResponse& ContextSaveResponse::operator=(const ContextSaveResponse& rhs)
{
    if(this == &rhs) return *this;
    this->context = rhs.context;
    return *this;
};
/// <summary>
/// This command saves a session context, object context, or sequence object context outside the TPM.
/// </summary>
ContextSaveResponse::ContextSaveResponse(const ContextSaveResponse& r)
{
    this->context = r.context;
};
/// <summary>
/// This command saves a session context, object context, or sequence object context outside the TPM.
/// </summary>
TpmStructureBase* ContextSaveResponse::Clone() const
{
    ContextSaveResponse* _x = new ContextSaveResponse(*this);
    return _x;
};
void* ContextSaveResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&context); return (void*) (&context);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_ContextLoad_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ContextLoad_REQUEST_ID;
};
/// <summary>
/// This command is used to reload a context that has been saved by TPM2_ContextSave().
/// </summary>
TPM2_ContextLoad_REQUEST::TPM2_ContextLoad_REQUEST()
{
    return;
};
TPM2_ContextLoad_REQUEST::TPM2_ContextLoad_REQUEST
(
    const TPMS_CONTEXT& _context
)
{
    context= _context;
};
/// <summary>
/// This command is used to reload a context that has been saved by TPM2_ContextSave().
/// </summary>
TPM2_ContextLoad_REQUEST::~TPM2_ContextLoad_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to reload a context that has been saved by TPM2_ContextSave().
/// </summary>
TPM2_ContextLoad_REQUEST& TPM2_ContextLoad_REQUEST::operator=(const TPM2_ContextLoad_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->context = rhs.context;
    return *this;
};
/// <summary>
/// This command is used to reload a context that has been saved by TPM2_ContextSave().
/// </summary>
TPM2_ContextLoad_REQUEST::TPM2_ContextLoad_REQUEST(const TPM2_ContextLoad_REQUEST& r)
{
    this->context = r.context;
};
/// <summary>
/// This command is used to reload a context that has been saved by TPM2_ContextSave().
/// </summary>
TpmStructureBase* TPM2_ContextLoad_REQUEST::Clone() const
{
    TPM2_ContextLoad_REQUEST* _x = new TPM2_ContextLoad_REQUEST(*this);
    return _x;
};
void* TPM2_ContextLoad_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&context); return (void*) (&context);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId ContextLoadResponse::GetTypeId() const
{
    return TpmTypeId::ContextLoadResponse_ID;
};
/// <summary>
/// This command is used to reload a context that has been saved by TPM2_ContextSave().
/// </summary>
ContextLoadResponse::ContextLoadResponse()
{
    return;
};
ContextLoadResponse::ContextLoadResponse
(
    const TPM_HANDLE& _handle
)
{
    handle= _handle;
};
/// <summary>
/// This command is used to reload a context that has been saved by TPM2_ContextSave().
/// </summary>
ContextLoadResponse::~ContextLoadResponse()
{
    return;
};
/// <summary>
/// This command is used to reload a context that has been saved by TPM2_ContextSave().
/// </summary>
ContextLoadResponse& ContextLoadResponse::operator=(const ContextLoadResponse& rhs)
{
    if(this == &rhs) return *this;
    this->handle = rhs.handle;
    return *this;
};
/// <summary>
/// This command is used to reload a context that has been saved by TPM2_ContextSave().
/// </summary>
ContextLoadResponse::ContextLoadResponse(const ContextLoadResponse& r)
{
    this->handle = r.handle;
};
/// <summary>
/// This command is used to reload a context that has been saved by TPM2_ContextSave().
/// </summary>
TpmStructureBase* ContextLoadResponse::Clone() const
{
    ContextLoadResponse* _x = new ContextLoadResponse(*this);
    return _x;
};
void* ContextLoadResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return (void*) (&handle);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_FlushContext_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_FlushContext_REQUEST_ID;
};
/// <summary>
/// This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
/// </summary>
TPM2_FlushContext_REQUEST::TPM2_FlushContext_REQUEST()
{
    return;
};
TPM2_FlushContext_REQUEST::TPM2_FlushContext_REQUEST
(
    const TPM_HANDLE& _flushHandle
)
{
    flushHandle= _flushHandle;
};
/// <summary>
/// This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
/// </summary>
TPM2_FlushContext_REQUEST::~TPM2_FlushContext_REQUEST()
{
    return;
};
/// <summary>
/// This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
/// </summary>
TPM2_FlushContext_REQUEST& TPM2_FlushContext_REQUEST::operator=(const TPM2_FlushContext_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->flushHandle = rhs.flushHandle;
    return *this;
};
/// <summary>
/// This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
/// </summary>
TPM2_FlushContext_REQUEST::TPM2_FlushContext_REQUEST(const TPM2_FlushContext_REQUEST& r)
{
    this->flushHandle = r.flushHandle;
};
/// <summary>
/// This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
/// </summary>
TpmStructureBase* TPM2_FlushContext_REQUEST::Clone() const
{
    TPM2_FlushContext_REQUEST* _x = new TPM2_FlushContext_REQUEST(*this);
    return _x;
};
void* TPM2_FlushContext_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&flushHandle); return (void*) (&flushHandle);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId FlushContextResponse::GetTypeId() const
{
    return TpmTypeId::FlushContextResponse_ID;
};
/// <summary>
/// This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
/// </summary>
FlushContextResponse::FlushContextResponse()
{
    return;
};
/// <summary>
/// This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
/// </summary>
FlushContextResponse::~FlushContextResponse()
{
    return;
};
/// <summary>
/// This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
/// </summary>
FlushContextResponse& FlushContextResponse::operator=(const FlushContextResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
/// </summary>
FlushContextResponse::FlushContextResponse(const FlushContextResponse& r)
{
};
/// <summary>
/// This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
/// </summary>
TpmStructureBase* FlushContextResponse::Clone() const
{
    FlushContextResponse* _x = new FlushContextResponse(*this);
    return _x;
};
void* FlushContextResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_EvictControl_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_EvictControl_REQUEST_ID;
};
/// <summary>
/// This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
/// </summary>
TPM2_EvictControl_REQUEST::TPM2_EvictControl_REQUEST()
{
    return;
};
TPM2_EvictControl_REQUEST::TPM2_EvictControl_REQUEST
(
    const TPM_HANDLE& _auth,
    const TPM_HANDLE& _objectHandle,
    const TPM_HANDLE& _persistentHandle
)
{
    auth= _auth;
    objectHandle= _objectHandle;
    persistentHandle= _persistentHandle;
};
/// <summary>
/// This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
/// </summary>
TPM2_EvictControl_REQUEST::~TPM2_EvictControl_REQUEST()
{
    return;
};
/// <summary>
/// This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
/// </summary>
TPM2_EvictControl_REQUEST& TPM2_EvictControl_REQUEST::operator=(const TPM2_EvictControl_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->auth = rhs.auth;
    this->objectHandle = rhs.objectHandle;
    this->persistentHandle = rhs.persistentHandle;
    return *this;
};
/// <summary>
/// This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
/// </summary>
TPM2_EvictControl_REQUEST::TPM2_EvictControl_REQUEST(const TPM2_EvictControl_REQUEST& r)
{
    this->auth = r.auth;
    this->objectHandle = r.objectHandle;
    this->persistentHandle = r.persistentHandle;
};
/// <summary>
/// This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
/// </summary>
TpmStructureBase* TPM2_EvictControl_REQUEST::Clone() const
{
    TPM2_EvictControl_REQUEST* _x = new TPM2_EvictControl_REQUEST(*this);
    return _x;
};
void* TPM2_EvictControl_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&auth); return (void*) (&auth);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return (void*) (&objectHandle);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&persistentHandle); return (void*) (&persistentHandle);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId EvictControlResponse::GetTypeId() const
{
    return TpmTypeId::EvictControlResponse_ID;
};
/// <summary>
/// This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
/// </summary>
EvictControlResponse::EvictControlResponse()
{
    return;
};
/// <summary>
/// This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
/// </summary>
EvictControlResponse::~EvictControlResponse()
{
    return;
};
/// <summary>
/// This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
/// </summary>
EvictControlResponse& EvictControlResponse::operator=(const EvictControlResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
/// </summary>
EvictControlResponse::EvictControlResponse(const EvictControlResponse& r)
{
};
/// <summary>
/// This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
/// </summary>
TpmStructureBase* EvictControlResponse::Clone() const
{
    EvictControlResponse* _x = new EvictControlResponse(*this);
    return _x;
};
void* EvictControlResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_ReadClock_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ReadClock_REQUEST_ID;
};
/// <summary>
/// This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
/// </summary>
TPM2_ReadClock_REQUEST::TPM2_ReadClock_REQUEST()
{
    return;
};
/// <summary>
/// This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
/// </summary>
TPM2_ReadClock_REQUEST::~TPM2_ReadClock_REQUEST()
{
    return;
};
/// <summary>
/// This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
/// </summary>
TPM2_ReadClock_REQUEST& TPM2_ReadClock_REQUEST::operator=(const TPM2_ReadClock_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
/// </summary>
TPM2_ReadClock_REQUEST::TPM2_ReadClock_REQUEST(const TPM2_ReadClock_REQUEST& r)
{
};
/// <summary>
/// This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
/// </summary>
TpmStructureBase* TPM2_ReadClock_REQUEST::Clone() const
{
    TPM2_ReadClock_REQUEST* _x = new TPM2_ReadClock_REQUEST(*this);
    return _x;
};
void* TPM2_ReadClock_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId ReadClockResponse::GetTypeId() const
{
    return TpmTypeId::ReadClockResponse_ID;
};
/// <summary>
/// This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
/// </summary>
ReadClockResponse::ReadClockResponse()
{
    return;
};
ReadClockResponse::ReadClockResponse
(
    const TPMS_TIME_INFO& _currentTime
)
{
    currentTime= _currentTime;
};
/// <summary>
/// This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
/// </summary>
ReadClockResponse::~ReadClockResponse()
{
    return;
};
/// <summary>
/// This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
/// </summary>
ReadClockResponse& ReadClockResponse::operator=(const ReadClockResponse& rhs)
{
    if(this == &rhs) return *this;
    this->currentTime = rhs.currentTime;
    return *this;
};
/// <summary>
/// This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
/// </summary>
ReadClockResponse::ReadClockResponse(const ReadClockResponse& r)
{
    this->currentTime = r.currentTime;
};
/// <summary>
/// This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
/// </summary>
TpmStructureBase* ReadClockResponse::Clone() const
{
    ReadClockResponse* _x = new ReadClockResponse(*this);
    return _x;
};
void* ReadClockResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&currentTime); return (void*) (&currentTime);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_ClockSet_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ClockSet_REQUEST_ID;
};
/// <summary>
/// This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
/// </summary>
TPM2_ClockSet_REQUEST::TPM2_ClockSet_REQUEST()
{
    return;
};
TPM2_ClockSet_REQUEST::TPM2_ClockSet_REQUEST
(
    const TPM_HANDLE& _auth,
    const UINT64& _newTime
)
{
    auth= _auth;
    newTime= _newTime;
};
/// <summary>
/// This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
/// </summary>
TPM2_ClockSet_REQUEST::~TPM2_ClockSet_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
/// </summary>
TPM2_ClockSet_REQUEST& TPM2_ClockSet_REQUEST::operator=(const TPM2_ClockSet_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->auth = rhs.auth;
    this->newTime = rhs.newTime;
    return *this;
};
/// <summary>
/// This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
/// </summary>
TPM2_ClockSet_REQUEST::TPM2_ClockSet_REQUEST(const TPM2_ClockSet_REQUEST& r)
{
    this->auth = r.auth;
    this->newTime = r.newTime;
};
/// <summary>
/// This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
/// </summary>
TpmStructureBase* TPM2_ClockSet_REQUEST::Clone() const
{
    TPM2_ClockSet_REQUEST* _x = new TPM2_ClockSet_REQUEST(*this);
    return _x;
};
void* TPM2_ClockSet_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&auth); return (void*) (&auth);
            case 1: return (void*) (&newTime);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId ClockSetResponse::GetTypeId() const
{
    return TpmTypeId::ClockSetResponse_ID;
};
/// <summary>
/// This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
/// </summary>
ClockSetResponse::ClockSetResponse()
{
    return;
};
/// <summary>
/// This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
/// </summary>
ClockSetResponse::~ClockSetResponse()
{
    return;
};
/// <summary>
/// This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
/// </summary>
ClockSetResponse& ClockSetResponse::operator=(const ClockSetResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
/// </summary>
ClockSetResponse::ClockSetResponse(const ClockSetResponse& r)
{
};
/// <summary>
/// This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
/// </summary>
TpmStructureBase* ClockSetResponse::Clone() const
{
    ClockSetResponse* _x = new ClockSetResponse(*this);
    return _x;
};
void* ClockSetResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_ClockRateAdjust_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ClockRateAdjust_REQUEST_ID;
};
/// <summary>
/// This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
/// </summary>
TPM2_ClockRateAdjust_REQUEST::TPM2_ClockRateAdjust_REQUEST()
{
    return;
};
TPM2_ClockRateAdjust_REQUEST::TPM2_ClockRateAdjust_REQUEST
(
    const TPM_HANDLE& _auth,
    const TPM_CLOCK_ADJUST& _rateAdjust
)
{
    auth= _auth;
    rateAdjust= _rateAdjust;
};
/// <summary>
/// This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
/// </summary>
TPM2_ClockRateAdjust_REQUEST::~TPM2_ClockRateAdjust_REQUEST()
{
    return;
};
/// <summary>
/// This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
/// </summary>
TPM2_ClockRateAdjust_REQUEST& TPM2_ClockRateAdjust_REQUEST::operator=(const TPM2_ClockRateAdjust_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->auth = rhs.auth;
    this->rateAdjust = rhs.rateAdjust;
    return *this;
};
/// <summary>
/// This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
/// </summary>
TPM2_ClockRateAdjust_REQUEST::TPM2_ClockRateAdjust_REQUEST(const TPM2_ClockRateAdjust_REQUEST& r)
{
    this->auth = r.auth;
    this->rateAdjust = r.rateAdjust;
};
/// <summary>
/// This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
/// </summary>
TpmStructureBase* TPM2_ClockRateAdjust_REQUEST::Clone() const
{
    TPM2_ClockRateAdjust_REQUEST* _x = new TPM2_ClockRateAdjust_REQUEST(*this);
    return _x;
};
void* TPM2_ClockRateAdjust_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&auth); return (void*) (&auth);
            case 1: return (void*) (&rateAdjust);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId ClockRateAdjustResponse::GetTypeId() const
{
    return TpmTypeId::ClockRateAdjustResponse_ID;
};
/// <summary>
/// This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
/// </summary>
ClockRateAdjustResponse::ClockRateAdjustResponse()
{
    return;
};
/// <summary>
/// This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
/// </summary>
ClockRateAdjustResponse::~ClockRateAdjustResponse()
{
    return;
};
/// <summary>
/// This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
/// </summary>
ClockRateAdjustResponse& ClockRateAdjustResponse::operator=(const ClockRateAdjustResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
/// </summary>
ClockRateAdjustResponse::ClockRateAdjustResponse(const ClockRateAdjustResponse& r)
{
};
/// <summary>
/// This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
/// </summary>
TpmStructureBase* ClockRateAdjustResponse::Clone() const
{
    ClockRateAdjustResponse* _x = new ClockRateAdjustResponse(*this);
    return _x;
};
void* ClockRateAdjustResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_GetCapability_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_GetCapability_REQUEST_ID;
};
/// <summary>
/// This command returns various information regarding the TPM and its current state.
/// </summary>
TPM2_GetCapability_REQUEST::TPM2_GetCapability_REQUEST()
{
    return;
};
TPM2_GetCapability_REQUEST::TPM2_GetCapability_REQUEST
(
    const TPM_CAP& _capability,
    const UINT32& _property,
    const UINT32& _propertyCount
)
{
    capability= _capability;
    property= _property;
    propertyCount= _propertyCount;
};
/// <summary>
/// This command returns various information regarding the TPM and its current state.
/// </summary>
TPM2_GetCapability_REQUEST::~TPM2_GetCapability_REQUEST()
{
    return;
};
/// <summary>
/// This command returns various information regarding the TPM and its current state.
/// </summary>
TPM2_GetCapability_REQUEST& TPM2_GetCapability_REQUEST::operator=(const TPM2_GetCapability_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->capability = rhs.capability;
    this->property = rhs.property;
    this->propertyCount = rhs.propertyCount;
    return *this;
};
/// <summary>
/// This command returns various information regarding the TPM and its current state.
/// </summary>
TPM2_GetCapability_REQUEST::TPM2_GetCapability_REQUEST(const TPM2_GetCapability_REQUEST& r)
{
    this->capability = r.capability;
    this->property = r.property;
    this->propertyCount = r.propertyCount;
};
/// <summary>
/// This command returns various information regarding the TPM and its current state.
/// </summary>
TpmStructureBase* TPM2_GetCapability_REQUEST::Clone() const
{
    TPM2_GetCapability_REQUEST* _x = new TPM2_GetCapability_REQUEST(*this);
    return _x;
};
void* TPM2_GetCapability_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&capability);
            case 1: return (void*) (&property);
            case 2: return (void*) (&propertyCount);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId GetCapabilityResponse::GetTypeId() const
{
    return TpmTypeId::GetCapabilityResponse_ID;
};
/// <summary>
/// This command returns various information regarding the TPM and its current state.
/// </summary>
GetCapabilityResponse::GetCapabilityResponse()
{
    capabilityData = NULL;
    return;
};
GetCapabilityResponse::GetCapabilityResponse
(
    const BYTE& _moreData,
    const TPMU_CAPABILITIES& _capabilityData
)
{
    moreData= _moreData;
    capabilityData = dynamic_cast<TPMU_CAPABILITIES*> (_capabilityData.Clone());
};
/// <summary>
/// This command returns various information regarding the TPM and its current state.
/// </summary>
GetCapabilityResponse::~GetCapabilityResponse()
{
    if(capabilityData != NULL) { delete capabilityData;capabilityData=NULL; }
    return;
};
/// <summary>
/// This command returns various information regarding the TPM and its current state.
/// </summary>
GetCapabilityResponse& GetCapabilityResponse::operator=(const GetCapabilityResponse& rhs)
{
    if(this == &rhs) return *this;
    this->moreData = rhs.moreData;
    this->capabilityDataCapability = rhs.capabilityDataCapability;
    if(capabilityData != NULL) delete capabilityData;
    if(rhs.capabilityData != NULL)capabilityData = dynamic_cast<TPMU_CAPABILITIES*>(rhs.capabilityData->Clone());
    return *this;
};
/// <summary>
/// This command returns various information regarding the TPM and its current state.
/// </summary>
GetCapabilityResponse::GetCapabilityResponse(const GetCapabilityResponse& r)
{
    this->moreData = r.moreData;
    this->capabilityDataCapability = r.capabilityDataCapability;
    if(r.capabilityData != NULL)capabilityData = dynamic_cast<TPMU_CAPABILITIES*>(r.capabilityData->Clone());
};
/// <summary>
/// This command returns various information regarding the TPM and its current state.
/// </summary>
TpmStructureBase* GetCapabilityResponse::Clone() const
{
    GetCapabilityResponse* _x = new GetCapabilityResponse(*this);
    return _x;
};
void* GetCapabilityResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&moreData);
            case 1: return (void*) (&capabilityDataCapability);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(capabilityData); return (void*) (&capabilityData);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_TestParms_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_TestParms_REQUEST_ID;
};
/// <summary>
/// This command is used to check to see if specific combinations of algorithm parameters are supported.
/// </summary>
TPM2_TestParms_REQUEST::TPM2_TestParms_REQUEST()
{
    parameters = NULL;
    return;
};
TPM2_TestParms_REQUEST::TPM2_TestParms_REQUEST
(
    const TPMU_PUBLIC_PARMS& _parameters
)
{
    parameters = dynamic_cast<TPMU_PUBLIC_PARMS*> (_parameters.Clone());
};
/// <summary>
/// This command is used to check to see if specific combinations of algorithm parameters are supported.
/// </summary>
TPM2_TestParms_REQUEST::~TPM2_TestParms_REQUEST()
{
    if(parameters != NULL) { delete parameters;parameters=NULL; }
    return;
};
/// <summary>
/// This command is used to check to see if specific combinations of algorithm parameters are supported.
/// </summary>
TPM2_TestParms_REQUEST& TPM2_TestParms_REQUEST::operator=(const TPM2_TestParms_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->parametersType = rhs.parametersType;
    if(parameters != NULL) delete parameters;
    if(rhs.parameters != NULL)parameters = dynamic_cast<TPMU_PUBLIC_PARMS*>(rhs.parameters->Clone());
    return *this;
};
/// <summary>
/// This command is used to check to see if specific combinations of algorithm parameters are supported.
/// </summary>
TPM2_TestParms_REQUEST::TPM2_TestParms_REQUEST(const TPM2_TestParms_REQUEST& r)
{
    this->parametersType = r.parametersType;
    if(r.parameters != NULL)parameters = dynamic_cast<TPMU_PUBLIC_PARMS*>(r.parameters->Clone());
};
/// <summary>
/// This command is used to check to see if specific combinations of algorithm parameters are supported.
/// </summary>
TpmStructureBase* TPM2_TestParms_REQUEST::Clone() const
{
    TPM2_TestParms_REQUEST* _x = new TPM2_TestParms_REQUEST(*this);
    return _x;
};
void* TPM2_TestParms_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&parametersType);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(parameters); return (void*) (&parameters);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TestParmsResponse::GetTypeId() const
{
    return TpmTypeId::TestParmsResponse_ID;
};
/// <summary>
/// This command is used to check to see if specific combinations of algorithm parameters are supported.
/// </summary>
TestParmsResponse::TestParmsResponse()
{
    return;
};
/// <summary>
/// This command is used to check to see if specific combinations of algorithm parameters are supported.
/// </summary>
TestParmsResponse::~TestParmsResponse()
{
    return;
};
/// <summary>
/// This command is used to check to see if specific combinations of algorithm parameters are supported.
/// </summary>
TestParmsResponse& TestParmsResponse::operator=(const TestParmsResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command is used to check to see if specific combinations of algorithm parameters are supported.
/// </summary>
TestParmsResponse::TestParmsResponse(const TestParmsResponse& r)
{
};
/// <summary>
/// This command is used to check to see if specific combinations of algorithm parameters are supported.
/// </summary>
TpmStructureBase* TestParmsResponse::Clone() const
{
    TestParmsResponse* _x = new TestParmsResponse(*this);
    return _x;
};
void* TestParmsResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_NV_DefineSpace_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID;
};
/// <summary>
/// This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
/// </summary>
TPM2_NV_DefineSpace_REQUEST::TPM2_NV_DefineSpace_REQUEST()
{
    return;
};
TPM2_NV_DefineSpace_REQUEST::TPM2_NV_DefineSpace_REQUEST
(
    const TPM_HANDLE& _authHandle,
    const std::vector<BYTE>& _auth,
    const TPMS_NV_PUBLIC& _publicInfo
)
{
    authHandle= _authHandle;
    auth= _auth;
    publicInfo= _publicInfo;
};
/// <summary>
/// This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
/// </summary>
TPM2_NV_DefineSpace_REQUEST::~TPM2_NV_DefineSpace_REQUEST()
{
    return;
};
/// <summary>
/// This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
/// </summary>
TPM2_NV_DefineSpace_REQUEST& TPM2_NV_DefineSpace_REQUEST::operator=(const TPM2_NV_DefineSpace_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    this->authSize = rhs.authSize;
    this->auth = rhs.auth;
    this->publicInfoSize = rhs.publicInfoSize;
    this->publicInfo = rhs.publicInfo;
    return *this;
};
/// <summary>
/// This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
/// </summary>
TPM2_NV_DefineSpace_REQUEST::TPM2_NV_DefineSpace_REQUEST(const TPM2_NV_DefineSpace_REQUEST& r)
{
    this->authHandle = r.authHandle;
    this->authSize = r.authSize;
    this->auth = r.auth;
    this->publicInfoSize = r.publicInfoSize;
    this->publicInfo = r.publicInfo;
};
/// <summary>
/// This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
/// </summary>
TpmStructureBase* TPM2_NV_DefineSpace_REQUEST::Clone() const
{
    TPM2_NV_DefineSpace_REQUEST* _x = new TPM2_NV_DefineSpace_REQUEST(*this);
    return _x;
};
void* TPM2_NV_DefineSpace_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 1: return (void*) (&authSize);
            case 2: { if(newArraySize != -1)auth.resize(newArraySize); arraySize = (int)auth.size(); return (void*)(&auth); }
            case 3: return (void*) (&publicInfoSize);
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&publicInfo); return (void*) (&publicInfo);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&auth[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId NV_DefineSpaceResponse::GetTypeId() const
{
    return TpmTypeId::NV_DefineSpaceResponse_ID;
};
/// <summary>
/// This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
/// </summary>
NV_DefineSpaceResponse::NV_DefineSpaceResponse()
{
    return;
};
/// <summary>
/// This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
/// </summary>
NV_DefineSpaceResponse::~NV_DefineSpaceResponse()
{
    return;
};
/// <summary>
/// This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
/// </summary>
NV_DefineSpaceResponse& NV_DefineSpaceResponse::operator=(const NV_DefineSpaceResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
/// </summary>
NV_DefineSpaceResponse::NV_DefineSpaceResponse(const NV_DefineSpaceResponse& r)
{
};
/// <summary>
/// This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
/// </summary>
TpmStructureBase* NV_DefineSpaceResponse::Clone() const
{
    NV_DefineSpaceResponse* _x = new NV_DefineSpaceResponse(*this);
    return _x;
};
void* NV_DefineSpaceResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_NV_UndefineSpace_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_UndefineSpace_REQUEST_ID;
};
/// <summary>
/// This command removes an Index from the TPM.
/// </summary>
TPM2_NV_UndefineSpace_REQUEST::TPM2_NV_UndefineSpace_REQUEST()
{
    return;
};
TPM2_NV_UndefineSpace_REQUEST::TPM2_NV_UndefineSpace_REQUEST
(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex
)
{
    authHandle= _authHandle;
    nvIndex= _nvIndex;
};
/// <summary>
/// This command removes an Index from the TPM.
/// </summary>
TPM2_NV_UndefineSpace_REQUEST::~TPM2_NV_UndefineSpace_REQUEST()
{
    return;
};
/// <summary>
/// This command removes an Index from the TPM.
/// </summary>
TPM2_NV_UndefineSpace_REQUEST& TPM2_NV_UndefineSpace_REQUEST::operator=(const TPM2_NV_UndefineSpace_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    this->nvIndex = rhs.nvIndex;
    return *this;
};
/// <summary>
/// This command removes an Index from the TPM.
/// </summary>
TPM2_NV_UndefineSpace_REQUEST::TPM2_NV_UndefineSpace_REQUEST(const TPM2_NV_UndefineSpace_REQUEST& r)
{
    this->authHandle = r.authHandle;
    this->nvIndex = r.nvIndex;
};
/// <summary>
/// This command removes an Index from the TPM.
/// </summary>
TpmStructureBase* TPM2_NV_UndefineSpace_REQUEST::Clone() const
{
    TPM2_NV_UndefineSpace_REQUEST* _x = new TPM2_NV_UndefineSpace_REQUEST(*this);
    return _x;
};
void* TPM2_NV_UndefineSpace_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return (void*) (&nvIndex);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId NV_UndefineSpaceResponse::GetTypeId() const
{
    return TpmTypeId::NV_UndefineSpaceResponse_ID;
};
/// <summary>
/// This command removes an Index from the TPM.
/// </summary>
NV_UndefineSpaceResponse::NV_UndefineSpaceResponse()
{
    return;
};
/// <summary>
/// This command removes an Index from the TPM.
/// </summary>
NV_UndefineSpaceResponse::~NV_UndefineSpaceResponse()
{
    return;
};
/// <summary>
/// This command removes an Index from the TPM.
/// </summary>
NV_UndefineSpaceResponse& NV_UndefineSpaceResponse::operator=(const NV_UndefineSpaceResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command removes an Index from the TPM.
/// </summary>
NV_UndefineSpaceResponse::NV_UndefineSpaceResponse(const NV_UndefineSpaceResponse& r)
{
};
/// <summary>
/// This command removes an Index from the TPM.
/// </summary>
TpmStructureBase* NV_UndefineSpaceResponse::Clone() const
{
    NV_UndefineSpaceResponse* _x = new NV_UndefineSpaceResponse(*this);
    return _x;
};
void* NV_UndefineSpaceResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_NV_UndefineSpaceSpecial_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_UndefineSpaceSpecial_REQUEST_ID;
};
/// <summary>
/// This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
/// </summary>
TPM2_NV_UndefineSpaceSpecial_REQUEST::TPM2_NV_UndefineSpaceSpecial_REQUEST()
{
    return;
};
TPM2_NV_UndefineSpaceSpecial_REQUEST::TPM2_NV_UndefineSpaceSpecial_REQUEST
(
    const TPM_HANDLE& _nvIndex,
    const TPM_HANDLE& _platform
)
{
    nvIndex= _nvIndex;
    platform= _platform;
};
/// <summary>
/// This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
/// </summary>
TPM2_NV_UndefineSpaceSpecial_REQUEST::~TPM2_NV_UndefineSpaceSpecial_REQUEST()
{
    return;
};
/// <summary>
/// This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
/// </summary>
TPM2_NV_UndefineSpaceSpecial_REQUEST& TPM2_NV_UndefineSpaceSpecial_REQUEST::operator=(const TPM2_NV_UndefineSpaceSpecial_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->nvIndex = rhs.nvIndex;
    this->platform = rhs.platform;
    return *this;
};
/// <summary>
/// This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
/// </summary>
TPM2_NV_UndefineSpaceSpecial_REQUEST::TPM2_NV_UndefineSpaceSpecial_REQUEST(const TPM2_NV_UndefineSpaceSpecial_REQUEST& r)
{
    this->nvIndex = r.nvIndex;
    this->platform = r.platform;
};
/// <summary>
/// This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
/// </summary>
TpmStructureBase* TPM2_NV_UndefineSpaceSpecial_REQUEST::Clone() const
{
    TPM2_NV_UndefineSpaceSpecial_REQUEST* _x = new TPM2_NV_UndefineSpaceSpecial_REQUEST(*this);
    return _x;
};
void* TPM2_NV_UndefineSpaceSpecial_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return (void*) (&nvIndex);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&platform); return (void*) (&platform);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId NV_UndefineSpaceSpecialResponse::GetTypeId() const
{
    return TpmTypeId::NV_UndefineSpaceSpecialResponse_ID;
};
/// <summary>
/// This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
/// </summary>
NV_UndefineSpaceSpecialResponse::NV_UndefineSpaceSpecialResponse()
{
    return;
};
/// <summary>
/// This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
/// </summary>
NV_UndefineSpaceSpecialResponse::~NV_UndefineSpaceSpecialResponse()
{
    return;
};
/// <summary>
/// This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
/// </summary>
NV_UndefineSpaceSpecialResponse& NV_UndefineSpaceSpecialResponse::operator=(const NV_UndefineSpaceSpecialResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
/// </summary>
NV_UndefineSpaceSpecialResponse::NV_UndefineSpaceSpecialResponse(const NV_UndefineSpaceSpecialResponse& r)
{
};
/// <summary>
/// This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
/// </summary>
TpmStructureBase* NV_UndefineSpaceSpecialResponse::Clone() const
{
    NV_UndefineSpaceSpecialResponse* _x = new NV_UndefineSpaceSpecialResponse(*this);
    return _x;
};
void* NV_UndefineSpaceSpecialResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_NV_ReadPublic_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_ReadPublic_REQUEST_ID;
};
/// <summary>
/// This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
/// </summary>
TPM2_NV_ReadPublic_REQUEST::TPM2_NV_ReadPublic_REQUEST()
{
    return;
};
TPM2_NV_ReadPublic_REQUEST::TPM2_NV_ReadPublic_REQUEST
(
    const TPM_HANDLE& _nvIndex
)
{
    nvIndex= _nvIndex;
};
/// <summary>
/// This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
/// </summary>
TPM2_NV_ReadPublic_REQUEST::~TPM2_NV_ReadPublic_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
/// </summary>
TPM2_NV_ReadPublic_REQUEST& TPM2_NV_ReadPublic_REQUEST::operator=(const TPM2_NV_ReadPublic_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->nvIndex = rhs.nvIndex;
    return *this;
};
/// <summary>
/// This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
/// </summary>
TPM2_NV_ReadPublic_REQUEST::TPM2_NV_ReadPublic_REQUEST(const TPM2_NV_ReadPublic_REQUEST& r)
{
    this->nvIndex = r.nvIndex;
};
/// <summary>
/// This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
/// </summary>
TpmStructureBase* TPM2_NV_ReadPublic_REQUEST::Clone() const
{
    TPM2_NV_ReadPublic_REQUEST* _x = new TPM2_NV_ReadPublic_REQUEST(*this);
    return _x;
};
void* TPM2_NV_ReadPublic_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return (void*) (&nvIndex);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId NV_ReadPublicResponse::GetTypeId() const
{
    return TpmTypeId::NV_ReadPublicResponse_ID;
};
/// <summary>
/// This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
/// </summary>
NV_ReadPublicResponse::NV_ReadPublicResponse()
{
    return;
};
NV_ReadPublicResponse::NV_ReadPublicResponse
(
    const TPMS_NV_PUBLIC& _nvPublic,
    const std::vector<BYTE>& _nvName
)
{
    nvPublic= _nvPublic;
    nvName= _nvName;
};
/// <summary>
/// This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
/// </summary>
NV_ReadPublicResponse::~NV_ReadPublicResponse()
{
    return;
};
/// <summary>
/// This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
/// </summary>
NV_ReadPublicResponse& NV_ReadPublicResponse::operator=(const NV_ReadPublicResponse& rhs)
{
    if(this == &rhs) return *this;
    this->nvPublicSize = rhs.nvPublicSize;
    this->nvPublic = rhs.nvPublic;
    this->nvNameSize = rhs.nvNameSize;
    this->nvName = rhs.nvName;
    return *this;
};
/// <summary>
/// This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
/// </summary>
NV_ReadPublicResponse::NV_ReadPublicResponse(const NV_ReadPublicResponse& r)
{
    this->nvPublicSize = r.nvPublicSize;
    this->nvPublic = r.nvPublic;
    this->nvNameSize = r.nvNameSize;
    this->nvName = r.nvName;
};
/// <summary>
/// This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
/// </summary>
TpmStructureBase* NV_ReadPublicResponse::Clone() const
{
    NV_ReadPublicResponse* _x = new NV_ReadPublicResponse(*this);
    return _x;
};
void* NV_ReadPublicResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&nvPublicSize);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvPublic); return (void*) (&nvPublic);
            case 2: return (void*) (&nvNameSize);
            case 3: { if(newArraySize != -1)nvName.resize(newArraySize); arraySize = (int)nvName.size(); return (void*)(&nvName); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&nvName[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_NV_Write_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_Write_REQUEST_ID;
};
/// <summary>
/// This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
/// </summary>
TPM2_NV_Write_REQUEST::TPM2_NV_Write_REQUEST()
{
    return;
};
TPM2_NV_Write_REQUEST::TPM2_NV_Write_REQUEST
(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    const std::vector<BYTE>& _data,
    const UINT16& _offset
)
{
    authHandle= _authHandle;
    nvIndex= _nvIndex;
    data= _data;
    offset= _offset;
};
/// <summary>
/// This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
/// </summary>
TPM2_NV_Write_REQUEST::~TPM2_NV_Write_REQUEST()
{
    return;
};
/// <summary>
/// This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
/// </summary>
TPM2_NV_Write_REQUEST& TPM2_NV_Write_REQUEST::operator=(const TPM2_NV_Write_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    this->nvIndex = rhs.nvIndex;
    this->dataSize = rhs.dataSize;
    this->data = rhs.data;
    this->offset = rhs.offset;
    return *this;
};
/// <summary>
/// This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
/// </summary>
TPM2_NV_Write_REQUEST::TPM2_NV_Write_REQUEST(const TPM2_NV_Write_REQUEST& r)
{
    this->authHandle = r.authHandle;
    this->nvIndex = r.nvIndex;
    this->dataSize = r.dataSize;
    this->data = r.data;
    this->offset = r.offset;
};
/// <summary>
/// This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
/// </summary>
TpmStructureBase* TPM2_NV_Write_REQUEST::Clone() const
{
    TPM2_NV_Write_REQUEST* _x = new TPM2_NV_Write_REQUEST(*this);
    return _x;
};
void* TPM2_NV_Write_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return (void*) (&nvIndex);
            case 2: return (void*) (&dataSize);
            case 3: { if(newArraySize != -1)data.resize(newArraySize); arraySize = (int)data.size(); return (void*)(&data); }
            case 4: return (void*) (&offset);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&data[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId NV_WriteResponse::GetTypeId() const
{
    return TpmTypeId::NV_WriteResponse_ID;
};
/// <summary>
/// This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
/// </summary>
NV_WriteResponse::NV_WriteResponse()
{
    return;
};
/// <summary>
/// This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
/// </summary>
NV_WriteResponse::~NV_WriteResponse()
{
    return;
};
/// <summary>
/// This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
/// </summary>
NV_WriteResponse& NV_WriteResponse::operator=(const NV_WriteResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
/// </summary>
NV_WriteResponse::NV_WriteResponse(const NV_WriteResponse& r)
{
};
/// <summary>
/// This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
/// </summary>
TpmStructureBase* NV_WriteResponse::Clone() const
{
    NV_WriteResponse* _x = new NV_WriteResponse(*this);
    return _x;
};
void* NV_WriteResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_NV_Increment_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_Increment_REQUEST_ID;
};
/// <summary>
/// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
/// </summary>
TPM2_NV_Increment_REQUEST::TPM2_NV_Increment_REQUEST()
{
    return;
};
TPM2_NV_Increment_REQUEST::TPM2_NV_Increment_REQUEST
(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex
)
{
    authHandle= _authHandle;
    nvIndex= _nvIndex;
};
/// <summary>
/// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
/// </summary>
TPM2_NV_Increment_REQUEST::~TPM2_NV_Increment_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
/// </summary>
TPM2_NV_Increment_REQUEST& TPM2_NV_Increment_REQUEST::operator=(const TPM2_NV_Increment_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    this->nvIndex = rhs.nvIndex;
    return *this;
};
/// <summary>
/// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
/// </summary>
TPM2_NV_Increment_REQUEST::TPM2_NV_Increment_REQUEST(const TPM2_NV_Increment_REQUEST& r)
{
    this->authHandle = r.authHandle;
    this->nvIndex = r.nvIndex;
};
/// <summary>
/// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
/// </summary>
TpmStructureBase* TPM2_NV_Increment_REQUEST::Clone() const
{
    TPM2_NV_Increment_REQUEST* _x = new TPM2_NV_Increment_REQUEST(*this);
    return _x;
};
void* TPM2_NV_Increment_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return (void*) (&nvIndex);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId NV_IncrementResponse::GetTypeId() const
{
    return TpmTypeId::NV_IncrementResponse_ID;
};
/// <summary>
/// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
/// </summary>
NV_IncrementResponse::NV_IncrementResponse()
{
    return;
};
/// <summary>
/// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
/// </summary>
NV_IncrementResponse::~NV_IncrementResponse()
{
    return;
};
/// <summary>
/// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
/// </summary>
NV_IncrementResponse& NV_IncrementResponse::operator=(const NV_IncrementResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
/// </summary>
NV_IncrementResponse::NV_IncrementResponse(const NV_IncrementResponse& r)
{
};
/// <summary>
/// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
/// </summary>
TpmStructureBase* NV_IncrementResponse::Clone() const
{
    NV_IncrementResponse* _x = new NV_IncrementResponse(*this);
    return _x;
};
void* NV_IncrementResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_NV_Extend_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_Extend_REQUEST_ID;
};
/// <summary>
/// This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
/// </summary>
TPM2_NV_Extend_REQUEST::TPM2_NV_Extend_REQUEST()
{
    return;
};
TPM2_NV_Extend_REQUEST::TPM2_NV_Extend_REQUEST
(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    const std::vector<BYTE>& _data
)
{
    authHandle= _authHandle;
    nvIndex= _nvIndex;
    data= _data;
};
/// <summary>
/// This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
/// </summary>
TPM2_NV_Extend_REQUEST::~TPM2_NV_Extend_REQUEST()
{
    return;
};
/// <summary>
/// This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
/// </summary>
TPM2_NV_Extend_REQUEST& TPM2_NV_Extend_REQUEST::operator=(const TPM2_NV_Extend_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    this->nvIndex = rhs.nvIndex;
    this->dataSize = rhs.dataSize;
    this->data = rhs.data;
    return *this;
};
/// <summary>
/// This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
/// </summary>
TPM2_NV_Extend_REQUEST::TPM2_NV_Extend_REQUEST(const TPM2_NV_Extend_REQUEST& r)
{
    this->authHandle = r.authHandle;
    this->nvIndex = r.nvIndex;
    this->dataSize = r.dataSize;
    this->data = r.data;
};
/// <summary>
/// This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
/// </summary>
TpmStructureBase* TPM2_NV_Extend_REQUEST::Clone() const
{
    TPM2_NV_Extend_REQUEST* _x = new TPM2_NV_Extend_REQUEST(*this);
    return _x;
};
void* TPM2_NV_Extend_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return (void*) (&nvIndex);
            case 2: return (void*) (&dataSize);
            case 3: { if(newArraySize != -1)data.resize(newArraySize); arraySize = (int)data.size(); return (void*)(&data); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 3: return (void*)(&data[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId NV_ExtendResponse::GetTypeId() const
{
    return TpmTypeId::NV_ExtendResponse_ID;
};
/// <summary>
/// This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
/// </summary>
NV_ExtendResponse::NV_ExtendResponse()
{
    return;
};
/// <summary>
/// This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
/// </summary>
NV_ExtendResponse::~NV_ExtendResponse()
{
    return;
};
/// <summary>
/// This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
/// </summary>
NV_ExtendResponse& NV_ExtendResponse::operator=(const NV_ExtendResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
/// </summary>
NV_ExtendResponse::NV_ExtendResponse(const NV_ExtendResponse& r)
{
};
/// <summary>
/// This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
/// </summary>
TpmStructureBase* NV_ExtendResponse::Clone() const
{
    NV_ExtendResponse* _x = new NV_ExtendResponse(*this);
    return _x;
};
void* NV_ExtendResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_NV_SetBits_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_SetBits_REQUEST_ID;
};
/// <summary>
/// This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
/// </summary>
TPM2_NV_SetBits_REQUEST::TPM2_NV_SetBits_REQUEST()
{
    return;
};
TPM2_NV_SetBits_REQUEST::TPM2_NV_SetBits_REQUEST
(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    const UINT64& _bits
)
{
    authHandle= _authHandle;
    nvIndex= _nvIndex;
    bits= _bits;
};
/// <summary>
/// This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
/// </summary>
TPM2_NV_SetBits_REQUEST::~TPM2_NV_SetBits_REQUEST()
{
    return;
};
/// <summary>
/// This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
/// </summary>
TPM2_NV_SetBits_REQUEST& TPM2_NV_SetBits_REQUEST::operator=(const TPM2_NV_SetBits_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    this->nvIndex = rhs.nvIndex;
    this->bits = rhs.bits;
    return *this;
};
/// <summary>
/// This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
/// </summary>
TPM2_NV_SetBits_REQUEST::TPM2_NV_SetBits_REQUEST(const TPM2_NV_SetBits_REQUEST& r)
{
    this->authHandle = r.authHandle;
    this->nvIndex = r.nvIndex;
    this->bits = r.bits;
};
/// <summary>
/// This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
/// </summary>
TpmStructureBase* TPM2_NV_SetBits_REQUEST::Clone() const
{
    TPM2_NV_SetBits_REQUEST* _x = new TPM2_NV_SetBits_REQUEST(*this);
    return _x;
};
void* TPM2_NV_SetBits_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return (void*) (&nvIndex);
            case 2: return (void*) (&bits);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId NV_SetBitsResponse::GetTypeId() const
{
    return TpmTypeId::NV_SetBitsResponse_ID;
};
/// <summary>
/// This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
/// </summary>
NV_SetBitsResponse::NV_SetBitsResponse()
{
    return;
};
/// <summary>
/// This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
/// </summary>
NV_SetBitsResponse::~NV_SetBitsResponse()
{
    return;
};
/// <summary>
/// This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
/// </summary>
NV_SetBitsResponse& NV_SetBitsResponse::operator=(const NV_SetBitsResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
/// </summary>
NV_SetBitsResponse::NV_SetBitsResponse(const NV_SetBitsResponse& r)
{
};
/// <summary>
/// This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
/// </summary>
TpmStructureBase* NV_SetBitsResponse::Clone() const
{
    NV_SetBitsResponse* _x = new NV_SetBitsResponse(*this);
    return _x;
};
void* NV_SetBitsResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_NV_WriteLock_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_WriteLock_REQUEST_ID;
};
/// <summary>
/// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
/// </summary>
TPM2_NV_WriteLock_REQUEST::TPM2_NV_WriteLock_REQUEST()
{
    return;
};
TPM2_NV_WriteLock_REQUEST::TPM2_NV_WriteLock_REQUEST
(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex
)
{
    authHandle= _authHandle;
    nvIndex= _nvIndex;
};
/// <summary>
/// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
/// </summary>
TPM2_NV_WriteLock_REQUEST::~TPM2_NV_WriteLock_REQUEST()
{
    return;
};
/// <summary>
/// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
/// </summary>
TPM2_NV_WriteLock_REQUEST& TPM2_NV_WriteLock_REQUEST::operator=(const TPM2_NV_WriteLock_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    this->nvIndex = rhs.nvIndex;
    return *this;
};
/// <summary>
/// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
/// </summary>
TPM2_NV_WriteLock_REQUEST::TPM2_NV_WriteLock_REQUEST(const TPM2_NV_WriteLock_REQUEST& r)
{
    this->authHandle = r.authHandle;
    this->nvIndex = r.nvIndex;
};
/// <summary>
/// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
/// </summary>
TpmStructureBase* TPM2_NV_WriteLock_REQUEST::Clone() const
{
    TPM2_NV_WriteLock_REQUEST* _x = new TPM2_NV_WriteLock_REQUEST(*this);
    return _x;
};
void* TPM2_NV_WriteLock_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return (void*) (&nvIndex);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId NV_WriteLockResponse::GetTypeId() const
{
    return TpmTypeId::NV_WriteLockResponse_ID;
};
/// <summary>
/// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
/// </summary>
NV_WriteLockResponse::NV_WriteLockResponse()
{
    return;
};
/// <summary>
/// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
/// </summary>
NV_WriteLockResponse::~NV_WriteLockResponse()
{
    return;
};
/// <summary>
/// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
/// </summary>
NV_WriteLockResponse& NV_WriteLockResponse::operator=(const NV_WriteLockResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
/// </summary>
NV_WriteLockResponse::NV_WriteLockResponse(const NV_WriteLockResponse& r)
{
};
/// <summary>
/// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
/// </summary>
TpmStructureBase* NV_WriteLockResponse::Clone() const
{
    NV_WriteLockResponse* _x = new NV_WriteLockResponse(*this);
    return _x;
};
void* NV_WriteLockResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_NV_GlobalWriteLock_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_GlobalWriteLock_REQUEST_ID;
};
/// <summary>
/// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
/// </summary>
TPM2_NV_GlobalWriteLock_REQUEST::TPM2_NV_GlobalWriteLock_REQUEST()
{
    return;
};
TPM2_NV_GlobalWriteLock_REQUEST::TPM2_NV_GlobalWriteLock_REQUEST
(
    const TPM_HANDLE& _authHandle
)
{
    authHandle= _authHandle;
};
/// <summary>
/// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
/// </summary>
TPM2_NV_GlobalWriteLock_REQUEST::~TPM2_NV_GlobalWriteLock_REQUEST()
{
    return;
};
/// <summary>
/// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
/// </summary>
TPM2_NV_GlobalWriteLock_REQUEST& TPM2_NV_GlobalWriteLock_REQUEST::operator=(const TPM2_NV_GlobalWriteLock_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    return *this;
};
/// <summary>
/// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
/// </summary>
TPM2_NV_GlobalWriteLock_REQUEST::TPM2_NV_GlobalWriteLock_REQUEST(const TPM2_NV_GlobalWriteLock_REQUEST& r)
{
    this->authHandle = r.authHandle;
};
/// <summary>
/// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
/// </summary>
TpmStructureBase* TPM2_NV_GlobalWriteLock_REQUEST::Clone() const
{
    TPM2_NV_GlobalWriteLock_REQUEST* _x = new TPM2_NV_GlobalWriteLock_REQUEST(*this);
    return _x;
};
void* TPM2_NV_GlobalWriteLock_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId NV_GlobalWriteLockResponse::GetTypeId() const
{
    return TpmTypeId::NV_GlobalWriteLockResponse_ID;
};
/// <summary>
/// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
/// </summary>
NV_GlobalWriteLockResponse::NV_GlobalWriteLockResponse()
{
    return;
};
/// <summary>
/// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
/// </summary>
NV_GlobalWriteLockResponse::~NV_GlobalWriteLockResponse()
{
    return;
};
/// <summary>
/// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
/// </summary>
NV_GlobalWriteLockResponse& NV_GlobalWriteLockResponse::operator=(const NV_GlobalWriteLockResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
/// </summary>
NV_GlobalWriteLockResponse::NV_GlobalWriteLockResponse(const NV_GlobalWriteLockResponse& r)
{
};
/// <summary>
/// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
/// </summary>
TpmStructureBase* NV_GlobalWriteLockResponse::Clone() const
{
    NV_GlobalWriteLockResponse* _x = new NV_GlobalWriteLockResponse(*this);
    return _x;
};
void* NV_GlobalWriteLockResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_NV_Read_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_Read_REQUEST_ID;
};
/// <summary>
/// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
/// </summary>
TPM2_NV_Read_REQUEST::TPM2_NV_Read_REQUEST()
{
    return;
};
TPM2_NV_Read_REQUEST::TPM2_NV_Read_REQUEST
(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    const UINT16& _size,
    const UINT16& _offset
)
{
    authHandle= _authHandle;
    nvIndex= _nvIndex;
    size= _size;
    offset= _offset;
};
/// <summary>
/// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
/// </summary>
TPM2_NV_Read_REQUEST::~TPM2_NV_Read_REQUEST()
{
    return;
};
/// <summary>
/// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
/// </summary>
TPM2_NV_Read_REQUEST& TPM2_NV_Read_REQUEST::operator=(const TPM2_NV_Read_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    this->nvIndex = rhs.nvIndex;
    this->size = rhs.size;
    this->offset = rhs.offset;
    return *this;
};
/// <summary>
/// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
/// </summary>
TPM2_NV_Read_REQUEST::TPM2_NV_Read_REQUEST(const TPM2_NV_Read_REQUEST& r)
{
    this->authHandle = r.authHandle;
    this->nvIndex = r.nvIndex;
    this->size = r.size;
    this->offset = r.offset;
};
/// <summary>
/// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
/// </summary>
TpmStructureBase* TPM2_NV_Read_REQUEST::Clone() const
{
    TPM2_NV_Read_REQUEST* _x = new TPM2_NV_Read_REQUEST(*this);
    return _x;
};
void* TPM2_NV_Read_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return (void*) (&nvIndex);
            case 2: return (void*) (&size);
            case 3: return (void*) (&offset);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId NV_ReadResponse::GetTypeId() const
{
    return TpmTypeId::NV_ReadResponse_ID;
};
/// <summary>
/// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
/// </summary>
NV_ReadResponse::NV_ReadResponse()
{
    return;
};
NV_ReadResponse::NV_ReadResponse
(
    const std::vector<BYTE>& _data
)
{
    data= _data;
};
/// <summary>
/// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
/// </summary>
NV_ReadResponse::~NV_ReadResponse()
{
    return;
};
/// <summary>
/// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
/// </summary>
NV_ReadResponse& NV_ReadResponse::operator=(const NV_ReadResponse& rhs)
{
    if(this == &rhs) return *this;
    this->dataSize = rhs.dataSize;
    this->data = rhs.data;
    return *this;
};
/// <summary>
/// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
/// </summary>
NV_ReadResponse::NV_ReadResponse(const NV_ReadResponse& r)
{
    this->dataSize = r.dataSize;
    this->data = r.data;
};
/// <summary>
/// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
/// </summary>
TpmStructureBase* NV_ReadResponse::Clone() const
{
    NV_ReadResponse* _x = new NV_ReadResponse(*this);
    return _x;
};
void* NV_ReadResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&dataSize);
            case 1: { if(newArraySize != -1)data.resize(newArraySize); arraySize = (int)data.size(); return (void*)(&data); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&data[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_NV_ReadLock_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_ReadLock_REQUEST_ID;
};
/// <summary>
/// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
/// </summary>
TPM2_NV_ReadLock_REQUEST::TPM2_NV_ReadLock_REQUEST()
{
    return;
};
TPM2_NV_ReadLock_REQUEST::TPM2_NV_ReadLock_REQUEST
(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex
)
{
    authHandle= _authHandle;
    nvIndex= _nvIndex;
};
/// <summary>
/// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
/// </summary>
TPM2_NV_ReadLock_REQUEST::~TPM2_NV_ReadLock_REQUEST()
{
    return;
};
/// <summary>
/// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
/// </summary>
TPM2_NV_ReadLock_REQUEST& TPM2_NV_ReadLock_REQUEST::operator=(const TPM2_NV_ReadLock_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->authHandle = rhs.authHandle;
    this->nvIndex = rhs.nvIndex;
    return *this;
};
/// <summary>
/// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
/// </summary>
TPM2_NV_ReadLock_REQUEST::TPM2_NV_ReadLock_REQUEST(const TPM2_NV_ReadLock_REQUEST& r)
{
    this->authHandle = r.authHandle;
    this->nvIndex = r.nvIndex;
};
/// <summary>
/// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
/// </summary>
TpmStructureBase* TPM2_NV_ReadLock_REQUEST::Clone() const
{
    TPM2_NV_ReadLock_REQUEST* _x = new TPM2_NV_ReadLock_REQUEST(*this);
    return _x;
};
void* TPM2_NV_ReadLock_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return (void*) (&nvIndex);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId NV_ReadLockResponse::GetTypeId() const
{
    return TpmTypeId::NV_ReadLockResponse_ID;
};
/// <summary>
/// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
/// </summary>
NV_ReadLockResponse::NV_ReadLockResponse()
{
    return;
};
/// <summary>
/// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
/// </summary>
NV_ReadLockResponse::~NV_ReadLockResponse()
{
    return;
};
/// <summary>
/// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
/// </summary>
NV_ReadLockResponse& NV_ReadLockResponse::operator=(const NV_ReadLockResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
/// </summary>
NV_ReadLockResponse::NV_ReadLockResponse(const NV_ReadLockResponse& r)
{
};
/// <summary>
/// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
/// </summary>
TpmStructureBase* NV_ReadLockResponse::Clone() const
{
    NV_ReadLockResponse* _x = new NV_ReadLockResponse(*this);
    return _x;
};
void* NV_ReadLockResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_NV_ChangeAuth_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_ChangeAuth_REQUEST_ID;
};
/// <summary>
/// This command allows the authorization secret for an NV Index to be changed.
/// </summary>
TPM2_NV_ChangeAuth_REQUEST::TPM2_NV_ChangeAuth_REQUEST()
{
    return;
};
TPM2_NV_ChangeAuth_REQUEST::TPM2_NV_ChangeAuth_REQUEST
(
    const TPM_HANDLE& _nvIndex,
    const std::vector<BYTE>& _newAuth
)
{
    nvIndex= _nvIndex;
    newAuth= _newAuth;
};
/// <summary>
/// This command allows the authorization secret for an NV Index to be changed.
/// </summary>
TPM2_NV_ChangeAuth_REQUEST::~TPM2_NV_ChangeAuth_REQUEST()
{
    return;
};
/// <summary>
/// This command allows the authorization secret for an NV Index to be changed.
/// </summary>
TPM2_NV_ChangeAuth_REQUEST& TPM2_NV_ChangeAuth_REQUEST::operator=(const TPM2_NV_ChangeAuth_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->nvIndex = rhs.nvIndex;
    this->newAuthSize = rhs.newAuthSize;
    this->newAuth = rhs.newAuth;
    return *this;
};
/// <summary>
/// This command allows the authorization secret for an NV Index to be changed.
/// </summary>
TPM2_NV_ChangeAuth_REQUEST::TPM2_NV_ChangeAuth_REQUEST(const TPM2_NV_ChangeAuth_REQUEST& r)
{
    this->nvIndex = r.nvIndex;
    this->newAuthSize = r.newAuthSize;
    this->newAuth = r.newAuth;
};
/// <summary>
/// This command allows the authorization secret for an NV Index to be changed.
/// </summary>
TpmStructureBase* TPM2_NV_ChangeAuth_REQUEST::Clone() const
{
    TPM2_NV_ChangeAuth_REQUEST* _x = new TPM2_NV_ChangeAuth_REQUEST(*this);
    return _x;
};
void* TPM2_NV_ChangeAuth_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return (void*) (&nvIndex);
            case 1: return (void*) (&newAuthSize);
            case 2: { if(newArraySize != -1)newAuth.resize(newArraySize); arraySize = (int)newAuth.size(); return (void*)(&newAuth); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&newAuth[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId NV_ChangeAuthResponse::GetTypeId() const
{
    return TpmTypeId::NV_ChangeAuthResponse_ID;
};
/// <summary>
/// This command allows the authorization secret for an NV Index to be changed.
/// </summary>
NV_ChangeAuthResponse::NV_ChangeAuthResponse()
{
    return;
};
/// <summary>
/// This command allows the authorization secret for an NV Index to be changed.
/// </summary>
NV_ChangeAuthResponse::~NV_ChangeAuthResponse()
{
    return;
};
/// <summary>
/// This command allows the authorization secret for an NV Index to be changed.
/// </summary>
NV_ChangeAuthResponse& NV_ChangeAuthResponse::operator=(const NV_ChangeAuthResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command allows the authorization secret for an NV Index to be changed.
/// </summary>
NV_ChangeAuthResponse::NV_ChangeAuthResponse(const NV_ChangeAuthResponse& r)
{
};
/// <summary>
/// This command allows the authorization secret for an NV Index to be changed.
/// </summary>
TpmStructureBase* NV_ChangeAuthResponse::Clone() const
{
    NV_ChangeAuthResponse* _x = new NV_ChangeAuthResponse(*this);
    return _x;
};
void* NV_ChangeAuthResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_NV_Certify_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
};
/// <summary>
/// The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
/// </summary>
TPM2_NV_Certify_REQUEST::TPM2_NV_Certify_REQUEST()
{
    inScheme = NULL;
    return;
};
TPM2_NV_Certify_REQUEST::TPM2_NV_Certify_REQUEST
(
    const TPM_HANDLE& _signHandle,
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    const std::vector<BYTE>& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme,
    const UINT16& _size,
    const UINT16& _offset
)
{
    signHandle= _signHandle;
    authHandle= _authHandle;
    nvIndex= _nvIndex;
    qualifyingData= _qualifyingData;
    inScheme = dynamic_cast<TPMU_SIG_SCHEME*> (_inScheme.Clone());
    size= _size;
    offset= _offset;
};
/// <summary>
/// The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
/// </summary>
TPM2_NV_Certify_REQUEST::~TPM2_NV_Certify_REQUEST()
{
    if(inScheme != NULL) { delete inScheme;inScheme=NULL; }
    return;
};
/// <summary>
/// The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
/// </summary>
TPM2_NV_Certify_REQUEST& TPM2_NV_Certify_REQUEST::operator=(const TPM2_NV_Certify_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->signHandle = rhs.signHandle;
    this->authHandle = rhs.authHandle;
    this->nvIndex = rhs.nvIndex;
    this->qualifyingDataSize = rhs.qualifyingDataSize;
    this->qualifyingData = rhs.qualifyingData;
    this->inSchemeScheme = rhs.inSchemeScheme;
    if(inScheme != NULL) delete inScheme;
    if(rhs.inScheme != NULL)inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(rhs.inScheme->Clone());
    this->size = rhs.size;
    this->offset = rhs.offset;
    return *this;
};
/// <summary>
/// The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
/// </summary>
TPM2_NV_Certify_REQUEST::TPM2_NV_Certify_REQUEST(const TPM2_NV_Certify_REQUEST& r)
{
    this->signHandle = r.signHandle;
    this->authHandle = r.authHandle;
    this->nvIndex = r.nvIndex;
    this->qualifyingDataSize = r.qualifyingDataSize;
    this->qualifyingData = r.qualifyingData;
    this->inSchemeScheme = r.inSchemeScheme;
    if(r.inScheme != NULL)inScheme = dynamic_cast<TPMU_SIG_SCHEME*>(r.inScheme->Clone());
    this->size = r.size;
    this->offset = r.offset;
};
/// <summary>
/// The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
/// </summary>
TpmStructureBase* TPM2_NV_Certify_REQUEST::Clone() const
{
    TPM2_NV_Certify_REQUEST* _x = new TPM2_NV_Certify_REQUEST(*this);
    return _x;
};
void* TPM2_NV_Certify_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return (void*) (&signHandle);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return (void*) (&nvIndex);
            case 3: return (void*) (&qualifyingDataSize);
            case 4: { if(newArraySize != -1)qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return (void*)(&qualifyingData); }
            case 5: return (void*) (&inSchemeScheme);
            case 6: pStruct = dynamic_cast<TpmStructureBase*>(inScheme); return (void*) (&inScheme);
            case 7: return (void*) (&size);
            case 8: return (void*) (&offset);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 4: return (void*)(&qualifyingData[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId NV_CertifyResponse::GetTypeId() const
{
    return TpmTypeId::NV_CertifyResponse_ID;
};
/// <summary>
/// The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
/// </summary>
NV_CertifyResponse::NV_CertifyResponse()
{
    signature = NULL;
    return;
};
NV_CertifyResponse::NV_CertifyResponse
(
    const TPMS_ATTEST& _certifyInfo,
    const TPMU_SIGNATURE& _signature
)
{
    certifyInfo= _certifyInfo;
    signature = dynamic_cast<TPMU_SIGNATURE*> (_signature.Clone());
};
/// <summary>
/// The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
/// </summary>
NV_CertifyResponse::~NV_CertifyResponse()
{
    if(signature != NULL) { delete signature;signature=NULL; }
    return;
};
/// <summary>
/// The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
/// </summary>
NV_CertifyResponse& NV_CertifyResponse::operator=(const NV_CertifyResponse& rhs)
{
    if(this == &rhs) return *this;
    this->certifyInfoSize = rhs.certifyInfoSize;
    this->certifyInfo = rhs.certifyInfo;
    this->signatureSigAlg = rhs.signatureSigAlg;
    if(signature != NULL) delete signature;
    if(rhs.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(rhs.signature->Clone());
    return *this;
};
/// <summary>
/// The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
/// </summary>
NV_CertifyResponse::NV_CertifyResponse(const NV_CertifyResponse& r)
{
    this->certifyInfoSize = r.certifyInfoSize;
    this->certifyInfo = r.certifyInfo;
    this->signatureSigAlg = r.signatureSigAlg;
    if(r.signature != NULL)signature = dynamic_cast<TPMU_SIGNATURE*>(r.signature->Clone());
};
/// <summary>
/// The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
/// </summary>
TpmStructureBase* NV_CertifyResponse::Clone() const
{
    NV_CertifyResponse* _x = new NV_CertifyResponse(*this);
    return _x;
};
void* NV_CertifyResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&certifyInfoSize);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&certifyInfo); return (void*) (&certifyInfo);
            case 2: return (void*) (&signatureSigAlg);
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(signature); return (void*) (&signature);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_AC_GetCapability_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_AC_GetCapability_REQUEST_ID;
};
/// <summary>
/// The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
/// </summary>
TPM2_AC_GetCapability_REQUEST::TPM2_AC_GetCapability_REQUEST()
{
    return;
};
TPM2_AC_GetCapability_REQUEST::TPM2_AC_GetCapability_REQUEST
(
    const TPM_HANDLE& _ac,
    const TPM_AT& _capability,
    const UINT32& _count
)
{
    ac= _ac;
    capability= _capability;
    count= _count;
};
/// <summary>
/// The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
/// </summary>
TPM2_AC_GetCapability_REQUEST::~TPM2_AC_GetCapability_REQUEST()
{
    return;
};
/// <summary>
/// The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
/// </summary>
TPM2_AC_GetCapability_REQUEST& TPM2_AC_GetCapability_REQUEST::operator=(const TPM2_AC_GetCapability_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->ac = rhs.ac;
    this->capability = rhs.capability;
    this->count = rhs.count;
    return *this;
};
/// <summary>
/// The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
/// </summary>
TPM2_AC_GetCapability_REQUEST::TPM2_AC_GetCapability_REQUEST(const TPM2_AC_GetCapability_REQUEST& r)
{
    this->ac = r.ac;
    this->capability = r.capability;
    this->count = r.count;
};
/// <summary>
/// The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
/// </summary>
TpmStructureBase* TPM2_AC_GetCapability_REQUEST::Clone() const
{
    TPM2_AC_GetCapability_REQUEST* _x = new TPM2_AC_GetCapability_REQUEST(*this);
    return _x;
};
void* TPM2_AC_GetCapability_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&ac); return (void*) (&ac);
            case 1: return (void*) (&capability);
            case 2: return (void*) (&count);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId AC_GetCapabilityResponse::GetTypeId() const
{
    return TpmTypeId::AC_GetCapabilityResponse_ID;
};
/// <summary>
/// The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
/// </summary>
AC_GetCapabilityResponse::AC_GetCapabilityResponse()
{
    return;
};
AC_GetCapabilityResponse::AC_GetCapabilityResponse
(
    const BYTE& _moreData,
    const std::vector<TPMS_AC_OUTPUT>& _capabilitiesData
)
{
    moreData= _moreData;
    capabilitiesData= _capabilitiesData;
};
/// <summary>
/// The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
/// </summary>
AC_GetCapabilityResponse::~AC_GetCapabilityResponse()
{
    return;
};
/// <summary>
/// The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
/// </summary>
AC_GetCapabilityResponse& AC_GetCapabilityResponse::operator=(const AC_GetCapabilityResponse& rhs)
{
    if(this == &rhs) return *this;
    this->moreData = rhs.moreData;
    this->capabilitiesDataCount = rhs.capabilitiesDataCount;
    this->capabilitiesData = rhs.capabilitiesData;
    return *this;
};
/// <summary>
/// The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
/// </summary>
AC_GetCapabilityResponse::AC_GetCapabilityResponse(const AC_GetCapabilityResponse& r)
{
    this->moreData = r.moreData;
    this->capabilitiesDataCount = r.capabilitiesDataCount;
    this->capabilitiesData = r.capabilitiesData;
};
/// <summary>
/// The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
/// </summary>
TpmStructureBase* AC_GetCapabilityResponse::Clone() const
{
    AC_GetCapabilityResponse* _x = new AC_GetCapabilityResponse(*this);
    return _x;
};
void* AC_GetCapabilityResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&moreData);
            case 1: return (void*) (&capabilitiesDataCount);
            case 2: { if(newArraySize != -1)capabilitiesData.resize(newArraySize); arraySize = (int)capabilitiesData.size(); return (void*)(&capabilitiesData); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&capabilitiesData[arrayIndex]);return (void*)(&capabilitiesData[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2_AC_Send_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_AC_Send_REQUEST_ID;
};
/// <summary>
/// The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
/// </summary>
TPM2_AC_Send_REQUEST::TPM2_AC_Send_REQUEST()
{
    return;
};
TPM2_AC_Send_REQUEST::TPM2_AC_Send_REQUEST
(
    const TPM_HANDLE& _sendObject,
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _ac,
    const std::vector<BYTE>& _acDataIn
)
{
    sendObject= _sendObject;
    authHandle= _authHandle;
    ac= _ac;
    acDataIn= _acDataIn;
};
/// <summary>
/// The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
/// </summary>
TPM2_AC_Send_REQUEST::~TPM2_AC_Send_REQUEST()
{
    return;
};
/// <summary>
/// The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
/// </summary>
TPM2_AC_Send_REQUEST& TPM2_AC_Send_REQUEST::operator=(const TPM2_AC_Send_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->sendObject = rhs.sendObject;
    this->authHandle = rhs.authHandle;
    this->ac = rhs.ac;
    this->acDataInSize = rhs.acDataInSize;
    this->acDataIn = rhs.acDataIn;
    return *this;
};
/// <summary>
/// The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
/// </summary>
TPM2_AC_Send_REQUEST::TPM2_AC_Send_REQUEST(const TPM2_AC_Send_REQUEST& r)
{
    this->sendObject = r.sendObject;
    this->authHandle = r.authHandle;
    this->ac = r.ac;
    this->acDataInSize = r.acDataInSize;
    this->acDataIn = r.acDataIn;
};
/// <summary>
/// The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
/// </summary>
TpmStructureBase* TPM2_AC_Send_REQUEST::Clone() const
{
    TPM2_AC_Send_REQUEST* _x = new TPM2_AC_Send_REQUEST(*this);
    return _x;
};
void* TPM2_AC_Send_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&sendObject); return (void*) (&sendObject);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return (void*) (&authHandle);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&ac); return (void*) (&ac);
            case 3: return (void*) (&acDataInSize);
            case 4: { if(newArraySize != -1)acDataIn.resize(newArraySize); arraySize = (int)acDataIn.size(); return (void*)(&acDataIn); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 4: return (void*)(&acDataIn[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId AC_SendResponse::GetTypeId() const
{
    return TpmTypeId::AC_SendResponse_ID;
};
/// <summary>
/// The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
/// </summary>
AC_SendResponse::AC_SendResponse()
{
    return;
};
AC_SendResponse::AC_SendResponse
(
    const TPMS_AC_OUTPUT& _acDataOut
)
{
    acDataOut= _acDataOut;
};
/// <summary>
/// The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
/// </summary>
AC_SendResponse::~AC_SendResponse()
{
    return;
};
/// <summary>
/// The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
/// </summary>
AC_SendResponse& AC_SendResponse::operator=(const AC_SendResponse& rhs)
{
    if(this == &rhs) return *this;
    this->acDataOut = rhs.acDataOut;
    return *this;
};
/// <summary>
/// The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
/// </summary>
AC_SendResponse::AC_SendResponse(const AC_SendResponse& r)
{
    this->acDataOut = r.acDataOut;
};
/// <summary>
/// The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
/// </summary>
TpmStructureBase* AC_SendResponse::Clone() const
{
    AC_SendResponse* _x = new AC_SendResponse(*this);
    return _x;
};
void* AC_SendResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&acDataOut); return (void*) (&acDataOut);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TPM2_Policy_AC_SendSelect_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
};
/// <summary>
/// This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
/// </summary>
TPM2_Policy_AC_SendSelect_REQUEST::TPM2_Policy_AC_SendSelect_REQUEST()
{
    return;
};
TPM2_Policy_AC_SendSelect_REQUEST::TPM2_Policy_AC_SendSelect_REQUEST
(
    const TPM_HANDLE& _policySession,
    const std::vector<BYTE>& _objectName,
    const std::vector<BYTE>& _authHandleName,
    const std::vector<BYTE>& _acName,
    const BYTE& _includeObject
)
{
    policySession= _policySession;
    objectName= _objectName;
    authHandleName= _authHandleName;
    acName= _acName;
    includeObject= _includeObject;
};
/// <summary>
/// This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
/// </summary>
TPM2_Policy_AC_SendSelect_REQUEST::~TPM2_Policy_AC_SendSelect_REQUEST()
{
    return;
};
/// <summary>
/// This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
/// </summary>
TPM2_Policy_AC_SendSelect_REQUEST& TPM2_Policy_AC_SendSelect_REQUEST::operator=(const TPM2_Policy_AC_SendSelect_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->policySession = rhs.policySession;
    this->objectNameSize = rhs.objectNameSize;
    this->objectName = rhs.objectName;
    this->authHandleNameSize = rhs.authHandleNameSize;
    this->authHandleName = rhs.authHandleName;
    this->acNameSize = rhs.acNameSize;
    this->acName = rhs.acName;
    this->includeObject = rhs.includeObject;
    return *this;
};
/// <summary>
/// This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
/// </summary>
TPM2_Policy_AC_SendSelect_REQUEST::TPM2_Policy_AC_SendSelect_REQUEST(const TPM2_Policy_AC_SendSelect_REQUEST& r)
{
    this->policySession = r.policySession;
    this->objectNameSize = r.objectNameSize;
    this->objectName = r.objectName;
    this->authHandleNameSize = r.authHandleNameSize;
    this->authHandleName = r.authHandleName;
    this->acNameSize = r.acNameSize;
    this->acName = r.acName;
    this->includeObject = r.includeObject;
};
/// <summary>
/// This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
/// </summary>
TpmStructureBase* TPM2_Policy_AC_SendSelect_REQUEST::Clone() const
{
    TPM2_Policy_AC_SendSelect_REQUEST* _x = new TPM2_Policy_AC_SendSelect_REQUEST(*this);
    return _x;
};
void* TPM2_Policy_AC_SendSelect_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return (void*) (&policySession);
            case 1: return (void*) (&objectNameSize);
            case 2: { if(newArraySize != -1)objectName.resize(newArraySize); arraySize = (int)objectName.size(); return (void*)(&objectName); }
            case 3: return (void*) (&authHandleNameSize);
            case 4: { if(newArraySize != -1)authHandleName.resize(newArraySize); arraySize = (int)authHandleName.size(); return (void*)(&authHandleName); }
            case 5: return (void*) (&acNameSize);
            case 6: { if(newArraySize != -1)acName.resize(newArraySize); arraySize = (int)acName.size(); return (void*)(&acName); }
            case 7: return (void*) (&includeObject);
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&objectName[arrayIndex]);
            case 4: return (void*)(&authHandleName[arrayIndex]);
            case 6: return (void*)(&acName[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId Policy_AC_SendSelectResponse::GetTypeId() const
{
    return TpmTypeId::Policy_AC_SendSelectResponse_ID;
};
/// <summary>
/// This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
/// </summary>
Policy_AC_SendSelectResponse::Policy_AC_SendSelectResponse()
{
    return;
};
/// <summary>
/// This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
/// </summary>
Policy_AC_SendSelectResponse::~Policy_AC_SendSelectResponse()
{
    return;
};
/// <summary>
/// This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
/// </summary>
Policy_AC_SendSelectResponse& Policy_AC_SendSelectResponse::operator=(const Policy_AC_SendSelectResponse& rhs)
{
    if(this == &rhs) return *this;
    return *this;
};
/// <summary>
/// This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
/// </summary>
Policy_AC_SendSelectResponse::Policy_AC_SendSelectResponse(const Policy_AC_SendSelectResponse& r)
{
};
/// <summary>
/// This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
/// </summary>
TpmStructureBase* Policy_AC_SendSelectResponse::Clone() const
{
    Policy_AC_SendSelectResponse* _x = new Policy_AC_SendSelectResponse(*this);
    return _x;
};
void* Policy_AC_SendSelectResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
throw logic_error("error");
return NULL;
};
TpmTypeId TPM2_Vendor_TCG_Test_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Vendor_TCG_Test_REQUEST_ID;
};
/// <summary>
/// This is a placeholder to allow testing of the dispatch code.
/// </summary>
TPM2_Vendor_TCG_Test_REQUEST::TPM2_Vendor_TCG_Test_REQUEST()
{
    return;
};
TPM2_Vendor_TCG_Test_REQUEST::TPM2_Vendor_TCG_Test_REQUEST
(
    const std::vector<BYTE>& _inputData
)
{
    inputData= _inputData;
};
/// <summary>
/// This is a placeholder to allow testing of the dispatch code.
/// </summary>
TPM2_Vendor_TCG_Test_REQUEST::~TPM2_Vendor_TCG_Test_REQUEST()
{
    return;
};
/// <summary>
/// This is a placeholder to allow testing of the dispatch code.
/// </summary>
TPM2_Vendor_TCG_Test_REQUEST& TPM2_Vendor_TCG_Test_REQUEST::operator=(const TPM2_Vendor_TCG_Test_REQUEST& rhs)
{
    if(this == &rhs) return *this;
    this->inputDataSize = rhs.inputDataSize;
    this->inputData = rhs.inputData;
    return *this;
};
/// <summary>
/// This is a placeholder to allow testing of the dispatch code.
/// </summary>
TPM2_Vendor_TCG_Test_REQUEST::TPM2_Vendor_TCG_Test_REQUEST(const TPM2_Vendor_TCG_Test_REQUEST& r)
{
    this->inputDataSize = r.inputDataSize;
    this->inputData = r.inputData;
};
/// <summary>
/// This is a placeholder to allow testing of the dispatch code.
/// </summary>
TpmStructureBase* TPM2_Vendor_TCG_Test_REQUEST::Clone() const
{
    TPM2_Vendor_TCG_Test_REQUEST* _x = new TPM2_Vendor_TCG_Test_REQUEST(*this);
    return _x;
};
void* TPM2_Vendor_TCG_Test_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&inputDataSize);
            case 1: { if(newArraySize != -1)inputData.resize(newArraySize); arraySize = (int)inputData.size(); return (void*)(&inputData); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&inputData[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId Vendor_TCG_TestResponse::GetTypeId() const
{
    return TpmTypeId::Vendor_TCG_TestResponse_ID;
};
/// <summary>
/// This is a placeholder to allow testing of the dispatch code.
/// </summary>
Vendor_TCG_TestResponse::Vendor_TCG_TestResponse()
{
    return;
};
Vendor_TCG_TestResponse::Vendor_TCG_TestResponse
(
    const std::vector<BYTE>& _outputData
)
{
    outputData= _outputData;
};
/// <summary>
/// This is a placeholder to allow testing of the dispatch code.
/// </summary>
Vendor_TCG_TestResponse::~Vendor_TCG_TestResponse()
{
    return;
};
/// <summary>
/// This is a placeholder to allow testing of the dispatch code.
/// </summary>
Vendor_TCG_TestResponse& Vendor_TCG_TestResponse::operator=(const Vendor_TCG_TestResponse& rhs)
{
    if(this == &rhs) return *this;
    this->outputDataSize = rhs.outputDataSize;
    this->outputData = rhs.outputData;
    return *this;
};
/// <summary>
/// This is a placeholder to allow testing of the dispatch code.
/// </summary>
Vendor_TCG_TestResponse::Vendor_TCG_TestResponse(const Vendor_TCG_TestResponse& r)
{
    this->outputDataSize = r.outputDataSize;
    this->outputData = r.outputData;
};
/// <summary>
/// This is a placeholder to allow testing of the dispatch code.
/// </summary>
TpmStructureBase* Vendor_TCG_TestResponse::Clone() const
{
    Vendor_TCG_TestResponse* _x = new Vendor_TCG_TestResponse(*this);
    return _x;
};
void* Vendor_TCG_TestResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&outputDataSize);
            case 1: { if(newArraySize != -1)outputData.resize(newArraySize); arraySize = (int)outputData.size(); return (void*)(&outputData); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&outputData[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TssObject::GetTypeId() const
{
    return TpmTypeId::TssObject_ID;
};
/// <summary>
/// Contains the public and the plaintext-sensitive and/or encrypted private part of a TPM key (or other object)
/// </summary>
TssObject::TssObject()
{
    return;
};
TssObject::TssObject
(
    const TPMT_PUBLIC& _Public,
    const TPMT_SENSITIVE& _Sensitive,
    const TPM2B_PRIVATE& _Private
)
{
    Public= _Public;
    Sensitive= _Sensitive;
    Private= _Private;
};
/// <summary>
/// Contains the public and the plaintext-sensitive and/or encrypted private part of a TPM key (or other object)
/// </summary>
TssObject::~TssObject()
{
    return;
};
/// <summary>
/// Contains the public and the plaintext-sensitive and/or encrypted private part of a TPM key (or other object)
/// </summary>
TssObject& TssObject::operator=(const TssObject& rhs)
{
    if(this == &rhs) return *this;
    this->Public = rhs.Public;
    this->Sensitive = rhs.Sensitive;
    this->Private = rhs.Private;
    return *this;
};
/// <summary>
/// Contains the public and the plaintext-sensitive and/or encrypted private part of a TPM key (or other object)
/// </summary>
TssObject::TssObject(const TssObject& r)
{
    this->Public = r.Public;
    this->Sensitive = r.Sensitive;
    this->Private = r.Private;
};
/// <summary>
/// Contains the public and the plaintext-sensitive and/or encrypted private part of a TPM key (or other object)
/// </summary>
TpmStructureBase* TssObject::Clone() const
{
    TssObject* _x = new TssObject(*this);
    return _x;
};
void* TssObject::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&Public); return (void*) (&Public);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&Sensitive); return (void*) (&Sensitive);
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&Private); return (void*) (&Private);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId PcrValue::GetTypeId() const
{
    return TpmTypeId::PcrValue_ID;
};
/// <summary>
/// Contains a PCR index and associated hash(pcr-value) [TSS]
/// </summary>
PcrValue::PcrValue()
{
    return;
};
PcrValue::PcrValue
(
    const UINT32& _index,
    const TPMT_HA& _value
)
{
    index= _index;
    value= _value;
};
/// <summary>
/// Contains a PCR index and associated hash(pcr-value) [TSS]
/// </summary>
PcrValue::~PcrValue()
{
    return;
};
/// <summary>
/// Contains a PCR index and associated hash(pcr-value) [TSS]
/// </summary>
PcrValue& PcrValue::operator=(const PcrValue& rhs)
{
    if(this == &rhs) return *this;
    this->index = rhs.index;
    this->value = rhs.value;
    return *this;
};
/// <summary>
/// Contains a PCR index and associated hash(pcr-value) [TSS]
/// </summary>
PcrValue::PcrValue(const PcrValue& r)
{
    this->index = r.index;
    this->value = r.value;
};
/// <summary>
/// Contains a PCR index and associated hash(pcr-value) [TSS]
/// </summary>
TpmStructureBase* PcrValue::Clone() const
{
    PcrValue* _x = new PcrValue(*this);
    return _x;
};
void* PcrValue::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&index);
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&value); return (void*) (&value);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId SessionIn::GetTypeId() const
{
    return TpmTypeId::SessionIn_ID;
};
/// <summary>
/// Structure representing a session block in a command buffer [TSS]
/// </summary>
SessionIn::SessionIn()
{
    return;
};
SessionIn::SessionIn
(
    const TPM_HANDLE& _handle,
    const std::vector<BYTE>& _nonceCaller,
    const TPMA_SESSION& _attributes,
    const std::vector<BYTE>& _auth
)
{
    handle= _handle;
    nonceCaller= _nonceCaller;
    attributes= _attributes;
    auth= _auth;
};
/// <summary>
/// Structure representing a session block in a command buffer [TSS]
/// </summary>
SessionIn::~SessionIn()
{
    return;
};
/// <summary>
/// Structure representing a session block in a command buffer [TSS]
/// </summary>
SessionIn& SessionIn::operator=(const SessionIn& rhs)
{
    if(this == &rhs) return *this;
    this->handle = rhs.handle;
    this->nonceCallerSize = rhs.nonceCallerSize;
    this->nonceCaller = rhs.nonceCaller;
    this->attributes = rhs.attributes;
    this->authSize = rhs.authSize;
    this->auth = rhs.auth;
    return *this;
};
/// <summary>
/// Structure representing a session block in a command buffer [TSS]
/// </summary>
SessionIn::SessionIn(const SessionIn& r)
{
    this->handle = r.handle;
    this->nonceCallerSize = r.nonceCallerSize;
    this->nonceCaller = r.nonceCaller;
    this->attributes = r.attributes;
    this->authSize = r.authSize;
    this->auth = r.auth;
};
/// <summary>
/// Structure representing a session block in a command buffer [TSS]
/// </summary>
TpmStructureBase* SessionIn::Clone() const
{
    SessionIn* _x = new SessionIn(*this);
    return _x;
};
void* SessionIn::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return (void*) (&handle);
            case 1: return (void*) (&nonceCallerSize);
            case 2: { if(newArraySize != -1)nonceCaller.resize(newArraySize); arraySize = (int)nonceCaller.size(); return (void*)(&nonceCaller); }
            case 3: return (void*) (&attributes);
            case 4: return (void*) (&authSize);
            case 5: { if(newArraySize != -1)auth.resize(newArraySize); arraySize = (int)auth.size(); return (void*)(&auth); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&nonceCaller[arrayIndex]);
            case 5: return (void*)(&auth[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId SessionOut::GetTypeId() const
{
    return TpmTypeId::SessionOut_ID;
};
/// <summary>
/// Structure representing a session block in a response buffer [TSS]
/// </summary>
SessionOut::SessionOut()
{
    return;
};
SessionOut::SessionOut
(
    const std::vector<BYTE>& _nonceTpm,
    const TPMA_SESSION& _attributes,
    const std::vector<BYTE>& _auth
)
{
    nonceTpm= _nonceTpm;
    attributes= _attributes;
    auth= _auth;
};
/// <summary>
/// Structure representing a session block in a response buffer [TSS]
/// </summary>
SessionOut::~SessionOut()
{
    return;
};
/// <summary>
/// Structure representing a session block in a response buffer [TSS]
/// </summary>
SessionOut& SessionOut::operator=(const SessionOut& rhs)
{
    if(this == &rhs) return *this;
    this->nonceTpmSize = rhs.nonceTpmSize;
    this->nonceTpm = rhs.nonceTpm;
    this->attributes = rhs.attributes;
    this->authSize = rhs.authSize;
    this->auth = rhs.auth;
    return *this;
};
/// <summary>
/// Structure representing a session block in a response buffer [TSS]
/// </summary>
SessionOut::SessionOut(const SessionOut& r)
{
    this->nonceTpmSize = r.nonceTpmSize;
    this->nonceTpm = r.nonceTpm;
    this->attributes = r.attributes;
    this->authSize = r.authSize;
    this->auth = r.auth;
};
/// <summary>
/// Structure representing a session block in a response buffer [TSS]
/// </summary>
TpmStructureBase* SessionOut::Clone() const
{
    SessionOut* _x = new SessionOut(*this);
    return _x;
};
void* SessionOut::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&nonceTpmSize);
            case 1: { if(newArraySize != -1)nonceTpm.resize(newArraySize); arraySize = (int)nonceTpm.size(); return (void*)(&nonceTpm); }
            case 2: return (void*) (&attributes);
            case 3: return (void*) (&authSize);
            case 4: { if(newArraySize != -1)auth.resize(newArraySize); arraySize = (int)auth.size(); return (void*)(&auth); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&nonceTpm[arrayIndex]);
            case 4: return (void*)(&auth[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId CommandHeader::GetTypeId() const
{
    return TpmTypeId::CommandHeader_ID;
};
/// <summary>
/// Command header [TSS]
/// </summary>
CommandHeader::CommandHeader()
{
    return;
};
CommandHeader::CommandHeader
(
    const TPM_ST& _Tag,
    const UINT32& _CommandSize,
    const TPM_CC& _CommandCode
)
{
    Tag= _Tag;
    CommandSize= _CommandSize;
    CommandCode= _CommandCode;
};
/// <summary>
/// Command header [TSS]
/// </summary>
CommandHeader::~CommandHeader()
{
    return;
};
/// <summary>
/// Command header [TSS]
/// </summary>
CommandHeader& CommandHeader::operator=(const CommandHeader& rhs)
{
    if(this == &rhs) return *this;
    this->Tag = rhs.Tag;
    this->CommandSize = rhs.CommandSize;
    this->CommandCode = rhs.CommandCode;
    return *this;
};
/// <summary>
/// Command header [TSS]
/// </summary>
CommandHeader::CommandHeader(const CommandHeader& r)
{
    this->Tag = r.Tag;
    this->CommandSize = r.CommandSize;
    this->CommandCode = r.CommandCode;
};
/// <summary>
/// Command header [TSS]
/// </summary>
TpmStructureBase* CommandHeader::Clone() const
{
    CommandHeader* _x = new CommandHeader(*this);
    return _x;
};
void* CommandHeader::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&Tag);
            case 1: return (void*) (&CommandSize);
            case 2: return (void*) (&CommandCode);
            default: throw runtime_error("element out of range.");
        }
    } else {
    }
    return NULL;
};
TpmTypeId TSS_KEY::GetTypeId() const
{
    return TpmTypeId::TSS_KEY_ID;
};
/// <summary>
/// Contains the public and private part of a TPM key
/// </summary>
TSS_KEY::TSS_KEY()
{
    return;
};
TSS_KEY::TSS_KEY
(
    const TPMT_PUBLIC& _publicPart,
    const std::vector<BYTE>& _privatePart
)
{
    publicPart= _publicPart;
    privatePart= _privatePart;
};
/// <summary>
/// Contains the public and private part of a TPM key
/// </summary>
TSS_KEY::~TSS_KEY()
{
    return;
};
/// <summary>
/// Contains the public and private part of a TPM key
/// </summary>
TSS_KEY& TSS_KEY::operator=(const TSS_KEY& rhs)
{
    if(this == &rhs) return *this;
    this->publicPart = rhs.publicPart;
    this->privatePartSize = rhs.privatePartSize;
    this->privatePart = rhs.privatePart;
    TSS_KEY_CUSTOM_CLONE(this, rhs)
    return *this;
};
/// <summary>
/// Contains the public and private part of a TPM key
/// </summary>
TSS_KEY::TSS_KEY(const TSS_KEY& r)
{
    this->publicPart = r.publicPart;
    this->privatePartSize = r.privatePartSize;
    this->privatePart = r.privatePart;
    TSS_KEY_CUSTOM_CLONE(this, r)
};
/// <summary>
/// Contains the public and private part of a TPM key
/// </summary>
TpmStructureBase* TSS_KEY::Clone() const
{
    TSS_KEY* _x = new TSS_KEY(*this);
    return _x;
};
void* TSS_KEY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&publicPart); return (void*) (&publicPart);
            case 1: return (void*) (&privatePartSize);
            case 2: { if(newArraySize != -1)privatePart.resize(newArraySize); arraySize = (int)privatePart.size(); return (void*)(&privatePart); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 2: return (void*)(&privatePart[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_DIGEST_Symcipher::GetTypeId() const
{
    return TpmTypeId::TPM2B_DIGEST_Symcipher_ID;
};
/// <summary>
/// Auto-derived from TPM2B_DIGEST to provide unique GetUnionSelector() implementation
/// </summary>
TPM2B_DIGEST_Symcipher::TPM2B_DIGEST_Symcipher()
{
    return;
};
TPM2B_DIGEST_Symcipher::TPM2B_DIGEST_Symcipher
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// Auto-derived from TPM2B_DIGEST to provide unique GetUnionSelector() implementation
/// </summary>
TPM2B_DIGEST_Symcipher::~TPM2B_DIGEST_Symcipher()
{
    return;
};
/// <summary>
/// Auto-derived from TPM2B_DIGEST to provide unique GetUnionSelector() implementation
/// </summary>
TPM2B_DIGEST_Symcipher& TPM2B_DIGEST_Symcipher::operator=(const TPM2B_DIGEST_Symcipher& rhs)
{
    if(this == &rhs) return *this;
    (TPM2B_DIGEST&)*this = (TPM2B_DIGEST)rhs;
    return *this;
};
/// <summary>
/// Auto-derived from TPM2B_DIGEST to provide unique GetUnionSelector() implementation
/// </summary>
TPM2B_DIGEST_Symcipher::TPM2B_DIGEST_Symcipher(const TPM2B_DIGEST_Symcipher& r)
  : TPM2B_DIGEST(r)
{
};
/// <summary>
/// Auto-derived from TPM2B_DIGEST to provide unique GetUnionSelector() implementation
/// </summary>
TpmStructureBase* TPM2B_DIGEST_Symcipher::Clone() const
{
    TPM2B_DIGEST_Symcipher* _x = new TPM2B_DIGEST_Symcipher(*this);
    return _x;
};
void* TPM2B_DIGEST_Symcipher::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmTypeId TPM2B_DIGEST_Keyedhash::GetTypeId() const
{
    return TpmTypeId::TPM2B_DIGEST_Keyedhash_ID;
};
/// <summary>
/// Auto-derived from TPM2B_DIGEST
/// </summary>
TPM2B_DIGEST_Keyedhash::TPM2B_DIGEST_Keyedhash()
{
    return;
};
TPM2B_DIGEST_Keyedhash::TPM2B_DIGEST_Keyedhash
(
    const std::vector<BYTE>& _buffer
)
{
    buffer= _buffer;
};
/// <summary>
/// Auto-derived from TPM2B_DIGEST
/// </summary>
TPM2B_DIGEST_Keyedhash::~TPM2B_DIGEST_Keyedhash()
{
    return;
};
/// <summary>
/// Auto-derived from TPM2B_DIGEST
/// </summary>
TPM2B_DIGEST_Keyedhash& TPM2B_DIGEST_Keyedhash::operator=(const TPM2B_DIGEST_Keyedhash& rhs)
{
    if(this == &rhs) return *this;
    (TPM2B_DIGEST&)*this = (TPM2B_DIGEST)rhs;
    return *this;
};
/// <summary>
/// Auto-derived from TPM2B_DIGEST
/// </summary>
TPM2B_DIGEST_Keyedhash::TPM2B_DIGEST_Keyedhash(const TPM2B_DIGEST_Keyedhash& r)
  : TPM2B_DIGEST(r)
{
};
/// <summary>
/// Auto-derived from TPM2B_DIGEST
/// </summary>
TpmStructureBase* TPM2B_DIGEST_Keyedhash::Clone() const
{
    TPM2B_DIGEST_Keyedhash* _x = new TPM2B_DIGEST_Keyedhash(*this);
    return _x;
};
void* TPM2B_DIGEST_Keyedhash::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return (void*) (&size);
            case 1: { if(newArraySize != -1)buffer.resize(newArraySize); arraySize = (int)buffer.size(); return (void*)(&buffer); }
            default: throw runtime_error("element out of range.");
        }
    } else {
        switch(memIndex)
        {
            case 1: return (void*)(&buffer[arrayIndex]);
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
};
TpmStructureBase* TpmStructureBase::Factory(TpmTypeId id, TpmTypeId dynacastType, void*& pointerToUnion)
{
    TpmStructureBase* obj = NULL;
    pointerToUnion = NULL;
    switch(id) {
    case TpmTypeId::TPMS_NULL_UNION_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_NULL_UNION()  ); break;
    case TpmTypeId::TPMT_HA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMT_HA()  ); break;
    case TpmTypeId::TPM_HANDLE_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM_HANDLE()  ); break;
    case TpmTypeId::TPMS_EMPTY_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_EMPTY()  ); break;
    case TpmTypeId::TPMS_ALGORITHM_DESCRIPTION_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_ALGORITHM_DESCRIPTION()  ); break;
    case TpmTypeId::TPM2B_DIGEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_DIGEST()  ); break;
    case TpmTypeId::TPM2B_DATA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_DATA()  ); break;
    case TpmTypeId::TPM2B_NONCE_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_NONCE()  ); break;
    case TpmTypeId::TPM2B_AUTH_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_AUTH()  ); break;
    case TpmTypeId::TPM2B_OPERAND_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_OPERAND()  ); break;
    case TpmTypeId::TPM2B_EVENT_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_EVENT()  ); break;
    case TpmTypeId::TPM2B_MAX_BUFFER_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_MAX_BUFFER()  ); break;
    case TpmTypeId::TPM2B_MAX_NV_BUFFER_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_MAX_NV_BUFFER()  ); break;
    case TpmTypeId::TPM2B_TIMEOUT_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_TIMEOUT()  ); break;
    case TpmTypeId::TPM2B_IV_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_IV()  ); break;
    case TpmTypeId::TPM2B_NAME_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_NAME()  ); break;
    case TpmTypeId::TPMS_PCR_SELECT_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_PCR_SELECT()  ); break;
    case TpmTypeId::TPMS_PCR_SELECTION_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_PCR_SELECTION()  ); break;
    case TpmTypeId::TPMT_TK_CREATION_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMT_TK_CREATION()  ); break;
    case TpmTypeId::TPMT_TK_VERIFIED_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMT_TK_VERIFIED()  ); break;
    case TpmTypeId::TPMT_TK_AUTH_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMT_TK_AUTH()  ); break;
    case TpmTypeId::TPMT_TK_HASHCHECK_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMT_TK_HASHCHECK()  ); break;
    case TpmTypeId::TPMS_ALG_PROPERTY_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_ALG_PROPERTY()  ); break;
    case TpmTypeId::TPMS_TAGGED_PROPERTY_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_TAGGED_PROPERTY()  ); break;
    case TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_TAGGED_PCR_SELECT()  ); break;
    case TpmTypeId::TPMS_TAGGED_POLICY_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_TAGGED_POLICY()  ); break;
    case TpmTypeId::TPML_CC_ID: obj = dynamic_cast<TpmStructureBase*>( new TPML_CC()  ); break;
    case TpmTypeId::TPML_CCA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPML_CCA()  ); break;
    case TpmTypeId::TPML_ALG_ID: obj = dynamic_cast<TpmStructureBase*>( new TPML_ALG()  ); break;
    case TpmTypeId::TPML_HANDLE_ID: obj = dynamic_cast<TpmStructureBase*>( new TPML_HANDLE()  ); break;
    case TpmTypeId::TPML_DIGEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPML_DIGEST()  ); break;
    case TpmTypeId::TPML_DIGEST_VALUES_ID: obj = dynamic_cast<TpmStructureBase*>( new TPML_DIGEST_VALUES()  ); break;
    case TpmTypeId::TPML_PCR_SELECTION_ID: obj = dynamic_cast<TpmStructureBase*>( new TPML_PCR_SELECTION()  ); break;
    case TpmTypeId::TPML_ALG_PROPERTY_ID: obj = dynamic_cast<TpmStructureBase*>( new TPML_ALG_PROPERTY()  ); break;
    case TpmTypeId::TPML_TAGGED_TPM_PROPERTY_ID: obj = dynamic_cast<TpmStructureBase*>( new TPML_TAGGED_TPM_PROPERTY()  ); break;
    case TpmTypeId::TPML_TAGGED_PCR_PROPERTY_ID: obj = dynamic_cast<TpmStructureBase*>( new TPML_TAGGED_PCR_PROPERTY()  ); break;
    case TpmTypeId::TPML_ECC_CURVE_ID: obj = dynamic_cast<TpmStructureBase*>( new TPML_ECC_CURVE()  ); break;
    case TpmTypeId::TPML_TAGGED_POLICY_ID: obj = dynamic_cast<TpmStructureBase*>( new TPML_TAGGED_POLICY()  ); break;
    case TpmTypeId::TPMS_CAPABILITY_DATA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_CAPABILITY_DATA()  ); break;
    case TpmTypeId::TPMS_CLOCK_INFO_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_CLOCK_INFO()  ); break;
    case TpmTypeId::TPMS_TIME_INFO_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_TIME_INFO()  ); break;
    case TpmTypeId::TPMS_TIME_ATTEST_INFO_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_TIME_ATTEST_INFO()  ); break;
    case TpmTypeId::TPMS_CERTIFY_INFO_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_CERTIFY_INFO()  ); break;
    case TpmTypeId::TPMS_QUOTE_INFO_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_QUOTE_INFO()  ); break;
    case TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_COMMAND_AUDIT_INFO()  ); break;
    case TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SESSION_AUDIT_INFO()  ); break;
    case TpmTypeId::TPMS_CREATION_INFO_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_CREATION_INFO()  ); break;
    case TpmTypeId::TPMS_NV_CERTIFY_INFO_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_NV_CERTIFY_INFO()  ); break;
    case TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_NV_DIGEST_CERTIFY_INFO()  ); break;
    case TpmTypeId::TPMS_ATTEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_ATTEST()  ); break;
    case TpmTypeId::TPM2B_ATTEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_ATTEST()  ); break;
    case TpmTypeId::TPMS_AUTH_COMMAND_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_AUTH_COMMAND()  ); break;
    case TpmTypeId::AUTHResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new AUTHResponse()  ); break;
    case TpmTypeId::TPMS_NULL_SYM_KEY_BITS_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_NULL_SYM_KEY_BITS()  ); break;
    case TpmTypeId::TPMS_XOR_SYM_MODE_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_XOR_SYM_MODE()  ); break;
    case TpmTypeId::TPMS_NULL_SYM_MODE_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_NULL_SYM_MODE()  ); break;
    case TpmTypeId::TPMS_TDES_SYM_DETAILS_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_TDES_SYM_DETAILS()  ); break;
    case TpmTypeId::TPMS_AES_SYM_DETAILS_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_AES_SYM_DETAILS()  ); break;
    case TpmTypeId::TPMS_SM4_SYM_DETAILS_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SM4_SYM_DETAILS()  ); break;
    case TpmTypeId::TPMS_CAMELLIA_SYM_DETAILS_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_CAMELLIA_SYM_DETAILS()  ); break;
    case TpmTypeId::TPMS_ANY_SYM_DETAILS_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_ANY_SYM_DETAILS()  ); break;
    case TpmTypeId::TPMS_XOR_SYM_DETAILS_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_XOR_SYM_DETAILS()  ); break;
    case TpmTypeId::TPMS_NULL_SYM_DETAILS_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_NULL_SYM_DETAILS()  ); break;
    case TpmTypeId::TPMT_SYM_DEF_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMT_SYM_DEF()  ); break;
    case TpmTypeId::TPMT_SYM_DEF_OBJECT_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMT_SYM_DEF_OBJECT()  ); break;
    case TpmTypeId::TPM2B_SYM_KEY_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_SYM_KEY()  ); break;
    case TpmTypeId::TPMS_SYMCIPHER_PARMS_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SYMCIPHER_PARMS()  ); break;
    case TpmTypeId::TPM2B_LABEL_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_LABEL()  ); break;
    case TpmTypeId::TPMS_DERIVE_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_DERIVE()  ); break;
    case TpmTypeId::TPM2B_DERIVE_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_DERIVE()  ); break;
    case TpmTypeId::TPM2B_SENSITIVE_DATA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_SENSITIVE_DATA()  ); break;
    case TpmTypeId::TPMS_SENSITIVE_CREATE_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SENSITIVE_CREATE()  ); break;
    case TpmTypeId::TPM2B_SENSITIVE_CREATE_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_SENSITIVE_CREATE()  ); break;
    case TpmTypeId::TPMS_SCHEME_HASH_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SCHEME_HASH()  ); break;
    case TpmTypeId::TPMS_SCHEME_ECDAA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SCHEME_ECDAA()  ); break;
    case TpmTypeId::TPMS_SCHEME_HMAC_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SCHEME_HMAC()  ); break;
    case TpmTypeId::TPMS_SCHEME_XOR_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SCHEME_XOR()  ); break;
    case TpmTypeId::TPMS_NULL_SCHEME_KEYEDHASH_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_NULL_SCHEME_KEYEDHASH()  ); break;
    case TpmTypeId::TPMT_KEYEDHASH_SCHEME_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMT_KEYEDHASH_SCHEME()  ); break;
    case TpmTypeId::TPMS_SIG_SCHEME_RSASSA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SIG_SCHEME_RSASSA()  ); break;
    case TpmTypeId::TPMS_SIG_SCHEME_RSAPSS_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SIG_SCHEME_RSAPSS()  ); break;
    case TpmTypeId::TPMS_SIG_SCHEME_ECDSA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SIG_SCHEME_ECDSA()  ); break;
    case TpmTypeId::TPMS_SIG_SCHEME_SM2_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SIG_SCHEME_SM2()  ); break;
    case TpmTypeId::TPMS_SIG_SCHEME_ECSCHNORR_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SIG_SCHEME_ECSCHNORR()  ); break;
    case TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SIG_SCHEME_ECDAA()  ); break;
    case TpmTypeId::TPMS_NULL_SIG_SCHEME_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_NULL_SIG_SCHEME()  ); break;
    case TpmTypeId::TPMT_SIG_SCHEME_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMT_SIG_SCHEME()  ); break;
    case TpmTypeId::TPMS_ENC_SCHEME_OAEP_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_ENC_SCHEME_OAEP()  ); break;
    case TpmTypeId::TPMS_ENC_SCHEME_RSAES_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_ENC_SCHEME_RSAES()  ); break;
    case TpmTypeId::TPMS_KEY_SCHEME_ECDH_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_KEY_SCHEME_ECDH()  ); break;
    case TpmTypeId::TPMS_KEY_SCHEME_ECMQV_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_KEY_SCHEME_ECMQV()  ); break;
    case TpmTypeId::TPMS_SCHEME_MGF1_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SCHEME_MGF1()  ); break;
    case TpmTypeId::TPMS_SCHEME_KDF1_SP800_56A_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SCHEME_KDF1_SP800_56A()  ); break;
    case TpmTypeId::TPMS_SCHEME_KDF2_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SCHEME_KDF2()  ); break;
    case TpmTypeId::TPMS_SCHEME_KDF1_SP800_108_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SCHEME_KDF1_SP800_108()  ); break;
    case TpmTypeId::TPMS_NULL_KDF_SCHEME_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_NULL_KDF_SCHEME()  ); break;
    case TpmTypeId::TPMT_KDF_SCHEME_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMT_KDF_SCHEME()  ); break;
    case TpmTypeId::TPMS_NULL_ASYM_SCHEME_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_NULL_ASYM_SCHEME()  ); break;
    case TpmTypeId::TPMT_ASYM_SCHEME_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMT_ASYM_SCHEME()  ); break;
    case TpmTypeId::TPMT_RSA_SCHEME_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMT_RSA_SCHEME()  ); break;
    case TpmTypeId::TPMT_RSA_DECRYPT_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMT_RSA_DECRYPT()  ); break;
    case TpmTypeId::TPM2B_PUBLIC_KEY_RSA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_PUBLIC_KEY_RSA()  ); break;
    case TpmTypeId::TPM2B_PRIVATE_KEY_RSA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_PRIVATE_KEY_RSA()  ); break;
    case TpmTypeId::TPM2B_ECC_PARAMETER_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_ECC_PARAMETER()  ); break;
    case TpmTypeId::TPMS_ECC_POINT_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_ECC_POINT()  ); break;
    case TpmTypeId::TPM2B_ECC_POINT_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_ECC_POINT()  ); break;
    case TpmTypeId::TPMT_ECC_SCHEME_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMT_ECC_SCHEME()  ); break;
    case TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_ALGORITHM_DETAIL_ECC()  ); break;
    case TpmTypeId::TPMS_SIGNATURE_RSA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SIGNATURE_RSA()  ); break;
    case TpmTypeId::TPMS_SIGNATURE_RSASSA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SIGNATURE_RSASSA()  ); break;
    case TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SIGNATURE_RSAPSS()  ); break;
    case TpmTypeId::TPMS_SIGNATURE_ECC_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SIGNATURE_ECC()  ); break;
    case TpmTypeId::TPMS_SIGNATURE_ECDSA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SIGNATURE_ECDSA()  ); break;
    case TpmTypeId::TPMS_SIGNATURE_ECDAA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SIGNATURE_ECDAA()  ); break;
    case TpmTypeId::TPMS_SIGNATURE_SM2_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SIGNATURE_SM2()  ); break;
    case TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_SIGNATURE_ECSCHNORR()  ); break;
    case TpmTypeId::TPMS_NULL_SIGNATURE_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_NULL_SIGNATURE()  ); break;
    case TpmTypeId::TPMT_SIGNATURE_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMT_SIGNATURE()  ); break;
    case TpmTypeId::TPM2B_ENCRYPTED_SECRET_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_ENCRYPTED_SECRET()  ); break;
    case TpmTypeId::TPMS_KEYEDHASH_PARMS_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_KEYEDHASH_PARMS()  ); break;
    case TpmTypeId::TPMS_ASYM_PARMS_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_ASYM_PARMS()  ); break;
    case TpmTypeId::TPMS_RSA_PARMS_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_RSA_PARMS()  ); break;
    case TpmTypeId::TPMS_ECC_PARMS_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_ECC_PARMS()  ); break;
    case TpmTypeId::TPMT_PUBLIC_PARMS_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMT_PUBLIC_PARMS()  ); break;
    case TpmTypeId::TPMT_PUBLIC_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMT_PUBLIC()  ); break;
    case TpmTypeId::TPM2B_PUBLIC_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_PUBLIC()  ); break;
    case TpmTypeId::TPM2B_TEMPLATE_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_TEMPLATE()  ); break;
    case TpmTypeId::TPM2B_PRIVATE_VENDOR_SPECIFIC_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_PRIVATE_VENDOR_SPECIFIC()  ); break;
    case TpmTypeId::TPMT_SENSITIVE_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMT_SENSITIVE()  ); break;
    case TpmTypeId::TPM2B_SENSITIVE_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_SENSITIVE()  ); break;
    case TpmTypeId::_PRIVATE_ID: obj = dynamic_cast<TpmStructureBase*>( new _PRIVATE()  ); break;
    case TpmTypeId::TPM2B_PRIVATE_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_PRIVATE()  ); break;
    case TpmTypeId::TPMS_ID_OBJECT_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_ID_OBJECT()  ); break;
    case TpmTypeId::TPM2B_ID_OBJECT_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_ID_OBJECT()  ); break;
    case TpmTypeId::TPMS_NV_PIN_COUNTER_PARAMETERS_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_NV_PIN_COUNTER_PARAMETERS()  ); break;
    case TpmTypeId::TPMS_NV_PUBLIC_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_NV_PUBLIC()  ); break;
    case TpmTypeId::TPM2B_NV_PUBLIC_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_NV_PUBLIC()  ); break;
    case TpmTypeId::TPM2B_CONTEXT_SENSITIVE_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_CONTEXT_SENSITIVE()  ); break;
    case TpmTypeId::TPMS_CONTEXT_DATA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_CONTEXT_DATA()  ); break;
    case TpmTypeId::TPM2B_CONTEXT_DATA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_CONTEXT_DATA()  ); break;
    case TpmTypeId::TPMS_CONTEXT_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_CONTEXT()  ); break;
    case TpmTypeId::TPMS_CREATION_DATA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_CREATION_DATA()  ); break;
    case TpmTypeId::TPM2B_CREATION_DATA_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_CREATION_DATA()  ); break;
    case TpmTypeId::TPMS_AC_OUTPUT_ID: obj = dynamic_cast<TpmStructureBase*>( new TPMS_AC_OUTPUT()  ); break;
    case TpmTypeId::TPML_AC_CAPABILITIES_ID: obj = dynamic_cast<TpmStructureBase*>( new TPML_AC_CAPABILITIES()  ); break;
    case TpmTypeId::TPM2_Startup_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_Startup_REQUEST()  ); break;
    case TpmTypeId::StartupResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new StartupResponse()  ); break;
    case TpmTypeId::TPM2_Shutdown_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_Shutdown_REQUEST()  ); break;
    case TpmTypeId::ShutdownResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new ShutdownResponse()  ); break;
    case TpmTypeId::TPM2_SelfTest_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_SelfTest_REQUEST()  ); break;
    case TpmTypeId::SelfTestResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new SelfTestResponse()  ); break;
    case TpmTypeId::TPM2_IncrementalSelfTest_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_IncrementalSelfTest_REQUEST()  ); break;
    case TpmTypeId::IncrementalSelfTestResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new IncrementalSelfTestResponse()  ); break;
    case TpmTypeId::TPM2_GetTestResult_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_GetTestResult_REQUEST()  ); break;
    case TpmTypeId::GetTestResultResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new GetTestResultResponse()  ); break;
    case TpmTypeId::TPM2_StartAuthSession_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_StartAuthSession_REQUEST()  ); break;
    case TpmTypeId::StartAuthSessionResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new StartAuthSessionResponse()  ); break;
    case TpmTypeId::TPM2_PolicyRestart_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyRestart_REQUEST()  ); break;
    case TpmTypeId::PolicyRestartResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyRestartResponse()  ); break;
    case TpmTypeId::TPM2_Create_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_Create_REQUEST()  ); break;
    case TpmTypeId::CreateResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new CreateResponse()  ); break;
    case TpmTypeId::TPM2_Load_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_Load_REQUEST()  ); break;
    case TpmTypeId::LoadResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new LoadResponse()  ); break;
    case TpmTypeId::TPM2_LoadExternal_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_LoadExternal_REQUEST()  ); break;
    case TpmTypeId::LoadExternalResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new LoadExternalResponse()  ); break;
    case TpmTypeId::TPM2_ReadPublic_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_ReadPublic_REQUEST()  ); break;
    case TpmTypeId::ReadPublicResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new ReadPublicResponse()  ); break;
    case TpmTypeId::TPM2_ActivateCredential_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_ActivateCredential_REQUEST()  ); break;
    case TpmTypeId::ActivateCredentialResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new ActivateCredentialResponse()  ); break;
    case TpmTypeId::TPM2_MakeCredential_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_MakeCredential_REQUEST()  ); break;
    case TpmTypeId::MakeCredentialResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new MakeCredentialResponse()  ); break;
    case TpmTypeId::TPM2_Unseal_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_Unseal_REQUEST()  ); break;
    case TpmTypeId::UnsealResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new UnsealResponse()  ); break;
    case TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_ObjectChangeAuth_REQUEST()  ); break;
    case TpmTypeId::ObjectChangeAuthResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new ObjectChangeAuthResponse()  ); break;
    case TpmTypeId::TPM2_CreateLoaded_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_CreateLoaded_REQUEST()  ); break;
    case TpmTypeId::CreateLoadedResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new CreateLoadedResponse()  ); break;
    case TpmTypeId::TPM2_Duplicate_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_Duplicate_REQUEST()  ); break;
    case TpmTypeId::DuplicateResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new DuplicateResponse()  ); break;
    case TpmTypeId::TPM2_Rewrap_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_Rewrap_REQUEST()  ); break;
    case TpmTypeId::RewrapResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new RewrapResponse()  ); break;
    case TpmTypeId::TPM2_Import_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_Import_REQUEST()  ); break;
    case TpmTypeId::ImportResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new ImportResponse()  ); break;
    case TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_RSA_Encrypt_REQUEST()  ); break;
    case TpmTypeId::RSA_EncryptResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new RSA_EncryptResponse()  ); break;
    case TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_RSA_Decrypt_REQUEST()  ); break;
    case TpmTypeId::RSA_DecryptResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new RSA_DecryptResponse()  ); break;
    case TpmTypeId::TPM2_ECDH_KeyGen_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_ECDH_KeyGen_REQUEST()  ); break;
    case TpmTypeId::ECDH_KeyGenResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new ECDH_KeyGenResponse()  ); break;
    case TpmTypeId::TPM2_ECDH_ZGen_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_ECDH_ZGen_REQUEST()  ); break;
    case TpmTypeId::ECDH_ZGenResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new ECDH_ZGenResponse()  ); break;
    case TpmTypeId::TPM2_ECC_Parameters_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_ECC_Parameters_REQUEST()  ); break;
    case TpmTypeId::ECC_ParametersResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new ECC_ParametersResponse()  ); break;
    case TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_ZGen_2Phase_REQUEST()  ); break;
    case TpmTypeId::ZGen_2PhaseResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new ZGen_2PhaseResponse()  ); break;
    case TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_EncryptDecrypt_REQUEST()  ); break;
    case TpmTypeId::EncryptDecryptResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new EncryptDecryptResponse()  ); break;
    case TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_EncryptDecrypt2_REQUEST()  ); break;
    case TpmTypeId::EncryptDecrypt2Response_ID: obj = dynamic_cast<TpmStructureBase*>( new EncryptDecrypt2Response()  ); break;
    case TpmTypeId::TPM2_Hash_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_Hash_REQUEST()  ); break;
    case TpmTypeId::HashResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new HashResponse()  ); break;
    case TpmTypeId::TPM2_HMAC_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_HMAC_REQUEST()  ); break;
    case TpmTypeId::HMACResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new HMACResponse()  ); break;
    case TpmTypeId::TPM2_MAC_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_MAC_REQUEST()  ); break;
    case TpmTypeId::MACResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new MACResponse()  ); break;
    case TpmTypeId::TPM2_GetRandom_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_GetRandom_REQUEST()  ); break;
    case TpmTypeId::GetRandomResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new GetRandomResponse()  ); break;
    case TpmTypeId::TPM2_StirRandom_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_StirRandom_REQUEST()  ); break;
    case TpmTypeId::StirRandomResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new StirRandomResponse()  ); break;
    case TpmTypeId::TPM2_HMAC_Start_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_HMAC_Start_REQUEST()  ); break;
    case TpmTypeId::HMAC_StartResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new HMAC_StartResponse()  ); break;
    case TpmTypeId::TPM2_MAC_Start_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_MAC_Start_REQUEST()  ); break;
    case TpmTypeId::MAC_StartResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new MAC_StartResponse()  ); break;
    case TpmTypeId::TPM2_HashSequenceStart_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_HashSequenceStart_REQUEST()  ); break;
    case TpmTypeId::HashSequenceStartResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new HashSequenceStartResponse()  ); break;
    case TpmTypeId::TPM2_SequenceUpdate_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_SequenceUpdate_REQUEST()  ); break;
    case TpmTypeId::SequenceUpdateResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new SequenceUpdateResponse()  ); break;
    case TpmTypeId::TPM2_SequenceComplete_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_SequenceComplete_REQUEST()  ); break;
    case TpmTypeId::SequenceCompleteResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new SequenceCompleteResponse()  ); break;
    case TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_EventSequenceComplete_REQUEST()  ); break;
    case TpmTypeId::EventSequenceCompleteResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new EventSequenceCompleteResponse()  ); break;
    case TpmTypeId::TPM2_Certify_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_Certify_REQUEST()  ); break;
    case TpmTypeId::CertifyResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new CertifyResponse()  ); break;
    case TpmTypeId::TPM2_CertifyCreation_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_CertifyCreation_REQUEST()  ); break;
    case TpmTypeId::CertifyCreationResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new CertifyCreationResponse()  ); break;
    case TpmTypeId::TPM2_Quote_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_Quote_REQUEST()  ); break;
    case TpmTypeId::QuoteResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new QuoteResponse()  ); break;
    case TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_GetSessionAuditDigest_REQUEST()  ); break;
    case TpmTypeId::GetSessionAuditDigestResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new GetSessionAuditDigestResponse()  ); break;
    case TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_GetCommandAuditDigest_REQUEST()  ); break;
    case TpmTypeId::GetCommandAuditDigestResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new GetCommandAuditDigestResponse()  ); break;
    case TpmTypeId::TPM2_GetTime_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_GetTime_REQUEST()  ); break;
    case TpmTypeId::GetTimeResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new GetTimeResponse()  ); break;
    case TpmTypeId::TPM2_CertifyX509_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_CertifyX509_REQUEST()  ); break;
    case TpmTypeId::CertifyX509Response_ID: obj = dynamic_cast<TpmStructureBase*>( new CertifyX509Response()  ); break;
    case TpmTypeId::TPM2_Commit_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_Commit_REQUEST()  ); break;
    case TpmTypeId::CommitResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new CommitResponse()  ); break;
    case TpmTypeId::TPM2_EC_Ephemeral_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_EC_Ephemeral_REQUEST()  ); break;
    case TpmTypeId::EC_EphemeralResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new EC_EphemeralResponse()  ); break;
    case TpmTypeId::TPM2_VerifySignature_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_VerifySignature_REQUEST()  ); break;
    case TpmTypeId::VerifySignatureResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new VerifySignatureResponse()  ); break;
    case TpmTypeId::TPM2_Sign_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_Sign_REQUEST()  ); break;
    case TpmTypeId::SignResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new SignResponse()  ); break;
    case TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_SetCommandCodeAuditStatus_REQUEST()  ); break;
    case TpmTypeId::SetCommandCodeAuditStatusResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new SetCommandCodeAuditStatusResponse()  ); break;
    case TpmTypeId::TPM2_PCR_Extend_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PCR_Extend_REQUEST()  ); break;
    case TpmTypeId::PCR_ExtendResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PCR_ExtendResponse()  ); break;
    case TpmTypeId::TPM2_PCR_Event_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PCR_Event_REQUEST()  ); break;
    case TpmTypeId::PCR_EventResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PCR_EventResponse()  ); break;
    case TpmTypeId::TPM2_PCR_Read_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PCR_Read_REQUEST()  ); break;
    case TpmTypeId::PCR_ReadResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PCR_ReadResponse()  ); break;
    case TpmTypeId::TPM2_PCR_Allocate_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PCR_Allocate_REQUEST()  ); break;
    case TpmTypeId::PCR_AllocateResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PCR_AllocateResponse()  ); break;
    case TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PCR_SetAuthPolicy_REQUEST()  ); break;
    case TpmTypeId::PCR_SetAuthPolicyResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PCR_SetAuthPolicyResponse()  ); break;
    case TpmTypeId::TPM2_PCR_SetAuthValue_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PCR_SetAuthValue_REQUEST()  ); break;
    case TpmTypeId::PCR_SetAuthValueResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PCR_SetAuthValueResponse()  ); break;
    case TpmTypeId::TPM2_PCR_Reset_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PCR_Reset_REQUEST()  ); break;
    case TpmTypeId::PCR_ResetResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PCR_ResetResponse()  ); break;
    case TpmTypeId::TPM2_PolicySigned_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicySigned_REQUEST()  ); break;
    case TpmTypeId::PolicySignedResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicySignedResponse()  ); break;
    case TpmTypeId::TPM2_PolicySecret_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicySecret_REQUEST()  ); break;
    case TpmTypeId::PolicySecretResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicySecretResponse()  ); break;
    case TpmTypeId::TPM2_PolicyTicket_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyTicket_REQUEST()  ); break;
    case TpmTypeId::PolicyTicketResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyTicketResponse()  ); break;
    case TpmTypeId::TPM2_PolicyOR_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyOR_REQUEST()  ); break;
    case TpmTypeId::PolicyORResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyORResponse()  ); break;
    case TpmTypeId::TPM2_PolicyPCR_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyPCR_REQUEST()  ); break;
    case TpmTypeId::PolicyPCRResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyPCRResponse()  ); break;
    case TpmTypeId::TPM2_PolicyLocality_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyLocality_REQUEST()  ); break;
    case TpmTypeId::PolicyLocalityResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyLocalityResponse()  ); break;
    case TpmTypeId::TPM2_PolicyNV_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyNV_REQUEST()  ); break;
    case TpmTypeId::PolicyNVResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyNVResponse()  ); break;
    case TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyCounterTimer_REQUEST()  ); break;
    case TpmTypeId::PolicyCounterTimerResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyCounterTimerResponse()  ); break;
    case TpmTypeId::TPM2_PolicyCommandCode_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyCommandCode_REQUEST()  ); break;
    case TpmTypeId::PolicyCommandCodeResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyCommandCodeResponse()  ); break;
    case TpmTypeId::TPM2_PolicyPhysicalPresence_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyPhysicalPresence_REQUEST()  ); break;
    case TpmTypeId::PolicyPhysicalPresenceResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyPhysicalPresenceResponse()  ); break;
    case TpmTypeId::TPM2_PolicyCpHash_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyCpHash_REQUEST()  ); break;
    case TpmTypeId::PolicyCpHashResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyCpHashResponse()  ); break;
    case TpmTypeId::TPM2_PolicyNameHash_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyNameHash_REQUEST()  ); break;
    case TpmTypeId::PolicyNameHashResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyNameHashResponse()  ); break;
    case TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyDuplicationSelect_REQUEST()  ); break;
    case TpmTypeId::PolicyDuplicationSelectResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyDuplicationSelectResponse()  ); break;
    case TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyAuthorize_REQUEST()  ); break;
    case TpmTypeId::PolicyAuthorizeResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyAuthorizeResponse()  ); break;
    case TpmTypeId::TPM2_PolicyAuthValue_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyAuthValue_REQUEST()  ); break;
    case TpmTypeId::PolicyAuthValueResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyAuthValueResponse()  ); break;
    case TpmTypeId::TPM2_PolicyPassword_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyPassword_REQUEST()  ); break;
    case TpmTypeId::PolicyPasswordResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyPasswordResponse()  ); break;
    case TpmTypeId::TPM2_PolicyGetDigest_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyGetDigest_REQUEST()  ); break;
    case TpmTypeId::PolicyGetDigestResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyGetDigestResponse()  ); break;
    case TpmTypeId::TPM2_PolicyNvWritten_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyNvWritten_REQUEST()  ); break;
    case TpmTypeId::PolicyNvWrittenResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyNvWrittenResponse()  ); break;
    case TpmTypeId::TPM2_PolicyTemplate_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyTemplate_REQUEST()  ); break;
    case TpmTypeId::PolicyTemplateResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyTemplateResponse()  ); break;
    case TpmTypeId::TPM2_PolicyAuthorizeNV_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PolicyAuthorizeNV_REQUEST()  ); break;
    case TpmTypeId::PolicyAuthorizeNVResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PolicyAuthorizeNVResponse()  ); break;
    case TpmTypeId::TPM2_CreatePrimary_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_CreatePrimary_REQUEST()  ); break;
    case TpmTypeId::CreatePrimaryResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new CreatePrimaryResponse()  ); break;
    case TpmTypeId::TPM2_HierarchyControl_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_HierarchyControl_REQUEST()  ); break;
    case TpmTypeId::HierarchyControlResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new HierarchyControlResponse()  ); break;
    case TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_SetPrimaryPolicy_REQUEST()  ); break;
    case TpmTypeId::SetPrimaryPolicyResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new SetPrimaryPolicyResponse()  ); break;
    case TpmTypeId::TPM2_ChangePPS_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_ChangePPS_REQUEST()  ); break;
    case TpmTypeId::ChangePPSResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new ChangePPSResponse()  ); break;
    case TpmTypeId::TPM2_ChangeEPS_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_ChangeEPS_REQUEST()  ); break;
    case TpmTypeId::ChangeEPSResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new ChangeEPSResponse()  ); break;
    case TpmTypeId::TPM2_Clear_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_Clear_REQUEST()  ); break;
    case TpmTypeId::ClearResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new ClearResponse()  ); break;
    case TpmTypeId::TPM2_ClearControl_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_ClearControl_REQUEST()  ); break;
    case TpmTypeId::ClearControlResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new ClearControlResponse()  ); break;
    case TpmTypeId::TPM2_HierarchyChangeAuth_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_HierarchyChangeAuth_REQUEST()  ); break;
    case TpmTypeId::HierarchyChangeAuthResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new HierarchyChangeAuthResponse()  ); break;
    case TpmTypeId::TPM2_DictionaryAttackLockReset_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_DictionaryAttackLockReset_REQUEST()  ); break;
    case TpmTypeId::DictionaryAttackLockResetResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new DictionaryAttackLockResetResponse()  ); break;
    case TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_DictionaryAttackParameters_REQUEST()  ); break;
    case TpmTypeId::DictionaryAttackParametersResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new DictionaryAttackParametersResponse()  ); break;
    case TpmTypeId::TPM2_PP_Commands_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_PP_Commands_REQUEST()  ); break;
    case TpmTypeId::PP_CommandsResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new PP_CommandsResponse()  ); break;
    case TpmTypeId::TPM2_SetAlgorithmSet_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_SetAlgorithmSet_REQUEST()  ); break;
    case TpmTypeId::SetAlgorithmSetResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new SetAlgorithmSetResponse()  ); break;
    case TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_FieldUpgradeStart_REQUEST()  ); break;
    case TpmTypeId::FieldUpgradeStartResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new FieldUpgradeStartResponse()  ); break;
    case TpmTypeId::TPM2_FieldUpgradeData_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_FieldUpgradeData_REQUEST()  ); break;
    case TpmTypeId::FieldUpgradeDataResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new FieldUpgradeDataResponse()  ); break;
    case TpmTypeId::TPM2_FirmwareRead_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_FirmwareRead_REQUEST()  ); break;
    case TpmTypeId::FirmwareReadResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new FirmwareReadResponse()  ); break;
    case TpmTypeId::TPM2_ContextSave_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_ContextSave_REQUEST()  ); break;
    case TpmTypeId::ContextSaveResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new ContextSaveResponse()  ); break;
    case TpmTypeId::TPM2_ContextLoad_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_ContextLoad_REQUEST()  ); break;
    case TpmTypeId::ContextLoadResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new ContextLoadResponse()  ); break;
    case TpmTypeId::TPM2_FlushContext_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_FlushContext_REQUEST()  ); break;
    case TpmTypeId::FlushContextResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new FlushContextResponse()  ); break;
    case TpmTypeId::TPM2_EvictControl_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_EvictControl_REQUEST()  ); break;
    case TpmTypeId::EvictControlResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new EvictControlResponse()  ); break;
    case TpmTypeId::TPM2_ReadClock_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_ReadClock_REQUEST()  ); break;
    case TpmTypeId::ReadClockResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new ReadClockResponse()  ); break;
    case TpmTypeId::TPM2_ClockSet_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_ClockSet_REQUEST()  ); break;
    case TpmTypeId::ClockSetResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new ClockSetResponse()  ); break;
    case TpmTypeId::TPM2_ClockRateAdjust_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_ClockRateAdjust_REQUEST()  ); break;
    case TpmTypeId::ClockRateAdjustResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new ClockRateAdjustResponse()  ); break;
    case TpmTypeId::TPM2_GetCapability_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_GetCapability_REQUEST()  ); break;
    case TpmTypeId::GetCapabilityResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new GetCapabilityResponse()  ); break;
    case TpmTypeId::TPM2_TestParms_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_TestParms_REQUEST()  ); break;
    case TpmTypeId::TestParmsResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new TestParmsResponse()  ); break;
    case TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_NV_DefineSpace_REQUEST()  ); break;
    case TpmTypeId::NV_DefineSpaceResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new NV_DefineSpaceResponse()  ); break;
    case TpmTypeId::TPM2_NV_UndefineSpace_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_NV_UndefineSpace_REQUEST()  ); break;
    case TpmTypeId::NV_UndefineSpaceResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new NV_UndefineSpaceResponse()  ); break;
    case TpmTypeId::TPM2_NV_UndefineSpaceSpecial_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_NV_UndefineSpaceSpecial_REQUEST()  ); break;
    case TpmTypeId::NV_UndefineSpaceSpecialResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new NV_UndefineSpaceSpecialResponse()  ); break;
    case TpmTypeId::TPM2_NV_ReadPublic_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_NV_ReadPublic_REQUEST()  ); break;
    case TpmTypeId::NV_ReadPublicResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new NV_ReadPublicResponse()  ); break;
    case TpmTypeId::TPM2_NV_Write_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_NV_Write_REQUEST()  ); break;
    case TpmTypeId::NV_WriteResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new NV_WriteResponse()  ); break;
    case TpmTypeId::TPM2_NV_Increment_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_NV_Increment_REQUEST()  ); break;
    case TpmTypeId::NV_IncrementResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new NV_IncrementResponse()  ); break;
    case TpmTypeId::TPM2_NV_Extend_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_NV_Extend_REQUEST()  ); break;
    case TpmTypeId::NV_ExtendResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new NV_ExtendResponse()  ); break;
    case TpmTypeId::TPM2_NV_SetBits_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_NV_SetBits_REQUEST()  ); break;
    case TpmTypeId::NV_SetBitsResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new NV_SetBitsResponse()  ); break;
    case TpmTypeId::TPM2_NV_WriteLock_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_NV_WriteLock_REQUEST()  ); break;
    case TpmTypeId::NV_WriteLockResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new NV_WriteLockResponse()  ); break;
    case TpmTypeId::TPM2_NV_GlobalWriteLock_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_NV_GlobalWriteLock_REQUEST()  ); break;
    case TpmTypeId::NV_GlobalWriteLockResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new NV_GlobalWriteLockResponse()  ); break;
    case TpmTypeId::TPM2_NV_Read_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_NV_Read_REQUEST()  ); break;
    case TpmTypeId::NV_ReadResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new NV_ReadResponse()  ); break;
    case TpmTypeId::TPM2_NV_ReadLock_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_NV_ReadLock_REQUEST()  ); break;
    case TpmTypeId::NV_ReadLockResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new NV_ReadLockResponse()  ); break;
    case TpmTypeId::TPM2_NV_ChangeAuth_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_NV_ChangeAuth_REQUEST()  ); break;
    case TpmTypeId::NV_ChangeAuthResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new NV_ChangeAuthResponse()  ); break;
    case TpmTypeId::TPM2_NV_Certify_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_NV_Certify_REQUEST()  ); break;
    case TpmTypeId::NV_CertifyResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new NV_CertifyResponse()  ); break;
    case TpmTypeId::TPM2_AC_GetCapability_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_AC_GetCapability_REQUEST()  ); break;
    case TpmTypeId::AC_GetCapabilityResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new AC_GetCapabilityResponse()  ); break;
    case TpmTypeId::TPM2_AC_Send_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_AC_Send_REQUEST()  ); break;
    case TpmTypeId::AC_SendResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new AC_SendResponse()  ); break;
    case TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_Policy_AC_SendSelect_REQUEST()  ); break;
    case TpmTypeId::Policy_AC_SendSelectResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new Policy_AC_SendSelectResponse()  ); break;
    case TpmTypeId::TPM2_Vendor_TCG_Test_REQUEST_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2_Vendor_TCG_Test_REQUEST()  ); break;
    case TpmTypeId::Vendor_TCG_TestResponse_ID: obj = dynamic_cast<TpmStructureBase*>( new Vendor_TCG_TestResponse()  ); break;
    case TpmTypeId::TssObject_ID: obj = dynamic_cast<TpmStructureBase*>( new TssObject()  ); break;
    case TpmTypeId::PcrValue_ID: obj = dynamic_cast<TpmStructureBase*>( new PcrValue()  ); break;
    case TpmTypeId::SessionIn_ID: obj = dynamic_cast<TpmStructureBase*>( new SessionIn()  ); break;
    case TpmTypeId::SessionOut_ID: obj = dynamic_cast<TpmStructureBase*>( new SessionOut()  ); break;
    case TpmTypeId::CommandHeader_ID: obj = dynamic_cast<TpmStructureBase*>( new CommandHeader()  ); break;
    case TpmTypeId::TSS_KEY_ID: obj = dynamic_cast<TpmStructureBase*>( new TSS_KEY()  ); break;
    case TpmTypeId::TPM2B_DIGEST_Symcipher_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_DIGEST_Symcipher()  ); break;
    case TpmTypeId::TPM2B_DIGEST_Keyedhash_ID: obj = dynamic_cast<TpmStructureBase*>( new TPM2B_DIGEST_Keyedhash()  ); break;
    default: throw new runtime_error("Factory only makes TPM structs and unions");
    };
    if(dynacastType==TpmTypeId::None) return obj;
    void* pUnion = NULL;
    switch(dynacastType) {
    case TpmTypeId::TPMU_HA_ID: pUnion = (void*) (dynamic_cast<TPMU_HA*>( obj)); break;
    case TpmTypeId::TPMU_NAME_ID: pUnion = (void*) (dynamic_cast<TPMU_NAME*>( obj)); break;
    case TpmTypeId::TPMU_CAPABILITIES_ID: pUnion = (void*) (dynamic_cast<TPMU_CAPABILITIES*>( obj)); break;
    case TpmTypeId::TPMU_ATTEST_ID: pUnion = (void*) (dynamic_cast<TPMU_ATTEST*>( obj)); break;
    case TpmTypeId::TPMU_SYM_KEY_BITS_ID: pUnion = (void*) (dynamic_cast<TPMU_SYM_KEY_BITS*>( obj)); break;
    case TpmTypeId::TPMU_SYM_MODE_ID: pUnion = (void*) (dynamic_cast<TPMU_SYM_MODE*>( obj)); break;
    case TpmTypeId::TPMU_SYM_DETAILS_ID: pUnion = (void*) (dynamic_cast<TPMU_SYM_DETAILS*>( obj)); break;
    case TpmTypeId::TPMU_SENSITIVE_CREATE_ID: pUnion = (void*) (dynamic_cast<TPMU_SENSITIVE_CREATE*>( obj)); break;
    case TpmTypeId::TPMU_SCHEME_KEYEDHASH_ID: pUnion = (void*) (dynamic_cast<TPMU_SCHEME_KEYEDHASH*>( obj)); break;
    case TpmTypeId::TPMU_SIG_SCHEME_ID: pUnion = (void*) (dynamic_cast<TPMU_SIG_SCHEME*>( obj)); break;
    case TpmTypeId::TPMU_KDF_SCHEME_ID: pUnion = (void*) (dynamic_cast<TPMU_KDF_SCHEME*>( obj)); break;
    case TpmTypeId::TPMU_ASYM_SCHEME_ID: pUnion = (void*) (dynamic_cast<TPMU_ASYM_SCHEME*>( obj)); break;
    case TpmTypeId::TPMU_SIGNATURE_ID: pUnion = (void*) (dynamic_cast<TPMU_SIGNATURE*>( obj)); break;
    case TpmTypeId::TPMU_ENCRYPTED_SECRET_ID: pUnion = (void*) (dynamic_cast<TPMU_ENCRYPTED_SECRET*>( obj)); break;
    case TpmTypeId::TPMU_PUBLIC_ID_ID: pUnion = (void*) (dynamic_cast<TPMU_PUBLIC_ID*>( obj)); break;
    case TpmTypeId::TPMU_PUBLIC_PARMS_ID: pUnion = (void*) (dynamic_cast<TPMU_PUBLIC_PARMS*>( obj)); break;
    case TpmTypeId::TPMU_SENSITIVE_COMPOSITE_ID: pUnion = (void*) (dynamic_cast<TPMU_SENSITIVE_COMPOSITE*>( obj)); break;
    default: throw new runtime_error("Factory only casts to TPM unions");
    };
    pointerToUnion=pUnion;
    return obj;
};
void StructMarshallInfo::TpmTypeInitter()
{
    StructMarshallInfo* sInf;
    //===================TPMS_NULL_UNION
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPMS_NULL_UNION_ID]=sInf;
    sInf->Name = "TPMS_NULL_UNION";
    sInf->MyTypeInfo=typeid(TPMS_NULL_UNION).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPMT_HA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMT_HA_ID]=sInf;
    sInf->Name = "TPMT_HA";
    sInf->MyTypeInfo=typeid(TPMT_HA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hashAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hashAlg";
    sInf->Fields[0].ParentTypeName = "TPMT_HA";
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    //digest
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::SpecialVariableLengthArray;
    sInf->Fields[1].ElementName = "digest";
    sInf->Fields[1].ParentTypeName = "TPMT_HA";
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM_HANDLE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM_HANDLE_ID]=sInf;
    sInf->Name = "TPM_HANDLE";
    sInf->MyTypeInfo=typeid(TPM_HANDLE).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //handle
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "handle";
    sInf->Fields[0].ParentTypeName = "TPM_HANDLE";
    sInf->Fields[0].ParentType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPMS_EMPTY
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPMS_EMPTY_ID]=sInf;
    sInf->Name = "TPMS_EMPTY";
    sInf->MyTypeInfo=typeid(TPMS_EMPTY).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPMS_ALGORITHM_DESCRIPTION
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMS_ALGORITHM_DESCRIPTION_ID]=sInf;
    sInf->Name = "TPMS_ALGORITHM_DESCRIPTION";
    sInf->MyTypeInfo=typeid(TPMS_ALGORITHM_DESCRIPTION).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //alg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "alg";
    sInf->Fields[0].ParentTypeName = "TPMS_ALGORITHM_DESCRIPTION";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ALGORITHM_DESCRIPTION_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    //attributes
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMA_ALGORITHM_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMA_ALGORITHM";
    sInf->Fields[1].ElementSize = sizeof(TPMA_ALGORITHM);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "attributes";
    sInf->Fields[1].ParentTypeName = "TPMS_ALGORITHM_DESCRIPTION";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_ALGORITHM_DESCRIPTION_ID;
    sInf->Fields[1].Sort = ElementSort::TpmBitfield;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPM2B_DIGEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_DIGEST_ID]=sInf;
    sInf->Name = "TPM2B_DIGEST";
    sInf->MyTypeInfo=typeid(TPM2B_DIGEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_DIGEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_DIGEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_DIGEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_DIGEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2B_DATA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_DATA_ID]=sInf;
    sInf->Name = "TPM2B_DATA";
    sInf->MyTypeInfo=typeid(TPM2B_DATA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_DATA";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_DATA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_DATA";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_DATA_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2B_EVENT
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_EVENT_ID]=sInf;
    sInf->Name = "TPM2B_EVENT";
    sInf->MyTypeInfo=typeid(TPM2B_EVENT).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_EVENT";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_EVENT_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_EVENT";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_EVENT_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2B_MAX_BUFFER
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_MAX_BUFFER_ID]=sInf;
    sInf->Name = "TPM2B_MAX_BUFFER";
    sInf->MyTypeInfo=typeid(TPM2B_MAX_BUFFER).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_MAX_BUFFER";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_MAX_BUFFER_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_MAX_BUFFER";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_MAX_BUFFER_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2B_MAX_NV_BUFFER
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_MAX_NV_BUFFER_ID]=sInf;
    sInf->Name = "TPM2B_MAX_NV_BUFFER";
    sInf->MyTypeInfo=typeid(TPM2B_MAX_NV_BUFFER).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_MAX_NV_BUFFER";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_MAX_NV_BUFFER_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_MAX_NV_BUFFER";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_MAX_NV_BUFFER_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2B_TIMEOUT
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_TIMEOUT_ID]=sInf;
    sInf->Name = "TPM2B_TIMEOUT";
    sInf->MyTypeInfo=typeid(TPM2B_TIMEOUT).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_TIMEOUT";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_TIMEOUT_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_TIMEOUT";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_TIMEOUT_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2B_IV
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_IV_ID]=sInf;
    sInf->Name = "TPM2B_IV";
    sInf->MyTypeInfo=typeid(TPM2B_IV).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_IV";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_IV_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_IV";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_IV_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2B_NAME
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_NAME_ID]=sInf;
    sInf->Name = "TPM2B_NAME";
    sInf->MyTypeInfo=typeid(TPM2B_NAME).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_NAME";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_NAME_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //name
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "name";
    sInf->Fields[1].ParentTypeName = "TPM2B_NAME";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_NAME_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMS_PCR_SELECT
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMS_PCR_SELECT_ID]=sInf;
    sInf->Name = "TPMS_PCR_SELECT";
    sInf->MyTypeInfo=typeid(TPMS_PCR_SELECT).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //sizeofSelect
    sInf->Fields[0].ThisElementType = TpmTypeId::byte_ID;
    sInf->Fields[0].ThisElementTypeName = "byte";
    sInf->Fields[0].ElementSize = sizeof(byte);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "sizeofSelect";
    sInf->Fields[0].ParentTypeName = "TPMS_PCR_SELECT";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_PCR_SELECT_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //pcrSelect
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "pcrSelect";
    sInf->Fields[1].ParentTypeName = "TPMS_PCR_SELECT";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_PCR_SELECT_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMS_PCR_SELECTION
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPMS_PCR_SELECTION_ID]=sInf;
    sInf->Name = "TPMS_PCR_SELECTION";
    sInf->MyTypeInfo=typeid(TPMS_PCR_SELECTION).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hash
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hash";
    sInf->Fields[0].ParentTypeName = "TPMS_PCR_SELECTION";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //sizeofSelect
    sInf->Fields[1].ThisElementType = TpmTypeId::byte_ID;
    sInf->Fields[1].ThisElementTypeName = "byte";
    sInf->Fields[1].ElementSize = sizeof(byte);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "sizeofSelect";
    sInf->Fields[1].ParentTypeName = "TPMS_PCR_SELECTION";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //pcrSelect
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "pcrSelect";
    sInf->Fields[2].ParentTypeName = "TPMS_PCR_SELECTION";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPMT_TK_CREATION
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPMT_TK_CREATION_ID]=sInf;
    sInf->Name = "TPMT_TK_CREATION";
    sInf->MyTypeInfo=typeid(TPMT_TK_CREATION).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //tag
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ST_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ST";
    sInf->Fields[0].ElementSize = sizeof(TPM_ST);
    sInf->Fields[0].ElementMarshallType = MarshallType::ConstantValue;
    sInf->Fields[0].ElementName = "tag";
    sInf->Fields[0].ParentTypeName = "TPMT_TK_CREATION";
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_TK_CREATION_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    //hierarchy
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "hierarchy";
    sInf->Fields[1].ParentTypeName = "TPMT_TK_CREATION";
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_TK_CREATION_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //digestSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "digestSize";
    sInf->Fields[2].ParentTypeName = "TPMT_TK_CREATION";
    sInf->Fields[2].ParentType = TpmTypeId::TPMT_TK_CREATION_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //digest
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "digest";
    sInf->Fields[3].ParentTypeName = "TPMT_TK_CREATION";
    sInf->Fields[3].ParentType = TpmTypeId::TPMT_TK_CREATION_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPMT_TK_VERIFIED
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPMT_TK_VERIFIED_ID]=sInf;
    sInf->Name = "TPMT_TK_VERIFIED";
    sInf->MyTypeInfo=typeid(TPMT_TK_VERIFIED).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //tag
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ST_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ST";
    sInf->Fields[0].ElementSize = sizeof(TPM_ST);
    sInf->Fields[0].ElementMarshallType = MarshallType::ConstantValue;
    sInf->Fields[0].ElementName = "tag";
    sInf->Fields[0].ParentTypeName = "TPMT_TK_VERIFIED";
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_TK_VERIFIED_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    //hierarchy
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "hierarchy";
    sInf->Fields[1].ParentTypeName = "TPMT_TK_VERIFIED";
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_TK_VERIFIED_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //digestSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "digestSize";
    sInf->Fields[2].ParentTypeName = "TPMT_TK_VERIFIED";
    sInf->Fields[2].ParentType = TpmTypeId::TPMT_TK_VERIFIED_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //digest
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "digest";
    sInf->Fields[3].ParentTypeName = "TPMT_TK_VERIFIED";
    sInf->Fields[3].ParentType = TpmTypeId::TPMT_TK_VERIFIED_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPMT_TK_AUTH
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPMT_TK_AUTH_ID]=sInf;
    sInf->Name = "TPMT_TK_AUTH";
    sInf->MyTypeInfo=typeid(TPMT_TK_AUTH).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //tag
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ST_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ST";
    sInf->Fields[0].ElementSize = sizeof(TPM_ST);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "tag";
    sInf->Fields[0].ParentTypeName = "TPMT_TK_AUTH";
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_TK_AUTH_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    //hierarchy
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "hierarchy";
    sInf->Fields[1].ParentTypeName = "TPMT_TK_AUTH";
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_TK_AUTH_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //digestSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "digestSize";
    sInf->Fields[2].ParentTypeName = "TPMT_TK_AUTH";
    sInf->Fields[2].ParentType = TpmTypeId::TPMT_TK_AUTH_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //digest
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "digest";
    sInf->Fields[3].ParentTypeName = "TPMT_TK_AUTH";
    sInf->Fields[3].ParentType = TpmTypeId::TPMT_TK_AUTH_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPMT_TK_HASHCHECK
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPMT_TK_HASHCHECK_ID]=sInf;
    sInf->Name = "TPMT_TK_HASHCHECK";
    sInf->MyTypeInfo=typeid(TPMT_TK_HASHCHECK).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //tag
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ST_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ST";
    sInf->Fields[0].ElementSize = sizeof(TPM_ST);
    sInf->Fields[0].ElementMarshallType = MarshallType::ConstantValue;
    sInf->Fields[0].ElementName = "tag";
    sInf->Fields[0].ParentTypeName = "TPMT_TK_HASHCHECK";
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    //hierarchy
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "hierarchy";
    sInf->Fields[1].ParentTypeName = "TPMT_TK_HASHCHECK";
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //digestSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "digestSize";
    sInf->Fields[2].ParentTypeName = "TPMT_TK_HASHCHECK";
    sInf->Fields[2].ParentType = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //digest
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "digest";
    sInf->Fields[3].ParentTypeName = "TPMT_TK_HASHCHECK";
    sInf->Fields[3].ParentType = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPMS_ALG_PROPERTY
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMS_ALG_PROPERTY_ID]=sInf;
    sInf->Name = "TPMS_ALG_PROPERTY";
    sInf->MyTypeInfo=typeid(TPMS_ALG_PROPERTY).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //alg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "alg";
    sInf->Fields[0].ParentTypeName = "TPMS_ALG_PROPERTY";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ALG_PROPERTY_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    //algProperties
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMA_ALGORITHM_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMA_ALGORITHM";
    sInf->Fields[1].ElementSize = sizeof(TPMA_ALGORITHM);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "algProperties";
    sInf->Fields[1].ParentTypeName = "TPMS_ALG_PROPERTY";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_ALG_PROPERTY_ID;
    sInf->Fields[1].Sort = ElementSort::TpmBitfield;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPMS_TAGGED_PROPERTY
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMS_TAGGED_PROPERTY_ID]=sInf;
    sInf->Name = "TPMS_TAGGED_PROPERTY";
    sInf->MyTypeInfo=typeid(TPMS_TAGGED_PROPERTY).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //property
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_PT_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_PT";
    sInf->Fields[0].ElementSize = sizeof(TPM_PT);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "property";
    sInf->Fields[0].ParentTypeName = "TPMS_TAGGED_PROPERTY";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_TAGGED_PROPERTY_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    //value
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT32";
    sInf->Fields[1].ElementSize = sizeof(UINT32);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "value";
    sInf->Fields[1].ParentTypeName = "TPMS_TAGGED_PROPERTY";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_TAGGED_PROPERTY_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPMS_TAGGED_PCR_SELECT
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID]=sInf;
    sInf->Name = "TPMS_TAGGED_PCR_SELECT";
    sInf->MyTypeInfo=typeid(TPMS_TAGGED_PCR_SELECT).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //tag
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_PT_PCR_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_PT_PCR";
    sInf->Fields[0].ElementSize = sizeof(TPM_PT_PCR);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "tag";
    sInf->Fields[0].ParentTypeName = "TPMS_TAGGED_PCR_SELECT";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    //sizeofSelect
    sInf->Fields[1].ThisElementType = TpmTypeId::byte_ID;
    sInf->Fields[1].ThisElementTypeName = "byte";
    sInf->Fields[1].ElementSize = sizeof(byte);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "sizeofSelect";
    sInf->Fields[1].ParentTypeName = "TPMS_TAGGED_PCR_SELECT";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //pcrSelect
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "pcrSelect";
    sInf->Fields[2].ParentTypeName = "TPMS_TAGGED_PCR_SELECT";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPMS_TAGGED_POLICY
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMS_TAGGED_POLICY_ID]=sInf;
    sInf->Name = "TPMS_TAGGED_POLICY";
    sInf->MyTypeInfo=typeid(TPMS_TAGGED_POLICY).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //handle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "handle";
    sInf->Fields[0].ParentTypeName = "TPMS_TAGGED_POLICY";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_TAGGED_POLICY_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //policyHash
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMT_HA";
    sInf->Fields[1].ElementSize = sizeof(TPMT_HA);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "policyHash";
    sInf->Fields[1].ParentTypeName = "TPMS_TAGGED_POLICY";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_TAGGED_POLICY_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPML_CC
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPML_CC_ID]=sInf;
    sInf->Name = "TPML_CC";
    sInf->MyTypeInfo=typeid(TPML_CC).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //count
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "count";
    sInf->Fields[0].ParentTypeName = "TPML_CC";
    sInf->Fields[0].ParentType = TpmTypeId::TPML_CC_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //commandCodes
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_CC_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_CC";
    sInf->Fields[1].ElementSize = sizeof(TPM_CC);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "commandCodes";
    sInf->Fields[1].ParentTypeName = "TPML_CC";
    sInf->Fields[1].ParentType = TpmTypeId::TPML_CC_ID;
    sInf->Fields[1].Sort = ElementSort::TpmEnum;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPML_CCA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPML_CCA_ID]=sInf;
    sInf->Name = "TPML_CCA";
    sInf->MyTypeInfo=typeid(TPML_CCA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //count
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "count";
    sInf->Fields[0].ParentTypeName = "TPML_CCA";
    sInf->Fields[0].ParentType = TpmTypeId::TPML_CCA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //commandAttributes
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMA_CC_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMA_CC";
    sInf->Fields[1].ElementSize = sizeof(TPMA_CC);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "commandAttributes";
    sInf->Fields[1].ParentTypeName = "TPML_CCA";
    sInf->Fields[1].ParentType = TpmTypeId::TPML_CCA_ID;
    sInf->Fields[1].Sort = ElementSort::TpmBitfield;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPML_ALG
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPML_ALG_ID]=sInf;
    sInf->Name = "TPML_ALG";
    sInf->MyTypeInfo=typeid(TPML_ALG).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //count
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "count";
    sInf->Fields[0].ParentTypeName = "TPML_ALG";
    sInf->Fields[0].ParentType = TpmTypeId::TPML_ALG_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //algorithms
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[1].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "algorithms";
    sInf->Fields[1].ParentTypeName = "TPML_ALG";
    sInf->Fields[1].ParentType = TpmTypeId::TPML_ALG_ID;
    sInf->Fields[1].Sort = ElementSort::TpmEnum;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPML_HANDLE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPML_HANDLE_ID]=sInf;
    sInf->Name = "TPML_HANDLE";
    sInf->MyTypeInfo=typeid(TPML_HANDLE).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //count
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "count";
    sInf->Fields[0].ParentTypeName = "TPML_HANDLE";
    sInf->Fields[0].ParentType = TpmTypeId::TPML_HANDLE_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //handle
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "handle";
    sInf->Fields[1].ParentTypeName = "TPML_HANDLE";
    sInf->Fields[1].ParentType = TpmTypeId::TPML_HANDLE_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPML_DIGEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPML_DIGEST_ID]=sInf;
    sInf->Name = "TPML_DIGEST";
    sInf->MyTypeInfo=typeid(TPML_DIGEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //count
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "count";
    sInf->Fields[0].ParentTypeName = "TPML_DIGEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPML_DIGEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //digests
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM2B_DIGEST_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM2B_DIGEST";
    sInf->Fields[1].ElementSize = sizeof(TPM2B_DIGEST);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "digests";
    sInf->Fields[1].ParentTypeName = "TPML_DIGEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPML_DIGEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPML_DIGEST_VALUES
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPML_DIGEST_VALUES_ID]=sInf;
    sInf->Name = "TPML_DIGEST_VALUES";
    sInf->MyTypeInfo=typeid(TPML_DIGEST_VALUES).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //count
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "count";
    sInf->Fields[0].ParentTypeName = "TPML_DIGEST_VALUES";
    sInf->Fields[0].ParentType = TpmTypeId::TPML_DIGEST_VALUES_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //digests
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMT_HA";
    sInf->Fields[1].ElementSize = sizeof(TPMT_HA);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "digests";
    sInf->Fields[1].ParentTypeName = "TPML_DIGEST_VALUES";
    sInf->Fields[1].ParentType = TpmTypeId::TPML_DIGEST_VALUES_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPML_PCR_SELECTION
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPML_PCR_SELECTION_ID]=sInf;
    sInf->Name = "TPML_PCR_SELECTION";
    sInf->MyTypeInfo=typeid(TPML_PCR_SELECTION).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //count
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "count";
    sInf->Fields[0].ParentTypeName = "TPML_PCR_SELECTION";
    sInf->Fields[0].ParentType = TpmTypeId::TPML_PCR_SELECTION_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //pcrSelections
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_PCR_SELECTION";
    sInf->Fields[1].ElementSize = sizeof(TPMS_PCR_SELECTION);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "pcrSelections";
    sInf->Fields[1].ParentTypeName = "TPML_PCR_SELECTION";
    sInf->Fields[1].ParentType = TpmTypeId::TPML_PCR_SELECTION_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPML_ALG_PROPERTY
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPML_ALG_PROPERTY_ID]=sInf;
    sInf->Name = "TPML_ALG_PROPERTY";
    sInf->MyTypeInfo=typeid(TPML_ALG_PROPERTY).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //count
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "count";
    sInf->Fields[0].ParentTypeName = "TPML_ALG_PROPERTY";
    sInf->Fields[0].ParentType = TpmTypeId::TPML_ALG_PROPERTY_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //algProperties
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_ALG_PROPERTY_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_ALG_PROPERTY";
    sInf->Fields[1].ElementSize = sizeof(TPMS_ALG_PROPERTY);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "algProperties";
    sInf->Fields[1].ParentTypeName = "TPML_ALG_PROPERTY";
    sInf->Fields[1].ParentType = TpmTypeId::TPML_ALG_PROPERTY_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPML_TAGGED_TPM_PROPERTY
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPML_TAGGED_TPM_PROPERTY_ID]=sInf;
    sInf->Name = "TPML_TAGGED_TPM_PROPERTY";
    sInf->MyTypeInfo=typeid(TPML_TAGGED_TPM_PROPERTY).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //count
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "count";
    sInf->Fields[0].ParentTypeName = "TPML_TAGGED_TPM_PROPERTY";
    sInf->Fields[0].ParentType = TpmTypeId::TPML_TAGGED_TPM_PROPERTY_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //tpmProperty
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_TAGGED_PROPERTY_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_TAGGED_PROPERTY";
    sInf->Fields[1].ElementSize = sizeof(TPMS_TAGGED_PROPERTY);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "tpmProperty";
    sInf->Fields[1].ParentTypeName = "TPML_TAGGED_TPM_PROPERTY";
    sInf->Fields[1].ParentType = TpmTypeId::TPML_TAGGED_TPM_PROPERTY_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPML_TAGGED_PCR_PROPERTY
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPML_TAGGED_PCR_PROPERTY_ID]=sInf;
    sInf->Name = "TPML_TAGGED_PCR_PROPERTY";
    sInf->MyTypeInfo=typeid(TPML_TAGGED_PCR_PROPERTY).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //count
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "count";
    sInf->Fields[0].ParentTypeName = "TPML_TAGGED_PCR_PROPERTY";
    sInf->Fields[0].ParentType = TpmTypeId::TPML_TAGGED_PCR_PROPERTY_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //pcrProperty
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_TAGGED_PCR_SELECT";
    sInf->Fields[1].ElementSize = sizeof(TPMS_TAGGED_PCR_SELECT);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "pcrProperty";
    sInf->Fields[1].ParentTypeName = "TPML_TAGGED_PCR_PROPERTY";
    sInf->Fields[1].ParentType = TpmTypeId::TPML_TAGGED_PCR_PROPERTY_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPML_ECC_CURVE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPML_ECC_CURVE_ID]=sInf;
    sInf->Name = "TPML_ECC_CURVE";
    sInf->MyTypeInfo=typeid(TPML_ECC_CURVE).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //count
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "count";
    sInf->Fields[0].ParentTypeName = "TPML_ECC_CURVE";
    sInf->Fields[0].ParentType = TpmTypeId::TPML_ECC_CURVE_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //eccCurves
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_ECC_CURVE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_ECC_CURVE";
    sInf->Fields[1].ElementSize = sizeof(TPM_ECC_CURVE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "eccCurves";
    sInf->Fields[1].ParentTypeName = "TPML_ECC_CURVE";
    sInf->Fields[1].ParentType = TpmTypeId::TPML_ECC_CURVE_ID;
    sInf->Fields[1].Sort = ElementSort::TpmEnum;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPML_TAGGED_POLICY
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPML_TAGGED_POLICY_ID]=sInf;
    sInf->Name = "TPML_TAGGED_POLICY";
    sInf->MyTypeInfo=typeid(TPML_TAGGED_POLICY).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //count
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "count";
    sInf->Fields[0].ParentTypeName = "TPML_TAGGED_POLICY";
    sInf->Fields[0].ParentType = TpmTypeId::TPML_TAGGED_POLICY_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //policies
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_TAGGED_POLICY_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_TAGGED_POLICY";
    sInf->Fields[1].ElementSize = sizeof(TPMS_TAGGED_POLICY);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "policies";
    sInf->Fields[1].ParentTypeName = "TPML_TAGGED_POLICY";
    sInf->Fields[1].ParentType = TpmTypeId::TPML_TAGGED_POLICY_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMS_CAPABILITY_DATA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMS_CAPABILITY_DATA_ID]=sInf;
    sInf->Name = "TPMS_CAPABILITY_DATA";
    sInf->MyTypeInfo=typeid(TPMS_CAPABILITY_DATA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //capability
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_CAP_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_CAP";
    sInf->Fields[0].ElementSize = sizeof(TPM_CAP);
    sInf->Fields[0].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[0].ElementName = "capability";
    sInf->Fields[0].ParentTypeName = "TPMS_CAPABILITY_DATA";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_CAPABILITY_DATA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    sInf->Fields[0].AssociatedElement=1;
    //data
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMU_CAPABILITIES_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMU_CAPABILITIES";
    sInf->Fields[1].ElementSize = sizeof(TPMU_CAPABILITIES);
    sInf->Fields[1].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[1].ElementName = "data";
    sInf->Fields[1].ParentTypeName = "TPMS_CAPABILITY_DATA";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_CAPABILITY_DATA_ID;
    sInf->Fields[1].Sort = ElementSort::TpmUnion;
    sInf->Fields[1].IsArray = FALSE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMS_CLOCK_INFO
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPMS_CLOCK_INFO_ID]=sInf;
    sInf->Name = "TPMS_CLOCK_INFO";
    sInf->MyTypeInfo=typeid(TPMS_CLOCK_INFO).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //clock
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT64_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT64";
    sInf->Fields[0].ElementSize = sizeof(UINT64);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "clock";
    sInf->Fields[0].ParentTypeName = "TPMS_CLOCK_INFO";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_CLOCK_INFO_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //resetCount
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT32";
    sInf->Fields[1].ElementSize = sizeof(UINT32);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "resetCount";
    sInf->Fields[1].ParentTypeName = "TPMS_CLOCK_INFO";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_CLOCK_INFO_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //restartCount
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT32";
    sInf->Fields[2].ElementSize = sizeof(UINT32);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "restartCount";
    sInf->Fields[2].ParentTypeName = "TPMS_CLOCK_INFO";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_CLOCK_INFO_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //safe
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "safe";
    sInf->Fields[3].ParentTypeName = "TPMS_CLOCK_INFO";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_CLOCK_INFO_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //===================TPMS_TIME_INFO
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMS_TIME_INFO_ID]=sInf;
    sInf->Name = "TPMS_TIME_INFO";
    sInf->MyTypeInfo=typeid(TPMS_TIME_INFO).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //time
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT64_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT64";
    sInf->Fields[0].ElementSize = sizeof(UINT64);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "time";
    sInf->Fields[0].ParentTypeName = "TPMS_TIME_INFO";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_TIME_INFO_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //clockInfo
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_CLOCK_INFO_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_CLOCK_INFO";
    sInf->Fields[1].ElementSize = sizeof(TPMS_CLOCK_INFO);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "clockInfo";
    sInf->Fields[1].ParentTypeName = "TPMS_TIME_INFO";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_TIME_INFO_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPMS_TIME_ATTEST_INFO
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMS_TIME_ATTEST_INFO_ID]=sInf;
    sInf->Name = "TPMS_TIME_ATTEST_INFO";
    sInf->MyTypeInfo=typeid(TPMS_TIME_ATTEST_INFO).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //time
    sInf->Fields[0].ThisElementType = TpmTypeId::TPMS_TIME_INFO_ID;
    sInf->Fields[0].ThisElementTypeName = "TPMS_TIME_INFO";
    sInf->Fields[0].ElementSize = sizeof(TPMS_TIME_INFO);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "time";
    sInf->Fields[0].ParentTypeName = "TPMS_TIME_ATTEST_INFO";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_TIME_ATTEST_INFO_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //firmwareVersion
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT64_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT64";
    sInf->Fields[1].ElementSize = sizeof(UINT64);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "firmwareVersion";
    sInf->Fields[1].ParentTypeName = "TPMS_TIME_ATTEST_INFO";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_TIME_ATTEST_INFO_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPMS_CERTIFY_INFO
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPMS_CERTIFY_INFO_ID]=sInf;
    sInf->Name = "TPMS_CERTIFY_INFO";
    sInf->MyTypeInfo=typeid(TPMS_CERTIFY_INFO).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //nameSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "nameSize";
    sInf->Fields[0].ParentTypeName = "TPMS_CERTIFY_INFO";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_CERTIFY_INFO_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //name
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "name";
    sInf->Fields[1].ParentTypeName = "TPMS_CERTIFY_INFO";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_CERTIFY_INFO_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //qualifiedNameSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "qualifiedNameSize";
    sInf->Fields[2].ParentTypeName = "TPMS_CERTIFY_INFO";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_CERTIFY_INFO_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //qualifiedName
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "qualifiedName";
    sInf->Fields[3].ParentTypeName = "TPMS_CERTIFY_INFO";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_CERTIFY_INFO_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPMS_QUOTE_INFO
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPMS_QUOTE_INFO_ID]=sInf;
    sInf->Name = "TPMS_QUOTE_INFO";
    sInf->MyTypeInfo=typeid(TPMS_QUOTE_INFO).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //pcrSelectCount
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "pcrSelectCount";
    sInf->Fields[0].ParentTypeName = "TPMS_QUOTE_INFO";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_QUOTE_INFO_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //pcrSelect
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_PCR_SELECTION";
    sInf->Fields[1].ElementSize = sizeof(TPMS_PCR_SELECTION);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "pcrSelect";
    sInf->Fields[1].ParentTypeName = "TPMS_QUOTE_INFO";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_QUOTE_INFO_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //pcrDigestSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "pcrDigestSize";
    sInf->Fields[2].ParentTypeName = "TPMS_QUOTE_INFO";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_QUOTE_INFO_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //pcrDigest
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "pcrDigest";
    sInf->Fields[3].ParentTypeName = "TPMS_QUOTE_INFO";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_QUOTE_INFO_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPMS_COMMAND_AUDIT_INFO
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(6);
    TypeMap[TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID]=sInf;
    sInf->Name = "TPMS_COMMAND_AUDIT_INFO";
    sInf->MyTypeInfo=typeid(TPMS_COMMAND_AUDIT_INFO).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //auditCounter
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT64_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT64";
    sInf->Fields[0].ElementSize = sizeof(UINT64);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "auditCounter";
    sInf->Fields[0].ParentTypeName = "TPMS_COMMAND_AUDIT_INFO";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //digestAlg
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[1].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "digestAlg";
    sInf->Fields[1].ParentTypeName = "TPMS_COMMAND_AUDIT_INFO";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    sInf->Fields[1].Sort = ElementSort::TpmEnum;
    sInf->Fields[1].IsArray = FALSE;
    //auditDigestSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "auditDigestSize";
    sInf->Fields[2].ParentTypeName = "TPMS_COMMAND_AUDIT_INFO";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //auditDigest
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "auditDigest";
    sInf->Fields[3].ParentTypeName = "TPMS_COMMAND_AUDIT_INFO";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //commandDigestSize
    sInf->Fields[4].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[4].ThisElementTypeName = "UINT16";
    sInf->Fields[4].ElementSize = sizeof(UINT16);
    sInf->Fields[4].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[4].ElementName = "commandDigestSize";
    sInf->Fields[4].ParentTypeName = "TPMS_COMMAND_AUDIT_INFO";
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    //commandDigest
    sInf->Fields[5].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[5].ThisElementTypeName = "BYTE";
    sInf->Fields[5].ElementSize = sizeof(BYTE);
    sInf->Fields[5].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[5].ElementName = "commandDigest";
    sInf->Fields[5].ParentTypeName = "TPMS_COMMAND_AUDIT_INFO";
    sInf->Fields[5].ParentType = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = TRUE;
    sInf->Fields[5].AssociatedElement=4;
    //===================TPMS_SESSION_AUDIT_INFO
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID]=sInf;
    sInf->Name = "TPMS_SESSION_AUDIT_INFO";
    sInf->MyTypeInfo=typeid(TPMS_SESSION_AUDIT_INFO).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //exclusiveSession
    sInf->Fields[0].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[0].ThisElementTypeName = "BYTE";
    sInf->Fields[0].ElementSize = sizeof(BYTE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "exclusiveSession";
    sInf->Fields[0].ParentTypeName = "TPMS_SESSION_AUDIT_INFO";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //sessionDigestSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "sessionDigestSize";
    sInf->Fields[1].ParentTypeName = "TPMS_SESSION_AUDIT_INFO";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //sessionDigest
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "sessionDigest";
    sInf->Fields[2].ParentTypeName = "TPMS_SESSION_AUDIT_INFO";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPMS_CREATION_INFO
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPMS_CREATION_INFO_ID]=sInf;
    sInf->Name = "TPMS_CREATION_INFO";
    sInf->MyTypeInfo=typeid(TPMS_CREATION_INFO).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //objectNameSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "objectNameSize";
    sInf->Fields[0].ParentTypeName = "TPMS_CREATION_INFO";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_CREATION_INFO_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //objectName
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "objectName";
    sInf->Fields[1].ParentTypeName = "TPMS_CREATION_INFO";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_CREATION_INFO_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //creationHashSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "creationHashSize";
    sInf->Fields[2].ParentTypeName = "TPMS_CREATION_INFO";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_CREATION_INFO_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //creationHash
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "creationHash";
    sInf->Fields[3].ParentTypeName = "TPMS_CREATION_INFO";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_CREATION_INFO_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPMS_NV_CERTIFY_INFO
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPMS_NV_CERTIFY_INFO_ID]=sInf;
    sInf->Name = "TPMS_NV_CERTIFY_INFO";
    sInf->MyTypeInfo=typeid(TPMS_NV_CERTIFY_INFO).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //indexNameSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "indexNameSize";
    sInf->Fields[0].ParentTypeName = "TPMS_NV_CERTIFY_INFO";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //indexName
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "indexName";
    sInf->Fields[1].ParentTypeName = "TPMS_NV_CERTIFY_INFO";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //offset
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "offset";
    sInf->Fields[2].ParentTypeName = "TPMS_NV_CERTIFY_INFO";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //nvContentsSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "nvContentsSize";
    sInf->Fields[3].ParentTypeName = "TPMS_NV_CERTIFY_INFO";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //nvContents
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "nvContents";
    sInf->Fields[4].ParentTypeName = "TPMS_NV_CERTIFY_INFO";
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //===================TPMS_NV_DIGEST_CERTIFY_INFO
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID]=sInf;
    sInf->Name = "TPMS_NV_DIGEST_CERTIFY_INFO";
    sInf->MyTypeInfo=typeid(TPMS_NV_DIGEST_CERTIFY_INFO).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //indexNameSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "indexNameSize";
    sInf->Fields[0].ParentTypeName = "TPMS_NV_DIGEST_CERTIFY_INFO";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //indexName
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "indexName";
    sInf->Fields[1].ParentTypeName = "TPMS_NV_DIGEST_CERTIFY_INFO";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //nvDigestSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "nvDigestSize";
    sInf->Fields[2].ParentTypeName = "TPMS_NV_DIGEST_CERTIFY_INFO";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //nvDigest
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "nvDigest";
    sInf->Fields[3].ParentTypeName = "TPMS_NV_DIGEST_CERTIFY_INFO";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPMS_ATTEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(9);
    TypeMap[TpmTypeId::TPMS_ATTEST_ID]=sInf;
    sInf->Name = "TPMS_ATTEST";
    sInf->MyTypeInfo=typeid(TPMS_ATTEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //magic
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_GENERATED_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_GENERATED";
    sInf->Fields[0].ElementSize = sizeof(TPM_GENERATED);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "magic";
    sInf->Fields[0].ParentTypeName = "TPMS_ATTEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    //type
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_ST_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_ST";
    sInf->Fields[1].ElementSize = sizeof(TPM_ST);
    sInf->Fields[1].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[1].ElementName = "type";
    sInf->Fields[1].ParentTypeName = "TPMS_ATTEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    sInf->Fields[1].AssociatedElement=8;
    //qualifiedSignerSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "qualifiedSignerSize";
    sInf->Fields[2].ParentTypeName = "TPMS_ATTEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //qualifiedSigner
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "qualifiedSigner";
    sInf->Fields[3].ParentTypeName = "TPMS_ATTEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //extraDataSize
    sInf->Fields[4].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[4].ThisElementTypeName = "UINT16";
    sInf->Fields[4].ElementSize = sizeof(UINT16);
    sInf->Fields[4].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[4].ElementName = "extraDataSize";
    sInf->Fields[4].ParentTypeName = "TPMS_ATTEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    //extraData
    sInf->Fields[5].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[5].ThisElementTypeName = "BYTE";
    sInf->Fields[5].ElementSize = sizeof(BYTE);
    sInf->Fields[5].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[5].ElementName = "extraData";
    sInf->Fields[5].ParentTypeName = "TPMS_ATTEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = TRUE;
    sInf->Fields[5].AssociatedElement=4;
    //clockInfo
    sInf->Fields[6].ThisElementType = TpmTypeId::TPMS_CLOCK_INFO_ID;
    sInf->Fields[6].ThisElementTypeName = "TPMS_CLOCK_INFO";
    sInf->Fields[6].ElementSize = sizeof(TPMS_CLOCK_INFO);
    sInf->Fields[6].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[6].ElementName = "clockInfo";
    sInf->Fields[6].ParentTypeName = "TPMS_ATTEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmStruct;
    sInf->Fields[6].IsArray = FALSE;
    //firmwareVersion
    sInf->Fields[7].ThisElementType = TpmTypeId::UINT64_ID;
    sInf->Fields[7].ThisElementTypeName = "UINT64";
    sInf->Fields[7].ElementSize = sizeof(UINT64);
    sInf->Fields[7].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[7].ElementName = "firmwareVersion";
    sInf->Fields[7].ParentTypeName = "TPMS_ATTEST";
    sInf->Fields[7].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[7].Sort = ElementSort::TpmValueType;
    sInf->Fields[7].IsArray = FALSE;
    //attested
    sInf->Fields[8].ThisElementType = TpmTypeId::TPMU_ATTEST_ID;
    sInf->Fields[8].ThisElementTypeName = "TPMU_ATTEST";
    sInf->Fields[8].ElementSize = sizeof(TPMU_ATTEST);
    sInf->Fields[8].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[8].ElementName = "attested";
    sInf->Fields[8].ParentTypeName = "TPMS_ATTEST";
    sInf->Fields[8].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[8].Sort = ElementSort::TpmUnion;
    sInf->Fields[8].IsArray = FALSE;
    sInf->Fields[8].AssociatedElement=1;
    //===================TPM2B_ATTEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_ATTEST_ID]=sInf;
    sInf->Name = "TPM2B_ATTEST";
    sInf->MyTypeInfo=typeid(TPM2B_ATTEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_ATTEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_ATTEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //attestationData
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_ATTEST";
    sInf->Fields[1].ElementSize = sizeof(TPMS_ATTEST);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "attestationData";
    sInf->Fields[1].ParentTypeName = "TPM2B_ATTEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_ATTEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPMS_AUTH_COMMAND
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(6);
    TypeMap[TpmTypeId::TPMS_AUTH_COMMAND_ID]=sInf;
    sInf->Name = "TPMS_AUTH_COMMAND";
    sInf->MyTypeInfo=typeid(TPMS_AUTH_COMMAND).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //sessionHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "sessionHandle";
    sInf->Fields[0].ParentTypeName = "TPMS_AUTH_COMMAND";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_AUTH_COMMAND_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //nonceSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "nonceSize";
    sInf->Fields[1].ParentTypeName = "TPMS_AUTH_COMMAND";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_AUTH_COMMAND_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //nonce
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "nonce";
    sInf->Fields[2].ParentTypeName = "TPMS_AUTH_COMMAND";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_AUTH_COMMAND_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //sessionAttributes
    sInf->Fields[3].ThisElementType = TpmTypeId::TPMA_SESSION_ID;
    sInf->Fields[3].ThisElementTypeName = "TPMA_SESSION";
    sInf->Fields[3].ElementSize = sizeof(TPMA_SESSION);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "sessionAttributes";
    sInf->Fields[3].ParentTypeName = "TPMS_AUTH_COMMAND";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_AUTH_COMMAND_ID;
    sInf->Fields[3].Sort = ElementSort::TpmBitfield;
    sInf->Fields[3].IsArray = FALSE;
    //hmacSize
    sInf->Fields[4].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[4].ThisElementTypeName = "UINT16";
    sInf->Fields[4].ElementSize = sizeof(UINT16);
    sInf->Fields[4].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[4].ElementName = "hmacSize";
    sInf->Fields[4].ParentTypeName = "TPMS_AUTH_COMMAND";
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_AUTH_COMMAND_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    //hmac
    sInf->Fields[5].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[5].ThisElementTypeName = "BYTE";
    sInf->Fields[5].ElementSize = sizeof(BYTE);
    sInf->Fields[5].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[5].ElementName = "hmac";
    sInf->Fields[5].ParentTypeName = "TPMS_AUTH_COMMAND";
    sInf->Fields[5].ParentType = TpmTypeId::TPMS_AUTH_COMMAND_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = TRUE;
    sInf->Fields[5].AssociatedElement=4;
    //===================TPMS_AUTH_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::AUTHResponse_ID]=sInf;
    sInf->Name = "AUTHResponse";
    sInf->MyTypeInfo=typeid(AUTHResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //nonceSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "nonceSize";
    sInf->Fields[0].ParentTypeName = "AUTHResponse";
    sInf->Fields[0].ParentType = TpmTypeId::AUTHResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //nonce
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "nonce";
    sInf->Fields[1].ParentTypeName = "AUTHResponse";
    sInf->Fields[1].ParentType = TpmTypeId::AUTHResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //sessionAttributes
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMA_SESSION_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMA_SESSION";
    sInf->Fields[2].ElementSize = sizeof(TPMA_SESSION);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "sessionAttributes";
    sInf->Fields[2].ParentTypeName = "AUTHResponse";
    sInf->Fields[2].ParentType = TpmTypeId::AUTHResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmBitfield;
    sInf->Fields[2].IsArray = FALSE;
    //hmacSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "hmacSize";
    sInf->Fields[3].ParentTypeName = "AUTHResponse";
    sInf->Fields[3].ParentType = TpmTypeId::AUTHResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //hmac
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "hmac";
    sInf->Fields[4].ParentTypeName = "AUTHResponse";
    sInf->Fields[4].ParentType = TpmTypeId::AUTHResponse_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //===================TPMS_NULL_SYM_KEY_BITS
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPMS_NULL_SYM_KEY_BITS_ID]=sInf;
    sInf->Name = "TPMS_NULL_SYM_KEY_BITS";
    sInf->MyTypeInfo=typeid(TPMS_NULL_SYM_KEY_BITS).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPMS_XOR_SYM_MODE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPMS_XOR_SYM_MODE_ID]=sInf;
    sInf->Name = "TPMS_XOR_SYM_MODE";
    sInf->MyTypeInfo=typeid(TPMS_XOR_SYM_MODE).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPMS_NULL_SYM_MODE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPMS_NULL_SYM_MODE_ID]=sInf;
    sInf->Name = "TPMS_NULL_SYM_MODE";
    sInf->MyTypeInfo=typeid(TPMS_NULL_SYM_MODE).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPMS_TDES_SYM_DETAILS
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPMS_TDES_SYM_DETAILS_ID]=sInf;
    sInf->Name = "TPMS_TDES_SYM_DETAILS";
    sInf->MyTypeInfo=typeid(TPMS_TDES_SYM_DETAILS).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPMS_AES_SYM_DETAILS
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPMS_AES_SYM_DETAILS_ID]=sInf;
    sInf->Name = "TPMS_AES_SYM_DETAILS";
    sInf->MyTypeInfo=typeid(TPMS_AES_SYM_DETAILS).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPMS_SM4_SYM_DETAILS
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPMS_SM4_SYM_DETAILS_ID]=sInf;
    sInf->Name = "TPMS_SM4_SYM_DETAILS";
    sInf->MyTypeInfo=typeid(TPMS_SM4_SYM_DETAILS).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPMS_CAMELLIA_SYM_DETAILS
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPMS_CAMELLIA_SYM_DETAILS_ID]=sInf;
    sInf->Name = "TPMS_CAMELLIA_SYM_DETAILS";
    sInf->MyTypeInfo=typeid(TPMS_CAMELLIA_SYM_DETAILS).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPMS_ANY_SYM_DETAILS
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPMS_ANY_SYM_DETAILS_ID]=sInf;
    sInf->Name = "TPMS_ANY_SYM_DETAILS";
    sInf->MyTypeInfo=typeid(TPMS_ANY_SYM_DETAILS).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPMS_XOR_SYM_DETAILS
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPMS_XOR_SYM_DETAILS_ID]=sInf;
    sInf->Name = "TPMS_XOR_SYM_DETAILS";
    sInf->MyTypeInfo=typeid(TPMS_XOR_SYM_DETAILS).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPMS_NULL_SYM_DETAILS
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPMS_NULL_SYM_DETAILS_ID]=sInf;
    sInf->Name = "TPMS_NULL_SYM_DETAILS";
    sInf->MyTypeInfo=typeid(TPMS_NULL_SYM_DETAILS).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPMT_SYM_DEF
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPMT_SYM_DEF_ID]=sInf;
    sInf->Name = "TPMT_SYM_DEF";
    sInf->MyTypeInfo=typeid(TPMT_SYM_DEF).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //algorithm
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "algorithm";
    sInf->Fields[0].ParentTypeName = "TPMT_SYM_DEF";
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_SYM_DEF_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    //keyBits
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "keyBits";
    sInf->Fields[1].ParentTypeName = "TPMT_SYM_DEF";
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_SYM_DEF_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //mode
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[2].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "mode";
    sInf->Fields[2].ParentTypeName = "TPMT_SYM_DEF";
    sInf->Fields[2].ParentType = TpmTypeId::TPMT_SYM_DEF_ID;
    sInf->Fields[2].Sort = ElementSort::TpmEnum;
    sInf->Fields[2].IsArray = FALSE;
    //===================TPMT_SYM_DEF_OBJECT
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPMT_SYM_DEF_OBJECT_ID]=sInf;
    sInf->Name = "TPMT_SYM_DEF_OBJECT";
    sInf->MyTypeInfo=typeid(TPMT_SYM_DEF_OBJECT).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //algorithm
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "algorithm";
    sInf->Fields[0].ParentTypeName = "TPMT_SYM_DEF_OBJECT";
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    //keyBits
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "keyBits";
    sInf->Fields[1].ParentTypeName = "TPMT_SYM_DEF_OBJECT";
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //mode
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[2].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "mode";
    sInf->Fields[2].ParentTypeName = "TPMT_SYM_DEF_OBJECT";
    sInf->Fields[2].ParentType = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    sInf->Fields[2].Sort = ElementSort::TpmEnum;
    sInf->Fields[2].IsArray = FALSE;
    //===================TPM2B_SYM_KEY
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_SYM_KEY_ID]=sInf;
    sInf->Name = "TPM2B_SYM_KEY";
    sInf->MyTypeInfo=typeid(TPM2B_SYM_KEY).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_SYM_KEY";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_SYM_KEY_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_SYM_KEY";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_SYM_KEY_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMS_SYMCIPHER_PARMS
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPMS_SYMCIPHER_PARMS_ID]=sInf;
    sInf->Name = "TPMS_SYMCIPHER_PARMS";
    sInf->MyTypeInfo=typeid(TPMS_SYMCIPHER_PARMS).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //sym
    sInf->Fields[0].ThisElementType = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    sInf->Fields[0].ThisElementTypeName = "TPMT_SYM_DEF_OBJECT";
    sInf->Fields[0].ElementSize = sizeof(TPMT_SYM_DEF_OBJECT);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "sym";
    sInf->Fields[0].ParentTypeName = "TPMS_SYMCIPHER_PARMS";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SYMCIPHER_PARMS_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2B_LABEL
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_LABEL_ID]=sInf;
    sInf->Name = "TPM2B_LABEL";
    sInf->MyTypeInfo=typeid(TPM2B_LABEL).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_LABEL";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_LABEL_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_LABEL";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_LABEL_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMS_DERIVE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPMS_DERIVE_ID]=sInf;
    sInf->Name = "TPMS_DERIVE";
    sInf->MyTypeInfo=typeid(TPMS_DERIVE).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //labelSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "labelSize";
    sInf->Fields[0].ParentTypeName = "TPMS_DERIVE";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_DERIVE_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //label
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "label";
    sInf->Fields[1].ParentTypeName = "TPMS_DERIVE";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_DERIVE_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //contextSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "contextSize";
    sInf->Fields[2].ParentTypeName = "TPMS_DERIVE";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_DERIVE_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //context
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "context";
    sInf->Fields[3].ParentTypeName = "TPMS_DERIVE";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_DERIVE_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPM2B_DERIVE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_DERIVE_ID]=sInf;
    sInf->Name = "TPM2B_DERIVE";
    sInf->MyTypeInfo=typeid(TPM2B_DERIVE).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_DERIVE";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_DERIVE_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_DERIVE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_DERIVE";
    sInf->Fields[1].ElementSize = sizeof(TPMS_DERIVE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_DERIVE";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_DERIVE_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPM2B_SENSITIVE_DATA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_SENSITIVE_DATA_ID]=sInf;
    sInf->Name = "TPM2B_SENSITIVE_DATA";
    sInf->MyTypeInfo=typeid(TPM2B_SENSITIVE_DATA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_SENSITIVE_DATA";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_SENSITIVE_DATA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_SENSITIVE_DATA";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_SENSITIVE_DATA_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMS_SENSITIVE_CREATE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPMS_SENSITIVE_CREATE_ID]=sInf;
    sInf->Name = "TPMS_SENSITIVE_CREATE";
    sInf->MyTypeInfo=typeid(TPMS_SENSITIVE_CREATE).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //userAuthSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "userAuthSize";
    sInf->Fields[0].ParentTypeName = "TPMS_SENSITIVE_CREATE";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //userAuth
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "userAuth";
    sInf->Fields[1].ParentTypeName = "TPMS_SENSITIVE_CREATE";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //dataSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "dataSize";
    sInf->Fields[2].ParentTypeName = "TPMS_SENSITIVE_CREATE";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //data
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "data";
    sInf->Fields[3].ParentTypeName = "TPMS_SENSITIVE_CREATE";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPM2B_SENSITIVE_CREATE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_SENSITIVE_CREATE_ID]=sInf;
    sInf->Name = "TPM2B_SENSITIVE_CREATE";
    sInf->MyTypeInfo=typeid(TPM2B_SENSITIVE_CREATE).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_SENSITIVE_CREATE";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_SENSITIVE_CREATE_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //sensitive
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_SENSITIVE_CREATE";
    sInf->Fields[1].ElementSize = sizeof(TPMS_SENSITIVE_CREATE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "sensitive";
    sInf->Fields[1].ParentTypeName = "TPM2B_SENSITIVE_CREATE";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_SENSITIVE_CREATE_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPMS_SCHEME_HASH
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPMS_SCHEME_HASH_ID]=sInf;
    sInf->Name = "TPMS_SCHEME_HASH";
    sInf->MyTypeInfo=typeid(TPMS_SCHEME_HASH).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hashAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hashAlg";
    sInf->Fields[0].ParentTypeName = "TPMS_SCHEME_HASH";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SCHEME_HASH_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPMS_SCHEME_ECDAA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMS_SCHEME_ECDAA_ID]=sInf;
    sInf->Name = "TPMS_SCHEME_ECDAA";
    sInf->MyTypeInfo=typeid(TPMS_SCHEME_ECDAA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hashAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hashAlg";
    sInf->Fields[0].ParentTypeName = "TPMS_SCHEME_ECDAA";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SCHEME_ECDAA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //count
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "count";
    sInf->Fields[1].ParentTypeName = "TPMS_SCHEME_ECDAA";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SCHEME_ECDAA_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPMS_SCHEME_HMAC
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPMS_SCHEME_HMAC_ID]=sInf;
    sInf->Name = "TPMS_SCHEME_HMAC";
    sInf->MyTypeInfo=typeid(TPMS_SCHEME_HMAC).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hashAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hashAlg";
    sInf->Fields[0].ParentTypeName = "TPMS_SCHEME_HMAC";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SCHEME_HMAC_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPMS_SCHEME_XOR
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMS_SCHEME_XOR_ID]=sInf;
    sInf->Name = "TPMS_SCHEME_XOR";
    sInf->MyTypeInfo=typeid(TPMS_SCHEME_XOR).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hashAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hashAlg";
    sInf->Fields[0].ParentTypeName = "TPMS_SCHEME_XOR";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SCHEME_XOR_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //kdf
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[1].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "kdf";
    sInf->Fields[1].ParentTypeName = "TPMS_SCHEME_XOR";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SCHEME_XOR_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPMS_NULL_SCHEME_KEYEDHASH
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPMS_NULL_SCHEME_KEYEDHASH_ID]=sInf;
    sInf->Name = "TPMS_NULL_SCHEME_KEYEDHASH";
    sInf->MyTypeInfo=typeid(TPMS_NULL_SCHEME_KEYEDHASH).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPMT_KEYEDHASH_SCHEME
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMT_KEYEDHASH_SCHEME_ID]=sInf;
    sInf->Name = "TPMT_KEYEDHASH_SCHEME";
    sInf->MyTypeInfo=typeid(TPMT_KEYEDHASH_SCHEME).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //scheme
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[0].ElementName = "scheme";
    sInf->Fields[0].ParentTypeName = "TPMT_KEYEDHASH_SCHEME";
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_KEYEDHASH_SCHEME_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    sInf->Fields[0].AssociatedElement=1;
    //details
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMU_SCHEME_KEYEDHASH_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMU_SCHEME_KEYEDHASH";
    sInf->Fields[1].ElementSize = sizeof(TPMU_SCHEME_KEYEDHASH);
    sInf->Fields[1].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[1].ElementName = "details";
    sInf->Fields[1].ParentTypeName = "TPMT_KEYEDHASH_SCHEME";
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_KEYEDHASH_SCHEME_ID;
    sInf->Fields[1].Sort = ElementSort::TpmUnion;
    sInf->Fields[1].IsArray = FALSE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMS_SIG_SCHEME_RSASSA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPMS_SIG_SCHEME_RSASSA_ID]=sInf;
    sInf->Name = "TPMS_SIG_SCHEME_RSASSA";
    sInf->MyTypeInfo=typeid(TPMS_SIG_SCHEME_RSASSA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hashAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hashAlg";
    sInf->Fields[0].ParentTypeName = "TPMS_SIG_SCHEME_RSASSA";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIG_SCHEME_RSASSA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPMS_SIG_SCHEME_RSAPSS
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPMS_SIG_SCHEME_RSAPSS_ID]=sInf;
    sInf->Name = "TPMS_SIG_SCHEME_RSAPSS";
    sInf->MyTypeInfo=typeid(TPMS_SIG_SCHEME_RSAPSS).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hashAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hashAlg";
    sInf->Fields[0].ParentTypeName = "TPMS_SIG_SCHEME_RSAPSS";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIG_SCHEME_RSAPSS_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPMS_SIG_SCHEME_ECDSA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPMS_SIG_SCHEME_ECDSA_ID]=sInf;
    sInf->Name = "TPMS_SIG_SCHEME_ECDSA";
    sInf->MyTypeInfo=typeid(TPMS_SIG_SCHEME_ECDSA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hashAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hashAlg";
    sInf->Fields[0].ParentTypeName = "TPMS_SIG_SCHEME_ECDSA";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIG_SCHEME_ECDSA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPMS_SIG_SCHEME_SM2
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPMS_SIG_SCHEME_SM2_ID]=sInf;
    sInf->Name = "TPMS_SIG_SCHEME_SM2";
    sInf->MyTypeInfo=typeid(TPMS_SIG_SCHEME_SM2).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hashAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hashAlg";
    sInf->Fields[0].ParentTypeName = "TPMS_SIG_SCHEME_SM2";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIG_SCHEME_SM2_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPMS_SIG_SCHEME_ECSCHNORR
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPMS_SIG_SCHEME_ECSCHNORR_ID]=sInf;
    sInf->Name = "TPMS_SIG_SCHEME_ECSCHNORR";
    sInf->MyTypeInfo=typeid(TPMS_SIG_SCHEME_ECSCHNORR).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hashAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hashAlg";
    sInf->Fields[0].ParentTypeName = "TPMS_SIG_SCHEME_ECSCHNORR";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIG_SCHEME_ECSCHNORR_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPMS_SIG_SCHEME_ECDAA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID]=sInf;
    sInf->Name = "TPMS_SIG_SCHEME_ECDAA";
    sInf->MyTypeInfo=typeid(TPMS_SIG_SCHEME_ECDAA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hashAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hashAlg";
    sInf->Fields[0].ParentTypeName = "TPMS_SIG_SCHEME_ECDAA";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //count
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "count";
    sInf->Fields[1].ParentTypeName = "TPMS_SIG_SCHEME_ECDAA";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPMS_NULL_SIG_SCHEME
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPMS_NULL_SIG_SCHEME_ID]=sInf;
    sInf->Name = "TPMS_NULL_SIG_SCHEME";
    sInf->MyTypeInfo=typeid(TPMS_NULL_SIG_SCHEME).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPMT_SIG_SCHEME
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMT_SIG_SCHEME_ID]=sInf;
    sInf->Name = "TPMT_SIG_SCHEME";
    sInf->MyTypeInfo=typeid(TPMT_SIG_SCHEME).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //scheme
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[0].ElementName = "scheme";
    sInf->Fields[0].ParentTypeName = "TPMT_SIG_SCHEME";
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_SIG_SCHEME_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    sInf->Fields[0].AssociatedElement=1;
    //details
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMU_SIG_SCHEME";
    sInf->Fields[1].ElementSize = sizeof(TPMU_SIG_SCHEME);
    sInf->Fields[1].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[1].ElementName = "details";
    sInf->Fields[1].ParentTypeName = "TPMT_SIG_SCHEME";
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_SIG_SCHEME_ID;
    sInf->Fields[1].Sort = ElementSort::TpmUnion;
    sInf->Fields[1].IsArray = FALSE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMS_ENC_SCHEME_OAEP
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPMS_ENC_SCHEME_OAEP_ID]=sInf;
    sInf->Name = "TPMS_ENC_SCHEME_OAEP";
    sInf->MyTypeInfo=typeid(TPMS_ENC_SCHEME_OAEP).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hashAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hashAlg";
    sInf->Fields[0].ParentTypeName = "TPMS_ENC_SCHEME_OAEP";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ENC_SCHEME_OAEP_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPMS_ENC_SCHEME_RSAES
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPMS_ENC_SCHEME_RSAES_ID]=sInf;
    sInf->Name = "TPMS_ENC_SCHEME_RSAES";
    sInf->MyTypeInfo=typeid(TPMS_ENC_SCHEME_RSAES).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPMS_KEY_SCHEME_ECDH
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPMS_KEY_SCHEME_ECDH_ID]=sInf;
    sInf->Name = "TPMS_KEY_SCHEME_ECDH";
    sInf->MyTypeInfo=typeid(TPMS_KEY_SCHEME_ECDH).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hashAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hashAlg";
    sInf->Fields[0].ParentTypeName = "TPMS_KEY_SCHEME_ECDH";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_KEY_SCHEME_ECDH_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPMS_KEY_SCHEME_ECMQV
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPMS_KEY_SCHEME_ECMQV_ID]=sInf;
    sInf->Name = "TPMS_KEY_SCHEME_ECMQV";
    sInf->MyTypeInfo=typeid(TPMS_KEY_SCHEME_ECMQV).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hashAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hashAlg";
    sInf->Fields[0].ParentTypeName = "TPMS_KEY_SCHEME_ECMQV";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_KEY_SCHEME_ECMQV_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPMS_SCHEME_MGF1
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPMS_SCHEME_MGF1_ID]=sInf;
    sInf->Name = "TPMS_SCHEME_MGF1";
    sInf->MyTypeInfo=typeid(TPMS_SCHEME_MGF1).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hashAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hashAlg";
    sInf->Fields[0].ParentTypeName = "TPMS_SCHEME_MGF1";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SCHEME_MGF1_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPMS_SCHEME_KDF1_SP800_56A
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPMS_SCHEME_KDF1_SP800_56A_ID]=sInf;
    sInf->Name = "TPMS_SCHEME_KDF1_SP800_56A";
    sInf->MyTypeInfo=typeid(TPMS_SCHEME_KDF1_SP800_56A).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hashAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hashAlg";
    sInf->Fields[0].ParentTypeName = "TPMS_SCHEME_KDF1_SP800_56A";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SCHEME_KDF1_SP800_56A_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPMS_SCHEME_KDF2
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPMS_SCHEME_KDF2_ID]=sInf;
    sInf->Name = "TPMS_SCHEME_KDF2";
    sInf->MyTypeInfo=typeid(TPMS_SCHEME_KDF2).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hashAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hashAlg";
    sInf->Fields[0].ParentTypeName = "TPMS_SCHEME_KDF2";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SCHEME_KDF2_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPMS_SCHEME_KDF1_SP800_108
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPMS_SCHEME_KDF1_SP800_108_ID]=sInf;
    sInf->Name = "TPMS_SCHEME_KDF1_SP800_108";
    sInf->MyTypeInfo=typeid(TPMS_SCHEME_KDF1_SP800_108).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hashAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hashAlg";
    sInf->Fields[0].ParentTypeName = "TPMS_SCHEME_KDF1_SP800_108";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SCHEME_KDF1_SP800_108_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPMS_NULL_KDF_SCHEME
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPMS_NULL_KDF_SCHEME_ID]=sInf;
    sInf->Name = "TPMS_NULL_KDF_SCHEME";
    sInf->MyTypeInfo=typeid(TPMS_NULL_KDF_SCHEME).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPMT_KDF_SCHEME
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMT_KDF_SCHEME_ID]=sInf;
    sInf->Name = "TPMT_KDF_SCHEME";
    sInf->MyTypeInfo=typeid(TPMT_KDF_SCHEME).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //scheme
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[0].ElementName = "scheme";
    sInf->Fields[0].ParentTypeName = "TPMT_KDF_SCHEME";
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_KDF_SCHEME_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    sInf->Fields[0].AssociatedElement=1;
    //details
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMU_KDF_SCHEME_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMU_KDF_SCHEME";
    sInf->Fields[1].ElementSize = sizeof(TPMU_KDF_SCHEME);
    sInf->Fields[1].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[1].ElementName = "details";
    sInf->Fields[1].ParentTypeName = "TPMT_KDF_SCHEME";
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_KDF_SCHEME_ID;
    sInf->Fields[1].Sort = ElementSort::TpmUnion;
    sInf->Fields[1].IsArray = FALSE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMS_NULL_ASYM_SCHEME
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPMS_NULL_ASYM_SCHEME_ID]=sInf;
    sInf->Name = "TPMS_NULL_ASYM_SCHEME";
    sInf->MyTypeInfo=typeid(TPMS_NULL_ASYM_SCHEME).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPMT_ASYM_SCHEME
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMT_ASYM_SCHEME_ID]=sInf;
    sInf->Name = "TPMT_ASYM_SCHEME";
    sInf->MyTypeInfo=typeid(TPMT_ASYM_SCHEME).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //scheme
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[0].ElementName = "scheme";
    sInf->Fields[0].ParentTypeName = "TPMT_ASYM_SCHEME";
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_ASYM_SCHEME_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    sInf->Fields[0].AssociatedElement=1;
    //details
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMU_ASYM_SCHEME";
    sInf->Fields[1].ElementSize = sizeof(TPMU_ASYM_SCHEME);
    sInf->Fields[1].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[1].ElementName = "details";
    sInf->Fields[1].ParentTypeName = "TPMT_ASYM_SCHEME";
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_ASYM_SCHEME_ID;
    sInf->Fields[1].Sort = ElementSort::TpmUnion;
    sInf->Fields[1].IsArray = FALSE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMT_RSA_SCHEME
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMT_RSA_SCHEME_ID]=sInf;
    sInf->Name = "TPMT_RSA_SCHEME";
    sInf->MyTypeInfo=typeid(TPMT_RSA_SCHEME).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //scheme
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[0].ElementName = "scheme";
    sInf->Fields[0].ParentTypeName = "TPMT_RSA_SCHEME";
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_RSA_SCHEME_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    sInf->Fields[0].AssociatedElement=1;
    //details
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMU_ASYM_SCHEME";
    sInf->Fields[1].ElementSize = sizeof(TPMU_ASYM_SCHEME);
    sInf->Fields[1].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[1].ElementName = "details";
    sInf->Fields[1].ParentTypeName = "TPMT_RSA_SCHEME";
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_RSA_SCHEME_ID;
    sInf->Fields[1].Sort = ElementSort::TpmUnion;
    sInf->Fields[1].IsArray = FALSE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMT_RSA_DECRYPT
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMT_RSA_DECRYPT_ID]=sInf;
    sInf->Name = "TPMT_RSA_DECRYPT";
    sInf->MyTypeInfo=typeid(TPMT_RSA_DECRYPT).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //scheme
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[0].ElementName = "scheme";
    sInf->Fields[0].ParentTypeName = "TPMT_RSA_DECRYPT";
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_RSA_DECRYPT_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    sInf->Fields[0].AssociatedElement=1;
    //details
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMU_ASYM_SCHEME";
    sInf->Fields[1].ElementSize = sizeof(TPMU_ASYM_SCHEME);
    sInf->Fields[1].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[1].ElementName = "details";
    sInf->Fields[1].ParentTypeName = "TPMT_RSA_DECRYPT";
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_RSA_DECRYPT_ID;
    sInf->Fields[1].Sort = ElementSort::TpmUnion;
    sInf->Fields[1].IsArray = FALSE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2B_PUBLIC_KEY_RSA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_PUBLIC_KEY_RSA_ID]=sInf;
    sInf->Name = "TPM2B_PUBLIC_KEY_RSA";
    sInf->MyTypeInfo=typeid(TPM2B_PUBLIC_KEY_RSA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_PUBLIC_KEY_RSA";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_PUBLIC_KEY_RSA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_PUBLIC_KEY_RSA";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_PUBLIC_KEY_RSA_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2B_PRIVATE_KEY_RSA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_PRIVATE_KEY_RSA_ID]=sInf;
    sInf->Name = "TPM2B_PRIVATE_KEY_RSA";
    sInf->MyTypeInfo=typeid(TPM2B_PRIVATE_KEY_RSA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_PRIVATE_KEY_RSA";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_PRIVATE_KEY_RSA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_PRIVATE_KEY_RSA";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_PRIVATE_KEY_RSA_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2B_ECC_PARAMETER
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_ECC_PARAMETER_ID]=sInf;
    sInf->Name = "TPM2B_ECC_PARAMETER";
    sInf->MyTypeInfo=typeid(TPM2B_ECC_PARAMETER).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_ECC_PARAMETER";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_ECC_PARAMETER_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_ECC_PARAMETER";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_ECC_PARAMETER_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMS_ECC_POINT
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPMS_ECC_POINT_ID]=sInf;
    sInf->Name = "TPMS_ECC_POINT";
    sInf->MyTypeInfo=typeid(TPMS_ECC_POINT).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //xSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "xSize";
    sInf->Fields[0].ParentTypeName = "TPMS_ECC_POINT";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //x
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "x";
    sInf->Fields[1].ParentTypeName = "TPMS_ECC_POINT";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //ySize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "ySize";
    sInf->Fields[2].ParentTypeName = "TPMS_ECC_POINT";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //y
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "y";
    sInf->Fields[3].ParentTypeName = "TPMS_ECC_POINT";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPM2B_ECC_POINT
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_ECC_POINT_ID]=sInf;
    sInf->Name = "TPM2B_ECC_POINT";
    sInf->MyTypeInfo=typeid(TPM2B_ECC_POINT).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_ECC_POINT";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_ECC_POINT_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //point
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_ECC_POINT";
    sInf->Fields[1].ElementSize = sizeof(TPMS_ECC_POINT);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "point";
    sInf->Fields[1].ParentTypeName = "TPM2B_ECC_POINT";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_ECC_POINT_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPMT_ECC_SCHEME
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMT_ECC_SCHEME_ID]=sInf;
    sInf->Name = "TPMT_ECC_SCHEME";
    sInf->MyTypeInfo=typeid(TPMT_ECC_SCHEME).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //scheme
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[0].ElementName = "scheme";
    sInf->Fields[0].ParentTypeName = "TPMT_ECC_SCHEME";
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_ECC_SCHEME_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    sInf->Fields[0].AssociatedElement=1;
    //details
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMU_ASYM_SCHEME";
    sInf->Fields[1].ElementSize = sizeof(TPMU_ASYM_SCHEME);
    sInf->Fields[1].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[1].ElementName = "details";
    sInf->Fields[1].ParentTypeName = "TPMT_ECC_SCHEME";
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_ECC_SCHEME_ID;
    sInf->Fields[1].Sort = ElementSort::TpmUnion;
    sInf->Fields[1].IsArray = FALSE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMS_ALGORITHM_DETAIL_ECC
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(20);
    TypeMap[TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID]=sInf;
    sInf->Name = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->MyTypeInfo=typeid(TPMS_ALGORITHM_DETAIL_ECC).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //curveID
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ECC_CURVE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ECC_CURVE";
    sInf->Fields[0].ElementSize = sizeof(TPM_ECC_CURVE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "curveID";
    sInf->Fields[0].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    //keySize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "keySize";
    sInf->Fields[1].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //kdfScheme
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[2].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[2].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[2].ElementName = "kdfScheme";
    sInf->Fields[2].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    sInf->Fields[2].AssociatedElement=3;
    //kdf
    sInf->Fields[3].ThisElementType = TpmTypeId::TPMU_KDF_SCHEME_ID;
    sInf->Fields[3].ThisElementTypeName = "TPMU_KDF_SCHEME";
    sInf->Fields[3].ElementSize = sizeof(TPMU_KDF_SCHEME);
    sInf->Fields[3].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[3].ElementName = "kdf";
    sInf->Fields[3].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[3].Sort = ElementSort::TpmUnion;
    sInf->Fields[3].IsArray = FALSE;
    sInf->Fields[3].AssociatedElement=2;
    //signScheme
    sInf->Fields[4].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[4].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[4].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[4].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[4].ElementName = "signScheme";
    sInf->Fields[4].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    sInf->Fields[4].AssociatedElement=5;
    //sign
    sInf->Fields[5].ThisElementType = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[5].ThisElementTypeName = "TPMU_ASYM_SCHEME";
    sInf->Fields[5].ElementSize = sizeof(TPMU_ASYM_SCHEME);
    sInf->Fields[5].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[5].ElementName = "sign";
    sInf->Fields[5].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[5].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[5].Sort = ElementSort::TpmUnion;
    sInf->Fields[5].IsArray = FALSE;
    sInf->Fields[5].AssociatedElement=4;
    //pSize
    sInf->Fields[6].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[6].ThisElementTypeName = "UINT16";
    sInf->Fields[6].ElementSize = sizeof(UINT16);
    sInf->Fields[6].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[6].ElementName = "pSize";
    sInf->Fields[6].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[6].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = FALSE;
    //p
    sInf->Fields[7].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[7].ThisElementTypeName = "BYTE";
    sInf->Fields[7].ElementSize = sizeof(BYTE);
    sInf->Fields[7].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[7].ElementName = "p";
    sInf->Fields[7].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[7].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[7].Sort = ElementSort::TpmValueType;
    sInf->Fields[7].IsArray = TRUE;
    sInf->Fields[7].AssociatedElement=6;
    //aSize
    sInf->Fields[8].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[8].ThisElementTypeName = "UINT16";
    sInf->Fields[8].ElementSize = sizeof(UINT16);
    sInf->Fields[8].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[8].ElementName = "aSize";
    sInf->Fields[8].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[8].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[8].Sort = ElementSort::TpmValueType;
    sInf->Fields[8].IsArray = FALSE;
    //a
    sInf->Fields[9].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[9].ThisElementTypeName = "BYTE";
    sInf->Fields[9].ElementSize = sizeof(BYTE);
    sInf->Fields[9].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[9].ElementName = "a";
    sInf->Fields[9].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[9].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[9].Sort = ElementSort::TpmValueType;
    sInf->Fields[9].IsArray = TRUE;
    sInf->Fields[9].AssociatedElement=8;
    //bSize
    sInf->Fields[10].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[10].ThisElementTypeName = "UINT16";
    sInf->Fields[10].ElementSize = sizeof(UINT16);
    sInf->Fields[10].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[10].ElementName = "bSize";
    sInf->Fields[10].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[10].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[10].Sort = ElementSort::TpmValueType;
    sInf->Fields[10].IsArray = FALSE;
    //b
    sInf->Fields[11].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[11].ThisElementTypeName = "BYTE";
    sInf->Fields[11].ElementSize = sizeof(BYTE);
    sInf->Fields[11].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[11].ElementName = "b";
    sInf->Fields[11].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[11].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[11].Sort = ElementSort::TpmValueType;
    sInf->Fields[11].IsArray = TRUE;
    sInf->Fields[11].AssociatedElement=10;
    //gXSize
    sInf->Fields[12].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[12].ThisElementTypeName = "UINT16";
    sInf->Fields[12].ElementSize = sizeof(UINT16);
    sInf->Fields[12].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[12].ElementName = "gXSize";
    sInf->Fields[12].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[12].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[12].Sort = ElementSort::TpmValueType;
    sInf->Fields[12].IsArray = FALSE;
    //gX
    sInf->Fields[13].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[13].ThisElementTypeName = "BYTE";
    sInf->Fields[13].ElementSize = sizeof(BYTE);
    sInf->Fields[13].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[13].ElementName = "gX";
    sInf->Fields[13].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[13].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[13].Sort = ElementSort::TpmValueType;
    sInf->Fields[13].IsArray = TRUE;
    sInf->Fields[13].AssociatedElement=12;
    //gYSize
    sInf->Fields[14].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[14].ThisElementTypeName = "UINT16";
    sInf->Fields[14].ElementSize = sizeof(UINT16);
    sInf->Fields[14].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[14].ElementName = "gYSize";
    sInf->Fields[14].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[14].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[14].Sort = ElementSort::TpmValueType;
    sInf->Fields[14].IsArray = FALSE;
    //gY
    sInf->Fields[15].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[15].ThisElementTypeName = "BYTE";
    sInf->Fields[15].ElementSize = sizeof(BYTE);
    sInf->Fields[15].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[15].ElementName = "gY";
    sInf->Fields[15].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[15].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[15].Sort = ElementSort::TpmValueType;
    sInf->Fields[15].IsArray = TRUE;
    sInf->Fields[15].AssociatedElement=14;
    //nSize
    sInf->Fields[16].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[16].ThisElementTypeName = "UINT16";
    sInf->Fields[16].ElementSize = sizeof(UINT16);
    sInf->Fields[16].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[16].ElementName = "nSize";
    sInf->Fields[16].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[16].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[16].Sort = ElementSort::TpmValueType;
    sInf->Fields[16].IsArray = FALSE;
    //n
    sInf->Fields[17].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[17].ThisElementTypeName = "BYTE";
    sInf->Fields[17].ElementSize = sizeof(BYTE);
    sInf->Fields[17].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[17].ElementName = "n";
    sInf->Fields[17].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[17].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[17].Sort = ElementSort::TpmValueType;
    sInf->Fields[17].IsArray = TRUE;
    sInf->Fields[17].AssociatedElement=16;
    //hSize
    sInf->Fields[18].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[18].ThisElementTypeName = "UINT16";
    sInf->Fields[18].ElementSize = sizeof(UINT16);
    sInf->Fields[18].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[18].ElementName = "hSize";
    sInf->Fields[18].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[18].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[18].Sort = ElementSort::TpmValueType;
    sInf->Fields[18].IsArray = FALSE;
    //h
    sInf->Fields[19].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[19].ThisElementTypeName = "BYTE";
    sInf->Fields[19].ElementSize = sizeof(BYTE);
    sInf->Fields[19].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[19].ElementName = "h";
    sInf->Fields[19].ParentTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[19].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[19].Sort = ElementSort::TpmValueType;
    sInf->Fields[19].IsArray = TRUE;
    sInf->Fields[19].AssociatedElement=18;
    //===================TPMS_SIGNATURE_RSA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPMS_SIGNATURE_RSA_ID]=sInf;
    sInf->Name = "TPMS_SIGNATURE_RSA";
    sInf->MyTypeInfo=typeid(TPMS_SIGNATURE_RSA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hash
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hash";
    sInf->Fields[0].ParentTypeName = "TPMS_SIGNATURE_RSA";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_RSA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //sigSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "sigSize";
    sInf->Fields[1].ParentTypeName = "TPMS_SIGNATURE_RSA";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_RSA_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //sig
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "sig";
    sInf->Fields[2].ParentTypeName = "TPMS_SIGNATURE_RSA";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_RSA_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPMS_SIGNATURE_RSASSA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPMS_SIGNATURE_RSASSA_ID]=sInf;
    sInf->Name = "TPMS_SIGNATURE_RSASSA";
    sInf->MyTypeInfo=typeid(TPMS_SIGNATURE_RSASSA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hash
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hash";
    sInf->Fields[0].ParentTypeName = "TPMS_SIGNATURE_RSASSA";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_RSASSA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //sigSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "sigSize";
    sInf->Fields[1].ParentTypeName = "TPMS_SIGNATURE_RSASSA";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_RSASSA_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //sig
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "sig";
    sInf->Fields[2].ParentTypeName = "TPMS_SIGNATURE_RSASSA";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_RSASSA_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPMS_SIGNATURE_RSAPSS
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID]=sInf;
    sInf->Name = "TPMS_SIGNATURE_RSAPSS";
    sInf->MyTypeInfo=typeid(TPMS_SIGNATURE_RSAPSS).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hash
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hash";
    sInf->Fields[0].ParentTypeName = "TPMS_SIGNATURE_RSAPSS";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //sigSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "sigSize";
    sInf->Fields[1].ParentTypeName = "TPMS_SIGNATURE_RSAPSS";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //sig
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "sig";
    sInf->Fields[2].ParentTypeName = "TPMS_SIGNATURE_RSAPSS";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPMS_SIGNATURE_ECC
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPMS_SIGNATURE_ECC_ID]=sInf;
    sInf->Name = "TPMS_SIGNATURE_ECC";
    sInf->MyTypeInfo=typeid(TPMS_SIGNATURE_ECC).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hash
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hash";
    sInf->Fields[0].ParentTypeName = "TPMS_SIGNATURE_ECC";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_ECC_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //signatureRSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "signatureRSize";
    sInf->Fields[1].ParentTypeName = "TPMS_SIGNATURE_ECC";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_ECC_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //signatureR
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "signatureR";
    sInf->Fields[2].ParentTypeName = "TPMS_SIGNATURE_ECC";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_ECC_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //signatureSSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "signatureSSize";
    sInf->Fields[3].ParentTypeName = "TPMS_SIGNATURE_ECC";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_SIGNATURE_ECC_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //signatureS
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "signatureS";
    sInf->Fields[4].ParentTypeName = "TPMS_SIGNATURE_ECC";
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_SIGNATURE_ECC_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //===================TPMS_SIGNATURE_ECDSA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPMS_SIGNATURE_ECDSA_ID]=sInf;
    sInf->Name = "TPMS_SIGNATURE_ECDSA";
    sInf->MyTypeInfo=typeid(TPMS_SIGNATURE_ECDSA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hash
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hash";
    sInf->Fields[0].ParentTypeName = "TPMS_SIGNATURE_ECDSA";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //signatureRSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "signatureRSize";
    sInf->Fields[1].ParentTypeName = "TPMS_SIGNATURE_ECDSA";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //signatureR
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "signatureR";
    sInf->Fields[2].ParentTypeName = "TPMS_SIGNATURE_ECDSA";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //signatureSSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "signatureSSize";
    sInf->Fields[3].ParentTypeName = "TPMS_SIGNATURE_ECDSA";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //signatureS
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "signatureS";
    sInf->Fields[4].ParentTypeName = "TPMS_SIGNATURE_ECDSA";
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //===================TPMS_SIGNATURE_ECDAA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPMS_SIGNATURE_ECDAA_ID]=sInf;
    sInf->Name = "TPMS_SIGNATURE_ECDAA";
    sInf->MyTypeInfo=typeid(TPMS_SIGNATURE_ECDAA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hash
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hash";
    sInf->Fields[0].ParentTypeName = "TPMS_SIGNATURE_ECDAA";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //signatureRSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "signatureRSize";
    sInf->Fields[1].ParentTypeName = "TPMS_SIGNATURE_ECDAA";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //signatureR
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "signatureR";
    sInf->Fields[2].ParentTypeName = "TPMS_SIGNATURE_ECDAA";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //signatureSSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "signatureSSize";
    sInf->Fields[3].ParentTypeName = "TPMS_SIGNATURE_ECDAA";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //signatureS
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "signatureS";
    sInf->Fields[4].ParentTypeName = "TPMS_SIGNATURE_ECDAA";
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //===================TPMS_SIGNATURE_SM2
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPMS_SIGNATURE_SM2_ID]=sInf;
    sInf->Name = "TPMS_SIGNATURE_SM2";
    sInf->MyTypeInfo=typeid(TPMS_SIGNATURE_SM2).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hash
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hash";
    sInf->Fields[0].ParentTypeName = "TPMS_SIGNATURE_SM2";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_SM2_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //signatureRSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "signatureRSize";
    sInf->Fields[1].ParentTypeName = "TPMS_SIGNATURE_SM2";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_SM2_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //signatureR
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "signatureR";
    sInf->Fields[2].ParentTypeName = "TPMS_SIGNATURE_SM2";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_SM2_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //signatureSSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "signatureSSize";
    sInf->Fields[3].ParentTypeName = "TPMS_SIGNATURE_SM2";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_SIGNATURE_SM2_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //signatureS
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "signatureS";
    sInf->Fields[4].ParentTypeName = "TPMS_SIGNATURE_SM2";
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_SIGNATURE_SM2_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //===================TPMS_SIGNATURE_ECSCHNORR
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID]=sInf;
    sInf->Name = "TPMS_SIGNATURE_ECSCHNORR";
    sInf->MyTypeInfo=typeid(TPMS_SIGNATURE_ECSCHNORR).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //hash
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "hash";
    sInf->Fields[0].ParentTypeName = "TPMS_SIGNATURE_ECSCHNORR";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //signatureRSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "signatureRSize";
    sInf->Fields[1].ParentTypeName = "TPMS_SIGNATURE_ECSCHNORR";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //signatureR
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "signatureR";
    sInf->Fields[2].ParentTypeName = "TPMS_SIGNATURE_ECSCHNORR";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //signatureSSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "signatureSSize";
    sInf->Fields[3].ParentTypeName = "TPMS_SIGNATURE_ECSCHNORR";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //signatureS
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "signatureS";
    sInf->Fields[4].ParentTypeName = "TPMS_SIGNATURE_ECSCHNORR";
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //===================TPMS_NULL_SIGNATURE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPMS_NULL_SIGNATURE_ID]=sInf;
    sInf->Name = "TPMS_NULL_SIGNATURE";
    sInf->MyTypeInfo=typeid(TPMS_NULL_SIGNATURE).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPMT_SIGNATURE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMT_SIGNATURE_ID]=sInf;
    sInf->Name = "TPMT_SIGNATURE";
    sInf->MyTypeInfo=typeid(TPMT_SIGNATURE).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //sigAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[0].ElementName = "sigAlg";
    sInf->Fields[0].ParentTypeName = "TPMT_SIGNATURE";
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_SIGNATURE_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    sInf->Fields[0].AssociatedElement=1;
    //signature
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMU_SIGNATURE";
    sInf->Fields[1].ElementSize = sizeof(TPMU_SIGNATURE);
    sInf->Fields[1].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[1].ElementName = "signature";
    sInf->Fields[1].ParentTypeName = "TPMT_SIGNATURE";
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_SIGNATURE_ID;
    sInf->Fields[1].Sort = ElementSort::TpmUnion;
    sInf->Fields[1].IsArray = FALSE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2B_ENCRYPTED_SECRET
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_ENCRYPTED_SECRET_ID]=sInf;
    sInf->Name = "TPM2B_ENCRYPTED_SECRET";
    sInf->MyTypeInfo=typeid(TPM2B_ENCRYPTED_SECRET).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_ENCRYPTED_SECRET";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_ENCRYPTED_SECRET_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //secret
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "secret";
    sInf->Fields[1].ParentTypeName = "TPM2B_ENCRYPTED_SECRET";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_ENCRYPTED_SECRET_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMS_KEYEDHASH_PARMS
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMS_KEYEDHASH_PARMS_ID]=sInf;
    sInf->Name = "TPMS_KEYEDHASH_PARMS";
    sInf->MyTypeInfo=typeid(TPMS_KEYEDHASH_PARMS).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //schemeScheme
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[0].ElementName = "schemeScheme";
    sInf->Fields[0].ParentTypeName = "TPMS_KEYEDHASH_PARMS";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_KEYEDHASH_PARMS_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    sInf->Fields[0].AssociatedElement=1;
    //scheme
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMU_SCHEME_KEYEDHASH_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMU_SCHEME_KEYEDHASH";
    sInf->Fields[1].ElementSize = sizeof(TPMU_SCHEME_KEYEDHASH);
    sInf->Fields[1].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[1].ElementName = "scheme";
    sInf->Fields[1].ParentTypeName = "TPMS_KEYEDHASH_PARMS";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_KEYEDHASH_PARMS_ID;
    sInf->Fields[1].Sort = ElementSort::TpmUnion;
    sInf->Fields[1].IsArray = FALSE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMS_ASYM_PARMS
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPMS_ASYM_PARMS_ID]=sInf;
    sInf->Name = "TPMS_ASYM_PARMS";
    sInf->MyTypeInfo=typeid(TPMS_ASYM_PARMS).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //symmetric
    sInf->Fields[0].ThisElementType = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    sInf->Fields[0].ThisElementTypeName = "TPMT_SYM_DEF_OBJECT";
    sInf->Fields[0].ElementSize = sizeof(TPMT_SYM_DEF_OBJECT);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "symmetric";
    sInf->Fields[0].ParentTypeName = "TPMS_ASYM_PARMS";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ASYM_PARMS_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //schemeScheme
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[1].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[1].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[1].ElementName = "schemeScheme";
    sInf->Fields[1].ParentTypeName = "TPMS_ASYM_PARMS";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_ASYM_PARMS_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    sInf->Fields[1].AssociatedElement=2;
    //scheme
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMU_ASYM_SCHEME";
    sInf->Fields[2].ElementSize = sizeof(TPMU_ASYM_SCHEME);
    sInf->Fields[2].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[2].ElementName = "scheme";
    sInf->Fields[2].ParentTypeName = "TPMS_ASYM_PARMS";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_ASYM_PARMS_ID;
    sInf->Fields[2].Sort = ElementSort::TpmUnion;
    sInf->Fields[2].IsArray = FALSE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPMS_RSA_PARMS
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPMS_RSA_PARMS_ID]=sInf;
    sInf->Name = "TPMS_RSA_PARMS";
    sInf->MyTypeInfo=typeid(TPMS_RSA_PARMS).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //symmetric
    sInf->Fields[0].ThisElementType = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    sInf->Fields[0].ThisElementTypeName = "TPMT_SYM_DEF_OBJECT";
    sInf->Fields[0].ElementSize = sizeof(TPMT_SYM_DEF_OBJECT);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "symmetric";
    sInf->Fields[0].ParentTypeName = "TPMS_RSA_PARMS";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_RSA_PARMS_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //schemeScheme
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[1].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[1].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[1].ElementName = "schemeScheme";
    sInf->Fields[1].ParentTypeName = "TPMS_RSA_PARMS";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_RSA_PARMS_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    sInf->Fields[1].AssociatedElement=2;
    //scheme
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMU_ASYM_SCHEME";
    sInf->Fields[2].ElementSize = sizeof(TPMU_ASYM_SCHEME);
    sInf->Fields[2].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[2].ElementName = "scheme";
    sInf->Fields[2].ParentTypeName = "TPMS_RSA_PARMS";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_RSA_PARMS_ID;
    sInf->Fields[2].Sort = ElementSort::TpmUnion;
    sInf->Fields[2].IsArray = FALSE;
    sInf->Fields[2].AssociatedElement=1;
    //keyBits
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "keyBits";
    sInf->Fields[3].ParentTypeName = "TPMS_RSA_PARMS";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_RSA_PARMS_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //exponent
    sInf->Fields[4].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[4].ThisElementTypeName = "UINT32";
    sInf->Fields[4].ElementSize = sizeof(UINT32);
    sInf->Fields[4].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[4].ElementName = "exponent";
    sInf->Fields[4].ParentTypeName = "TPMS_RSA_PARMS";
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_RSA_PARMS_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    //===================TPMS_ECC_PARMS
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(6);
    TypeMap[TpmTypeId::TPMS_ECC_PARMS_ID]=sInf;
    sInf->Name = "TPMS_ECC_PARMS";
    sInf->MyTypeInfo=typeid(TPMS_ECC_PARMS).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //symmetric
    sInf->Fields[0].ThisElementType = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    sInf->Fields[0].ThisElementTypeName = "TPMT_SYM_DEF_OBJECT";
    sInf->Fields[0].ElementSize = sizeof(TPMT_SYM_DEF_OBJECT);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "symmetric";
    sInf->Fields[0].ParentTypeName = "TPMS_ECC_PARMS";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ECC_PARMS_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //schemeScheme
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[1].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[1].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[1].ElementName = "schemeScheme";
    sInf->Fields[1].ParentTypeName = "TPMS_ECC_PARMS";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_ECC_PARMS_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    sInf->Fields[1].AssociatedElement=2;
    //scheme
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMU_ASYM_SCHEME";
    sInf->Fields[2].ElementSize = sizeof(TPMU_ASYM_SCHEME);
    sInf->Fields[2].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[2].ElementName = "scheme";
    sInf->Fields[2].ParentTypeName = "TPMS_ECC_PARMS";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_ECC_PARMS_ID;
    sInf->Fields[2].Sort = ElementSort::TpmUnion;
    sInf->Fields[2].IsArray = FALSE;
    sInf->Fields[2].AssociatedElement=1;
    //curveID
    sInf->Fields[3].ThisElementType = TpmTypeId::TPM_ECC_CURVE_ID;
    sInf->Fields[3].ThisElementTypeName = "TPM_ECC_CURVE";
    sInf->Fields[3].ElementSize = sizeof(TPM_ECC_CURVE);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "curveID";
    sInf->Fields[3].ParentTypeName = "TPMS_ECC_PARMS";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_ECC_PARMS_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //kdfScheme
    sInf->Fields[4].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[4].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[4].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[4].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[4].ElementName = "kdfScheme";
    sInf->Fields[4].ParentTypeName = "TPMS_ECC_PARMS";
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_ECC_PARMS_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    sInf->Fields[4].AssociatedElement=5;
    //kdf
    sInf->Fields[5].ThisElementType = TpmTypeId::TPMU_KDF_SCHEME_ID;
    sInf->Fields[5].ThisElementTypeName = "TPMU_KDF_SCHEME";
    sInf->Fields[5].ElementSize = sizeof(TPMU_KDF_SCHEME);
    sInf->Fields[5].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[5].ElementName = "kdf";
    sInf->Fields[5].ParentTypeName = "TPMS_ECC_PARMS";
    sInf->Fields[5].ParentType = TpmTypeId::TPMS_ECC_PARMS_ID;
    sInf->Fields[5].Sort = ElementSort::TpmUnion;
    sInf->Fields[5].IsArray = FALSE;
    sInf->Fields[5].AssociatedElement=4;
    //===================TPMT_PUBLIC_PARMS
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMT_PUBLIC_PARMS_ID]=sInf;
    sInf->Name = "TPMT_PUBLIC_PARMS";
    sInf->MyTypeInfo=typeid(TPMT_PUBLIC_PARMS).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //type
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[0].ElementName = "type";
    sInf->Fields[0].ParentTypeName = "TPMT_PUBLIC_PARMS";
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_PUBLIC_PARMS_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    sInf->Fields[0].AssociatedElement=1;
    //parameters
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMU_PUBLIC_PARMS_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMU_PUBLIC_PARMS";
    sInf->Fields[1].ElementSize = sizeof(TPMU_PUBLIC_PARMS);
    sInf->Fields[1].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[1].ElementName = "parameters";
    sInf->Fields[1].ParentTypeName = "TPMT_PUBLIC_PARMS";
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_PUBLIC_PARMS_ID;
    sInf->Fields[1].Sort = ElementSort::TpmUnion;
    sInf->Fields[1].IsArray = FALSE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMT_PUBLIC
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(7);
    TypeMap[TpmTypeId::TPMT_PUBLIC_ID]=sInf;
    sInf->Name = "TPMT_PUBLIC";
    sInf->MyTypeInfo=typeid(TPMT_PUBLIC).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //type
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[0].ElementName = "type";
    sInf->Fields[0].ParentTypeName = "TPMT_PUBLIC";
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    sInf->Fields[0].AssociatedElement=5;
    //nameAlg
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[1].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "nameAlg";
    sInf->Fields[1].ParentTypeName = "TPMT_PUBLIC";
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //objectAttributes
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMA_OBJECT_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMA_OBJECT";
    sInf->Fields[2].ElementSize = sizeof(TPMA_OBJECT);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "objectAttributes";
    sInf->Fields[2].ParentTypeName = "TPMT_PUBLIC";
    sInf->Fields[2].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[2].Sort = ElementSort::TpmBitfield;
    sInf->Fields[2].IsArray = FALSE;
    //authPolicySize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "authPolicySize";
    sInf->Fields[3].ParentTypeName = "TPMT_PUBLIC";
    sInf->Fields[3].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //authPolicy
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "authPolicy";
    sInf->Fields[4].ParentTypeName = "TPMT_PUBLIC";
    sInf->Fields[4].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //parameters
    sInf->Fields[5].ThisElementType = TpmTypeId::TPMU_PUBLIC_PARMS_ID;
    sInf->Fields[5].ThisElementTypeName = "TPMU_PUBLIC_PARMS";
    sInf->Fields[5].ElementSize = sizeof(TPMU_PUBLIC_PARMS);
    sInf->Fields[5].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[5].ElementName = "parameters";
    sInf->Fields[5].ParentTypeName = "TPMT_PUBLIC";
    sInf->Fields[5].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[5].Sort = ElementSort::TpmUnion;
    sInf->Fields[5].IsArray = FALSE;
    sInf->Fields[5].AssociatedElement=0;
    //unique
    sInf->Fields[6].ThisElementType = TpmTypeId::TPMU_PUBLIC_ID_ID;
    sInf->Fields[6].ThisElementTypeName = "TPMU_PUBLIC_ID";
    sInf->Fields[6].ElementSize = sizeof(TPMU_PUBLIC_ID);
    sInf->Fields[6].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[6].ElementName = "unique";
    sInf->Fields[6].ParentTypeName = "TPMT_PUBLIC";
    sInf->Fields[6].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[6].Sort = ElementSort::TpmUnion;
    sInf->Fields[6].IsArray = FALSE;
    sInf->Fields[6].AssociatedElement=0;
    //===================TPM2B_PUBLIC
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_PUBLIC_ID]=sInf;
    sInf->Name = "TPM2B_PUBLIC";
    sInf->MyTypeInfo=typeid(TPM2B_PUBLIC).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_PUBLIC";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_PUBLIC_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //publicArea
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMT_PUBLIC";
    sInf->Fields[1].ElementSize = sizeof(TPMT_PUBLIC);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "publicArea";
    sInf->Fields[1].ParentTypeName = "TPM2B_PUBLIC";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_PUBLIC_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPM2B_TEMPLATE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_TEMPLATE_ID]=sInf;
    sInf->Name = "TPM2B_TEMPLATE";
    sInf->MyTypeInfo=typeid(TPM2B_TEMPLATE).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_TEMPLATE";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_TEMPLATE_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_TEMPLATE";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_TEMPLATE_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2B_PRIVATE_VENDOR_SPECIFIC
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_PRIVATE_VENDOR_SPECIFIC_ID]=sInf;
    sInf->Name = "TPM2B_PRIVATE_VENDOR_SPECIFIC";
    sInf->MyTypeInfo=typeid(TPM2B_PRIVATE_VENDOR_SPECIFIC).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_PRIVATE_VENDOR_SPECIFIC";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_PRIVATE_VENDOR_SPECIFIC_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_PRIVATE_VENDOR_SPECIFIC";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_PRIVATE_VENDOR_SPECIFIC_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMT_SENSITIVE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(6);
    TypeMap[TpmTypeId::TPMT_SENSITIVE_ID]=sInf;
    sInf->Name = "TPMT_SENSITIVE";
    sInf->MyTypeInfo=typeid(TPMT_SENSITIVE).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //sensitiveType
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[0].ElementName = "sensitiveType";
    sInf->Fields[0].ParentTypeName = "TPMT_SENSITIVE";
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_SENSITIVE_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    sInf->Fields[0].AssociatedElement=5;
    //authValueSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "authValueSize";
    sInf->Fields[1].ParentTypeName = "TPMT_SENSITIVE";
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_SENSITIVE_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //authValue
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "authValue";
    sInf->Fields[2].ParentTypeName = "TPMT_SENSITIVE";
    sInf->Fields[2].ParentType = TpmTypeId::TPMT_SENSITIVE_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //seedValueSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "seedValueSize";
    sInf->Fields[3].ParentTypeName = "TPMT_SENSITIVE";
    sInf->Fields[3].ParentType = TpmTypeId::TPMT_SENSITIVE_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //seedValue
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "seedValue";
    sInf->Fields[4].ParentTypeName = "TPMT_SENSITIVE";
    sInf->Fields[4].ParentType = TpmTypeId::TPMT_SENSITIVE_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //sensitive
    sInf->Fields[5].ThisElementType = TpmTypeId::TPMU_SENSITIVE_COMPOSITE_ID;
    sInf->Fields[5].ThisElementTypeName = "TPMU_SENSITIVE_COMPOSITE";
    sInf->Fields[5].ElementSize = sizeof(TPMU_SENSITIVE_COMPOSITE);
    sInf->Fields[5].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[5].ElementName = "sensitive";
    sInf->Fields[5].ParentTypeName = "TPMT_SENSITIVE";
    sInf->Fields[5].ParentType = TpmTypeId::TPMT_SENSITIVE_ID;
    sInf->Fields[5].Sort = ElementSort::TpmUnion;
    sInf->Fields[5].IsArray = FALSE;
    sInf->Fields[5].AssociatedElement=0;
    //===================TPM2B_SENSITIVE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_SENSITIVE_ID]=sInf;
    sInf->Name = "TPM2B_SENSITIVE";
    sInf->MyTypeInfo=typeid(TPM2B_SENSITIVE).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_SENSITIVE";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_SENSITIVE_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //sensitiveArea
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMT_SENSITIVE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMT_SENSITIVE";
    sInf->Fields[1].ElementSize = sizeof(TPMT_SENSITIVE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "sensitiveArea";
    sInf->Fields[1].ParentTypeName = "TPM2B_SENSITIVE";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_SENSITIVE_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================_PRIVATE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(6);
    TypeMap[TpmTypeId::_PRIVATE_ID]=sInf;
    sInf->Name = "_PRIVATE";
    sInf->MyTypeInfo=typeid(_PRIVATE).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //integrityOuterSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "integrityOuterSize";
    sInf->Fields[0].ParentTypeName = "_PRIVATE";
    sInf->Fields[0].ParentType = TpmTypeId::_PRIVATE_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //integrityOuter
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "integrityOuter";
    sInf->Fields[1].ParentTypeName = "_PRIVATE";
    sInf->Fields[1].ParentType = TpmTypeId::_PRIVATE_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //integrityInnerSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "integrityInnerSize";
    sInf->Fields[2].ParentTypeName = "_PRIVATE";
    sInf->Fields[2].ParentType = TpmTypeId::_PRIVATE_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //integrityInner
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "integrityInner";
    sInf->Fields[3].ParentTypeName = "_PRIVATE";
    sInf->Fields[3].ParentType = TpmTypeId::_PRIVATE_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //sensitiveSize
    sInf->Fields[4].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[4].ThisElementTypeName = "UINT16";
    sInf->Fields[4].ElementSize = sizeof(UINT16);
    sInf->Fields[4].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[4].ElementName = "sensitiveSize";
    sInf->Fields[4].ParentTypeName = "_PRIVATE";
    sInf->Fields[4].ParentType = TpmTypeId::_PRIVATE_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    //sensitive
    sInf->Fields[5].ThisElementType = TpmTypeId::TPMT_SENSITIVE_ID;
    sInf->Fields[5].ThisElementTypeName = "TPMT_SENSITIVE";
    sInf->Fields[5].ElementSize = sizeof(TPMT_SENSITIVE);
    sInf->Fields[5].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[5].ElementName = "sensitive";
    sInf->Fields[5].ParentTypeName = "_PRIVATE";
    sInf->Fields[5].ParentType = TpmTypeId::_PRIVATE_ID;
    sInf->Fields[5].Sort = ElementSort::TpmStruct;
    sInf->Fields[5].IsArray = FALSE;
    //===================TPM2B_PRIVATE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_PRIVATE_ID]=sInf;
    sInf->Name = "TPM2B_PRIVATE";
    sInf->MyTypeInfo=typeid(TPM2B_PRIVATE).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_PRIVATE";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_PRIVATE";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMS_ID_OBJECT
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPMS_ID_OBJECT_ID]=sInf;
    sInf->Name = "TPMS_ID_OBJECT";
    sInf->MyTypeInfo=typeid(TPMS_ID_OBJECT).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //integrityHMACSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "integrityHMACSize";
    sInf->Fields[0].ParentTypeName = "TPMS_ID_OBJECT";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ID_OBJECT_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //integrityHMAC
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "integrityHMAC";
    sInf->Fields[1].ParentTypeName = "TPMS_ID_OBJECT";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_ID_OBJECT_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //encIdentity
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::EncryptedVariableLengthArray;
    sInf->Fields[2].ElementName = "encIdentity";
    sInf->Fields[2].ParentTypeName = "TPMS_ID_OBJECT";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_ID_OBJECT_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    //===================TPM2B_ID_OBJECT
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_ID_OBJECT_ID]=sInf;
    sInf->Name = "TPM2B_ID_OBJECT";
    sInf->MyTypeInfo=typeid(TPM2B_ID_OBJECT).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_ID_OBJECT";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_ID_OBJECT_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //credential
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_ID_OBJECT_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_ID_OBJECT";
    sInf->Fields[1].ElementSize = sizeof(TPMS_ID_OBJECT);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "credential";
    sInf->Fields[1].ParentTypeName = "TPM2B_ID_OBJECT";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_ID_OBJECT_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPMS_NV_PIN_COUNTER_PARAMETERS
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMS_NV_PIN_COUNTER_PARAMETERS_ID]=sInf;
    sInf->Name = "TPMS_NV_PIN_COUNTER_PARAMETERS";
    sInf->MyTypeInfo=typeid(TPMS_NV_PIN_COUNTER_PARAMETERS).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //pinCount
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "pinCount";
    sInf->Fields[0].ParentTypeName = "TPMS_NV_PIN_COUNTER_PARAMETERS";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_NV_PIN_COUNTER_PARAMETERS_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //pinLimit
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT32";
    sInf->Fields[1].ElementSize = sizeof(UINT32);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "pinLimit";
    sInf->Fields[1].ParentTypeName = "TPMS_NV_PIN_COUNTER_PARAMETERS";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_NV_PIN_COUNTER_PARAMETERS_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPMS_NV_PUBLIC
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(6);
    TypeMap[TpmTypeId::TPMS_NV_PUBLIC_ID]=sInf;
    sInf->Name = "TPMS_NV_PUBLIC";
    sInf->MyTypeInfo=typeid(TPMS_NV_PUBLIC).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //nvIndex
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "nvIndex";
    sInf->Fields[0].ParentTypeName = "TPMS_NV_PUBLIC";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //nameAlg
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[1].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "nameAlg";
    sInf->Fields[1].ParentTypeName = "TPMS_NV_PUBLIC";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //attributes
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMA_NV_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMA_NV";
    sInf->Fields[2].ElementSize = sizeof(TPMA_NV);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "attributes";
    sInf->Fields[2].ParentTypeName = "TPMS_NV_PUBLIC";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    sInf->Fields[2].Sort = ElementSort::TpmBitfield;
    sInf->Fields[2].IsArray = FALSE;
    //authPolicySize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "authPolicySize";
    sInf->Fields[3].ParentTypeName = "TPMS_NV_PUBLIC";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //authPolicy
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "authPolicy";
    sInf->Fields[4].ParentTypeName = "TPMS_NV_PUBLIC";
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //dataSize
    sInf->Fields[5].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[5].ThisElementTypeName = "UINT16";
    sInf->Fields[5].ElementSize = sizeof(UINT16);
    sInf->Fields[5].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[5].ElementName = "dataSize";
    sInf->Fields[5].ParentTypeName = "TPMS_NV_PUBLIC";
    sInf->Fields[5].ParentType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    //===================TPM2B_NV_PUBLIC
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_NV_PUBLIC_ID]=sInf;
    sInf->Name = "TPM2B_NV_PUBLIC";
    sInf->MyTypeInfo=typeid(TPM2B_NV_PUBLIC).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_NV_PUBLIC";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_NV_PUBLIC_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //nvPublic
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_NV_PUBLIC";
    sInf->Fields[1].ElementSize = sizeof(TPMS_NV_PUBLIC);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "nvPublic";
    sInf->Fields[1].ParentTypeName = "TPM2B_NV_PUBLIC";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_NV_PUBLIC_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPM2B_CONTEXT_SENSITIVE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_CONTEXT_SENSITIVE_ID]=sInf;
    sInf->Name = "TPM2B_CONTEXT_SENSITIVE";
    sInf->MyTypeInfo=typeid(TPM2B_CONTEXT_SENSITIVE).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_CONTEXT_SENSITIVE";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_CONTEXT_SENSITIVE_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_CONTEXT_SENSITIVE";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_CONTEXT_SENSITIVE_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMS_CONTEXT_DATA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPMS_CONTEXT_DATA_ID]=sInf;
    sInf->Name = "TPMS_CONTEXT_DATA";
    sInf->MyTypeInfo=typeid(TPMS_CONTEXT_DATA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //integritySize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "integritySize";
    sInf->Fields[0].ParentTypeName = "TPMS_CONTEXT_DATA";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_CONTEXT_DATA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //integrity
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "integrity";
    sInf->Fields[1].ParentTypeName = "TPMS_CONTEXT_DATA";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_CONTEXT_DATA_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //encrypted
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::EncryptedVariableLengthArray;
    sInf->Fields[2].ElementName = "encrypted";
    sInf->Fields[2].ParentTypeName = "TPMS_CONTEXT_DATA";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_CONTEXT_DATA_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    //===================TPM2B_CONTEXT_DATA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_CONTEXT_DATA_ID]=sInf;
    sInf->Name = "TPM2B_CONTEXT_DATA";
    sInf->MyTypeInfo=typeid(TPM2B_CONTEXT_DATA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_CONTEXT_DATA";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_CONTEXT_DATA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_CONTEXT_DATA_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_CONTEXT_DATA";
    sInf->Fields[1].ElementSize = sizeof(TPMS_CONTEXT_DATA);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_CONTEXT_DATA";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_CONTEXT_DATA_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPMS_CONTEXT
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPMS_CONTEXT_ID]=sInf;
    sInf->Name = "TPMS_CONTEXT";
    sInf->MyTypeInfo=typeid(TPMS_CONTEXT).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //sequence
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT64_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT64";
    sInf->Fields[0].ElementSize = sizeof(UINT64);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "sequence";
    sInf->Fields[0].ParentTypeName = "TPMS_CONTEXT";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_CONTEXT_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //savedHandle
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "savedHandle";
    sInf->Fields[1].ParentTypeName = "TPMS_CONTEXT";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_CONTEXT_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //hierarchy
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[2].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "hierarchy";
    sInf->Fields[2].ParentTypeName = "TPMS_CONTEXT";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_CONTEXT_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //contextBlobSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[3].ElementName = "contextBlobSize";
    sInf->Fields[3].ParentTypeName = "TPMS_CONTEXT";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_CONTEXT_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //contextBlob
    sInf->Fields[4].ThisElementType = TpmTypeId::TPMS_CONTEXT_DATA_ID;
    sInf->Fields[4].ThisElementTypeName = "TPMS_CONTEXT_DATA";
    sInf->Fields[4].ElementSize = sizeof(TPMS_CONTEXT_DATA);
    sInf->Fields[4].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[4].ElementName = "contextBlob";
    sInf->Fields[4].ParentTypeName = "TPMS_CONTEXT";
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_CONTEXT_ID;
    sInf->Fields[4].Sort = ElementSort::TpmStruct;
    sInf->Fields[4].IsArray = FALSE;
    //===================TPMS_CREATION_DATA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(12);
    TypeMap[TpmTypeId::TPMS_CREATION_DATA_ID]=sInf;
    sInf->Name = "TPMS_CREATION_DATA";
    sInf->MyTypeInfo=typeid(TPMS_CREATION_DATA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //pcrSelectCount
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "pcrSelectCount";
    sInf->Fields[0].ParentTypeName = "TPMS_CREATION_DATA";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //pcrSelect
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_PCR_SELECTION";
    sInf->Fields[1].ElementSize = sizeof(TPMS_PCR_SELECTION);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "pcrSelect";
    sInf->Fields[1].ParentTypeName = "TPMS_CREATION_DATA";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //pcrDigestSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "pcrDigestSize";
    sInf->Fields[2].ParentTypeName = "TPMS_CREATION_DATA";
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //pcrDigest
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "pcrDigest";
    sInf->Fields[3].ParentTypeName = "TPMS_CREATION_DATA";
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //locality
    sInf->Fields[4].ThisElementType = TpmTypeId::TPMA_LOCALITY_ID;
    sInf->Fields[4].ThisElementTypeName = "TPMA_LOCALITY";
    sInf->Fields[4].ElementSize = sizeof(TPMA_LOCALITY);
    sInf->Fields[4].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[4].ElementName = "locality";
    sInf->Fields[4].ParentTypeName = "TPMS_CREATION_DATA";
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[4].Sort = ElementSort::TpmBitfield;
    sInf->Fields[4].IsArray = FALSE;
    //parentNameAlg
    sInf->Fields[5].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[5].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[5].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[5].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[5].ElementName = "parentNameAlg";
    sInf->Fields[5].ParentTypeName = "TPMS_CREATION_DATA";
    sInf->Fields[5].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[5].Sort = ElementSort::TpmEnum;
    sInf->Fields[5].IsArray = FALSE;
    //parentNameSize
    sInf->Fields[6].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[6].ThisElementTypeName = "UINT16";
    sInf->Fields[6].ElementSize = sizeof(UINT16);
    sInf->Fields[6].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[6].ElementName = "parentNameSize";
    sInf->Fields[6].ParentTypeName = "TPMS_CREATION_DATA";
    sInf->Fields[6].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = FALSE;
    //parentName
    sInf->Fields[7].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[7].ThisElementTypeName = "BYTE";
    sInf->Fields[7].ElementSize = sizeof(BYTE);
    sInf->Fields[7].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[7].ElementName = "parentName";
    sInf->Fields[7].ParentTypeName = "TPMS_CREATION_DATA";
    sInf->Fields[7].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[7].Sort = ElementSort::TpmValueType;
    sInf->Fields[7].IsArray = TRUE;
    sInf->Fields[7].AssociatedElement=6;
    //parentQualifiedNameSize
    sInf->Fields[8].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[8].ThisElementTypeName = "UINT16";
    sInf->Fields[8].ElementSize = sizeof(UINT16);
    sInf->Fields[8].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[8].ElementName = "parentQualifiedNameSize";
    sInf->Fields[8].ParentTypeName = "TPMS_CREATION_DATA";
    sInf->Fields[8].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[8].Sort = ElementSort::TpmValueType;
    sInf->Fields[8].IsArray = FALSE;
    //parentQualifiedName
    sInf->Fields[9].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[9].ThisElementTypeName = "BYTE";
    sInf->Fields[9].ElementSize = sizeof(BYTE);
    sInf->Fields[9].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[9].ElementName = "parentQualifiedName";
    sInf->Fields[9].ParentTypeName = "TPMS_CREATION_DATA";
    sInf->Fields[9].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[9].Sort = ElementSort::TpmValueType;
    sInf->Fields[9].IsArray = TRUE;
    sInf->Fields[9].AssociatedElement=8;
    //outsideInfoSize
    sInf->Fields[10].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[10].ThisElementTypeName = "UINT16";
    sInf->Fields[10].ElementSize = sizeof(UINT16);
    sInf->Fields[10].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[10].ElementName = "outsideInfoSize";
    sInf->Fields[10].ParentTypeName = "TPMS_CREATION_DATA";
    sInf->Fields[10].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[10].Sort = ElementSort::TpmValueType;
    sInf->Fields[10].IsArray = FALSE;
    //outsideInfo
    sInf->Fields[11].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[11].ThisElementTypeName = "BYTE";
    sInf->Fields[11].ElementSize = sizeof(BYTE);
    sInf->Fields[11].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[11].ElementName = "outsideInfo";
    sInf->Fields[11].ParentTypeName = "TPMS_CREATION_DATA";
    sInf->Fields[11].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[11].Sort = ElementSort::TpmValueType;
    sInf->Fields[11].IsArray = TRUE;
    sInf->Fields[11].AssociatedElement=10;
    //===================TPM2B_CREATION_DATA
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_CREATION_DATA_ID]=sInf;
    sInf->Name = "TPM2B_CREATION_DATA";
    sInf->MyTypeInfo=typeid(TPM2B_CREATION_DATA).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_CREATION_DATA";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_CREATION_DATA_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //creationData
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_CREATION_DATA";
    sInf->Fields[1].ElementSize = sizeof(TPMS_CREATION_DATA);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "creationData";
    sInf->Fields[1].ParentTypeName = "TPM2B_CREATION_DATA";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_CREATION_DATA_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPMS_AC_OUTPUT
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPMS_AC_OUTPUT_ID]=sInf;
    sInf->Name = "TPMS_AC_OUTPUT";
    sInf->MyTypeInfo=typeid(TPMS_AC_OUTPUT).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //tag
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_AT_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_AT";
    sInf->Fields[0].ElementSize = sizeof(TPM_AT);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "tag";
    sInf->Fields[0].ParentTypeName = "TPMS_AC_OUTPUT";
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_AC_OUTPUT_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    //data
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT32";
    sInf->Fields[1].ElementSize = sizeof(UINT32);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "data";
    sInf->Fields[1].ParentTypeName = "TPMS_AC_OUTPUT";
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_AC_OUTPUT_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPML_AC_CAPABILITIES
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPML_AC_CAPABILITIES_ID]=sInf;
    sInf->Name = "TPML_AC_CAPABILITIES";
    sInf->MyTypeInfo=typeid(TPML_AC_CAPABILITIES).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //count
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "count";
    sInf->Fields[0].ParentTypeName = "TPML_AC_CAPABILITIES";
    sInf->Fields[0].ParentType = TpmTypeId::TPML_AC_CAPABILITIES_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //acCapabilities
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_AC_OUTPUT_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_AC_OUTPUT";
    sInf->Fields[1].ElementSize = sizeof(TPMS_AC_OUTPUT);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "acCapabilities";
    sInf->Fields[1].ParentTypeName = "TPML_AC_CAPABILITIES";
    sInf->Fields[1].ParentType = TpmTypeId::TPML_AC_CAPABILITIES_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_Startup_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_Startup_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_Startup_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_Startup_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //startupType
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_SU_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_SU";
    sInf->Fields[0].ElementSize = sizeof(TPM_SU);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "startupType";
    sInf->Fields[0].ParentTypeName = "TPM2_Startup_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Startup_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_Startup_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::StartupResponse_ID]=sInf;
    sInf->Name = "StartupResponse";
    sInf->MyTypeInfo=typeid(StartupResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_Shutdown_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_Shutdown_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_Shutdown_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_Shutdown_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //shutdownType
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_SU_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_SU";
    sInf->Fields[0].ElementSize = sizeof(TPM_SU);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "shutdownType";
    sInf->Fields[0].ParentTypeName = "TPM2_Shutdown_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Shutdown_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_Shutdown_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::ShutdownResponse_ID]=sInf;
    sInf->Name = "ShutdownResponse";
    sInf->MyTypeInfo=typeid(ShutdownResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_SelfTest_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_SelfTest_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_SelfTest_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_SelfTest_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //fullTest
    sInf->Fields[0].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[0].ThisElementTypeName = "BYTE";
    sInf->Fields[0].ElementSize = sizeof(BYTE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "fullTest";
    sInf->Fields[0].ParentTypeName = "TPM2_SelfTest_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_SelfTest_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_SelfTest_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::SelfTestResponse_ID]=sInf;
    sInf->Name = "SelfTestResponse";
    sInf->MyTypeInfo=typeid(SelfTestResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_IncrementalSelfTest_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2_IncrementalSelfTest_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_IncrementalSelfTest_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_IncrementalSelfTest_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //toTestCount
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "toTestCount";
    sInf->Fields[0].ParentTypeName = "TPM2_IncrementalSelfTest_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_IncrementalSelfTest_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //toTest
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[1].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "toTest";
    sInf->Fields[1].ParentTypeName = "TPM2_IncrementalSelfTest_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_IncrementalSelfTest_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmEnum;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_IncrementalSelfTest_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::IncrementalSelfTestResponse_ID]=sInf;
    sInf->Name = "IncrementalSelfTestResponse";
    sInf->MyTypeInfo=typeid(IncrementalSelfTestResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //toDoListCount
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "toDoListCount";
    sInf->Fields[0].ParentTypeName = "IncrementalSelfTestResponse";
    sInf->Fields[0].ParentType = TpmTypeId::IncrementalSelfTestResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //toDoList
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[1].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "toDoList";
    sInf->Fields[1].ParentTypeName = "IncrementalSelfTestResponse";
    sInf->Fields[1].ParentType = TpmTypeId::IncrementalSelfTestResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmEnum;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_GetTestResult_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPM2_GetTestResult_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_GetTestResult_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_GetTestResult_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_GetTestResult_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::GetTestResultResponse_ID]=sInf;
    sInf->Name = "GetTestResultResponse";
    sInf->MyTypeInfo=typeid(GetTestResultResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //outDataSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "outDataSize";
    sInf->Fields[0].ParentTypeName = "GetTestResultResponse";
    sInf->Fields[0].ParentType = TpmTypeId::GetTestResultResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //outData
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "outData";
    sInf->Fields[1].ParentTypeName = "GetTestResultResponse";
    sInf->Fields[1].ParentType = TpmTypeId::GetTestResultResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //testResult
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_RC_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_RC";
    sInf->Fields[2].ElementSize = sizeof(TPM_RC);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "testResult";
    sInf->Fields[2].ParentTypeName = "GetTestResultResponse";
    sInf->Fields[2].ParentType = TpmTypeId::GetTestResultResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmEnum;
    sInf->Fields[2].IsArray = FALSE;
    //===================TPM2_StartAuthSession_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(9);
    TypeMap[TpmTypeId::TPM2_StartAuthSession_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_StartAuthSession_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_StartAuthSession_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 0;
    //tpmKey
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "tpmKey";
    sInf->Fields[0].ParentTypeName = "TPM2_StartAuthSession_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //bind
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "bind";
    sInf->Fields[1].ParentTypeName = "TPM2_StartAuthSession_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //nonceCallerSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "nonceCallerSize";
    sInf->Fields[2].ParentTypeName = "TPM2_StartAuthSession_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //nonceCaller
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "nonceCaller";
    sInf->Fields[3].ParentTypeName = "TPM2_StartAuthSession_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //encryptedSaltSize
    sInf->Fields[4].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[4].ThisElementTypeName = "UINT16";
    sInf->Fields[4].ElementSize = sizeof(UINT16);
    sInf->Fields[4].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[4].ElementName = "encryptedSaltSize";
    sInf->Fields[4].ParentTypeName = "TPM2_StartAuthSession_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    //encryptedSalt
    sInf->Fields[5].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[5].ThisElementTypeName = "BYTE";
    sInf->Fields[5].ElementSize = sizeof(BYTE);
    sInf->Fields[5].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[5].ElementName = "encryptedSalt";
    sInf->Fields[5].ParentTypeName = "TPM2_StartAuthSession_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = TRUE;
    sInf->Fields[5].AssociatedElement=4;
    //sessionType
    sInf->Fields[6].ThisElementType = TpmTypeId::TPM_SE_ID;
    sInf->Fields[6].ThisElementTypeName = "TPM_SE";
    sInf->Fields[6].ElementSize = sizeof(TPM_SE);
    sInf->Fields[6].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[6].ElementName = "sessionType";
    sInf->Fields[6].ParentTypeName = "TPM2_StartAuthSession_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmEnum;
    sInf->Fields[6].IsArray = FALSE;
    //symmetric
    sInf->Fields[7].ThisElementType = TpmTypeId::TPMT_SYM_DEF_ID;
    sInf->Fields[7].ThisElementTypeName = "TPMT_SYM_DEF";
    sInf->Fields[7].ElementSize = sizeof(TPMT_SYM_DEF);
    sInf->Fields[7].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[7].ElementName = "symmetric";
    sInf->Fields[7].ParentTypeName = "TPM2_StartAuthSession_REQUEST";
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    sInf->Fields[7].Sort = ElementSort::TpmStruct;
    sInf->Fields[7].IsArray = FALSE;
    //authHash
    sInf->Fields[8].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[8].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[8].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[8].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[8].ElementName = "authHash";
    sInf->Fields[8].ParentTypeName = "TPM2_StartAuthSession_REQUEST";
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    sInf->Fields[8].Sort = ElementSort::TpmValueType;
    sInf->Fields[8].IsArray = FALSE;
    //===================TPM2_StartAuthSession_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::StartAuthSessionResponse_ID]=sInf;
    sInf->Name = "StartAuthSessionResponse";
    sInf->MyTypeInfo=typeid(StartAuthSessionResponse).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //handle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "handle";
    sInf->Fields[0].ParentTypeName = "StartAuthSessionResponse";
    sInf->Fields[0].ParentType = TpmTypeId::StartAuthSessionResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //nonceTPMSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "nonceTPMSize";
    sInf->Fields[1].ParentTypeName = "StartAuthSessionResponse";
    sInf->Fields[1].ParentType = TpmTypeId::StartAuthSessionResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //nonceTPM
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "nonceTPM";
    sInf->Fields[2].ParentTypeName = "StartAuthSessionResponse";
    sInf->Fields[2].ParentType = TpmTypeId::StartAuthSessionResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPM2_PolicyRestart_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_PolicyRestart_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyRestart_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyRestart_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //sessionHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "sessionHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyRestart_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyRestart_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_PolicyRestart_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PolicyRestartResponse_ID]=sInf;
    sInf->Name = "PolicyRestartResponse";
    sInf->MyTypeInfo=typeid(PolicyRestartResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_Create_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(9);
    TypeMap[TpmTypeId::TPM2_Create_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_Create_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_Create_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //parentHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "parentHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_Create_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //inSensitiveSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[1].ElementName = "inSensitiveSize";
    sInf->Fields[1].ParentTypeName = "TPM2_Create_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //inSensitive
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMS_SENSITIVE_CREATE";
    sInf->Fields[2].ElementSize = sizeof(TPMS_SENSITIVE_CREATE);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "inSensitive";
    sInf->Fields[2].ParentTypeName = "TPM2_Create_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //inPublicSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[3].ElementName = "inPublicSize";
    sInf->Fields[3].ParentTypeName = "TPM2_Create_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //inPublic
    sInf->Fields[4].ThisElementType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[4].ThisElementTypeName = "TPMT_PUBLIC";
    sInf->Fields[4].ElementSize = sizeof(TPMT_PUBLIC);
    sInf->Fields[4].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[4].ElementName = "inPublic";
    sInf->Fields[4].ParentTypeName = "TPM2_Create_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmStruct;
    sInf->Fields[4].IsArray = FALSE;
    //outsideInfoSize
    sInf->Fields[5].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[5].ThisElementTypeName = "UINT16";
    sInf->Fields[5].ElementSize = sizeof(UINT16);
    sInf->Fields[5].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[5].ElementName = "outsideInfoSize";
    sInf->Fields[5].ParentTypeName = "TPM2_Create_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    //outsideInfo
    sInf->Fields[6].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[6].ThisElementTypeName = "BYTE";
    sInf->Fields[6].ElementSize = sizeof(BYTE);
    sInf->Fields[6].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[6].ElementName = "outsideInfo";
    sInf->Fields[6].ParentTypeName = "TPM2_Create_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = TRUE;
    sInf->Fields[6].AssociatedElement=5;
    //creationPCRCount
    sInf->Fields[7].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[7].ThisElementTypeName = "UINT32";
    sInf->Fields[7].ElementSize = sizeof(UINT32);
    sInf->Fields[7].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[7].ElementName = "creationPCRCount";
    sInf->Fields[7].ParentTypeName = "TPM2_Create_REQUEST";
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    sInf->Fields[7].Sort = ElementSort::TpmValueType;
    sInf->Fields[7].IsArray = FALSE;
    //creationPCR
    sInf->Fields[8].ThisElementType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[8].ThisElementTypeName = "TPMS_PCR_SELECTION";
    sInf->Fields[8].ElementSize = sizeof(TPMS_PCR_SELECTION);
    sInf->Fields[8].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[8].ElementName = "creationPCR";
    sInf->Fields[8].ParentTypeName = "TPM2_Create_REQUEST";
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    sInf->Fields[8].Sort = ElementSort::TpmStruct;
    sInf->Fields[8].IsArray = TRUE;
    sInf->Fields[8].AssociatedElement=7;
    //===================TPM2_Create_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(8);
    TypeMap[TpmTypeId::CreateResponse_ID]=sInf;
    sInf->Name = "CreateResponse";
    sInf->MyTypeInfo=typeid(CreateResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //outPrivate
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM2B_PRIVATE";
    sInf->Fields[0].ElementSize = sizeof(TPM2B_PRIVATE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "outPrivate";
    sInf->Fields[0].ParentTypeName = "CreateResponse";
    sInf->Fields[0].ParentType = TpmTypeId::CreateResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //outPublicSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[1].ElementName = "outPublicSize";
    sInf->Fields[1].ParentTypeName = "CreateResponse";
    sInf->Fields[1].ParentType = TpmTypeId::CreateResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //outPublic
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMT_PUBLIC";
    sInf->Fields[2].ElementSize = sizeof(TPMT_PUBLIC);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "outPublic";
    sInf->Fields[2].ParentTypeName = "CreateResponse";
    sInf->Fields[2].ParentType = TpmTypeId::CreateResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //creationDataSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[3].ElementName = "creationDataSize";
    sInf->Fields[3].ParentTypeName = "CreateResponse";
    sInf->Fields[3].ParentType = TpmTypeId::CreateResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //creationData
    sInf->Fields[4].ThisElementType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[4].ThisElementTypeName = "TPMS_CREATION_DATA";
    sInf->Fields[4].ElementSize = sizeof(TPMS_CREATION_DATA);
    sInf->Fields[4].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[4].ElementName = "creationData";
    sInf->Fields[4].ParentTypeName = "CreateResponse";
    sInf->Fields[4].ParentType = TpmTypeId::CreateResponse_ID;
    sInf->Fields[4].Sort = ElementSort::TpmStruct;
    sInf->Fields[4].IsArray = FALSE;
    //creationHashSize
    sInf->Fields[5].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[5].ThisElementTypeName = "UINT16";
    sInf->Fields[5].ElementSize = sizeof(UINT16);
    sInf->Fields[5].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[5].ElementName = "creationHashSize";
    sInf->Fields[5].ParentTypeName = "CreateResponse";
    sInf->Fields[5].ParentType = TpmTypeId::CreateResponse_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    //creationHash
    sInf->Fields[6].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[6].ThisElementTypeName = "BYTE";
    sInf->Fields[6].ElementSize = sizeof(BYTE);
    sInf->Fields[6].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[6].ElementName = "creationHash";
    sInf->Fields[6].ParentTypeName = "CreateResponse";
    sInf->Fields[6].ParentType = TpmTypeId::CreateResponse_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = TRUE;
    sInf->Fields[6].AssociatedElement=5;
    //creationTicket
    sInf->Fields[7].ThisElementType = TpmTypeId::TPMT_TK_CREATION_ID;
    sInf->Fields[7].ThisElementTypeName = "TPMT_TK_CREATION";
    sInf->Fields[7].ElementSize = sizeof(TPMT_TK_CREATION);
    sInf->Fields[7].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[7].ElementName = "creationTicket";
    sInf->Fields[7].ParentTypeName = "CreateResponse";
    sInf->Fields[7].ParentType = TpmTypeId::CreateResponse_ID;
    sInf->Fields[7].Sort = ElementSort::TpmStruct;
    sInf->Fields[7].IsArray = FALSE;
    //===================TPM2_Load_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPM2_Load_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_Load_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_Load_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //parentHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "parentHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_Load_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Load_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //inPrivate
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM2B_PRIVATE";
    sInf->Fields[1].ElementSize = sizeof(TPM2B_PRIVATE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "inPrivate";
    sInf->Fields[1].ParentTypeName = "TPM2_Load_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Load_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //inPublicSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[2].ElementName = "inPublicSize";
    sInf->Fields[2].ParentTypeName = "TPM2_Load_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Load_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //inPublic
    sInf->Fields[3].ThisElementType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[3].ThisElementTypeName = "TPMT_PUBLIC";
    sInf->Fields[3].ElementSize = sizeof(TPMT_PUBLIC);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "inPublic";
    sInf->Fields[3].ParentTypeName = "TPM2_Load_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Load_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmStruct;
    sInf->Fields[3].IsArray = FALSE;
    //===================TPM2_Load_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::LoadResponse_ID]=sInf;
    sInf->Name = "LoadResponse";
    sInf->MyTypeInfo=typeid(LoadResponse).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //handle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "handle";
    sInf->Fields[0].ParentTypeName = "LoadResponse";
    sInf->Fields[0].ParentType = TpmTypeId::LoadResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //nameSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "nameSize";
    sInf->Fields[1].ParentTypeName = "LoadResponse";
    sInf->Fields[1].ParentType = TpmTypeId::LoadResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //name
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "name";
    sInf->Fields[2].ParentTypeName = "LoadResponse";
    sInf->Fields[2].ParentType = TpmTypeId::LoadResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPM2_LoadExternal_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPM2_LoadExternal_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_LoadExternal_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_LoadExternal_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //inPrivateSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "inPrivateSize";
    sInf->Fields[0].ParentTypeName = "TPM2_LoadExternal_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_LoadExternal_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //inPrivate
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMT_SENSITIVE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMT_SENSITIVE";
    sInf->Fields[1].ElementSize = sizeof(TPMT_SENSITIVE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "inPrivate";
    sInf->Fields[1].ParentTypeName = "TPM2_LoadExternal_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_LoadExternal_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //inPublicSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[2].ElementName = "inPublicSize";
    sInf->Fields[2].ParentTypeName = "TPM2_LoadExternal_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_LoadExternal_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //inPublic
    sInf->Fields[3].ThisElementType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[3].ThisElementTypeName = "TPMT_PUBLIC";
    sInf->Fields[3].ElementSize = sizeof(TPMT_PUBLIC);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "inPublic";
    sInf->Fields[3].ParentTypeName = "TPM2_LoadExternal_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_LoadExternal_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmStruct;
    sInf->Fields[3].IsArray = FALSE;
    //hierarchy
    sInf->Fields[4].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[4].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[4].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[4].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[4].ElementName = "hierarchy";
    sInf->Fields[4].ParentTypeName = "TPM2_LoadExternal_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_LoadExternal_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmStruct;
    sInf->Fields[4].IsArray = FALSE;
    //===================TPM2_LoadExternal_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::LoadExternalResponse_ID]=sInf;
    sInf->Name = "LoadExternalResponse";
    sInf->MyTypeInfo=typeid(LoadExternalResponse).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //handle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "handle";
    sInf->Fields[0].ParentTypeName = "LoadExternalResponse";
    sInf->Fields[0].ParentType = TpmTypeId::LoadExternalResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //nameSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "nameSize";
    sInf->Fields[1].ParentTypeName = "LoadExternalResponse";
    sInf->Fields[1].ParentType = TpmTypeId::LoadExternalResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //name
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "name";
    sInf->Fields[2].ParentTypeName = "LoadExternalResponse";
    sInf->Fields[2].ParentType = TpmTypeId::LoadExternalResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPM2_ReadPublic_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_ReadPublic_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_ReadPublic_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_ReadPublic_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //objectHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "objectHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_ReadPublic_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ReadPublic_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_ReadPublic_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(6);
    TypeMap[TpmTypeId::ReadPublicResponse_ID]=sInf;
    sInf->Name = "ReadPublicResponse";
    sInf->MyTypeInfo=typeid(ReadPublicResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //outPublicSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "outPublicSize";
    sInf->Fields[0].ParentTypeName = "ReadPublicResponse";
    sInf->Fields[0].ParentType = TpmTypeId::ReadPublicResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //outPublic
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMT_PUBLIC";
    sInf->Fields[1].ElementSize = sizeof(TPMT_PUBLIC);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "outPublic";
    sInf->Fields[1].ParentTypeName = "ReadPublicResponse";
    sInf->Fields[1].ParentType = TpmTypeId::ReadPublicResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //nameSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "nameSize";
    sInf->Fields[2].ParentTypeName = "ReadPublicResponse";
    sInf->Fields[2].ParentType = TpmTypeId::ReadPublicResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //name
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "name";
    sInf->Fields[3].ParentTypeName = "ReadPublicResponse";
    sInf->Fields[3].ParentType = TpmTypeId::ReadPublicResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //qualifiedNameSize
    sInf->Fields[4].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[4].ThisElementTypeName = "UINT16";
    sInf->Fields[4].ElementSize = sizeof(UINT16);
    sInf->Fields[4].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[4].ElementName = "qualifiedNameSize";
    sInf->Fields[4].ParentTypeName = "ReadPublicResponse";
    sInf->Fields[4].ParentType = TpmTypeId::ReadPublicResponse_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    //qualifiedName
    sInf->Fields[5].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[5].ThisElementTypeName = "BYTE";
    sInf->Fields[5].ElementSize = sizeof(BYTE);
    sInf->Fields[5].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[5].ElementName = "qualifiedName";
    sInf->Fields[5].ParentTypeName = "ReadPublicResponse";
    sInf->Fields[5].ParentType = TpmTypeId::ReadPublicResponse_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = TRUE;
    sInf->Fields[5].AssociatedElement=4;
    //===================TPM2_ActivateCredential_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(6);
    TypeMap[TpmTypeId::TPM2_ActivateCredential_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_ActivateCredential_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_ActivateCredential_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 2;
    //activateHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "activateHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_ActivateCredential_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //keyHandle
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "keyHandle";
    sInf->Fields[1].ParentTypeName = "TPM2_ActivateCredential_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //credentialBlobSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[2].ElementName = "credentialBlobSize";
    sInf->Fields[2].ParentTypeName = "TPM2_ActivateCredential_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //credentialBlob
    sInf->Fields[3].ThisElementType = TpmTypeId::TPMS_ID_OBJECT_ID;
    sInf->Fields[3].ThisElementTypeName = "TPMS_ID_OBJECT";
    sInf->Fields[3].ElementSize = sizeof(TPMS_ID_OBJECT);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "credentialBlob";
    sInf->Fields[3].ParentTypeName = "TPM2_ActivateCredential_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmStruct;
    sInf->Fields[3].IsArray = FALSE;
    //secretSize
    sInf->Fields[4].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[4].ThisElementTypeName = "UINT16";
    sInf->Fields[4].ElementSize = sizeof(UINT16);
    sInf->Fields[4].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[4].ElementName = "secretSize";
    sInf->Fields[4].ParentTypeName = "TPM2_ActivateCredential_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    //secret
    sInf->Fields[5].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[5].ThisElementTypeName = "BYTE";
    sInf->Fields[5].ElementSize = sizeof(BYTE);
    sInf->Fields[5].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[5].ElementName = "secret";
    sInf->Fields[5].ParentTypeName = "TPM2_ActivateCredential_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = TRUE;
    sInf->Fields[5].AssociatedElement=4;
    //===================TPM2_ActivateCredential_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::ActivateCredentialResponse_ID]=sInf;
    sInf->Name = "ActivateCredentialResponse";
    sInf->MyTypeInfo=typeid(ActivateCredentialResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //certInfoSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "certInfoSize";
    sInf->Fields[0].ParentTypeName = "ActivateCredentialResponse";
    sInf->Fields[0].ParentType = TpmTypeId::ActivateCredentialResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //certInfo
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "certInfo";
    sInf->Fields[1].ParentTypeName = "ActivateCredentialResponse";
    sInf->Fields[1].ParentType = TpmTypeId::ActivateCredentialResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_MakeCredential_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPM2_MakeCredential_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_MakeCredential_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_MakeCredential_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //handle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "handle";
    sInf->Fields[0].ParentTypeName = "TPM2_MakeCredential_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_MakeCredential_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //credentialSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "credentialSize";
    sInf->Fields[1].ParentTypeName = "TPM2_MakeCredential_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_MakeCredential_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //credential
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "credential";
    sInf->Fields[2].ParentTypeName = "TPM2_MakeCredential_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_MakeCredential_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //objectNameSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "objectNameSize";
    sInf->Fields[3].ParentTypeName = "TPM2_MakeCredential_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_MakeCredential_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //objectName
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "objectName";
    sInf->Fields[4].ParentTypeName = "TPM2_MakeCredential_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_MakeCredential_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //===================TPM2_MakeCredential_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::MakeCredentialResponse_ID]=sInf;
    sInf->Name = "MakeCredentialResponse";
    sInf->MyTypeInfo=typeid(MakeCredentialResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //credentialBlobSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "credentialBlobSize";
    sInf->Fields[0].ParentTypeName = "MakeCredentialResponse";
    sInf->Fields[0].ParentType = TpmTypeId::MakeCredentialResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //credentialBlob
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_ID_OBJECT_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_ID_OBJECT";
    sInf->Fields[1].ElementSize = sizeof(TPMS_ID_OBJECT);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "credentialBlob";
    sInf->Fields[1].ParentTypeName = "MakeCredentialResponse";
    sInf->Fields[1].ParentType = TpmTypeId::MakeCredentialResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //secretSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "secretSize";
    sInf->Fields[2].ParentTypeName = "MakeCredentialResponse";
    sInf->Fields[2].ParentType = TpmTypeId::MakeCredentialResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //secret
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "secret";
    sInf->Fields[3].ParentTypeName = "MakeCredentialResponse";
    sInf->Fields[3].ParentType = TpmTypeId::MakeCredentialResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPM2_Unseal_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_Unseal_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_Unseal_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_Unseal_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //itemHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "itemHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_Unseal_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Unseal_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_Unseal_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::UnsealResponse_ID]=sInf;
    sInf->Name = "UnsealResponse";
    sInf->MyTypeInfo=typeid(UnsealResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //outDataSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "outDataSize";
    sInf->Fields[0].ParentTypeName = "UnsealResponse";
    sInf->Fields[0].ParentType = TpmTypeId::UnsealResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //outData
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "outData";
    sInf->Fields[1].ParentTypeName = "UnsealResponse";
    sInf->Fields[1].ParentType = TpmTypeId::UnsealResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_ObjectChangeAuth_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_ObjectChangeAuth_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_ObjectChangeAuth_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    //objectHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "objectHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_ObjectChangeAuth_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //parentHandle
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "parentHandle";
    sInf->Fields[1].ParentTypeName = "TPM2_ObjectChangeAuth_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //newAuthSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "newAuthSize";
    sInf->Fields[2].ParentTypeName = "TPM2_ObjectChangeAuth_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //newAuth
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "newAuth";
    sInf->Fields[3].ParentTypeName = "TPM2_ObjectChangeAuth_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPM2_ObjectChangeAuth_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::ObjectChangeAuthResponse_ID]=sInf;
    sInf->Name = "ObjectChangeAuthResponse";
    sInf->MyTypeInfo=typeid(ObjectChangeAuthResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //outPrivate
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM2B_PRIVATE";
    sInf->Fields[0].ElementSize = sizeof(TPM2B_PRIVATE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "outPrivate";
    sInf->Fields[0].ParentTypeName = "ObjectChangeAuthResponse";
    sInf->Fields[0].ParentType = TpmTypeId::ObjectChangeAuthResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_CreateLoaded_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPM2_CreateLoaded_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_CreateLoaded_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_CreateLoaded_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //parentHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "parentHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_CreateLoaded_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_CreateLoaded_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //inSensitiveSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[1].ElementName = "inSensitiveSize";
    sInf->Fields[1].ParentTypeName = "TPM2_CreateLoaded_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_CreateLoaded_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //inSensitive
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMS_SENSITIVE_CREATE";
    sInf->Fields[2].ElementSize = sizeof(TPMS_SENSITIVE_CREATE);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "inSensitive";
    sInf->Fields[2].ParentTypeName = "TPM2_CreateLoaded_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_CreateLoaded_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //inPublicSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "inPublicSize";
    sInf->Fields[3].ParentTypeName = "TPM2_CreateLoaded_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_CreateLoaded_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //inPublic
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "inPublic";
    sInf->Fields[4].ParentTypeName = "TPM2_CreateLoaded_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_CreateLoaded_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //===================TPM2_CreateLoaded_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(6);
    TypeMap[TpmTypeId::CreateLoadedResponse_ID]=sInf;
    sInf->Name = "CreateLoadedResponse";
    sInf->MyTypeInfo=typeid(CreateLoadedResponse).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //handle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "handle";
    sInf->Fields[0].ParentTypeName = "CreateLoadedResponse";
    sInf->Fields[0].ParentType = TpmTypeId::CreateLoadedResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //outPrivate
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM2B_PRIVATE";
    sInf->Fields[1].ElementSize = sizeof(TPM2B_PRIVATE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "outPrivate";
    sInf->Fields[1].ParentTypeName = "CreateLoadedResponse";
    sInf->Fields[1].ParentType = TpmTypeId::CreateLoadedResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //outPublicSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[2].ElementName = "outPublicSize";
    sInf->Fields[2].ParentTypeName = "CreateLoadedResponse";
    sInf->Fields[2].ParentType = TpmTypeId::CreateLoadedResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //outPublic
    sInf->Fields[3].ThisElementType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[3].ThisElementTypeName = "TPMT_PUBLIC";
    sInf->Fields[3].ElementSize = sizeof(TPMT_PUBLIC);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "outPublic";
    sInf->Fields[3].ParentTypeName = "CreateLoadedResponse";
    sInf->Fields[3].ParentType = TpmTypeId::CreateLoadedResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmStruct;
    sInf->Fields[3].IsArray = FALSE;
    //nameSize
    sInf->Fields[4].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[4].ThisElementTypeName = "UINT16";
    sInf->Fields[4].ElementSize = sizeof(UINT16);
    sInf->Fields[4].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[4].ElementName = "nameSize";
    sInf->Fields[4].ParentTypeName = "CreateLoadedResponse";
    sInf->Fields[4].ParentType = TpmTypeId::CreateLoadedResponse_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    //name
    sInf->Fields[5].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[5].ThisElementTypeName = "BYTE";
    sInf->Fields[5].ElementSize = sizeof(BYTE);
    sInf->Fields[5].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[5].ElementName = "name";
    sInf->Fields[5].ParentTypeName = "CreateLoadedResponse";
    sInf->Fields[5].ParentType = TpmTypeId::CreateLoadedResponse_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = TRUE;
    sInf->Fields[5].AssociatedElement=4;
    //===================TPM2_Duplicate_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPM2_Duplicate_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_Duplicate_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_Duplicate_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    //objectHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "objectHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_Duplicate_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Duplicate_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //newParentHandle
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "newParentHandle";
    sInf->Fields[1].ParentTypeName = "TPM2_Duplicate_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Duplicate_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //encryptionKeyInSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "encryptionKeyInSize";
    sInf->Fields[2].ParentTypeName = "TPM2_Duplicate_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Duplicate_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //encryptionKeyIn
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "encryptionKeyIn";
    sInf->Fields[3].ParentTypeName = "TPM2_Duplicate_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Duplicate_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //symmetricAlg
    sInf->Fields[4].ThisElementType = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    sInf->Fields[4].ThisElementTypeName = "TPMT_SYM_DEF_OBJECT";
    sInf->Fields[4].ElementSize = sizeof(TPMT_SYM_DEF_OBJECT);
    sInf->Fields[4].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[4].ElementName = "symmetricAlg";
    sInf->Fields[4].ParentTypeName = "TPM2_Duplicate_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_Duplicate_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmStruct;
    sInf->Fields[4].IsArray = FALSE;
    //===================TPM2_Duplicate_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::DuplicateResponse_ID]=sInf;
    sInf->Name = "DuplicateResponse";
    sInf->MyTypeInfo=typeid(DuplicateResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //encryptionKeyOutSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "encryptionKeyOutSize";
    sInf->Fields[0].ParentTypeName = "DuplicateResponse";
    sInf->Fields[0].ParentType = TpmTypeId::DuplicateResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //encryptionKeyOut
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "encryptionKeyOut";
    sInf->Fields[1].ParentTypeName = "DuplicateResponse";
    sInf->Fields[1].ParentType = TpmTypeId::DuplicateResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //duplicate
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM2B_PRIVATE";
    sInf->Fields[2].ElementSize = sizeof(TPM2B_PRIVATE);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "duplicate";
    sInf->Fields[2].ParentTypeName = "DuplicateResponse";
    sInf->Fields[2].ParentType = TpmTypeId::DuplicateResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //outSymSeedSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "outSymSeedSize";
    sInf->Fields[3].ParentTypeName = "DuplicateResponse";
    sInf->Fields[3].ParentType = TpmTypeId::DuplicateResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //outSymSeed
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "outSymSeed";
    sInf->Fields[4].ParentTypeName = "DuplicateResponse";
    sInf->Fields[4].ParentType = TpmTypeId::DuplicateResponse_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //===================TPM2_Rewrap_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(7);
    TypeMap[TpmTypeId::TPM2_Rewrap_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_Rewrap_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_Rewrap_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    //oldParent
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "oldParent";
    sInf->Fields[0].ParentTypeName = "TPM2_Rewrap_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //newParent
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "newParent";
    sInf->Fields[1].ParentTypeName = "TPM2_Rewrap_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //inDuplicate
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM2B_PRIVATE";
    sInf->Fields[2].ElementSize = sizeof(TPM2B_PRIVATE);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "inDuplicate";
    sInf->Fields[2].ParentTypeName = "TPM2_Rewrap_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //nameSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "nameSize";
    sInf->Fields[3].ParentTypeName = "TPM2_Rewrap_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //name
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "name";
    sInf->Fields[4].ParentTypeName = "TPM2_Rewrap_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //inSymSeedSize
    sInf->Fields[5].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[5].ThisElementTypeName = "UINT16";
    sInf->Fields[5].ElementSize = sizeof(UINT16);
    sInf->Fields[5].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[5].ElementName = "inSymSeedSize";
    sInf->Fields[5].ParentTypeName = "TPM2_Rewrap_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    //inSymSeed
    sInf->Fields[6].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[6].ThisElementTypeName = "BYTE";
    sInf->Fields[6].ElementSize = sizeof(BYTE);
    sInf->Fields[6].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[6].ElementName = "inSymSeed";
    sInf->Fields[6].ParentTypeName = "TPM2_Rewrap_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = TRUE;
    sInf->Fields[6].AssociatedElement=5;
    //===================TPM2_Rewrap_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::RewrapResponse_ID]=sInf;
    sInf->Name = "RewrapResponse";
    sInf->MyTypeInfo=typeid(RewrapResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //outDuplicate
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM2B_PRIVATE";
    sInf->Fields[0].ElementSize = sizeof(TPM2B_PRIVATE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "outDuplicate";
    sInf->Fields[0].ParentTypeName = "RewrapResponse";
    sInf->Fields[0].ParentType = TpmTypeId::RewrapResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //outSymSeedSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "outSymSeedSize";
    sInf->Fields[1].ParentTypeName = "RewrapResponse";
    sInf->Fields[1].ParentType = TpmTypeId::RewrapResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //outSymSeed
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "outSymSeed";
    sInf->Fields[2].ParentTypeName = "RewrapResponse";
    sInf->Fields[2].ParentType = TpmTypeId::RewrapResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPM2_Import_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(9);
    TypeMap[TpmTypeId::TPM2_Import_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_Import_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_Import_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //parentHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "parentHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_Import_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //encryptionKeySize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "encryptionKeySize";
    sInf->Fields[1].ParentTypeName = "TPM2_Import_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //encryptionKey
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "encryptionKey";
    sInf->Fields[2].ParentTypeName = "TPM2_Import_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //objectPublicSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[3].ElementName = "objectPublicSize";
    sInf->Fields[3].ParentTypeName = "TPM2_Import_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //objectPublic
    sInf->Fields[4].ThisElementType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[4].ThisElementTypeName = "TPMT_PUBLIC";
    sInf->Fields[4].ElementSize = sizeof(TPMT_PUBLIC);
    sInf->Fields[4].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[4].ElementName = "objectPublic";
    sInf->Fields[4].ParentTypeName = "TPM2_Import_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmStruct;
    sInf->Fields[4].IsArray = FALSE;
    //duplicate
    sInf->Fields[5].ThisElementType = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[5].ThisElementTypeName = "TPM2B_PRIVATE";
    sInf->Fields[5].ElementSize = sizeof(TPM2B_PRIVATE);
    sInf->Fields[5].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[5].ElementName = "duplicate";
    sInf->Fields[5].ParentTypeName = "TPM2_Import_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmStruct;
    sInf->Fields[5].IsArray = FALSE;
    //inSymSeedSize
    sInf->Fields[6].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[6].ThisElementTypeName = "UINT16";
    sInf->Fields[6].ElementSize = sizeof(UINT16);
    sInf->Fields[6].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[6].ElementName = "inSymSeedSize";
    sInf->Fields[6].ParentTypeName = "TPM2_Import_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = FALSE;
    //inSymSeed
    sInf->Fields[7].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[7].ThisElementTypeName = "BYTE";
    sInf->Fields[7].ElementSize = sizeof(BYTE);
    sInf->Fields[7].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[7].ElementName = "inSymSeed";
    sInf->Fields[7].ParentTypeName = "TPM2_Import_REQUEST";
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    sInf->Fields[7].Sort = ElementSort::TpmValueType;
    sInf->Fields[7].IsArray = TRUE;
    sInf->Fields[7].AssociatedElement=6;
    //symmetricAlg
    sInf->Fields[8].ThisElementType = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    sInf->Fields[8].ThisElementTypeName = "TPMT_SYM_DEF_OBJECT";
    sInf->Fields[8].ElementSize = sizeof(TPMT_SYM_DEF_OBJECT);
    sInf->Fields[8].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[8].ElementName = "symmetricAlg";
    sInf->Fields[8].ParentTypeName = "TPM2_Import_REQUEST";
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    sInf->Fields[8].Sort = ElementSort::TpmStruct;
    sInf->Fields[8].IsArray = FALSE;
    //===================TPM2_Import_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::ImportResponse_ID]=sInf;
    sInf->Name = "ImportResponse";
    sInf->MyTypeInfo=typeid(ImportResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //outPrivate
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM2B_PRIVATE";
    sInf->Fields[0].ElementSize = sizeof(TPM2B_PRIVATE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "outPrivate";
    sInf->Fields[0].ParentTypeName = "ImportResponse";
    sInf->Fields[0].ParentType = TpmTypeId::ImportResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_RSA_Encrypt_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(7);
    TypeMap[TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_RSA_Encrypt_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_RSA_Encrypt_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //keyHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "keyHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_RSA_Encrypt_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //messageSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "messageSize";
    sInf->Fields[1].ParentTypeName = "TPM2_RSA_Encrypt_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //message
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "message";
    sInf->Fields[2].ParentTypeName = "TPM2_RSA_Encrypt_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //inSchemeScheme
    sInf->Fields[3].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[3].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[3].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[3].ElementName = "inSchemeScheme";
    sInf->Fields[3].ParentTypeName = "TPM2_RSA_Encrypt_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    sInf->Fields[3].AssociatedElement=4;
    //inScheme
    sInf->Fields[4].ThisElementType = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[4].ThisElementTypeName = "TPMU_ASYM_SCHEME";
    sInf->Fields[4].ElementSize = sizeof(TPMU_ASYM_SCHEME);
    sInf->Fields[4].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[4].ElementName = "inScheme";
    sInf->Fields[4].ParentTypeName = "TPM2_RSA_Encrypt_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmUnion;
    sInf->Fields[4].IsArray = FALSE;
    sInf->Fields[4].AssociatedElement=3;
    //labelSize
    sInf->Fields[5].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[5].ThisElementTypeName = "UINT16";
    sInf->Fields[5].ElementSize = sizeof(UINT16);
    sInf->Fields[5].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[5].ElementName = "labelSize";
    sInf->Fields[5].ParentTypeName = "TPM2_RSA_Encrypt_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    //label
    sInf->Fields[6].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[6].ThisElementTypeName = "BYTE";
    sInf->Fields[6].ElementSize = sizeof(BYTE);
    sInf->Fields[6].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[6].ElementName = "label";
    sInf->Fields[6].ParentTypeName = "TPM2_RSA_Encrypt_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = TRUE;
    sInf->Fields[6].AssociatedElement=5;
    //===================TPM2_RSA_Encrypt_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::RSA_EncryptResponse_ID]=sInf;
    sInf->Name = "RSA_EncryptResponse";
    sInf->MyTypeInfo=typeid(RSA_EncryptResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //outDataSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "outDataSize";
    sInf->Fields[0].ParentTypeName = "RSA_EncryptResponse";
    sInf->Fields[0].ParentType = TpmTypeId::RSA_EncryptResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //outData
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "outData";
    sInf->Fields[1].ParentTypeName = "RSA_EncryptResponse";
    sInf->Fields[1].ParentType = TpmTypeId::RSA_EncryptResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_RSA_Decrypt_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(7);
    TypeMap[TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_RSA_Decrypt_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_RSA_Decrypt_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //keyHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "keyHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_RSA_Decrypt_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //cipherTextSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "cipherTextSize";
    sInf->Fields[1].ParentTypeName = "TPM2_RSA_Decrypt_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //cipherText
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "cipherText";
    sInf->Fields[2].ParentTypeName = "TPM2_RSA_Decrypt_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //inSchemeScheme
    sInf->Fields[3].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[3].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[3].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[3].ElementName = "inSchemeScheme";
    sInf->Fields[3].ParentTypeName = "TPM2_RSA_Decrypt_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    sInf->Fields[3].AssociatedElement=4;
    //inScheme
    sInf->Fields[4].ThisElementType = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[4].ThisElementTypeName = "TPMU_ASYM_SCHEME";
    sInf->Fields[4].ElementSize = sizeof(TPMU_ASYM_SCHEME);
    sInf->Fields[4].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[4].ElementName = "inScheme";
    sInf->Fields[4].ParentTypeName = "TPM2_RSA_Decrypt_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmUnion;
    sInf->Fields[4].IsArray = FALSE;
    sInf->Fields[4].AssociatedElement=3;
    //labelSize
    sInf->Fields[5].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[5].ThisElementTypeName = "UINT16";
    sInf->Fields[5].ElementSize = sizeof(UINT16);
    sInf->Fields[5].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[5].ElementName = "labelSize";
    sInf->Fields[5].ParentTypeName = "TPM2_RSA_Decrypt_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    //label
    sInf->Fields[6].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[6].ThisElementTypeName = "BYTE";
    sInf->Fields[6].ElementSize = sizeof(BYTE);
    sInf->Fields[6].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[6].ElementName = "label";
    sInf->Fields[6].ParentTypeName = "TPM2_RSA_Decrypt_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = TRUE;
    sInf->Fields[6].AssociatedElement=5;
    //===================TPM2_RSA_Decrypt_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::RSA_DecryptResponse_ID]=sInf;
    sInf->Name = "RSA_DecryptResponse";
    sInf->MyTypeInfo=typeid(RSA_DecryptResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //messageSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "messageSize";
    sInf->Fields[0].ParentTypeName = "RSA_DecryptResponse";
    sInf->Fields[0].ParentType = TpmTypeId::RSA_DecryptResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //message
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "message";
    sInf->Fields[1].ParentTypeName = "RSA_DecryptResponse";
    sInf->Fields[1].ParentType = TpmTypeId::RSA_DecryptResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_ECDH_KeyGen_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_ECDH_KeyGen_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_ECDH_KeyGen_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_ECDH_KeyGen_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //keyHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "keyHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_ECDH_KeyGen_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ECDH_KeyGen_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_ECDH_KeyGen_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::ECDH_KeyGenResponse_ID]=sInf;
    sInf->Name = "ECDH_KeyGenResponse";
    sInf->MyTypeInfo=typeid(ECDH_KeyGenResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //zPointSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "zPointSize";
    sInf->Fields[0].ParentTypeName = "ECDH_KeyGenResponse";
    sInf->Fields[0].ParentType = TpmTypeId::ECDH_KeyGenResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //zPoint
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_ECC_POINT";
    sInf->Fields[1].ElementSize = sizeof(TPMS_ECC_POINT);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "zPoint";
    sInf->Fields[1].ParentTypeName = "ECDH_KeyGenResponse";
    sInf->Fields[1].ParentType = TpmTypeId::ECDH_KeyGenResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //pubPointSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[2].ElementName = "pubPointSize";
    sInf->Fields[2].ParentTypeName = "ECDH_KeyGenResponse";
    sInf->Fields[2].ParentType = TpmTypeId::ECDH_KeyGenResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //pubPoint
    sInf->Fields[3].ThisElementType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[3].ThisElementTypeName = "TPMS_ECC_POINT";
    sInf->Fields[3].ElementSize = sizeof(TPMS_ECC_POINT);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "pubPoint";
    sInf->Fields[3].ParentTypeName = "ECDH_KeyGenResponse";
    sInf->Fields[3].ParentType = TpmTypeId::ECDH_KeyGenResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmStruct;
    sInf->Fields[3].IsArray = FALSE;
    //===================TPM2_ECDH_ZGen_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_ECDH_ZGen_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_ECDH_ZGen_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_ECDH_ZGen_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //keyHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "keyHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_ECDH_ZGen_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ECDH_ZGen_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //inPointSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[1].ElementName = "inPointSize";
    sInf->Fields[1].ParentTypeName = "TPM2_ECDH_ZGen_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_ECDH_ZGen_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //inPoint
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMS_ECC_POINT";
    sInf->Fields[2].ElementSize = sizeof(TPMS_ECC_POINT);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "inPoint";
    sInf->Fields[2].ParentTypeName = "TPM2_ECDH_ZGen_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_ECDH_ZGen_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //===================TPM2_ECDH_ZGen_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::ECDH_ZGenResponse_ID]=sInf;
    sInf->Name = "ECDH_ZGenResponse";
    sInf->MyTypeInfo=typeid(ECDH_ZGenResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //outPointSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "outPointSize";
    sInf->Fields[0].ParentTypeName = "ECDH_ZGenResponse";
    sInf->Fields[0].ParentType = TpmTypeId::ECDH_ZGenResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //outPoint
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_ECC_POINT";
    sInf->Fields[1].ElementSize = sizeof(TPMS_ECC_POINT);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "outPoint";
    sInf->Fields[1].ParentTypeName = "ECDH_ZGenResponse";
    sInf->Fields[1].ParentType = TpmTypeId::ECDH_ZGenResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPM2_ECC_Parameters_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_ECC_Parameters_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_ECC_Parameters_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_ECC_Parameters_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //curveID
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ECC_CURVE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ECC_CURVE";
    sInf->Fields[0].ElementSize = sizeof(TPM_ECC_CURVE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "curveID";
    sInf->Fields[0].ParentTypeName = "TPM2_ECC_Parameters_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ECC_Parameters_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_ECC_Parameters_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::ECC_ParametersResponse_ID]=sInf;
    sInf->Name = "ECC_ParametersResponse";
    sInf->MyTypeInfo=typeid(ECC_ParametersResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //parameters
    sInf->Fields[0].ThisElementType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[0].ThisElementTypeName = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Fields[0].ElementSize = sizeof(TPMS_ALGORITHM_DETAIL_ECC);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "parameters";
    sInf->Fields[0].ParentTypeName = "ECC_ParametersResponse";
    sInf->Fields[0].ParentType = TpmTypeId::ECC_ParametersResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_ZGen_2Phase_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(7);
    TypeMap[TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_ZGen_2Phase_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_ZGen_2Phase_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //keyA
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "keyA";
    sInf->Fields[0].ParentTypeName = "TPM2_ZGen_2Phase_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //inQsBSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[1].ElementName = "inQsBSize";
    sInf->Fields[1].ParentTypeName = "TPM2_ZGen_2Phase_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //inQsB
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMS_ECC_POINT";
    sInf->Fields[2].ElementSize = sizeof(TPMS_ECC_POINT);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "inQsB";
    sInf->Fields[2].ParentTypeName = "TPM2_ZGen_2Phase_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //inQeBSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[3].ElementName = "inQeBSize";
    sInf->Fields[3].ParentTypeName = "TPM2_ZGen_2Phase_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //inQeB
    sInf->Fields[4].ThisElementType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[4].ThisElementTypeName = "TPMS_ECC_POINT";
    sInf->Fields[4].ElementSize = sizeof(TPMS_ECC_POINT);
    sInf->Fields[4].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[4].ElementName = "inQeB";
    sInf->Fields[4].ParentTypeName = "TPM2_ZGen_2Phase_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmStruct;
    sInf->Fields[4].IsArray = FALSE;
    //inScheme
    sInf->Fields[5].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[5].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[5].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[5].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[5].ElementName = "inScheme";
    sInf->Fields[5].ParentTypeName = "TPM2_ZGen_2Phase_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    //counter
    sInf->Fields[6].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[6].ThisElementTypeName = "UINT16";
    sInf->Fields[6].ElementSize = sizeof(UINT16);
    sInf->Fields[6].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[6].ElementName = "counter";
    sInf->Fields[6].ParentTypeName = "TPM2_ZGen_2Phase_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = FALSE;
    //===================TPM2_ZGen_2Phase_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::ZGen_2PhaseResponse_ID]=sInf;
    sInf->Name = "ZGen_2PhaseResponse";
    sInf->MyTypeInfo=typeid(ZGen_2PhaseResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //outZ1Size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "outZ1Size";
    sInf->Fields[0].ParentTypeName = "ZGen_2PhaseResponse";
    sInf->Fields[0].ParentType = TpmTypeId::ZGen_2PhaseResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //outZ1
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_ECC_POINT";
    sInf->Fields[1].ElementSize = sizeof(TPMS_ECC_POINT);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "outZ1";
    sInf->Fields[1].ParentTypeName = "ZGen_2PhaseResponse";
    sInf->Fields[1].ParentType = TpmTypeId::ZGen_2PhaseResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //outZ2Size
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[2].ElementName = "outZ2Size";
    sInf->Fields[2].ParentTypeName = "ZGen_2PhaseResponse";
    sInf->Fields[2].ParentType = TpmTypeId::ZGen_2PhaseResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //outZ2
    sInf->Fields[3].ThisElementType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[3].ThisElementTypeName = "TPMS_ECC_POINT";
    sInf->Fields[3].ElementSize = sizeof(TPMS_ECC_POINT);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "outZ2";
    sInf->Fields[3].ParentTypeName = "ZGen_2PhaseResponse";
    sInf->Fields[3].ParentType = TpmTypeId::ZGen_2PhaseResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmStruct;
    sInf->Fields[3].IsArray = FALSE;
    //===================TPM2_EncryptDecrypt_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(7);
    TypeMap[TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_EncryptDecrypt_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_EncryptDecrypt_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //keyHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "keyHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_EncryptDecrypt_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //decrypt
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "decrypt";
    sInf->Fields[1].ParentTypeName = "TPM2_EncryptDecrypt_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //mode
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[2].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "mode";
    sInf->Fields[2].ParentTypeName = "TPM2_EncryptDecrypt_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //ivInSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "ivInSize";
    sInf->Fields[3].ParentTypeName = "TPM2_EncryptDecrypt_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //ivIn
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "ivIn";
    sInf->Fields[4].ParentTypeName = "TPM2_EncryptDecrypt_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //inDataSize
    sInf->Fields[5].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[5].ThisElementTypeName = "UINT16";
    sInf->Fields[5].ElementSize = sizeof(UINT16);
    sInf->Fields[5].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[5].ElementName = "inDataSize";
    sInf->Fields[5].ParentTypeName = "TPM2_EncryptDecrypt_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    //inData
    sInf->Fields[6].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[6].ThisElementTypeName = "BYTE";
    sInf->Fields[6].ElementSize = sizeof(BYTE);
    sInf->Fields[6].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[6].ElementName = "inData";
    sInf->Fields[6].ParentTypeName = "TPM2_EncryptDecrypt_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = TRUE;
    sInf->Fields[6].AssociatedElement=5;
    //===================TPM2_EncryptDecrypt_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::EncryptDecryptResponse_ID]=sInf;
    sInf->Name = "EncryptDecryptResponse";
    sInf->MyTypeInfo=typeid(EncryptDecryptResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //outDataSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "outDataSize";
    sInf->Fields[0].ParentTypeName = "EncryptDecryptResponse";
    sInf->Fields[0].ParentType = TpmTypeId::EncryptDecryptResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //outData
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "outData";
    sInf->Fields[1].ParentTypeName = "EncryptDecryptResponse";
    sInf->Fields[1].ParentType = TpmTypeId::EncryptDecryptResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //ivOutSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "ivOutSize";
    sInf->Fields[2].ParentTypeName = "EncryptDecryptResponse";
    sInf->Fields[2].ParentType = TpmTypeId::EncryptDecryptResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //ivOut
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "ivOut";
    sInf->Fields[3].ParentTypeName = "EncryptDecryptResponse";
    sInf->Fields[3].ParentType = TpmTypeId::EncryptDecryptResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPM2_EncryptDecrypt2_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(7);
    TypeMap[TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_EncryptDecrypt2_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_EncryptDecrypt2_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //keyHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "keyHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_EncryptDecrypt2_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //inDataSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "inDataSize";
    sInf->Fields[1].ParentTypeName = "TPM2_EncryptDecrypt2_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //inData
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "inData";
    sInf->Fields[2].ParentTypeName = "TPM2_EncryptDecrypt2_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //decrypt
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "decrypt";
    sInf->Fields[3].ParentTypeName = "TPM2_EncryptDecrypt2_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //mode
    sInf->Fields[4].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[4].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[4].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[4].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[4].ElementName = "mode";
    sInf->Fields[4].ParentTypeName = "TPM2_EncryptDecrypt2_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    //ivInSize
    sInf->Fields[5].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[5].ThisElementTypeName = "UINT16";
    sInf->Fields[5].ElementSize = sizeof(UINT16);
    sInf->Fields[5].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[5].ElementName = "ivInSize";
    sInf->Fields[5].ParentTypeName = "TPM2_EncryptDecrypt2_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    //ivIn
    sInf->Fields[6].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[6].ThisElementTypeName = "BYTE";
    sInf->Fields[6].ElementSize = sizeof(BYTE);
    sInf->Fields[6].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[6].ElementName = "ivIn";
    sInf->Fields[6].ParentTypeName = "TPM2_EncryptDecrypt2_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = TRUE;
    sInf->Fields[6].AssociatedElement=5;
    //===================TPM2_EncryptDecrypt2_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::EncryptDecrypt2Response_ID]=sInf;
    sInf->Name = "EncryptDecrypt2Response";
    sInf->MyTypeInfo=typeid(EncryptDecrypt2Response).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //outDataSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "outDataSize";
    sInf->Fields[0].ParentTypeName = "EncryptDecrypt2Response";
    sInf->Fields[0].ParentType = TpmTypeId::EncryptDecrypt2Response_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //outData
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "outData";
    sInf->Fields[1].ParentTypeName = "EncryptDecrypt2Response";
    sInf->Fields[1].ParentType = TpmTypeId::EncryptDecrypt2Response_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //ivOutSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "ivOutSize";
    sInf->Fields[2].ParentTypeName = "EncryptDecrypt2Response";
    sInf->Fields[2].ParentType = TpmTypeId::EncryptDecrypt2Response_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //ivOut
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "ivOut";
    sInf->Fields[3].ParentTypeName = "EncryptDecrypt2Response";
    sInf->Fields[3].ParentType = TpmTypeId::EncryptDecrypt2Response_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPM2_Hash_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPM2_Hash_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_Hash_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_Hash_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //dataSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "dataSize";
    sInf->Fields[0].ParentTypeName = "TPM2_Hash_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Hash_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //data
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "data";
    sInf->Fields[1].ParentTypeName = "TPM2_Hash_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Hash_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //hashAlg
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[2].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "hashAlg";
    sInf->Fields[2].ParentTypeName = "TPM2_Hash_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Hash_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //hierarchy
    sInf->Fields[3].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[3].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[3].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "hierarchy";
    sInf->Fields[3].ParentTypeName = "TPM2_Hash_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Hash_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmStruct;
    sInf->Fields[3].IsArray = FALSE;
    //===================TPM2_Hash_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::HashResponse_ID]=sInf;
    sInf->Name = "HashResponse";
    sInf->MyTypeInfo=typeid(HashResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //outHashSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "outHashSize";
    sInf->Fields[0].ParentTypeName = "HashResponse";
    sInf->Fields[0].ParentType = TpmTypeId::HashResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //outHash
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "outHash";
    sInf->Fields[1].ParentTypeName = "HashResponse";
    sInf->Fields[1].ParentType = TpmTypeId::HashResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //validation
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMT_TK_HASHCHECK";
    sInf->Fields[2].ElementSize = sizeof(TPMT_TK_HASHCHECK);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "validation";
    sInf->Fields[2].ParentTypeName = "HashResponse";
    sInf->Fields[2].ParentType = TpmTypeId::HashResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //===================TPM2_HMAC_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPM2_HMAC_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_HMAC_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_HMAC_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //handle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "handle";
    sInf->Fields[0].ParentTypeName = "TPM2_HMAC_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_HMAC_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //bufferSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "bufferSize";
    sInf->Fields[1].ParentTypeName = "TPM2_HMAC_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_HMAC_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //buffer
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "buffer";
    sInf->Fields[2].ParentTypeName = "TPM2_HMAC_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_HMAC_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //hashAlg
    sInf->Fields[3].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[3].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "hashAlg";
    sInf->Fields[3].ParentTypeName = "TPM2_HMAC_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_HMAC_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //===================TPM2_HMAC_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::HMACResponse_ID]=sInf;
    sInf->Name = "HMACResponse";
    sInf->MyTypeInfo=typeid(HMACResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //outHMACSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "outHMACSize";
    sInf->Fields[0].ParentTypeName = "HMACResponse";
    sInf->Fields[0].ParentType = TpmTypeId::HMACResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //outHMAC
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "outHMAC";
    sInf->Fields[1].ParentTypeName = "HMACResponse";
    sInf->Fields[1].ParentType = TpmTypeId::HMACResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_MAC_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPM2_MAC_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_MAC_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_MAC_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //handle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "handle";
    sInf->Fields[0].ParentTypeName = "TPM2_MAC_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_MAC_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //bufferSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "bufferSize";
    sInf->Fields[1].ParentTypeName = "TPM2_MAC_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_MAC_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //buffer
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "buffer";
    sInf->Fields[2].ParentTypeName = "TPM2_MAC_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_MAC_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //inScheme
    sInf->Fields[3].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[3].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "inScheme";
    sInf->Fields[3].ParentTypeName = "TPM2_MAC_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_MAC_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //===================TPM2_MAC_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::MACResponse_ID]=sInf;
    sInf->Name = "MACResponse";
    sInf->MyTypeInfo=typeid(MACResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //outMACSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "outMACSize";
    sInf->Fields[0].ParentTypeName = "MACResponse";
    sInf->Fields[0].ParentType = TpmTypeId::MACResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //outMAC
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "outMAC";
    sInf->Fields[1].ParentTypeName = "MACResponse";
    sInf->Fields[1].ParentType = TpmTypeId::MACResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_GetRandom_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_GetRandom_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_GetRandom_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_GetRandom_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //bytesRequested
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "bytesRequested";
    sInf->Fields[0].ParentTypeName = "TPM2_GetRandom_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_GetRandom_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_GetRandom_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::GetRandomResponse_ID]=sInf;
    sInf->Name = "GetRandomResponse";
    sInf->MyTypeInfo=typeid(GetRandomResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //randomBytesSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "randomBytesSize";
    sInf->Fields[0].ParentTypeName = "GetRandomResponse";
    sInf->Fields[0].ParentType = TpmTypeId::GetRandomResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //randomBytes
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "randomBytes";
    sInf->Fields[1].ParentTypeName = "GetRandomResponse";
    sInf->Fields[1].ParentType = TpmTypeId::GetRandomResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_StirRandom_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2_StirRandom_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_StirRandom_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_StirRandom_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //inDataSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "inDataSize";
    sInf->Fields[0].ParentTypeName = "TPM2_StirRandom_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_StirRandom_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //inData
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "inData";
    sInf->Fields[1].ParentTypeName = "TPM2_StirRandom_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_StirRandom_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_StirRandom_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::StirRandomResponse_ID]=sInf;
    sInf->Name = "StirRandomResponse";
    sInf->MyTypeInfo=typeid(StirRandomResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_HMAC_Start_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPM2_HMAC_Start_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_HMAC_Start_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_HMAC_Start_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //handle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "handle";
    sInf->Fields[0].ParentTypeName = "TPM2_HMAC_Start_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_HMAC_Start_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //authSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "authSize";
    sInf->Fields[1].ParentTypeName = "TPM2_HMAC_Start_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_HMAC_Start_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //auth
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "auth";
    sInf->Fields[2].ParentTypeName = "TPM2_HMAC_Start_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_HMAC_Start_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //hashAlg
    sInf->Fields[3].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[3].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "hashAlg";
    sInf->Fields[3].ParentTypeName = "TPM2_HMAC_Start_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_HMAC_Start_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //===================TPM2_HMAC_Start_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::HMAC_StartResponse_ID]=sInf;
    sInf->Name = "HMAC_StartResponse";
    sInf->MyTypeInfo=typeid(HMAC_StartResponse).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //handle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "handle";
    sInf->Fields[0].ParentTypeName = "HMAC_StartResponse";
    sInf->Fields[0].ParentType = TpmTypeId::HMAC_StartResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_MAC_Start_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPM2_MAC_Start_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_MAC_Start_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_MAC_Start_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //handle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "handle";
    sInf->Fields[0].ParentTypeName = "TPM2_MAC_Start_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_MAC_Start_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //authSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "authSize";
    sInf->Fields[1].ParentTypeName = "TPM2_MAC_Start_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_MAC_Start_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //auth
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "auth";
    sInf->Fields[2].ParentTypeName = "TPM2_MAC_Start_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_MAC_Start_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //inScheme
    sInf->Fields[3].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[3].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "inScheme";
    sInf->Fields[3].ParentTypeName = "TPM2_MAC_Start_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_MAC_Start_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //===================TPM2_MAC_Start_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::MAC_StartResponse_ID]=sInf;
    sInf->Name = "MAC_StartResponse";
    sInf->MyTypeInfo=typeid(MAC_StartResponse).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //handle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "handle";
    sInf->Fields[0].ParentTypeName = "MAC_StartResponse";
    sInf->Fields[0].ParentType = TpmTypeId::MAC_StartResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_HashSequenceStart_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_HashSequenceStart_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_HashSequenceStart_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_HashSequenceStart_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //authSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "authSize";
    sInf->Fields[0].ParentTypeName = "TPM2_HashSequenceStart_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_HashSequenceStart_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //auth
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "auth";
    sInf->Fields[1].ParentTypeName = "TPM2_HashSequenceStart_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_HashSequenceStart_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //hashAlg
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[2].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "hashAlg";
    sInf->Fields[2].ParentTypeName = "TPM2_HashSequenceStart_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_HashSequenceStart_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //===================TPM2_HashSequenceStart_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::HashSequenceStartResponse_ID]=sInf;
    sInf->Name = "HashSequenceStartResponse";
    sInf->MyTypeInfo=typeid(HashSequenceStartResponse).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //handle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "handle";
    sInf->Fields[0].ParentTypeName = "HashSequenceStartResponse";
    sInf->Fields[0].ParentType = TpmTypeId::HashSequenceStartResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_SequenceUpdate_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_SequenceUpdate_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_SequenceUpdate_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_SequenceUpdate_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //sequenceHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "sequenceHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_SequenceUpdate_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_SequenceUpdate_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //bufferSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "bufferSize";
    sInf->Fields[1].ParentTypeName = "TPM2_SequenceUpdate_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_SequenceUpdate_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //buffer
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "buffer";
    sInf->Fields[2].ParentTypeName = "TPM2_SequenceUpdate_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_SequenceUpdate_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPM2_SequenceUpdate_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::SequenceUpdateResponse_ID]=sInf;
    sInf->Name = "SequenceUpdateResponse";
    sInf->MyTypeInfo=typeid(SequenceUpdateResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_SequenceComplete_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPM2_SequenceComplete_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_SequenceComplete_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_SequenceComplete_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //sequenceHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "sequenceHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_SequenceComplete_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_SequenceComplete_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //bufferSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "bufferSize";
    sInf->Fields[1].ParentTypeName = "TPM2_SequenceComplete_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_SequenceComplete_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //buffer
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "buffer";
    sInf->Fields[2].ParentTypeName = "TPM2_SequenceComplete_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_SequenceComplete_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //hierarchy
    sInf->Fields[3].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[3].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[3].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "hierarchy";
    sInf->Fields[3].ParentTypeName = "TPM2_SequenceComplete_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_SequenceComplete_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmStruct;
    sInf->Fields[3].IsArray = FALSE;
    //===================TPM2_SequenceComplete_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::SequenceCompleteResponse_ID]=sInf;
    sInf->Name = "SequenceCompleteResponse";
    sInf->MyTypeInfo=typeid(SequenceCompleteResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //resultSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "resultSize";
    sInf->Fields[0].ParentTypeName = "SequenceCompleteResponse";
    sInf->Fields[0].ParentType = TpmTypeId::SequenceCompleteResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //result
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "result";
    sInf->Fields[1].ParentTypeName = "SequenceCompleteResponse";
    sInf->Fields[1].ParentType = TpmTypeId::SequenceCompleteResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //validation
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMT_TK_HASHCHECK";
    sInf->Fields[2].ElementSize = sizeof(TPMT_TK_HASHCHECK);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "validation";
    sInf->Fields[2].ParentTypeName = "SequenceCompleteResponse";
    sInf->Fields[2].ParentType = TpmTypeId::SequenceCompleteResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //===================TPM2_EventSequenceComplete_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_EventSequenceComplete_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_EventSequenceComplete_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 2;
    //pcrHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "pcrHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_EventSequenceComplete_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //sequenceHandle
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "sequenceHandle";
    sInf->Fields[1].ParentTypeName = "TPM2_EventSequenceComplete_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //bufferSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "bufferSize";
    sInf->Fields[2].ParentTypeName = "TPM2_EventSequenceComplete_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //buffer
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "buffer";
    sInf->Fields[3].ParentTypeName = "TPM2_EventSequenceComplete_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPM2_EventSequenceComplete_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::EventSequenceCompleteResponse_ID]=sInf;
    sInf->Name = "EventSequenceCompleteResponse";
    sInf->MyTypeInfo=typeid(EventSequenceCompleteResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //resultsCount
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "resultsCount";
    sInf->Fields[0].ParentTypeName = "EventSequenceCompleteResponse";
    sInf->Fields[0].ParentType = TpmTypeId::EventSequenceCompleteResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //results
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMT_HA";
    sInf->Fields[1].ElementSize = sizeof(TPMT_HA);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "results";
    sInf->Fields[1].ParentTypeName = "EventSequenceCompleteResponse";
    sInf->Fields[1].ParentType = TpmTypeId::EventSequenceCompleteResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_Certify_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(6);
    TypeMap[TpmTypeId::TPM2_Certify_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_Certify_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_Certify_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 2;
    //objectHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "objectHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_Certify_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Certify_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //signHandle
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "signHandle";
    sInf->Fields[1].ParentTypeName = "TPM2_Certify_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Certify_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //qualifyingDataSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "qualifyingDataSize";
    sInf->Fields[2].ParentTypeName = "TPM2_Certify_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Certify_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //qualifyingData
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "qualifyingData";
    sInf->Fields[3].ParentTypeName = "TPM2_Certify_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Certify_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //inSchemeScheme
    sInf->Fields[4].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[4].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[4].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[4].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[4].ElementName = "inSchemeScheme";
    sInf->Fields[4].ParentTypeName = "TPM2_Certify_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_Certify_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    sInf->Fields[4].AssociatedElement=5;
    //inScheme
    sInf->Fields[5].ThisElementType = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[5].ThisElementTypeName = "TPMU_SIG_SCHEME";
    sInf->Fields[5].ElementSize = sizeof(TPMU_SIG_SCHEME);
    sInf->Fields[5].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[5].ElementName = "inScheme";
    sInf->Fields[5].ParentTypeName = "TPM2_Certify_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_Certify_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmUnion;
    sInf->Fields[5].IsArray = FALSE;
    sInf->Fields[5].AssociatedElement=4;
    //===================TPM2_Certify_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::CertifyResponse_ID]=sInf;
    sInf->Name = "CertifyResponse";
    sInf->MyTypeInfo=typeid(CertifyResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //certifyInfoSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "certifyInfoSize";
    sInf->Fields[0].ParentTypeName = "CertifyResponse";
    sInf->Fields[0].ParentType = TpmTypeId::CertifyResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //certifyInfo
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_ATTEST";
    sInf->Fields[1].ElementSize = sizeof(TPMS_ATTEST);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "certifyInfo";
    sInf->Fields[1].ParentTypeName = "CertifyResponse";
    sInf->Fields[1].ParentType = TpmTypeId::CertifyResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //signatureSigAlg
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[2].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[2].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[2].ElementName = "signatureSigAlg";
    sInf->Fields[2].ParentTypeName = "CertifyResponse";
    sInf->Fields[2].ParentType = TpmTypeId::CertifyResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    sInf->Fields[2].AssociatedElement=3;
    //signature
    sInf->Fields[3].ThisElementType = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[3].ThisElementTypeName = "TPMU_SIGNATURE";
    sInf->Fields[3].ElementSize = sizeof(TPMU_SIGNATURE);
    sInf->Fields[3].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[3].ElementName = "signature";
    sInf->Fields[3].ParentTypeName = "CertifyResponse";
    sInf->Fields[3].ParentType = TpmTypeId::CertifyResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmUnion;
    sInf->Fields[3].IsArray = FALSE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPM2_CertifyCreation_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(9);
    TypeMap[TpmTypeId::TPM2_CertifyCreation_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_CertifyCreation_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_CertifyCreation_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    //signHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "signHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_CertifyCreation_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //objectHandle
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "objectHandle";
    sInf->Fields[1].ParentTypeName = "TPM2_CertifyCreation_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //qualifyingDataSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "qualifyingDataSize";
    sInf->Fields[2].ParentTypeName = "TPM2_CertifyCreation_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //qualifyingData
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "qualifyingData";
    sInf->Fields[3].ParentTypeName = "TPM2_CertifyCreation_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //creationHashSize
    sInf->Fields[4].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[4].ThisElementTypeName = "UINT16";
    sInf->Fields[4].ElementSize = sizeof(UINT16);
    sInf->Fields[4].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[4].ElementName = "creationHashSize";
    sInf->Fields[4].ParentTypeName = "TPM2_CertifyCreation_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    //creationHash
    sInf->Fields[5].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[5].ThisElementTypeName = "BYTE";
    sInf->Fields[5].ElementSize = sizeof(BYTE);
    sInf->Fields[5].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[5].ElementName = "creationHash";
    sInf->Fields[5].ParentTypeName = "TPM2_CertifyCreation_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = TRUE;
    sInf->Fields[5].AssociatedElement=4;
    //inSchemeScheme
    sInf->Fields[6].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[6].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[6].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[6].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[6].ElementName = "inSchemeScheme";
    sInf->Fields[6].ParentTypeName = "TPM2_CertifyCreation_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = FALSE;
    sInf->Fields[6].AssociatedElement=7;
    //inScheme
    sInf->Fields[7].ThisElementType = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[7].ThisElementTypeName = "TPMU_SIG_SCHEME";
    sInf->Fields[7].ElementSize = sizeof(TPMU_SIG_SCHEME);
    sInf->Fields[7].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[7].ElementName = "inScheme";
    sInf->Fields[7].ParentTypeName = "TPM2_CertifyCreation_REQUEST";
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    sInf->Fields[7].Sort = ElementSort::TpmUnion;
    sInf->Fields[7].IsArray = FALSE;
    sInf->Fields[7].AssociatedElement=6;
    //creationTicket
    sInf->Fields[8].ThisElementType = TpmTypeId::TPMT_TK_CREATION_ID;
    sInf->Fields[8].ThisElementTypeName = "TPMT_TK_CREATION";
    sInf->Fields[8].ElementSize = sizeof(TPMT_TK_CREATION);
    sInf->Fields[8].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[8].ElementName = "creationTicket";
    sInf->Fields[8].ParentTypeName = "TPM2_CertifyCreation_REQUEST";
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    sInf->Fields[8].Sort = ElementSort::TpmStruct;
    sInf->Fields[8].IsArray = FALSE;
    //===================TPM2_CertifyCreation_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::CertifyCreationResponse_ID]=sInf;
    sInf->Name = "CertifyCreationResponse";
    sInf->MyTypeInfo=typeid(CertifyCreationResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //certifyInfoSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "certifyInfoSize";
    sInf->Fields[0].ParentTypeName = "CertifyCreationResponse";
    sInf->Fields[0].ParentType = TpmTypeId::CertifyCreationResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //certifyInfo
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_ATTEST";
    sInf->Fields[1].ElementSize = sizeof(TPMS_ATTEST);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "certifyInfo";
    sInf->Fields[1].ParentTypeName = "CertifyCreationResponse";
    sInf->Fields[1].ParentType = TpmTypeId::CertifyCreationResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //signatureSigAlg
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[2].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[2].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[2].ElementName = "signatureSigAlg";
    sInf->Fields[2].ParentTypeName = "CertifyCreationResponse";
    sInf->Fields[2].ParentType = TpmTypeId::CertifyCreationResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    sInf->Fields[2].AssociatedElement=3;
    //signature
    sInf->Fields[3].ThisElementType = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[3].ThisElementTypeName = "TPMU_SIGNATURE";
    sInf->Fields[3].ElementSize = sizeof(TPMU_SIGNATURE);
    sInf->Fields[3].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[3].ElementName = "signature";
    sInf->Fields[3].ParentTypeName = "CertifyCreationResponse";
    sInf->Fields[3].ParentType = TpmTypeId::CertifyCreationResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmUnion;
    sInf->Fields[3].IsArray = FALSE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPM2_Quote_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(7);
    TypeMap[TpmTypeId::TPM2_Quote_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_Quote_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_Quote_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //signHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "signHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_Quote_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //qualifyingDataSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "qualifyingDataSize";
    sInf->Fields[1].ParentTypeName = "TPM2_Quote_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //qualifyingData
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "qualifyingData";
    sInf->Fields[2].ParentTypeName = "TPM2_Quote_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //inSchemeScheme
    sInf->Fields[3].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[3].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[3].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[3].ElementName = "inSchemeScheme";
    sInf->Fields[3].ParentTypeName = "TPM2_Quote_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    sInf->Fields[3].AssociatedElement=4;
    //inScheme
    sInf->Fields[4].ThisElementType = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[4].ThisElementTypeName = "TPMU_SIG_SCHEME";
    sInf->Fields[4].ElementSize = sizeof(TPMU_SIG_SCHEME);
    sInf->Fields[4].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[4].ElementName = "inScheme";
    sInf->Fields[4].ParentTypeName = "TPM2_Quote_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmUnion;
    sInf->Fields[4].IsArray = FALSE;
    sInf->Fields[4].AssociatedElement=3;
    //PCRselectCount
    sInf->Fields[5].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[5].ThisElementTypeName = "UINT32";
    sInf->Fields[5].ElementSize = sizeof(UINT32);
    sInf->Fields[5].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[5].ElementName = "PCRselectCount";
    sInf->Fields[5].ParentTypeName = "TPM2_Quote_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    //PCRselect
    sInf->Fields[6].ThisElementType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[6].ThisElementTypeName = "TPMS_PCR_SELECTION";
    sInf->Fields[6].ElementSize = sizeof(TPMS_PCR_SELECTION);
    sInf->Fields[6].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[6].ElementName = "PCRselect";
    sInf->Fields[6].ParentTypeName = "TPM2_Quote_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmStruct;
    sInf->Fields[6].IsArray = TRUE;
    sInf->Fields[6].AssociatedElement=5;
    //===================TPM2_Quote_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::QuoteResponse_ID]=sInf;
    sInf->Name = "QuoteResponse";
    sInf->MyTypeInfo=typeid(QuoteResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //quotedSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "quotedSize";
    sInf->Fields[0].ParentTypeName = "QuoteResponse";
    sInf->Fields[0].ParentType = TpmTypeId::QuoteResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //quoted
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_ATTEST";
    sInf->Fields[1].ElementSize = sizeof(TPMS_ATTEST);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "quoted";
    sInf->Fields[1].ParentTypeName = "QuoteResponse";
    sInf->Fields[1].ParentType = TpmTypeId::QuoteResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //signatureSigAlg
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[2].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[2].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[2].ElementName = "signatureSigAlg";
    sInf->Fields[2].ParentTypeName = "QuoteResponse";
    sInf->Fields[2].ParentType = TpmTypeId::QuoteResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    sInf->Fields[2].AssociatedElement=3;
    //signature
    sInf->Fields[3].ThisElementType = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[3].ThisElementTypeName = "TPMU_SIGNATURE";
    sInf->Fields[3].ElementSize = sizeof(TPMU_SIGNATURE);
    sInf->Fields[3].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[3].ElementName = "signature";
    sInf->Fields[3].ParentTypeName = "QuoteResponse";
    sInf->Fields[3].ParentType = TpmTypeId::QuoteResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmUnion;
    sInf->Fields[3].IsArray = FALSE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPM2_GetSessionAuditDigest_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(7);
    TypeMap[TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_GetSessionAuditDigest_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_GetSessionAuditDigest_REQUEST).name();
    sInf->HandleCount = 3;
    sInf->AuthHandleCount = 2;
    //privacyAdminHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "privacyAdminHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_GetSessionAuditDigest_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //signHandle
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "signHandle";
    sInf->Fields[1].ParentTypeName = "TPM2_GetSessionAuditDigest_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //sessionHandle
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[2].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "sessionHandle";
    sInf->Fields[2].ParentTypeName = "TPM2_GetSessionAuditDigest_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //qualifyingDataSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "qualifyingDataSize";
    sInf->Fields[3].ParentTypeName = "TPM2_GetSessionAuditDigest_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //qualifyingData
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "qualifyingData";
    sInf->Fields[4].ParentTypeName = "TPM2_GetSessionAuditDigest_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //inSchemeScheme
    sInf->Fields[5].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[5].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[5].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[5].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[5].ElementName = "inSchemeScheme";
    sInf->Fields[5].ParentTypeName = "TPM2_GetSessionAuditDigest_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    sInf->Fields[5].AssociatedElement=6;
    //inScheme
    sInf->Fields[6].ThisElementType = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[6].ThisElementTypeName = "TPMU_SIG_SCHEME";
    sInf->Fields[6].ElementSize = sizeof(TPMU_SIG_SCHEME);
    sInf->Fields[6].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[6].ElementName = "inScheme";
    sInf->Fields[6].ParentTypeName = "TPM2_GetSessionAuditDigest_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmUnion;
    sInf->Fields[6].IsArray = FALSE;
    sInf->Fields[6].AssociatedElement=5;
    //===================TPM2_GetSessionAuditDigest_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::GetSessionAuditDigestResponse_ID]=sInf;
    sInf->Name = "GetSessionAuditDigestResponse";
    sInf->MyTypeInfo=typeid(GetSessionAuditDigestResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //auditInfoSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "auditInfoSize";
    sInf->Fields[0].ParentTypeName = "GetSessionAuditDigestResponse";
    sInf->Fields[0].ParentType = TpmTypeId::GetSessionAuditDigestResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //auditInfo
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_ATTEST";
    sInf->Fields[1].ElementSize = sizeof(TPMS_ATTEST);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "auditInfo";
    sInf->Fields[1].ParentTypeName = "GetSessionAuditDigestResponse";
    sInf->Fields[1].ParentType = TpmTypeId::GetSessionAuditDigestResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //signatureSigAlg
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[2].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[2].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[2].ElementName = "signatureSigAlg";
    sInf->Fields[2].ParentTypeName = "GetSessionAuditDigestResponse";
    sInf->Fields[2].ParentType = TpmTypeId::GetSessionAuditDigestResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    sInf->Fields[2].AssociatedElement=3;
    //signature
    sInf->Fields[3].ThisElementType = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[3].ThisElementTypeName = "TPMU_SIGNATURE";
    sInf->Fields[3].ElementSize = sizeof(TPMU_SIGNATURE);
    sInf->Fields[3].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[3].ElementName = "signature";
    sInf->Fields[3].ParentTypeName = "GetSessionAuditDigestResponse";
    sInf->Fields[3].ParentType = TpmTypeId::GetSessionAuditDigestResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmUnion;
    sInf->Fields[3].IsArray = FALSE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPM2_GetCommandAuditDigest_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(6);
    TypeMap[TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_GetCommandAuditDigest_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_GetCommandAuditDigest_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 2;
    //privacyHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "privacyHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_GetCommandAuditDigest_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //signHandle
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "signHandle";
    sInf->Fields[1].ParentTypeName = "TPM2_GetCommandAuditDigest_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //qualifyingDataSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "qualifyingDataSize";
    sInf->Fields[2].ParentTypeName = "TPM2_GetCommandAuditDigest_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //qualifyingData
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "qualifyingData";
    sInf->Fields[3].ParentTypeName = "TPM2_GetCommandAuditDigest_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //inSchemeScheme
    sInf->Fields[4].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[4].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[4].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[4].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[4].ElementName = "inSchemeScheme";
    sInf->Fields[4].ParentTypeName = "TPM2_GetCommandAuditDigest_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    sInf->Fields[4].AssociatedElement=5;
    //inScheme
    sInf->Fields[5].ThisElementType = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[5].ThisElementTypeName = "TPMU_SIG_SCHEME";
    sInf->Fields[5].ElementSize = sizeof(TPMU_SIG_SCHEME);
    sInf->Fields[5].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[5].ElementName = "inScheme";
    sInf->Fields[5].ParentTypeName = "TPM2_GetCommandAuditDigest_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmUnion;
    sInf->Fields[5].IsArray = FALSE;
    sInf->Fields[5].AssociatedElement=4;
    //===================TPM2_GetCommandAuditDigest_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::GetCommandAuditDigestResponse_ID]=sInf;
    sInf->Name = "GetCommandAuditDigestResponse";
    sInf->MyTypeInfo=typeid(GetCommandAuditDigestResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //auditInfoSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "auditInfoSize";
    sInf->Fields[0].ParentTypeName = "GetCommandAuditDigestResponse";
    sInf->Fields[0].ParentType = TpmTypeId::GetCommandAuditDigestResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //auditInfo
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_ATTEST";
    sInf->Fields[1].ElementSize = sizeof(TPMS_ATTEST);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "auditInfo";
    sInf->Fields[1].ParentTypeName = "GetCommandAuditDigestResponse";
    sInf->Fields[1].ParentType = TpmTypeId::GetCommandAuditDigestResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //signatureSigAlg
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[2].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[2].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[2].ElementName = "signatureSigAlg";
    sInf->Fields[2].ParentTypeName = "GetCommandAuditDigestResponse";
    sInf->Fields[2].ParentType = TpmTypeId::GetCommandAuditDigestResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    sInf->Fields[2].AssociatedElement=3;
    //signature
    sInf->Fields[3].ThisElementType = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[3].ThisElementTypeName = "TPMU_SIGNATURE";
    sInf->Fields[3].ElementSize = sizeof(TPMU_SIGNATURE);
    sInf->Fields[3].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[3].ElementName = "signature";
    sInf->Fields[3].ParentTypeName = "GetCommandAuditDigestResponse";
    sInf->Fields[3].ParentType = TpmTypeId::GetCommandAuditDigestResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmUnion;
    sInf->Fields[3].IsArray = FALSE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPM2_GetTime_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(6);
    TypeMap[TpmTypeId::TPM2_GetTime_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_GetTime_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_GetTime_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 2;
    //privacyAdminHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "privacyAdminHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_GetTime_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_GetTime_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //signHandle
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "signHandle";
    sInf->Fields[1].ParentTypeName = "TPM2_GetTime_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_GetTime_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //qualifyingDataSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "qualifyingDataSize";
    sInf->Fields[2].ParentTypeName = "TPM2_GetTime_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_GetTime_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //qualifyingData
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "qualifyingData";
    sInf->Fields[3].ParentTypeName = "TPM2_GetTime_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_GetTime_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //inSchemeScheme
    sInf->Fields[4].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[4].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[4].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[4].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[4].ElementName = "inSchemeScheme";
    sInf->Fields[4].ParentTypeName = "TPM2_GetTime_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_GetTime_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    sInf->Fields[4].AssociatedElement=5;
    //inScheme
    sInf->Fields[5].ThisElementType = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[5].ThisElementTypeName = "TPMU_SIG_SCHEME";
    sInf->Fields[5].ElementSize = sizeof(TPMU_SIG_SCHEME);
    sInf->Fields[5].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[5].ElementName = "inScheme";
    sInf->Fields[5].ParentTypeName = "TPM2_GetTime_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_GetTime_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmUnion;
    sInf->Fields[5].IsArray = FALSE;
    sInf->Fields[5].AssociatedElement=4;
    //===================TPM2_GetTime_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::GetTimeResponse_ID]=sInf;
    sInf->Name = "GetTimeResponse";
    sInf->MyTypeInfo=typeid(GetTimeResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //timeInfoSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "timeInfoSize";
    sInf->Fields[0].ParentTypeName = "GetTimeResponse";
    sInf->Fields[0].ParentType = TpmTypeId::GetTimeResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //timeInfo
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_ATTEST";
    sInf->Fields[1].ElementSize = sizeof(TPMS_ATTEST);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "timeInfo";
    sInf->Fields[1].ParentTypeName = "GetTimeResponse";
    sInf->Fields[1].ParentType = TpmTypeId::GetTimeResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //signatureSigAlg
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[2].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[2].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[2].ElementName = "signatureSigAlg";
    sInf->Fields[2].ParentTypeName = "GetTimeResponse";
    sInf->Fields[2].ParentType = TpmTypeId::GetTimeResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    sInf->Fields[2].AssociatedElement=3;
    //signature
    sInf->Fields[3].ThisElementType = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[3].ThisElementTypeName = "TPMU_SIGNATURE";
    sInf->Fields[3].ElementSize = sizeof(TPMU_SIGNATURE);
    sInf->Fields[3].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[3].ElementName = "signature";
    sInf->Fields[3].ParentTypeName = "GetTimeResponse";
    sInf->Fields[3].ParentType = TpmTypeId::GetTimeResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmUnion;
    sInf->Fields[3].IsArray = FALSE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPM2_CertifyX509_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(8);
    TypeMap[TpmTypeId::TPM2_CertifyX509_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_CertifyX509_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_CertifyX509_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 2;
    //objectHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "objectHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_CertifyX509_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //signHandle
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "signHandle";
    sInf->Fields[1].ParentTypeName = "TPM2_CertifyX509_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //qualifyingDataSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "qualifyingDataSize";
    sInf->Fields[2].ParentTypeName = "TPM2_CertifyX509_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //qualifyingData
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "qualifyingData";
    sInf->Fields[3].ParentTypeName = "TPM2_CertifyX509_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //inSchemeScheme
    sInf->Fields[4].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[4].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[4].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[4].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[4].ElementName = "inSchemeScheme";
    sInf->Fields[4].ParentTypeName = "TPM2_CertifyX509_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    sInf->Fields[4].AssociatedElement=5;
    //inScheme
    sInf->Fields[5].ThisElementType = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[5].ThisElementTypeName = "TPMU_SIG_SCHEME";
    sInf->Fields[5].ElementSize = sizeof(TPMU_SIG_SCHEME);
    sInf->Fields[5].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[5].ElementName = "inScheme";
    sInf->Fields[5].ParentTypeName = "TPM2_CertifyX509_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmUnion;
    sInf->Fields[5].IsArray = FALSE;
    sInf->Fields[5].AssociatedElement=4;
    //partialCertificateSize
    sInf->Fields[6].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[6].ThisElementTypeName = "UINT16";
    sInf->Fields[6].ElementSize = sizeof(UINT16);
    sInf->Fields[6].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[6].ElementName = "partialCertificateSize";
    sInf->Fields[6].ParentTypeName = "TPM2_CertifyX509_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = FALSE;
    //partialCertificate
    sInf->Fields[7].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[7].ThisElementTypeName = "BYTE";
    sInf->Fields[7].ElementSize = sizeof(BYTE);
    sInf->Fields[7].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[7].ElementName = "partialCertificate";
    sInf->Fields[7].ParentTypeName = "TPM2_CertifyX509_REQUEST";
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    sInf->Fields[7].Sort = ElementSort::TpmValueType;
    sInf->Fields[7].IsArray = TRUE;
    sInf->Fields[7].AssociatedElement=6;
    //===================TPM2_CertifyX509_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(6);
    TypeMap[TpmTypeId::CertifyX509Response_ID]=sInf;
    sInf->Name = "CertifyX509Response";
    sInf->MyTypeInfo=typeid(CertifyX509Response).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //addedToCertificateSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "addedToCertificateSize";
    sInf->Fields[0].ParentTypeName = "CertifyX509Response";
    sInf->Fields[0].ParentType = TpmTypeId::CertifyX509Response_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //addedToCertificate
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "addedToCertificate";
    sInf->Fields[1].ParentTypeName = "CertifyX509Response";
    sInf->Fields[1].ParentType = TpmTypeId::CertifyX509Response_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //tbsDigestSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "tbsDigestSize";
    sInf->Fields[2].ParentTypeName = "CertifyX509Response";
    sInf->Fields[2].ParentType = TpmTypeId::CertifyX509Response_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //tbsDigest
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "tbsDigest";
    sInf->Fields[3].ParentTypeName = "CertifyX509Response";
    sInf->Fields[3].ParentType = TpmTypeId::CertifyX509Response_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //signatureSigAlg
    sInf->Fields[4].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[4].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[4].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[4].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[4].ElementName = "signatureSigAlg";
    sInf->Fields[4].ParentTypeName = "CertifyX509Response";
    sInf->Fields[4].ParentType = TpmTypeId::CertifyX509Response_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    sInf->Fields[4].AssociatedElement=5;
    //signature
    sInf->Fields[5].ThisElementType = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[5].ThisElementTypeName = "TPMU_SIGNATURE";
    sInf->Fields[5].ElementSize = sizeof(TPMU_SIGNATURE);
    sInf->Fields[5].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[5].ElementName = "signature";
    sInf->Fields[5].ParentTypeName = "CertifyX509Response";
    sInf->Fields[5].ParentType = TpmTypeId::CertifyX509Response_ID;
    sInf->Fields[5].Sort = ElementSort::TpmUnion;
    sInf->Fields[5].IsArray = FALSE;
    sInf->Fields[5].AssociatedElement=4;
    //===================TPM2_Commit_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(7);
    TypeMap[TpmTypeId::TPM2_Commit_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_Commit_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_Commit_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //signHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "signHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_Commit_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //P1Size
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[1].ElementName = "P1Size";
    sInf->Fields[1].ParentTypeName = "TPM2_Commit_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //P1
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMS_ECC_POINT";
    sInf->Fields[2].ElementSize = sizeof(TPMS_ECC_POINT);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "P1";
    sInf->Fields[2].ParentTypeName = "TPM2_Commit_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //s2Size
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "s2Size";
    sInf->Fields[3].ParentTypeName = "TPM2_Commit_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //s2
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "s2";
    sInf->Fields[4].ParentTypeName = "TPM2_Commit_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //y2Size
    sInf->Fields[5].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[5].ThisElementTypeName = "UINT16";
    sInf->Fields[5].ElementSize = sizeof(UINT16);
    sInf->Fields[5].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[5].ElementName = "y2Size";
    sInf->Fields[5].ParentTypeName = "TPM2_Commit_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    //y2
    sInf->Fields[6].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[6].ThisElementTypeName = "BYTE";
    sInf->Fields[6].ElementSize = sizeof(BYTE);
    sInf->Fields[6].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[6].ElementName = "y2";
    sInf->Fields[6].ParentTypeName = "TPM2_Commit_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = TRUE;
    sInf->Fields[6].AssociatedElement=5;
    //===================TPM2_Commit_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(7);
    TypeMap[TpmTypeId::CommitResponse_ID]=sInf;
    sInf->Name = "CommitResponse";
    sInf->MyTypeInfo=typeid(CommitResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //KSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "KSize";
    sInf->Fields[0].ParentTypeName = "CommitResponse";
    sInf->Fields[0].ParentType = TpmTypeId::CommitResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //K
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_ECC_POINT";
    sInf->Fields[1].ElementSize = sizeof(TPMS_ECC_POINT);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "K";
    sInf->Fields[1].ParentTypeName = "CommitResponse";
    sInf->Fields[1].ParentType = TpmTypeId::CommitResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //LSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[2].ElementName = "LSize";
    sInf->Fields[2].ParentTypeName = "CommitResponse";
    sInf->Fields[2].ParentType = TpmTypeId::CommitResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //L
    sInf->Fields[3].ThisElementType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[3].ThisElementTypeName = "TPMS_ECC_POINT";
    sInf->Fields[3].ElementSize = sizeof(TPMS_ECC_POINT);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "L";
    sInf->Fields[3].ParentTypeName = "CommitResponse";
    sInf->Fields[3].ParentType = TpmTypeId::CommitResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmStruct;
    sInf->Fields[3].IsArray = FALSE;
    //ESize
    sInf->Fields[4].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[4].ThisElementTypeName = "UINT16";
    sInf->Fields[4].ElementSize = sizeof(UINT16);
    sInf->Fields[4].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[4].ElementName = "ESize";
    sInf->Fields[4].ParentTypeName = "CommitResponse";
    sInf->Fields[4].ParentType = TpmTypeId::CommitResponse_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    //E
    sInf->Fields[5].ThisElementType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[5].ThisElementTypeName = "TPMS_ECC_POINT";
    sInf->Fields[5].ElementSize = sizeof(TPMS_ECC_POINT);
    sInf->Fields[5].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[5].ElementName = "E";
    sInf->Fields[5].ParentTypeName = "CommitResponse";
    sInf->Fields[5].ParentType = TpmTypeId::CommitResponse_ID;
    sInf->Fields[5].Sort = ElementSort::TpmStruct;
    sInf->Fields[5].IsArray = FALSE;
    //counter
    sInf->Fields[6].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[6].ThisElementTypeName = "UINT16";
    sInf->Fields[6].ElementSize = sizeof(UINT16);
    sInf->Fields[6].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[6].ElementName = "counter";
    sInf->Fields[6].ParentTypeName = "CommitResponse";
    sInf->Fields[6].ParentType = TpmTypeId::CommitResponse_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = FALSE;
    //===================TPM2_EC_Ephemeral_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_EC_Ephemeral_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_EC_Ephemeral_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_EC_Ephemeral_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //curveID
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ECC_CURVE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ECC_CURVE";
    sInf->Fields[0].ElementSize = sizeof(TPM_ECC_CURVE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "curveID";
    sInf->Fields[0].ParentTypeName = "TPM2_EC_Ephemeral_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_EC_Ephemeral_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_EC_Ephemeral_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::EC_EphemeralResponse_ID]=sInf;
    sInf->Name = "EC_EphemeralResponse";
    sInf->MyTypeInfo=typeid(EC_EphemeralResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //QSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "QSize";
    sInf->Fields[0].ParentTypeName = "EC_EphemeralResponse";
    sInf->Fields[0].ParentType = TpmTypeId::EC_EphemeralResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //Q
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_ECC_POINT";
    sInf->Fields[1].ElementSize = sizeof(TPMS_ECC_POINT);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "Q";
    sInf->Fields[1].ParentTypeName = "EC_EphemeralResponse";
    sInf->Fields[1].ParentType = TpmTypeId::EC_EphemeralResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //counter
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "counter";
    sInf->Fields[2].ParentTypeName = "EC_EphemeralResponse";
    sInf->Fields[2].ParentType = TpmTypeId::EC_EphemeralResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //===================TPM2_VerifySignature_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPM2_VerifySignature_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_VerifySignature_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_VerifySignature_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //keyHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "keyHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_VerifySignature_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_VerifySignature_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //digestSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "digestSize";
    sInf->Fields[1].ParentTypeName = "TPM2_VerifySignature_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_VerifySignature_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //digest
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "digest";
    sInf->Fields[2].ParentTypeName = "TPM2_VerifySignature_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_VerifySignature_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //signatureSigAlg
    sInf->Fields[3].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[3].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[3].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[3].ElementName = "signatureSigAlg";
    sInf->Fields[3].ParentTypeName = "TPM2_VerifySignature_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_VerifySignature_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    sInf->Fields[3].AssociatedElement=4;
    //signature
    sInf->Fields[4].ThisElementType = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[4].ThisElementTypeName = "TPMU_SIGNATURE";
    sInf->Fields[4].ElementSize = sizeof(TPMU_SIGNATURE);
    sInf->Fields[4].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[4].ElementName = "signature";
    sInf->Fields[4].ParentTypeName = "TPM2_VerifySignature_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_VerifySignature_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmUnion;
    sInf->Fields[4].IsArray = FALSE;
    sInf->Fields[4].AssociatedElement=3;
    //===================TPM2_VerifySignature_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::VerifySignatureResponse_ID]=sInf;
    sInf->Name = "VerifySignatureResponse";
    sInf->MyTypeInfo=typeid(VerifySignatureResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //validation
    sInf->Fields[0].ThisElementType = TpmTypeId::TPMT_TK_VERIFIED_ID;
    sInf->Fields[0].ThisElementTypeName = "TPMT_TK_VERIFIED";
    sInf->Fields[0].ElementSize = sizeof(TPMT_TK_VERIFIED);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "validation";
    sInf->Fields[0].ParentTypeName = "VerifySignatureResponse";
    sInf->Fields[0].ParentType = TpmTypeId::VerifySignatureResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_Sign_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(6);
    TypeMap[TpmTypeId::TPM2_Sign_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_Sign_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_Sign_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //keyHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "keyHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_Sign_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Sign_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //digestSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "digestSize";
    sInf->Fields[1].ParentTypeName = "TPM2_Sign_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Sign_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //digest
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "digest";
    sInf->Fields[2].ParentTypeName = "TPM2_Sign_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Sign_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //inSchemeScheme
    sInf->Fields[3].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[3].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[3].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[3].ElementName = "inSchemeScheme";
    sInf->Fields[3].ParentTypeName = "TPM2_Sign_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Sign_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    sInf->Fields[3].AssociatedElement=4;
    //inScheme
    sInf->Fields[4].ThisElementType = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[4].ThisElementTypeName = "TPMU_SIG_SCHEME";
    sInf->Fields[4].ElementSize = sizeof(TPMU_SIG_SCHEME);
    sInf->Fields[4].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[4].ElementName = "inScheme";
    sInf->Fields[4].ParentTypeName = "TPM2_Sign_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_Sign_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmUnion;
    sInf->Fields[4].IsArray = FALSE;
    sInf->Fields[4].AssociatedElement=3;
    //validation
    sInf->Fields[5].ThisElementType = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    sInf->Fields[5].ThisElementTypeName = "TPMT_TK_HASHCHECK";
    sInf->Fields[5].ElementSize = sizeof(TPMT_TK_HASHCHECK);
    sInf->Fields[5].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[5].ElementName = "validation";
    sInf->Fields[5].ParentTypeName = "TPM2_Sign_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_Sign_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmStruct;
    sInf->Fields[5].IsArray = FALSE;
    //===================TPM2_Sign_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::SignResponse_ID]=sInf;
    sInf->Name = "SignResponse";
    sInf->MyTypeInfo=typeid(SignResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //signatureSigAlg
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[0].ElementName = "signatureSigAlg";
    sInf->Fields[0].ParentTypeName = "SignResponse";
    sInf->Fields[0].ParentType = TpmTypeId::SignResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    sInf->Fields[0].AssociatedElement=1;
    //signature
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMU_SIGNATURE";
    sInf->Fields[1].ElementSize = sizeof(TPMU_SIGNATURE);
    sInf->Fields[1].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[1].ElementName = "signature";
    sInf->Fields[1].ParentTypeName = "SignResponse";
    sInf->Fields[1].ParentType = TpmTypeId::SignResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmUnion;
    sInf->Fields[1].IsArray = FALSE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_SetCommandCodeAuditStatus_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(6);
    TypeMap[TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_SetCommandCodeAuditStatus_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_SetCommandCodeAuditStatus_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //auth
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "auth";
    sInf->Fields[0].ParentTypeName = "TPM2_SetCommandCodeAuditStatus_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //auditAlg
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[1].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "auditAlg";
    sInf->Fields[1].ParentTypeName = "TPM2_SetCommandCodeAuditStatus_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //setListCount
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT32";
    sInf->Fields[2].ElementSize = sizeof(UINT32);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "setListCount";
    sInf->Fields[2].ParentTypeName = "TPM2_SetCommandCodeAuditStatus_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //setList
    sInf->Fields[3].ThisElementType = TpmTypeId::TPM_CC_ID;
    sInf->Fields[3].ThisElementTypeName = "TPM_CC";
    sInf->Fields[3].ElementSize = sizeof(TPM_CC);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "setList";
    sInf->Fields[3].ParentTypeName = "TPM2_SetCommandCodeAuditStatus_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmEnum;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //clearListCount
    sInf->Fields[4].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[4].ThisElementTypeName = "UINT32";
    sInf->Fields[4].ElementSize = sizeof(UINT32);
    sInf->Fields[4].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[4].ElementName = "clearListCount";
    sInf->Fields[4].ParentTypeName = "TPM2_SetCommandCodeAuditStatus_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    //clearList
    sInf->Fields[5].ThisElementType = TpmTypeId::TPM_CC_ID;
    sInf->Fields[5].ThisElementTypeName = "TPM_CC";
    sInf->Fields[5].ElementSize = sizeof(TPM_CC);
    sInf->Fields[5].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[5].ElementName = "clearList";
    sInf->Fields[5].ParentTypeName = "TPM2_SetCommandCodeAuditStatus_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmEnum;
    sInf->Fields[5].IsArray = TRUE;
    sInf->Fields[5].AssociatedElement=4;
    //===================TPM2_SetCommandCodeAuditStatus_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::SetCommandCodeAuditStatusResponse_ID]=sInf;
    sInf->Name = "SetCommandCodeAuditStatusResponse";
    sInf->MyTypeInfo=typeid(SetCommandCodeAuditStatusResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PCR_Extend_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_PCR_Extend_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PCR_Extend_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PCR_Extend_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //pcrHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "pcrHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_PCR_Extend_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PCR_Extend_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //digestsCount
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT32";
    sInf->Fields[1].ElementSize = sizeof(UINT32);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "digestsCount";
    sInf->Fields[1].ParentTypeName = "TPM2_PCR_Extend_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PCR_Extend_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //digests
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMT_HA";
    sInf->Fields[2].ElementSize = sizeof(TPMT_HA);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "digests";
    sInf->Fields[2].ParentTypeName = "TPM2_PCR_Extend_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PCR_Extend_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPM2_PCR_Extend_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PCR_ExtendResponse_ID]=sInf;
    sInf->Name = "PCR_ExtendResponse";
    sInf->MyTypeInfo=typeid(PCR_ExtendResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PCR_Event_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_PCR_Event_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PCR_Event_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PCR_Event_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //pcrHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "pcrHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_PCR_Event_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PCR_Event_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //eventDataSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "eventDataSize";
    sInf->Fields[1].ParentTypeName = "TPM2_PCR_Event_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PCR_Event_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //eventData
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "eventData";
    sInf->Fields[2].ParentTypeName = "TPM2_PCR_Event_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PCR_Event_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPM2_PCR_Event_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::PCR_EventResponse_ID]=sInf;
    sInf->Name = "PCR_EventResponse";
    sInf->MyTypeInfo=typeid(PCR_EventResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //digestsCount
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "digestsCount";
    sInf->Fields[0].ParentTypeName = "PCR_EventResponse";
    sInf->Fields[0].ParentType = TpmTypeId::PCR_EventResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //digests
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMT_HA";
    sInf->Fields[1].ElementSize = sizeof(TPMT_HA);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "digests";
    sInf->Fields[1].ParentTypeName = "PCR_EventResponse";
    sInf->Fields[1].ParentType = TpmTypeId::PCR_EventResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_PCR_Read_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2_PCR_Read_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PCR_Read_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PCR_Read_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //pcrSelectionInCount
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "pcrSelectionInCount";
    sInf->Fields[0].ParentTypeName = "TPM2_PCR_Read_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PCR_Read_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //pcrSelectionIn
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_PCR_SELECTION";
    sInf->Fields[1].ElementSize = sizeof(TPMS_PCR_SELECTION);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "pcrSelectionIn";
    sInf->Fields[1].ParentTypeName = "TPM2_PCR_Read_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PCR_Read_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_PCR_Read_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::PCR_ReadResponse_ID]=sInf;
    sInf->Name = "PCR_ReadResponse";
    sInf->MyTypeInfo=typeid(PCR_ReadResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //pcrUpdateCounter
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "pcrUpdateCounter";
    sInf->Fields[0].ParentTypeName = "PCR_ReadResponse";
    sInf->Fields[0].ParentType = TpmTypeId::PCR_ReadResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //pcrSelectionOutCount
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT32";
    sInf->Fields[1].ElementSize = sizeof(UINT32);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "pcrSelectionOutCount";
    sInf->Fields[1].ParentTypeName = "PCR_ReadResponse";
    sInf->Fields[1].ParentType = TpmTypeId::PCR_ReadResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //pcrSelectionOut
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMS_PCR_SELECTION";
    sInf->Fields[2].ElementSize = sizeof(TPMS_PCR_SELECTION);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "pcrSelectionOut";
    sInf->Fields[2].ParentTypeName = "PCR_ReadResponse";
    sInf->Fields[2].ParentType = TpmTypeId::PCR_ReadResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //pcrValuesCount
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT32";
    sInf->Fields[3].ElementSize = sizeof(UINT32);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "pcrValuesCount";
    sInf->Fields[3].ParentTypeName = "PCR_ReadResponse";
    sInf->Fields[3].ParentType = TpmTypeId::PCR_ReadResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //pcrValues
    sInf->Fields[4].ThisElementType = TpmTypeId::TPM2B_DIGEST_ID;
    sInf->Fields[4].ThisElementTypeName = "TPM2B_DIGEST";
    sInf->Fields[4].ElementSize = sizeof(TPM2B_DIGEST);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "pcrValues";
    sInf->Fields[4].ParentTypeName = "PCR_ReadResponse";
    sInf->Fields[4].ParentType = TpmTypeId::PCR_ReadResponse_ID;
    sInf->Fields[4].Sort = ElementSort::TpmStruct;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //===================TPM2_PCR_Allocate_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_PCR_Allocate_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PCR_Allocate_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PCR_Allocate_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_PCR_Allocate_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PCR_Allocate_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //pcrAllocationCount
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT32";
    sInf->Fields[1].ElementSize = sizeof(UINT32);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "pcrAllocationCount";
    sInf->Fields[1].ParentTypeName = "TPM2_PCR_Allocate_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PCR_Allocate_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //pcrAllocation
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMS_PCR_SELECTION";
    sInf->Fields[2].ElementSize = sizeof(TPMS_PCR_SELECTION);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "pcrAllocation";
    sInf->Fields[2].ParentTypeName = "TPM2_PCR_Allocate_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PCR_Allocate_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPM2_PCR_Allocate_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::PCR_AllocateResponse_ID]=sInf;
    sInf->Name = "PCR_AllocateResponse";
    sInf->MyTypeInfo=typeid(PCR_AllocateResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //allocationSuccess
    sInf->Fields[0].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[0].ThisElementTypeName = "BYTE";
    sInf->Fields[0].ElementSize = sizeof(BYTE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "allocationSuccess";
    sInf->Fields[0].ParentTypeName = "PCR_AllocateResponse";
    sInf->Fields[0].ParentType = TpmTypeId::PCR_AllocateResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //maxPCR
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT32";
    sInf->Fields[1].ElementSize = sizeof(UINT32);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "maxPCR";
    sInf->Fields[1].ParentTypeName = "PCR_AllocateResponse";
    sInf->Fields[1].ParentType = TpmTypeId::PCR_AllocateResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //sizeNeeded
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT32";
    sInf->Fields[2].ElementSize = sizeof(UINT32);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "sizeNeeded";
    sInf->Fields[2].ParentTypeName = "PCR_AllocateResponse";
    sInf->Fields[2].ParentType = TpmTypeId::PCR_AllocateResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //sizeAvailable
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT32";
    sInf->Fields[3].ElementSize = sizeof(UINT32);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "sizeAvailable";
    sInf->Fields[3].ParentTypeName = "PCR_AllocateResponse";
    sInf->Fields[3].ParentType = TpmTypeId::PCR_AllocateResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //===================TPM2_PCR_SetAuthPolicy_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PCR_SetAuthPolicy_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PCR_SetAuthPolicy_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_PCR_SetAuthPolicy_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //authPolicySize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "authPolicySize";
    sInf->Fields[1].ParentTypeName = "TPM2_PCR_SetAuthPolicy_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //authPolicy
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "authPolicy";
    sInf->Fields[2].ParentTypeName = "TPM2_PCR_SetAuthPolicy_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //hashAlg
    sInf->Fields[3].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[3].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "hashAlg";
    sInf->Fields[3].ParentTypeName = "TPM2_PCR_SetAuthPolicy_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //pcrNum
    sInf->Fields[4].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[4].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[4].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[4].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[4].ElementName = "pcrNum";
    sInf->Fields[4].ParentTypeName = "TPM2_PCR_SetAuthPolicy_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmStruct;
    sInf->Fields[4].IsArray = FALSE;
    //===================TPM2_PCR_SetAuthPolicy_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PCR_SetAuthPolicyResponse_ID]=sInf;
    sInf->Name = "PCR_SetAuthPolicyResponse";
    sInf->MyTypeInfo=typeid(PCR_SetAuthPolicyResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PCR_SetAuthValue_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_PCR_SetAuthValue_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PCR_SetAuthValue_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PCR_SetAuthValue_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //pcrHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "pcrHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_PCR_SetAuthValue_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PCR_SetAuthValue_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //authSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "authSize";
    sInf->Fields[1].ParentTypeName = "TPM2_PCR_SetAuthValue_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PCR_SetAuthValue_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //auth
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "auth";
    sInf->Fields[2].ParentTypeName = "TPM2_PCR_SetAuthValue_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PCR_SetAuthValue_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPM2_PCR_SetAuthValue_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PCR_SetAuthValueResponse_ID]=sInf;
    sInf->Name = "PCR_SetAuthValueResponse";
    sInf->MyTypeInfo=typeid(PCR_SetAuthValueResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PCR_Reset_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_PCR_Reset_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PCR_Reset_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PCR_Reset_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //pcrHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "pcrHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_PCR_Reset_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PCR_Reset_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_PCR_Reset_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PCR_ResetResponse_ID]=sInf;
    sInf->Name = "PCR_ResetResponse";
    sInf->MyTypeInfo=typeid(PCR_ResetResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PolicySigned_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(11);
    TypeMap[TpmTypeId::TPM2_PolicySigned_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicySigned_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicySigned_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 0;
    //authObject
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authObject";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicySigned_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //policySession
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "policySession";
    sInf->Fields[1].ParentTypeName = "TPM2_PolicySigned_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //nonceTPMSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "nonceTPMSize";
    sInf->Fields[2].ParentTypeName = "TPM2_PolicySigned_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //nonceTPM
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "nonceTPM";
    sInf->Fields[3].ParentTypeName = "TPM2_PolicySigned_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //cpHashASize
    sInf->Fields[4].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[4].ThisElementTypeName = "UINT16";
    sInf->Fields[4].ElementSize = sizeof(UINT16);
    sInf->Fields[4].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[4].ElementName = "cpHashASize";
    sInf->Fields[4].ParentTypeName = "TPM2_PolicySigned_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    //cpHashA
    sInf->Fields[5].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[5].ThisElementTypeName = "BYTE";
    sInf->Fields[5].ElementSize = sizeof(BYTE);
    sInf->Fields[5].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[5].ElementName = "cpHashA";
    sInf->Fields[5].ParentTypeName = "TPM2_PolicySigned_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = TRUE;
    sInf->Fields[5].AssociatedElement=4;
    //policyRefSize
    sInf->Fields[6].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[6].ThisElementTypeName = "UINT16";
    sInf->Fields[6].ElementSize = sizeof(UINT16);
    sInf->Fields[6].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[6].ElementName = "policyRefSize";
    sInf->Fields[6].ParentTypeName = "TPM2_PolicySigned_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = FALSE;
    //policyRef
    sInf->Fields[7].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[7].ThisElementTypeName = "BYTE";
    sInf->Fields[7].ElementSize = sizeof(BYTE);
    sInf->Fields[7].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[7].ElementName = "policyRef";
    sInf->Fields[7].ParentTypeName = "TPM2_PolicySigned_REQUEST";
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    sInf->Fields[7].Sort = ElementSort::TpmValueType;
    sInf->Fields[7].IsArray = TRUE;
    sInf->Fields[7].AssociatedElement=6;
    //expiration
    sInf->Fields[8].ThisElementType = TpmTypeId::INT32_ID;
    sInf->Fields[8].ThisElementTypeName = "INT32";
    sInf->Fields[8].ElementSize = sizeof(INT32);
    sInf->Fields[8].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[8].ElementName = "expiration";
    sInf->Fields[8].ParentTypeName = "TPM2_PolicySigned_REQUEST";
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    sInf->Fields[8].Sort = ElementSort::TpmValueType;
    sInf->Fields[8].IsArray = FALSE;
    //authSigAlg
    sInf->Fields[9].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[9].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[9].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[9].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[9].ElementName = "authSigAlg";
    sInf->Fields[9].ParentTypeName = "TPM2_PolicySigned_REQUEST";
    sInf->Fields[9].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    sInf->Fields[9].Sort = ElementSort::TpmValueType;
    sInf->Fields[9].IsArray = FALSE;
    sInf->Fields[9].AssociatedElement=10;
    //auth
    sInf->Fields[10].ThisElementType = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[10].ThisElementTypeName = "TPMU_SIGNATURE";
    sInf->Fields[10].ElementSize = sizeof(TPMU_SIGNATURE);
    sInf->Fields[10].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[10].ElementName = "auth";
    sInf->Fields[10].ParentTypeName = "TPM2_PolicySigned_REQUEST";
    sInf->Fields[10].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    sInf->Fields[10].Sort = ElementSort::TpmUnion;
    sInf->Fields[10].IsArray = FALSE;
    sInf->Fields[10].AssociatedElement=9;
    //===================TPM2_PolicySigned_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::PolicySignedResponse_ID]=sInf;
    sInf->Name = "PolicySignedResponse";
    sInf->MyTypeInfo=typeid(PolicySignedResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //timeoutSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "timeoutSize";
    sInf->Fields[0].ParentTypeName = "PolicySignedResponse";
    sInf->Fields[0].ParentType = TpmTypeId::PolicySignedResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //timeout
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "timeout";
    sInf->Fields[1].ParentTypeName = "PolicySignedResponse";
    sInf->Fields[1].ParentType = TpmTypeId::PolicySignedResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //policyTicket
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMT_TK_AUTH_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMT_TK_AUTH";
    sInf->Fields[2].ElementSize = sizeof(TPMT_TK_AUTH);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "policyTicket";
    sInf->Fields[2].ParentTypeName = "PolicySignedResponse";
    sInf->Fields[2].ParentType = TpmTypeId::PolicySignedResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //===================TPM2_PolicySecret_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(9);
    TypeMap[TpmTypeId::TPM2_PolicySecret_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicySecret_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicySecret_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicySecret_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //policySession
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "policySession";
    sInf->Fields[1].ParentTypeName = "TPM2_PolicySecret_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //nonceTPMSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "nonceTPMSize";
    sInf->Fields[2].ParentTypeName = "TPM2_PolicySecret_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //nonceTPM
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "nonceTPM";
    sInf->Fields[3].ParentTypeName = "TPM2_PolicySecret_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //cpHashASize
    sInf->Fields[4].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[4].ThisElementTypeName = "UINT16";
    sInf->Fields[4].ElementSize = sizeof(UINT16);
    sInf->Fields[4].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[4].ElementName = "cpHashASize";
    sInf->Fields[4].ParentTypeName = "TPM2_PolicySecret_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    //cpHashA
    sInf->Fields[5].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[5].ThisElementTypeName = "BYTE";
    sInf->Fields[5].ElementSize = sizeof(BYTE);
    sInf->Fields[5].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[5].ElementName = "cpHashA";
    sInf->Fields[5].ParentTypeName = "TPM2_PolicySecret_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = TRUE;
    sInf->Fields[5].AssociatedElement=4;
    //policyRefSize
    sInf->Fields[6].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[6].ThisElementTypeName = "UINT16";
    sInf->Fields[6].ElementSize = sizeof(UINT16);
    sInf->Fields[6].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[6].ElementName = "policyRefSize";
    sInf->Fields[6].ParentTypeName = "TPM2_PolicySecret_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = FALSE;
    //policyRef
    sInf->Fields[7].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[7].ThisElementTypeName = "BYTE";
    sInf->Fields[7].ElementSize = sizeof(BYTE);
    sInf->Fields[7].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[7].ElementName = "policyRef";
    sInf->Fields[7].ParentTypeName = "TPM2_PolicySecret_REQUEST";
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    sInf->Fields[7].Sort = ElementSort::TpmValueType;
    sInf->Fields[7].IsArray = TRUE;
    sInf->Fields[7].AssociatedElement=6;
    //expiration
    sInf->Fields[8].ThisElementType = TpmTypeId::INT32_ID;
    sInf->Fields[8].ThisElementTypeName = "INT32";
    sInf->Fields[8].ElementSize = sizeof(INT32);
    sInf->Fields[8].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[8].ElementName = "expiration";
    sInf->Fields[8].ParentTypeName = "TPM2_PolicySecret_REQUEST";
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    sInf->Fields[8].Sort = ElementSort::TpmValueType;
    sInf->Fields[8].IsArray = FALSE;
    //===================TPM2_PolicySecret_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::PolicySecretResponse_ID]=sInf;
    sInf->Name = "PolicySecretResponse";
    sInf->MyTypeInfo=typeid(PolicySecretResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //timeoutSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "timeoutSize";
    sInf->Fields[0].ParentTypeName = "PolicySecretResponse";
    sInf->Fields[0].ParentType = TpmTypeId::PolicySecretResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //timeout
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "timeout";
    sInf->Fields[1].ParentTypeName = "PolicySecretResponse";
    sInf->Fields[1].ParentType = TpmTypeId::PolicySecretResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //policyTicket
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMT_TK_AUTH_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMT_TK_AUTH";
    sInf->Fields[2].ElementSize = sizeof(TPMT_TK_AUTH);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "policyTicket";
    sInf->Fields[2].ParentTypeName = "PolicySecretResponse";
    sInf->Fields[2].ParentType = TpmTypeId::PolicySecretResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //===================TPM2_PolicyTicket_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(10);
    TypeMap[TpmTypeId::TPM2_PolicyTicket_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyTicket_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyTicket_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //policySession
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "policySession";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyTicket_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //timeoutSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "timeoutSize";
    sInf->Fields[1].ParentTypeName = "TPM2_PolicyTicket_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //timeout
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "timeout";
    sInf->Fields[2].ParentTypeName = "TPM2_PolicyTicket_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //cpHashASize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "cpHashASize";
    sInf->Fields[3].ParentTypeName = "TPM2_PolicyTicket_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //cpHashA
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "cpHashA";
    sInf->Fields[4].ParentTypeName = "TPM2_PolicyTicket_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //policyRefSize
    sInf->Fields[5].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[5].ThisElementTypeName = "UINT16";
    sInf->Fields[5].ElementSize = sizeof(UINT16);
    sInf->Fields[5].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[5].ElementName = "policyRefSize";
    sInf->Fields[5].ParentTypeName = "TPM2_PolicyTicket_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    //policyRef
    sInf->Fields[6].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[6].ThisElementTypeName = "BYTE";
    sInf->Fields[6].ElementSize = sizeof(BYTE);
    sInf->Fields[6].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[6].ElementName = "policyRef";
    sInf->Fields[6].ParentTypeName = "TPM2_PolicyTicket_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = TRUE;
    sInf->Fields[6].AssociatedElement=5;
    //authNameSize
    sInf->Fields[7].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[7].ThisElementTypeName = "UINT16";
    sInf->Fields[7].ElementSize = sizeof(UINT16);
    sInf->Fields[7].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[7].ElementName = "authNameSize";
    sInf->Fields[7].ParentTypeName = "TPM2_PolicyTicket_REQUEST";
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    sInf->Fields[7].Sort = ElementSort::TpmValueType;
    sInf->Fields[7].IsArray = FALSE;
    //authName
    sInf->Fields[8].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[8].ThisElementTypeName = "BYTE";
    sInf->Fields[8].ElementSize = sizeof(BYTE);
    sInf->Fields[8].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[8].ElementName = "authName";
    sInf->Fields[8].ParentTypeName = "TPM2_PolicyTicket_REQUEST";
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    sInf->Fields[8].Sort = ElementSort::TpmValueType;
    sInf->Fields[8].IsArray = TRUE;
    sInf->Fields[8].AssociatedElement=7;
    //ticket
    sInf->Fields[9].ThisElementType = TpmTypeId::TPMT_TK_AUTH_ID;
    sInf->Fields[9].ThisElementTypeName = "TPMT_TK_AUTH";
    sInf->Fields[9].ElementSize = sizeof(TPMT_TK_AUTH);
    sInf->Fields[9].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[9].ElementName = "ticket";
    sInf->Fields[9].ParentTypeName = "TPM2_PolicyTicket_REQUEST";
    sInf->Fields[9].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    sInf->Fields[9].Sort = ElementSort::TpmStruct;
    sInf->Fields[9].IsArray = FALSE;
    //===================TPM2_PolicyTicket_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PolicyTicketResponse_ID]=sInf;
    sInf->Name = "PolicyTicketResponse";
    sInf->MyTypeInfo=typeid(PolicyTicketResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PolicyOR_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_PolicyOR_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyOR_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyOR_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //policySession
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "policySession";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyOR_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyOR_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //pHashListCount
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT32";
    sInf->Fields[1].ElementSize = sizeof(UINT32);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "pHashListCount";
    sInf->Fields[1].ParentTypeName = "TPM2_PolicyOR_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyOR_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //pHashList
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM2B_DIGEST_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM2B_DIGEST";
    sInf->Fields[2].ElementSize = sizeof(TPM2B_DIGEST);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "pHashList";
    sInf->Fields[2].ParentTypeName = "TPM2_PolicyOR_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyOR_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPM2_PolicyOR_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PolicyORResponse_ID]=sInf;
    sInf->Name = "PolicyORResponse";
    sInf->MyTypeInfo=typeid(PolicyORResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PolicyPCR_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPM2_PolicyPCR_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyPCR_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyPCR_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //policySession
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "policySession";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyPCR_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyPCR_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //pcrDigestSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "pcrDigestSize";
    sInf->Fields[1].ParentTypeName = "TPM2_PolicyPCR_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyPCR_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //pcrDigest
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "pcrDigest";
    sInf->Fields[2].ParentTypeName = "TPM2_PolicyPCR_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyPCR_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //pcrsCount
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT32";
    sInf->Fields[3].ElementSize = sizeof(UINT32);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "pcrsCount";
    sInf->Fields[3].ParentTypeName = "TPM2_PolicyPCR_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PolicyPCR_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //pcrs
    sInf->Fields[4].ThisElementType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[4].ThisElementTypeName = "TPMS_PCR_SELECTION";
    sInf->Fields[4].ElementSize = sizeof(TPMS_PCR_SELECTION);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "pcrs";
    sInf->Fields[4].ParentTypeName = "TPM2_PolicyPCR_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PolicyPCR_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmStruct;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //===================TPM2_PolicyPCR_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PolicyPCRResponse_ID]=sInf;
    sInf->Name = "PolicyPCRResponse";
    sInf->MyTypeInfo=typeid(PolicyPCRResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PolicyLocality_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2_PolicyLocality_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyLocality_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyLocality_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //policySession
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "policySession";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyLocality_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyLocality_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //locality
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMA_LOCALITY_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMA_LOCALITY";
    sInf->Fields[1].ElementSize = sizeof(TPMA_LOCALITY);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "locality";
    sInf->Fields[1].ParentTypeName = "TPM2_PolicyLocality_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyLocality_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmBitfield;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPM2_PolicyLocality_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PolicyLocalityResponse_ID]=sInf;
    sInf->Name = "PolicyLocalityResponse";
    sInf->MyTypeInfo=typeid(PolicyLocalityResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PolicyNV_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(7);
    TypeMap[TpmTypeId::TPM2_PolicyNV_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyNV_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyNV_REQUEST).name();
    sInf->HandleCount = 3;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyNV_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //nvIndex
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "nvIndex";
    sInf->Fields[1].ParentTypeName = "TPM2_PolicyNV_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //policySession
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[2].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "policySession";
    sInf->Fields[2].ParentTypeName = "TPM2_PolicyNV_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //operandBSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "operandBSize";
    sInf->Fields[3].ParentTypeName = "TPM2_PolicyNV_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //operandB
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "operandB";
    sInf->Fields[4].ParentTypeName = "TPM2_PolicyNV_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //offset
    sInf->Fields[5].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[5].ThisElementTypeName = "UINT16";
    sInf->Fields[5].ElementSize = sizeof(UINT16);
    sInf->Fields[5].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[5].ElementName = "offset";
    sInf->Fields[5].ParentTypeName = "TPM2_PolicyNV_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    //operation
    sInf->Fields[6].ThisElementType = TpmTypeId::TPM_EO_ID;
    sInf->Fields[6].ThisElementTypeName = "TPM_EO";
    sInf->Fields[6].ElementSize = sizeof(TPM_EO);
    sInf->Fields[6].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[6].ElementName = "operation";
    sInf->Fields[6].ParentTypeName = "TPM2_PolicyNV_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmEnum;
    sInf->Fields[6].IsArray = FALSE;
    //===================TPM2_PolicyNV_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PolicyNVResponse_ID]=sInf;
    sInf->Name = "PolicyNVResponse";
    sInf->MyTypeInfo=typeid(PolicyNVResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PolicyCounterTimer_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyCounterTimer_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyCounterTimer_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //policySession
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "policySession";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyCounterTimer_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //operandBSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "operandBSize";
    sInf->Fields[1].ParentTypeName = "TPM2_PolicyCounterTimer_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //operandB
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "operandB";
    sInf->Fields[2].ParentTypeName = "TPM2_PolicyCounterTimer_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //offset
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "offset";
    sInf->Fields[3].ParentTypeName = "TPM2_PolicyCounterTimer_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //operation
    sInf->Fields[4].ThisElementType = TpmTypeId::TPM_EO_ID;
    sInf->Fields[4].ThisElementTypeName = "TPM_EO";
    sInf->Fields[4].ElementSize = sizeof(TPM_EO);
    sInf->Fields[4].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[4].ElementName = "operation";
    sInf->Fields[4].ParentTypeName = "TPM2_PolicyCounterTimer_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmEnum;
    sInf->Fields[4].IsArray = FALSE;
    //===================TPM2_PolicyCounterTimer_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PolicyCounterTimerResponse_ID]=sInf;
    sInf->Name = "PolicyCounterTimerResponse";
    sInf->MyTypeInfo=typeid(PolicyCounterTimerResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PolicyCommandCode_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2_PolicyCommandCode_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyCommandCode_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyCommandCode_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //policySession
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "policySession";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyCommandCode_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyCommandCode_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //code
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_CC_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_CC";
    sInf->Fields[1].ElementSize = sizeof(TPM_CC);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "code";
    sInf->Fields[1].ParentTypeName = "TPM2_PolicyCommandCode_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyCommandCode_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmEnum;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPM2_PolicyCommandCode_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PolicyCommandCodeResponse_ID]=sInf;
    sInf->Name = "PolicyCommandCodeResponse";
    sInf->MyTypeInfo=typeid(PolicyCommandCodeResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PolicyPhysicalPresence_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_PolicyPhysicalPresence_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyPhysicalPresence_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyPhysicalPresence_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //policySession
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "policySession";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyPhysicalPresence_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyPhysicalPresence_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_PolicyPhysicalPresence_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PolicyPhysicalPresenceResponse_ID]=sInf;
    sInf->Name = "PolicyPhysicalPresenceResponse";
    sInf->MyTypeInfo=typeid(PolicyPhysicalPresenceResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PolicyCpHash_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_PolicyCpHash_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyCpHash_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyCpHash_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //policySession
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "policySession";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyCpHash_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyCpHash_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //cpHashASize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "cpHashASize";
    sInf->Fields[1].ParentTypeName = "TPM2_PolicyCpHash_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyCpHash_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //cpHashA
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "cpHashA";
    sInf->Fields[2].ParentTypeName = "TPM2_PolicyCpHash_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyCpHash_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPM2_PolicyCpHash_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PolicyCpHashResponse_ID]=sInf;
    sInf->Name = "PolicyCpHashResponse";
    sInf->MyTypeInfo=typeid(PolicyCpHashResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PolicyNameHash_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_PolicyNameHash_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyNameHash_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyNameHash_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //policySession
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "policySession";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyNameHash_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyNameHash_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //nameHashSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "nameHashSize";
    sInf->Fields[1].ParentTypeName = "TPM2_PolicyNameHash_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyNameHash_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //nameHash
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "nameHash";
    sInf->Fields[2].ParentTypeName = "TPM2_PolicyNameHash_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyNameHash_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPM2_PolicyNameHash_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PolicyNameHashResponse_ID]=sInf;
    sInf->Name = "PolicyNameHashResponse";
    sInf->MyTypeInfo=typeid(PolicyNameHashResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PolicyDuplicationSelect_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(6);
    TypeMap[TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyDuplicationSelect_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyDuplicationSelect_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //policySession
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "policySession";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyDuplicationSelect_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //objectNameSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "objectNameSize";
    sInf->Fields[1].ParentTypeName = "TPM2_PolicyDuplicationSelect_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //objectName
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "objectName";
    sInf->Fields[2].ParentTypeName = "TPM2_PolicyDuplicationSelect_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //newParentNameSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "newParentNameSize";
    sInf->Fields[3].ParentTypeName = "TPM2_PolicyDuplicationSelect_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //newParentName
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "newParentName";
    sInf->Fields[4].ParentTypeName = "TPM2_PolicyDuplicationSelect_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //includeObject
    sInf->Fields[5].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[5].ThisElementTypeName = "BYTE";
    sInf->Fields[5].ElementSize = sizeof(BYTE);
    sInf->Fields[5].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[5].ElementName = "includeObject";
    sInf->Fields[5].ParentTypeName = "TPM2_PolicyDuplicationSelect_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    //===================TPM2_PolicyDuplicationSelect_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PolicyDuplicationSelectResponse_ID]=sInf;
    sInf->Name = "PolicyDuplicationSelectResponse";
    sInf->MyTypeInfo=typeid(PolicyDuplicationSelectResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PolicyAuthorize_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(8);
    TypeMap[TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyAuthorize_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyAuthorize_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //policySession
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "policySession";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyAuthorize_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //approvedPolicySize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "approvedPolicySize";
    sInf->Fields[1].ParentTypeName = "TPM2_PolicyAuthorize_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //approvedPolicy
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "approvedPolicy";
    sInf->Fields[2].ParentTypeName = "TPM2_PolicyAuthorize_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //policyRefSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "policyRefSize";
    sInf->Fields[3].ParentTypeName = "TPM2_PolicyAuthorize_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //policyRef
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "policyRef";
    sInf->Fields[4].ParentTypeName = "TPM2_PolicyAuthorize_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //keySignSize
    sInf->Fields[5].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[5].ThisElementTypeName = "UINT16";
    sInf->Fields[5].ElementSize = sizeof(UINT16);
    sInf->Fields[5].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[5].ElementName = "keySignSize";
    sInf->Fields[5].ParentTypeName = "TPM2_PolicyAuthorize_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    //keySign
    sInf->Fields[6].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[6].ThisElementTypeName = "BYTE";
    sInf->Fields[6].ElementSize = sizeof(BYTE);
    sInf->Fields[6].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[6].ElementName = "keySign";
    sInf->Fields[6].ParentTypeName = "TPM2_PolicyAuthorize_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = TRUE;
    sInf->Fields[6].AssociatedElement=5;
    //checkTicket
    sInf->Fields[7].ThisElementType = TpmTypeId::TPMT_TK_VERIFIED_ID;
    sInf->Fields[7].ThisElementTypeName = "TPMT_TK_VERIFIED";
    sInf->Fields[7].ElementSize = sizeof(TPMT_TK_VERIFIED);
    sInf->Fields[7].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[7].ElementName = "checkTicket";
    sInf->Fields[7].ParentTypeName = "TPM2_PolicyAuthorize_REQUEST";
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    sInf->Fields[7].Sort = ElementSort::TpmStruct;
    sInf->Fields[7].IsArray = FALSE;
    //===================TPM2_PolicyAuthorize_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PolicyAuthorizeResponse_ID]=sInf;
    sInf->Name = "PolicyAuthorizeResponse";
    sInf->MyTypeInfo=typeid(PolicyAuthorizeResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PolicyAuthValue_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_PolicyAuthValue_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyAuthValue_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyAuthValue_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //policySession
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "policySession";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyAuthValue_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyAuthValue_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_PolicyAuthValue_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PolicyAuthValueResponse_ID]=sInf;
    sInf->Name = "PolicyAuthValueResponse";
    sInf->MyTypeInfo=typeid(PolicyAuthValueResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PolicyPassword_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_PolicyPassword_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyPassword_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyPassword_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //policySession
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "policySession";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyPassword_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyPassword_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_PolicyPassword_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PolicyPasswordResponse_ID]=sInf;
    sInf->Name = "PolicyPasswordResponse";
    sInf->MyTypeInfo=typeid(PolicyPasswordResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PolicyGetDigest_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_PolicyGetDigest_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyGetDigest_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyGetDigest_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //policySession
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "policySession";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyGetDigest_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyGetDigest_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_PolicyGetDigest_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::PolicyGetDigestResponse_ID]=sInf;
    sInf->Name = "PolicyGetDigestResponse";
    sInf->MyTypeInfo=typeid(PolicyGetDigestResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //policyDigestSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "policyDigestSize";
    sInf->Fields[0].ParentTypeName = "PolicyGetDigestResponse";
    sInf->Fields[0].ParentType = TpmTypeId::PolicyGetDigestResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //policyDigest
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "policyDigest";
    sInf->Fields[1].ParentTypeName = "PolicyGetDigestResponse";
    sInf->Fields[1].ParentType = TpmTypeId::PolicyGetDigestResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_PolicyNvWritten_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2_PolicyNvWritten_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyNvWritten_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyNvWritten_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //policySession
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "policySession";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyNvWritten_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyNvWritten_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //writtenSet
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "writtenSet";
    sInf->Fields[1].ParentTypeName = "TPM2_PolicyNvWritten_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyNvWritten_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPM2_PolicyNvWritten_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PolicyNvWrittenResponse_ID]=sInf;
    sInf->Name = "PolicyNvWrittenResponse";
    sInf->MyTypeInfo=typeid(PolicyNvWrittenResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PolicyTemplate_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_PolicyTemplate_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyTemplate_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyTemplate_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //policySession
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "policySession";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyTemplate_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyTemplate_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //templateHashSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "templateHashSize";
    sInf->Fields[1].ParentTypeName = "TPM2_PolicyTemplate_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyTemplate_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //templateHash
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "templateHash";
    sInf->Fields[2].ParentTypeName = "TPM2_PolicyTemplate_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyTemplate_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPM2_PolicyTemplate_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PolicyTemplateResponse_ID]=sInf;
    sInf->Name = "PolicyTemplateResponse";
    sInf->MyTypeInfo=typeid(PolicyTemplateResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PolicyAuthorizeNV_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_PolicyAuthorizeNV_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PolicyAuthorizeNV_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PolicyAuthorizeNV_REQUEST).name();
    sInf->HandleCount = 3;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_PolicyAuthorizeNV_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyAuthorizeNV_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //nvIndex
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "nvIndex";
    sInf->Fields[1].ParentTypeName = "TPM2_PolicyAuthorizeNV_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyAuthorizeNV_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //policySession
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[2].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "policySession";
    sInf->Fields[2].ParentTypeName = "TPM2_PolicyAuthorizeNV_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyAuthorizeNV_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //===================TPM2_PolicyAuthorizeNV_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PolicyAuthorizeNVResponse_ID]=sInf;
    sInf->Name = "PolicyAuthorizeNVResponse";
    sInf->MyTypeInfo=typeid(PolicyAuthorizeNVResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_CreatePrimary_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(9);
    TypeMap[TpmTypeId::TPM2_CreatePrimary_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_CreatePrimary_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_CreatePrimary_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //primaryHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "primaryHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_CreatePrimary_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //inSensitiveSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[1].ElementName = "inSensitiveSize";
    sInf->Fields[1].ParentTypeName = "TPM2_CreatePrimary_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //inSensitive
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMS_SENSITIVE_CREATE";
    sInf->Fields[2].ElementSize = sizeof(TPMS_SENSITIVE_CREATE);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "inSensitive";
    sInf->Fields[2].ParentTypeName = "TPM2_CreatePrimary_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //inPublicSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[3].ElementName = "inPublicSize";
    sInf->Fields[3].ParentTypeName = "TPM2_CreatePrimary_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //inPublic
    sInf->Fields[4].ThisElementType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[4].ThisElementTypeName = "TPMT_PUBLIC";
    sInf->Fields[4].ElementSize = sizeof(TPMT_PUBLIC);
    sInf->Fields[4].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[4].ElementName = "inPublic";
    sInf->Fields[4].ParentTypeName = "TPM2_CreatePrimary_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmStruct;
    sInf->Fields[4].IsArray = FALSE;
    //outsideInfoSize
    sInf->Fields[5].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[5].ThisElementTypeName = "UINT16";
    sInf->Fields[5].ElementSize = sizeof(UINT16);
    sInf->Fields[5].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[5].ElementName = "outsideInfoSize";
    sInf->Fields[5].ParentTypeName = "TPM2_CreatePrimary_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    //outsideInfo
    sInf->Fields[6].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[6].ThisElementTypeName = "BYTE";
    sInf->Fields[6].ElementSize = sizeof(BYTE);
    sInf->Fields[6].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[6].ElementName = "outsideInfo";
    sInf->Fields[6].ParentTypeName = "TPM2_CreatePrimary_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = TRUE;
    sInf->Fields[6].AssociatedElement=5;
    //creationPCRCount
    sInf->Fields[7].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[7].ThisElementTypeName = "UINT32";
    sInf->Fields[7].ElementSize = sizeof(UINT32);
    sInf->Fields[7].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[7].ElementName = "creationPCRCount";
    sInf->Fields[7].ParentTypeName = "TPM2_CreatePrimary_REQUEST";
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    sInf->Fields[7].Sort = ElementSort::TpmValueType;
    sInf->Fields[7].IsArray = FALSE;
    //creationPCR
    sInf->Fields[8].ThisElementType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[8].ThisElementTypeName = "TPMS_PCR_SELECTION";
    sInf->Fields[8].ElementSize = sizeof(TPMS_PCR_SELECTION);
    sInf->Fields[8].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[8].ElementName = "creationPCR";
    sInf->Fields[8].ParentTypeName = "TPM2_CreatePrimary_REQUEST";
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    sInf->Fields[8].Sort = ElementSort::TpmStruct;
    sInf->Fields[8].IsArray = TRUE;
    sInf->Fields[8].AssociatedElement=7;
    //===================TPM2_CreatePrimary_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(10);
    TypeMap[TpmTypeId::CreatePrimaryResponse_ID]=sInf;
    sInf->Name = "CreatePrimaryResponse";
    sInf->MyTypeInfo=typeid(CreatePrimaryResponse).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //handle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "handle";
    sInf->Fields[0].ParentTypeName = "CreatePrimaryResponse";
    sInf->Fields[0].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //outPublicSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[1].ElementName = "outPublicSize";
    sInf->Fields[1].ParentTypeName = "CreatePrimaryResponse";
    sInf->Fields[1].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //outPublic
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMT_PUBLIC";
    sInf->Fields[2].ElementSize = sizeof(TPMT_PUBLIC);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "outPublic";
    sInf->Fields[2].ParentTypeName = "CreatePrimaryResponse";
    sInf->Fields[2].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //creationDataSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[3].ElementName = "creationDataSize";
    sInf->Fields[3].ParentTypeName = "CreatePrimaryResponse";
    sInf->Fields[3].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //creationData
    sInf->Fields[4].ThisElementType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[4].ThisElementTypeName = "TPMS_CREATION_DATA";
    sInf->Fields[4].ElementSize = sizeof(TPMS_CREATION_DATA);
    sInf->Fields[4].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[4].ElementName = "creationData";
    sInf->Fields[4].ParentTypeName = "CreatePrimaryResponse";
    sInf->Fields[4].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    sInf->Fields[4].Sort = ElementSort::TpmStruct;
    sInf->Fields[4].IsArray = FALSE;
    //creationHashSize
    sInf->Fields[5].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[5].ThisElementTypeName = "UINT16";
    sInf->Fields[5].ElementSize = sizeof(UINT16);
    sInf->Fields[5].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[5].ElementName = "creationHashSize";
    sInf->Fields[5].ParentTypeName = "CreatePrimaryResponse";
    sInf->Fields[5].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    //creationHash
    sInf->Fields[6].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[6].ThisElementTypeName = "BYTE";
    sInf->Fields[6].ElementSize = sizeof(BYTE);
    sInf->Fields[6].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[6].ElementName = "creationHash";
    sInf->Fields[6].ParentTypeName = "CreatePrimaryResponse";
    sInf->Fields[6].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = TRUE;
    sInf->Fields[6].AssociatedElement=5;
    //creationTicket
    sInf->Fields[7].ThisElementType = TpmTypeId::TPMT_TK_CREATION_ID;
    sInf->Fields[7].ThisElementTypeName = "TPMT_TK_CREATION";
    sInf->Fields[7].ElementSize = sizeof(TPMT_TK_CREATION);
    sInf->Fields[7].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[7].ElementName = "creationTicket";
    sInf->Fields[7].ParentTypeName = "CreatePrimaryResponse";
    sInf->Fields[7].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    sInf->Fields[7].Sort = ElementSort::TpmStruct;
    sInf->Fields[7].IsArray = FALSE;
    //nameSize
    sInf->Fields[8].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[8].ThisElementTypeName = "UINT16";
    sInf->Fields[8].ElementSize = sizeof(UINT16);
    sInf->Fields[8].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[8].ElementName = "nameSize";
    sInf->Fields[8].ParentTypeName = "CreatePrimaryResponse";
    sInf->Fields[8].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    sInf->Fields[8].Sort = ElementSort::TpmValueType;
    sInf->Fields[8].IsArray = FALSE;
    //name
    sInf->Fields[9].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[9].ThisElementTypeName = "BYTE";
    sInf->Fields[9].ElementSize = sizeof(BYTE);
    sInf->Fields[9].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[9].ElementName = "name";
    sInf->Fields[9].ParentTypeName = "CreatePrimaryResponse";
    sInf->Fields[9].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    sInf->Fields[9].Sort = ElementSort::TpmValueType;
    sInf->Fields[9].IsArray = TRUE;
    sInf->Fields[9].AssociatedElement=8;
    //===================TPM2_HierarchyControl_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_HierarchyControl_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_HierarchyControl_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_HierarchyControl_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_HierarchyControl_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_HierarchyControl_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //enable
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "enable";
    sInf->Fields[1].ParentTypeName = "TPM2_HierarchyControl_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_HierarchyControl_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //state
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "state";
    sInf->Fields[2].ParentTypeName = "TPM2_HierarchyControl_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_HierarchyControl_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //===================TPM2_HierarchyControl_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::HierarchyControlResponse_ID]=sInf;
    sInf->Name = "HierarchyControlResponse";
    sInf->MyTypeInfo=typeid(HierarchyControlResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_SetPrimaryPolicy_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_SetPrimaryPolicy_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_SetPrimaryPolicy_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_SetPrimaryPolicy_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //authPolicySize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "authPolicySize";
    sInf->Fields[1].ParentTypeName = "TPM2_SetPrimaryPolicy_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //authPolicy
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "authPolicy";
    sInf->Fields[2].ParentTypeName = "TPM2_SetPrimaryPolicy_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //hashAlg
    sInf->Fields[3].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[3].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "hashAlg";
    sInf->Fields[3].ParentTypeName = "TPM2_SetPrimaryPolicy_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //===================TPM2_SetPrimaryPolicy_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::SetPrimaryPolicyResponse_ID]=sInf;
    sInf->Name = "SetPrimaryPolicyResponse";
    sInf->MyTypeInfo=typeid(SetPrimaryPolicyResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_ChangePPS_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_ChangePPS_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_ChangePPS_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_ChangePPS_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_ChangePPS_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ChangePPS_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_ChangePPS_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::ChangePPSResponse_ID]=sInf;
    sInf->Name = "ChangePPSResponse";
    sInf->MyTypeInfo=typeid(ChangePPSResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_ChangeEPS_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_ChangeEPS_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_ChangeEPS_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_ChangeEPS_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_ChangeEPS_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ChangeEPS_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_ChangeEPS_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::ChangeEPSResponse_ID]=sInf;
    sInf->Name = "ChangeEPSResponse";
    sInf->MyTypeInfo=typeid(ChangeEPSResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_Clear_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_Clear_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_Clear_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_Clear_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_Clear_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Clear_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_Clear_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::ClearResponse_ID]=sInf;
    sInf->Name = "ClearResponse";
    sInf->MyTypeInfo=typeid(ClearResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_ClearControl_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2_ClearControl_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_ClearControl_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_ClearControl_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //auth
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "auth";
    sInf->Fields[0].ParentTypeName = "TPM2_ClearControl_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ClearControl_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //disable
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "disable";
    sInf->Fields[1].ParentTypeName = "TPM2_ClearControl_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_ClearControl_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPM2_ClearControl_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::ClearControlResponse_ID]=sInf;
    sInf->Name = "ClearControlResponse";
    sInf->MyTypeInfo=typeid(ClearControlResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_HierarchyChangeAuth_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_HierarchyChangeAuth_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_HierarchyChangeAuth_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_HierarchyChangeAuth_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_HierarchyChangeAuth_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_HierarchyChangeAuth_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //newAuthSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "newAuthSize";
    sInf->Fields[1].ParentTypeName = "TPM2_HierarchyChangeAuth_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_HierarchyChangeAuth_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //newAuth
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "newAuth";
    sInf->Fields[2].ParentTypeName = "TPM2_HierarchyChangeAuth_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_HierarchyChangeAuth_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPM2_HierarchyChangeAuth_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::HierarchyChangeAuthResponse_ID]=sInf;
    sInf->Name = "HierarchyChangeAuthResponse";
    sInf->MyTypeInfo=typeid(HierarchyChangeAuthResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_DictionaryAttackLockReset_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_DictionaryAttackLockReset_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_DictionaryAttackLockReset_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_DictionaryAttackLockReset_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //lockHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "lockHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_DictionaryAttackLockReset_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_DictionaryAttackLockReset_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_DictionaryAttackLockReset_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::DictionaryAttackLockResetResponse_ID]=sInf;
    sInf->Name = "DictionaryAttackLockResetResponse";
    sInf->MyTypeInfo=typeid(DictionaryAttackLockResetResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_DictionaryAttackParameters_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_DictionaryAttackParameters_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_DictionaryAttackParameters_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //lockHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "lockHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_DictionaryAttackParameters_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //newMaxTries
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT32";
    sInf->Fields[1].ElementSize = sizeof(UINT32);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "newMaxTries";
    sInf->Fields[1].ParentTypeName = "TPM2_DictionaryAttackParameters_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //newRecoveryTime
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT32";
    sInf->Fields[2].ElementSize = sizeof(UINT32);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "newRecoveryTime";
    sInf->Fields[2].ParentTypeName = "TPM2_DictionaryAttackParameters_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //lockoutRecovery
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT32";
    sInf->Fields[3].ElementSize = sizeof(UINT32);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "lockoutRecovery";
    sInf->Fields[3].ParentTypeName = "TPM2_DictionaryAttackParameters_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //===================TPM2_DictionaryAttackParameters_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::DictionaryAttackParametersResponse_ID]=sInf;
    sInf->Name = "DictionaryAttackParametersResponse";
    sInf->MyTypeInfo=typeid(DictionaryAttackParametersResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_PP_Commands_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPM2_PP_Commands_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_PP_Commands_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_PP_Commands_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //auth
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "auth";
    sInf->Fields[0].ParentTypeName = "TPM2_PP_Commands_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PP_Commands_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //setListCount
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT32";
    sInf->Fields[1].ElementSize = sizeof(UINT32);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "setListCount";
    sInf->Fields[1].ParentTypeName = "TPM2_PP_Commands_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PP_Commands_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //setList
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_CC_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_CC";
    sInf->Fields[2].ElementSize = sizeof(TPM_CC);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "setList";
    sInf->Fields[2].ParentTypeName = "TPM2_PP_Commands_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PP_Commands_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmEnum;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //clearListCount
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT32";
    sInf->Fields[3].ElementSize = sizeof(UINT32);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "clearListCount";
    sInf->Fields[3].ParentTypeName = "TPM2_PP_Commands_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PP_Commands_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //clearList
    sInf->Fields[4].ThisElementType = TpmTypeId::TPM_CC_ID;
    sInf->Fields[4].ThisElementTypeName = "TPM_CC";
    sInf->Fields[4].ElementSize = sizeof(TPM_CC);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "clearList";
    sInf->Fields[4].ParentTypeName = "TPM2_PP_Commands_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PP_Commands_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmEnum;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //===================TPM2_PP_Commands_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::PP_CommandsResponse_ID]=sInf;
    sInf->Name = "PP_CommandsResponse";
    sInf->MyTypeInfo=typeid(PP_CommandsResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_SetAlgorithmSet_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2_SetAlgorithmSet_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_SetAlgorithmSet_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_SetAlgorithmSet_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_SetAlgorithmSet_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_SetAlgorithmSet_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //algorithmSet
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT32";
    sInf->Fields[1].ElementSize = sizeof(UINT32);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "algorithmSet";
    sInf->Fields[1].ParentTypeName = "TPM2_SetAlgorithmSet_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_SetAlgorithmSet_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPM2_SetAlgorithmSet_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::SetAlgorithmSetResponse_ID]=sInf;
    sInf->Name = "SetAlgorithmSetResponse";
    sInf->MyTypeInfo=typeid(SetAlgorithmSetResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_FieldUpgradeStart_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(6);
    TypeMap[TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_FieldUpgradeStart_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_FieldUpgradeStart_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    //authorization
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authorization";
    sInf->Fields[0].ParentTypeName = "TPM2_FieldUpgradeStart_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //keyHandle
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "keyHandle";
    sInf->Fields[1].ParentTypeName = "TPM2_FieldUpgradeStart_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //fuDigestSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "fuDigestSize";
    sInf->Fields[2].ParentTypeName = "TPM2_FieldUpgradeStart_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //fuDigest
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "fuDigest";
    sInf->Fields[3].ParentTypeName = "TPM2_FieldUpgradeStart_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //manifestSignatureSigAlg
    sInf->Fields[4].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[4].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[4].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[4].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[4].ElementName = "manifestSignatureSigAlg";
    sInf->Fields[4].ParentTypeName = "TPM2_FieldUpgradeStart_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    sInf->Fields[4].AssociatedElement=5;
    //manifestSignature
    sInf->Fields[5].ThisElementType = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[5].ThisElementTypeName = "TPMU_SIGNATURE";
    sInf->Fields[5].ElementSize = sizeof(TPMU_SIGNATURE);
    sInf->Fields[5].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[5].ElementName = "manifestSignature";
    sInf->Fields[5].ParentTypeName = "TPM2_FieldUpgradeStart_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmUnion;
    sInf->Fields[5].IsArray = FALSE;
    sInf->Fields[5].AssociatedElement=4;
    //===================TPM2_FieldUpgradeStart_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::FieldUpgradeStartResponse_ID]=sInf;
    sInf->Name = "FieldUpgradeStartResponse";
    sInf->MyTypeInfo=typeid(FieldUpgradeStartResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_FieldUpgradeData_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2_FieldUpgradeData_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_FieldUpgradeData_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_FieldUpgradeData_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //fuDataSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "fuDataSize";
    sInf->Fields[0].ParentTypeName = "TPM2_FieldUpgradeData_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_FieldUpgradeData_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //fuData
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "fuData";
    sInf->Fields[1].ParentTypeName = "TPM2_FieldUpgradeData_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_FieldUpgradeData_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_FieldUpgradeData_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::FieldUpgradeDataResponse_ID]=sInf;
    sInf->Name = "FieldUpgradeDataResponse";
    sInf->MyTypeInfo=typeid(FieldUpgradeDataResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //nextDigest
    sInf->Fields[0].ThisElementType = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[0].ThisElementTypeName = "TPMT_HA";
    sInf->Fields[0].ElementSize = sizeof(TPMT_HA);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "nextDigest";
    sInf->Fields[0].ParentTypeName = "FieldUpgradeDataResponse";
    sInf->Fields[0].ParentType = TpmTypeId::FieldUpgradeDataResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //firstDigest
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMT_HA";
    sInf->Fields[1].ElementSize = sizeof(TPMT_HA);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "firstDigest";
    sInf->Fields[1].ParentTypeName = "FieldUpgradeDataResponse";
    sInf->Fields[1].ParentType = TpmTypeId::FieldUpgradeDataResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPM2_FirmwareRead_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_FirmwareRead_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_FirmwareRead_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_FirmwareRead_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //sequenceNumber
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "sequenceNumber";
    sInf->Fields[0].ParentTypeName = "TPM2_FirmwareRead_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_FirmwareRead_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_FirmwareRead_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::FirmwareReadResponse_ID]=sInf;
    sInf->Name = "FirmwareReadResponse";
    sInf->MyTypeInfo=typeid(FirmwareReadResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //fuDataSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "fuDataSize";
    sInf->Fields[0].ParentTypeName = "FirmwareReadResponse";
    sInf->Fields[0].ParentType = TpmTypeId::FirmwareReadResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //fuData
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "fuData";
    sInf->Fields[1].ParentTypeName = "FirmwareReadResponse";
    sInf->Fields[1].ParentType = TpmTypeId::FirmwareReadResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_ContextSave_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_ContextSave_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_ContextSave_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_ContextSave_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //saveHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "saveHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_ContextSave_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ContextSave_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_ContextSave_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::ContextSaveResponse_ID]=sInf;
    sInf->Name = "ContextSaveResponse";
    sInf->MyTypeInfo=typeid(ContextSaveResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //context
    sInf->Fields[0].ThisElementType = TpmTypeId::TPMS_CONTEXT_ID;
    sInf->Fields[0].ThisElementTypeName = "TPMS_CONTEXT";
    sInf->Fields[0].ElementSize = sizeof(TPMS_CONTEXT);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "context";
    sInf->Fields[0].ParentTypeName = "ContextSaveResponse";
    sInf->Fields[0].ParentType = TpmTypeId::ContextSaveResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_ContextLoad_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_ContextLoad_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_ContextLoad_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_ContextLoad_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //context
    sInf->Fields[0].ThisElementType = TpmTypeId::TPMS_CONTEXT_ID;
    sInf->Fields[0].ThisElementTypeName = "TPMS_CONTEXT";
    sInf->Fields[0].ElementSize = sizeof(TPMS_CONTEXT);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "context";
    sInf->Fields[0].ParentTypeName = "TPM2_ContextLoad_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ContextLoad_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_ContextLoad_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::ContextLoadResponse_ID]=sInf;
    sInf->Name = "ContextLoadResponse";
    sInf->MyTypeInfo=typeid(ContextLoadResponse).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //handle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "handle";
    sInf->Fields[0].ParentTypeName = "ContextLoadResponse";
    sInf->Fields[0].ParentType = TpmTypeId::ContextLoadResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_FlushContext_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_FlushContext_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_FlushContext_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_FlushContext_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //flushHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "flushHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_FlushContext_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_FlushContext_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_FlushContext_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::FlushContextResponse_ID]=sInf;
    sInf->Name = "FlushContextResponse";
    sInf->MyTypeInfo=typeid(FlushContextResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_EvictControl_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_EvictControl_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_EvictControl_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_EvictControl_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    //auth
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "auth";
    sInf->Fields[0].ParentTypeName = "TPM2_EvictControl_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_EvictControl_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //objectHandle
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "objectHandle";
    sInf->Fields[1].ParentTypeName = "TPM2_EvictControl_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_EvictControl_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //persistentHandle
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[2].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "persistentHandle";
    sInf->Fields[2].ParentTypeName = "TPM2_EvictControl_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_EvictControl_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //===================TPM2_EvictControl_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::EvictControlResponse_ID]=sInf;
    sInf->Name = "EvictControlResponse";
    sInf->MyTypeInfo=typeid(EvictControlResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_ReadClock_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TPM2_ReadClock_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_ReadClock_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_ReadClock_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_ReadClock_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::ReadClockResponse_ID]=sInf;
    sInf->Name = "ReadClockResponse";
    sInf->MyTypeInfo=typeid(ReadClockResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //currentTime
    sInf->Fields[0].ThisElementType = TpmTypeId::TPMS_TIME_INFO_ID;
    sInf->Fields[0].ThisElementTypeName = "TPMS_TIME_INFO";
    sInf->Fields[0].ElementSize = sizeof(TPMS_TIME_INFO);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "currentTime";
    sInf->Fields[0].ParentTypeName = "ReadClockResponse";
    sInf->Fields[0].ParentType = TpmTypeId::ReadClockResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_ClockSet_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2_ClockSet_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_ClockSet_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_ClockSet_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //auth
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "auth";
    sInf->Fields[0].ParentTypeName = "TPM2_ClockSet_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ClockSet_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //newTime
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT64_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT64";
    sInf->Fields[1].ElementSize = sizeof(UINT64);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "newTime";
    sInf->Fields[1].ParentTypeName = "TPM2_ClockSet_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_ClockSet_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPM2_ClockSet_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::ClockSetResponse_ID]=sInf;
    sInf->Name = "ClockSetResponse";
    sInf->MyTypeInfo=typeid(ClockSetResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_ClockRateAdjust_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2_ClockRateAdjust_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_ClockRateAdjust_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_ClockRateAdjust_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //auth
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "auth";
    sInf->Fields[0].ParentTypeName = "TPM2_ClockRateAdjust_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ClockRateAdjust_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //rateAdjust
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_CLOCK_ADJUST_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_CLOCK_ADJUST";
    sInf->Fields[1].ElementSize = sizeof(TPM_CLOCK_ADJUST);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "rateAdjust";
    sInf->Fields[1].ParentTypeName = "TPM2_ClockRateAdjust_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_ClockRateAdjust_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmEnum;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPM2_ClockRateAdjust_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::ClockRateAdjustResponse_ID]=sInf;
    sInf->Name = "ClockRateAdjustResponse";
    sInf->MyTypeInfo=typeid(ClockRateAdjustResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_GetCapability_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_GetCapability_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_GetCapability_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_GetCapability_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //capability
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_CAP_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_CAP";
    sInf->Fields[0].ElementSize = sizeof(TPM_CAP);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "capability";
    sInf->Fields[0].ParentTypeName = "TPM2_GetCapability_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_GetCapability_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    //property
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT32";
    sInf->Fields[1].ElementSize = sizeof(UINT32);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "property";
    sInf->Fields[1].ParentTypeName = "TPM2_GetCapability_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_GetCapability_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //propertyCount
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT32";
    sInf->Fields[2].ElementSize = sizeof(UINT32);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "propertyCount";
    sInf->Fields[2].ParentTypeName = "TPM2_GetCapability_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_GetCapability_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //===================TPM2_GetCapability_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::GetCapabilityResponse_ID]=sInf;
    sInf->Name = "GetCapabilityResponse";
    sInf->MyTypeInfo=typeid(GetCapabilityResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //moreData
    sInf->Fields[0].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[0].ThisElementTypeName = "BYTE";
    sInf->Fields[0].ElementSize = sizeof(BYTE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "moreData";
    sInf->Fields[0].ParentTypeName = "GetCapabilityResponse";
    sInf->Fields[0].ParentType = TpmTypeId::GetCapabilityResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //capabilityDataCapability
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_CAP_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_CAP";
    sInf->Fields[1].ElementSize = sizeof(TPM_CAP);
    sInf->Fields[1].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[1].ElementName = "capabilityDataCapability";
    sInf->Fields[1].ParentTypeName = "GetCapabilityResponse";
    sInf->Fields[1].ParentType = TpmTypeId::GetCapabilityResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmEnum;
    sInf->Fields[1].IsArray = FALSE;
    sInf->Fields[1].AssociatedElement=2;
    //capabilityData
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMU_CAPABILITIES_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMU_CAPABILITIES";
    sInf->Fields[2].ElementSize = sizeof(TPMU_CAPABILITIES);
    sInf->Fields[2].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[2].ElementName = "capabilityData";
    sInf->Fields[2].ParentTypeName = "GetCapabilityResponse";
    sInf->Fields[2].ParentType = TpmTypeId::GetCapabilityResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmUnion;
    sInf->Fields[2].IsArray = FALSE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPM2_TestParms_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2_TestParms_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_TestParms_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_TestParms_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //parametersType
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[0].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[0].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[0].ElementName = "parametersType";
    sInf->Fields[0].ParentTypeName = "TPM2_TestParms_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_TestParms_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    sInf->Fields[0].AssociatedElement=1;
    //parameters
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMU_PUBLIC_PARMS_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMU_PUBLIC_PARMS";
    sInf->Fields[1].ElementSize = sizeof(TPMU_PUBLIC_PARMS);
    sInf->Fields[1].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[1].ElementName = "parameters";
    sInf->Fields[1].ParentTypeName = "TPM2_TestParms_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_TestParms_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmUnion;
    sInf->Fields[1].IsArray = FALSE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_TestParms_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::TestParmsResponse_ID]=sInf;
    sInf->Name = "TestParmsResponse";
    sInf->MyTypeInfo=typeid(TestParmsResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_NV_DefineSpace_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_NV_DefineSpace_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_NV_DefineSpace_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_NV_DefineSpace_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //authSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "authSize";
    sInf->Fields[1].ParentTypeName = "TPM2_NV_DefineSpace_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //auth
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "auth";
    sInf->Fields[2].ParentTypeName = "TPM2_NV_DefineSpace_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //publicInfoSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[3].ElementName = "publicInfoSize";
    sInf->Fields[3].ParentTypeName = "TPM2_NV_DefineSpace_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //publicInfo
    sInf->Fields[4].ThisElementType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    sInf->Fields[4].ThisElementTypeName = "TPMS_NV_PUBLIC";
    sInf->Fields[4].ElementSize = sizeof(TPMS_NV_PUBLIC);
    sInf->Fields[4].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[4].ElementName = "publicInfo";
    sInf->Fields[4].ParentTypeName = "TPM2_NV_DefineSpace_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmStruct;
    sInf->Fields[4].IsArray = FALSE;
    //===================TPM2_NV_DefineSpace_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::NV_DefineSpaceResponse_ID]=sInf;
    sInf->Name = "NV_DefineSpaceResponse";
    sInf->MyTypeInfo=typeid(NV_DefineSpaceResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_NV_UndefineSpace_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2_NV_UndefineSpace_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_NV_UndefineSpace_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_NV_UndefineSpace_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_NV_UndefineSpace_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_UndefineSpace_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //nvIndex
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "nvIndex";
    sInf->Fields[1].ParentTypeName = "TPM2_NV_UndefineSpace_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_UndefineSpace_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPM2_NV_UndefineSpace_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::NV_UndefineSpaceResponse_ID]=sInf;
    sInf->Name = "NV_UndefineSpaceResponse";
    sInf->MyTypeInfo=typeid(NV_UndefineSpaceResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_NV_UndefineSpaceSpecial_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2_NV_UndefineSpaceSpecial_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_NV_UndefineSpaceSpecial_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_NV_UndefineSpaceSpecial_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 2;
    //nvIndex
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "nvIndex";
    sInf->Fields[0].ParentTypeName = "TPM2_NV_UndefineSpaceSpecial_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_UndefineSpaceSpecial_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //platform
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "platform";
    sInf->Fields[1].ParentTypeName = "TPM2_NV_UndefineSpaceSpecial_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_UndefineSpaceSpecial_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPM2_NV_UndefineSpaceSpecial_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::NV_UndefineSpaceSpecialResponse_ID]=sInf;
    sInf->Name = "NV_UndefineSpaceSpecialResponse";
    sInf->MyTypeInfo=typeid(NV_UndefineSpaceSpecialResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_NV_ReadPublic_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_NV_ReadPublic_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_NV_ReadPublic_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_NV_ReadPublic_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //nvIndex
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "nvIndex";
    sInf->Fields[0].ParentTypeName = "TPM2_NV_ReadPublic_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_ReadPublic_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_NV_ReadPublic_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::NV_ReadPublicResponse_ID]=sInf;
    sInf->Name = "NV_ReadPublicResponse";
    sInf->MyTypeInfo=typeid(NV_ReadPublicResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //nvPublicSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "nvPublicSize";
    sInf->Fields[0].ParentTypeName = "NV_ReadPublicResponse";
    sInf->Fields[0].ParentType = TpmTypeId::NV_ReadPublicResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //nvPublic
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_NV_PUBLIC";
    sInf->Fields[1].ElementSize = sizeof(TPMS_NV_PUBLIC);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "nvPublic";
    sInf->Fields[1].ParentTypeName = "NV_ReadPublicResponse";
    sInf->Fields[1].ParentType = TpmTypeId::NV_ReadPublicResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //nvNameSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "nvNameSize";
    sInf->Fields[2].ParentTypeName = "NV_ReadPublicResponse";
    sInf->Fields[2].ParentType = TpmTypeId::NV_ReadPublicResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //nvName
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "nvName";
    sInf->Fields[3].ParentTypeName = "NV_ReadPublicResponse";
    sInf->Fields[3].ParentType = TpmTypeId::NV_ReadPublicResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPM2_NV_Write_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPM2_NV_Write_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_NV_Write_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_NV_Write_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_NV_Write_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_Write_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //nvIndex
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "nvIndex";
    sInf->Fields[1].ParentTypeName = "TPM2_NV_Write_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_Write_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //dataSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "dataSize";
    sInf->Fields[2].ParentTypeName = "TPM2_NV_Write_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_NV_Write_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //data
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "data";
    sInf->Fields[3].ParentTypeName = "TPM2_NV_Write_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_NV_Write_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //offset
    sInf->Fields[4].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[4].ThisElementTypeName = "UINT16";
    sInf->Fields[4].ElementSize = sizeof(UINT16);
    sInf->Fields[4].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[4].ElementName = "offset";
    sInf->Fields[4].ParentTypeName = "TPM2_NV_Write_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_NV_Write_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    //===================TPM2_NV_Write_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::NV_WriteResponse_ID]=sInf;
    sInf->Name = "NV_WriteResponse";
    sInf->MyTypeInfo=typeid(NV_WriteResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_NV_Increment_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2_NV_Increment_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_NV_Increment_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_NV_Increment_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_NV_Increment_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_Increment_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //nvIndex
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "nvIndex";
    sInf->Fields[1].ParentTypeName = "TPM2_NV_Increment_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_Increment_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPM2_NV_Increment_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::NV_IncrementResponse_ID]=sInf;
    sInf->Name = "NV_IncrementResponse";
    sInf->MyTypeInfo=typeid(NV_IncrementResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_NV_Extend_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPM2_NV_Extend_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_NV_Extend_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_NV_Extend_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_NV_Extend_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_Extend_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //nvIndex
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "nvIndex";
    sInf->Fields[1].ParentTypeName = "TPM2_NV_Extend_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_Extend_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //dataSize
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[2].ElementName = "dataSize";
    sInf->Fields[2].ParentTypeName = "TPM2_NV_Extend_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_NV_Extend_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //data
    sInf->Fields[3].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[3].ThisElementTypeName = "BYTE";
    sInf->Fields[3].ElementSize = sizeof(BYTE);
    sInf->Fields[3].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[3].ElementName = "data";
    sInf->Fields[3].ParentTypeName = "TPM2_NV_Extend_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_NV_Extend_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = TRUE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPM2_NV_Extend_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::NV_ExtendResponse_ID]=sInf;
    sInf->Name = "NV_ExtendResponse";
    sInf->MyTypeInfo=typeid(NV_ExtendResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_NV_SetBits_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_NV_SetBits_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_NV_SetBits_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_NV_SetBits_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_NV_SetBits_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_SetBits_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //nvIndex
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "nvIndex";
    sInf->Fields[1].ParentTypeName = "TPM2_NV_SetBits_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_SetBits_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //bits
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT64_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT64";
    sInf->Fields[2].ElementSize = sizeof(UINT64);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "bits";
    sInf->Fields[2].ParentTypeName = "TPM2_NV_SetBits_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_NV_SetBits_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //===================TPM2_NV_SetBits_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::NV_SetBitsResponse_ID]=sInf;
    sInf->Name = "NV_SetBitsResponse";
    sInf->MyTypeInfo=typeid(NV_SetBitsResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_NV_WriteLock_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2_NV_WriteLock_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_NV_WriteLock_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_NV_WriteLock_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_NV_WriteLock_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_WriteLock_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //nvIndex
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "nvIndex";
    sInf->Fields[1].ParentTypeName = "TPM2_NV_WriteLock_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_WriteLock_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPM2_NV_WriteLock_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::NV_WriteLockResponse_ID]=sInf;
    sInf->Name = "NV_WriteLockResponse";
    sInf->MyTypeInfo=typeid(NV_WriteLockResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_NV_GlobalWriteLock_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::TPM2_NV_GlobalWriteLock_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_NV_GlobalWriteLock_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_NV_GlobalWriteLock_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_NV_GlobalWriteLock_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_GlobalWriteLock_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_NV_GlobalWriteLock_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::NV_GlobalWriteLockResponse_ID]=sInf;
    sInf->Name = "NV_GlobalWriteLockResponse";
    sInf->MyTypeInfo=typeid(NV_GlobalWriteLockResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_NV_Read_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::TPM2_NV_Read_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_NV_Read_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_NV_Read_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_NV_Read_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_Read_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //nvIndex
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "nvIndex";
    sInf->Fields[1].ParentTypeName = "TPM2_NV_Read_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_Read_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //size
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT16";
    sInf->Fields[2].ElementSize = sizeof(UINT16);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "size";
    sInf->Fields[2].ParentTypeName = "TPM2_NV_Read_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_NV_Read_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //offset
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "offset";
    sInf->Fields[3].ParentTypeName = "TPM2_NV_Read_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_NV_Read_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //===================TPM2_NV_Read_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::NV_ReadResponse_ID]=sInf;
    sInf->Name = "NV_ReadResponse";
    sInf->MyTypeInfo=typeid(NV_ReadResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //dataSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "dataSize";
    sInf->Fields[0].ParentTypeName = "NV_ReadResponse";
    sInf->Fields[0].ParentType = TpmTypeId::NV_ReadResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //data
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "data";
    sInf->Fields[1].ParentTypeName = "NV_ReadResponse";
    sInf->Fields[1].ParentType = TpmTypeId::NV_ReadResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_NV_ReadLock_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2_NV_ReadLock_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_NV_ReadLock_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_NV_ReadLock_REQUEST).name();
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    //authHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "authHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_NV_ReadLock_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_ReadLock_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //nvIndex
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "nvIndex";
    sInf->Fields[1].ParentTypeName = "TPM2_NV_ReadLock_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_ReadLock_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================TPM2_NV_ReadLock_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::NV_ReadLockResponse_ID]=sInf;
    sInf->Name = "NV_ReadLockResponse";
    sInf->MyTypeInfo=typeid(NV_ReadLockResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_NV_ChangeAuth_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_NV_ChangeAuth_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_NV_ChangeAuth_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_NV_ChangeAuth_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    //nvIndex
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "nvIndex";
    sInf->Fields[0].ParentTypeName = "TPM2_NV_ChangeAuth_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_ChangeAuth_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //newAuthSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "newAuthSize";
    sInf->Fields[1].ParentTypeName = "TPM2_NV_ChangeAuth_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_ChangeAuth_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //newAuth
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "newAuth";
    sInf->Fields[2].ParentTypeName = "TPM2_NV_ChangeAuth_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_NV_ChangeAuth_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPM2_NV_ChangeAuth_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::NV_ChangeAuthResponse_ID]=sInf;
    sInf->Name = "NV_ChangeAuthResponse";
    sInf->MyTypeInfo=typeid(NV_ChangeAuthResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_NV_Certify_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(9);
    TypeMap[TpmTypeId::TPM2_NV_Certify_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_NV_Certify_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_NV_Certify_REQUEST).name();
    sInf->HandleCount = 3;
    sInf->AuthHandleCount = 2;
    //signHandle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "signHandle";
    sInf->Fields[0].ParentTypeName = "TPM2_NV_Certify_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //authHandle
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "authHandle";
    sInf->Fields[1].ParentTypeName = "TPM2_NV_Certify_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //nvIndex
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[2].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "nvIndex";
    sInf->Fields[2].ParentTypeName = "TPM2_NV_Certify_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //qualifyingDataSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "qualifyingDataSize";
    sInf->Fields[3].ParentTypeName = "TPM2_NV_Certify_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //qualifyingData
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "qualifyingData";
    sInf->Fields[4].ParentTypeName = "TPM2_NV_Certify_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //inSchemeScheme
    sInf->Fields[5].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[5].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[5].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[5].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[5].ElementName = "inSchemeScheme";
    sInf->Fields[5].ParentTypeName = "TPM2_NV_Certify_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    sInf->Fields[5].AssociatedElement=6;
    //inScheme
    sInf->Fields[6].ThisElementType = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[6].ThisElementTypeName = "TPMU_SIG_SCHEME";
    sInf->Fields[6].ElementSize = sizeof(TPMU_SIG_SCHEME);
    sInf->Fields[6].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[6].ElementName = "inScheme";
    sInf->Fields[6].ParentTypeName = "TPM2_NV_Certify_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmUnion;
    sInf->Fields[6].IsArray = FALSE;
    sInf->Fields[6].AssociatedElement=5;
    //size
    sInf->Fields[7].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[7].ThisElementTypeName = "UINT16";
    sInf->Fields[7].ElementSize = sizeof(UINT16);
    sInf->Fields[7].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[7].ElementName = "size";
    sInf->Fields[7].ParentTypeName = "TPM2_NV_Certify_REQUEST";
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    sInf->Fields[7].Sort = ElementSort::TpmValueType;
    sInf->Fields[7].IsArray = FALSE;
    //offset
    sInf->Fields[8].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[8].ThisElementTypeName = "UINT16";
    sInf->Fields[8].ElementSize = sizeof(UINT16);
    sInf->Fields[8].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[8].ElementName = "offset";
    sInf->Fields[8].ParentTypeName = "TPM2_NV_Certify_REQUEST";
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    sInf->Fields[8].Sort = ElementSort::TpmValueType;
    sInf->Fields[8].IsArray = FALSE;
    //===================TPM2_NV_Certify_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(4);
    TypeMap[TpmTypeId::NV_CertifyResponse_ID]=sInf;
    sInf->Name = "NV_CertifyResponse";
    sInf->MyTypeInfo=typeid(NV_CertifyResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //certifyInfoSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::LengthOfStruct;
    sInf->Fields[0].ElementName = "certifyInfoSize";
    sInf->Fields[0].ParentTypeName = "NV_CertifyResponse";
    sInf->Fields[0].ParentType = TpmTypeId::NV_CertifyResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //certifyInfo
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMS_ATTEST";
    sInf->Fields[1].ElementSize = sizeof(TPMS_ATTEST);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "certifyInfo";
    sInf->Fields[1].ParentTypeName = "NV_CertifyResponse";
    sInf->Fields[1].ParentType = TpmTypeId::NV_CertifyResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //signatureSigAlg
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_ALG_ID";
    sInf->Fields[2].ElementSize = sizeof(TPM_ALG_ID);
    sInf->Fields[2].ElementMarshallType = MarshallType::UnionSelector;
    sInf->Fields[2].ElementName = "signatureSigAlg";
    sInf->Fields[2].ParentTypeName = "NV_CertifyResponse";
    sInf->Fields[2].ParentType = TpmTypeId::NV_CertifyResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    sInf->Fields[2].AssociatedElement=3;
    //signature
    sInf->Fields[3].ThisElementType = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[3].ThisElementTypeName = "TPMU_SIGNATURE";
    sInf->Fields[3].ElementSize = sizeof(TPMU_SIGNATURE);
    sInf->Fields[3].ElementMarshallType = MarshallType::UnionObject;
    sInf->Fields[3].ElementName = "signature";
    sInf->Fields[3].ParentTypeName = "NV_CertifyResponse";
    sInf->Fields[3].ParentType = TpmTypeId::NV_CertifyResponse_ID;
    sInf->Fields[3].Sort = ElementSort::TpmUnion;
    sInf->Fields[3].IsArray = FALSE;
    sInf->Fields[3].AssociatedElement=2;
    //===================TPM2_AC_GetCapability_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TPM2_AC_GetCapability_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_AC_GetCapability_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_AC_GetCapability_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //ac
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "ac";
    sInf->Fields[0].ParentTypeName = "TPM2_AC_GetCapability_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_AC_GetCapability_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //capability
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_AT_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_AT";
    sInf->Fields[1].ElementSize = sizeof(TPM_AT);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "capability";
    sInf->Fields[1].ParentTypeName = "TPM2_AC_GetCapability_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_AC_GetCapability_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmEnum;
    sInf->Fields[1].IsArray = FALSE;
    //count
    sInf->Fields[2].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[2].ThisElementTypeName = "UINT32";
    sInf->Fields[2].ElementSize = sizeof(UINT32);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "count";
    sInf->Fields[2].ParentTypeName = "TPM2_AC_GetCapability_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_AC_GetCapability_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = FALSE;
    //===================TPM2_AC_GetCapability_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::AC_GetCapabilityResponse_ID]=sInf;
    sInf->Name = "AC_GetCapabilityResponse";
    sInf->MyTypeInfo=typeid(AC_GetCapabilityResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //moreData
    sInf->Fields[0].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[0].ThisElementTypeName = "BYTE";
    sInf->Fields[0].ElementSize = sizeof(BYTE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "moreData";
    sInf->Fields[0].ParentTypeName = "AC_GetCapabilityResponse";
    sInf->Fields[0].ParentType = TpmTypeId::AC_GetCapabilityResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //capabilitiesDataCount
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT32";
    sInf->Fields[1].ElementSize = sizeof(UINT32);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "capabilitiesDataCount";
    sInf->Fields[1].ParentTypeName = "AC_GetCapabilityResponse";
    sInf->Fields[1].ParentType = TpmTypeId::AC_GetCapabilityResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //capabilitiesData
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMS_AC_OUTPUT_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMS_AC_OUTPUT";
    sInf->Fields[2].ElementSize = sizeof(TPMS_AC_OUTPUT);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "capabilitiesData";
    sInf->Fields[2].ParentTypeName = "AC_GetCapabilityResponse";
    sInf->Fields[2].ParentType = TpmTypeId::AC_GetCapabilityResponse_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPM2_AC_Send_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::TPM2_AC_Send_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_AC_Send_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_AC_Send_REQUEST).name();
    sInf->HandleCount = 3;
    sInf->AuthHandleCount = 2;
    //sendObject
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "sendObject";
    sInf->Fields[0].ParentTypeName = "TPM2_AC_Send_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_AC_Send_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //authHandle
    sInf->Fields[1].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[1].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "authHandle";
    sInf->Fields[1].ParentTypeName = "TPM2_AC_Send_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_AC_Send_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //ac
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[2].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "ac";
    sInf->Fields[2].ParentTypeName = "TPM2_AC_Send_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_AC_Send_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //acDataInSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "acDataInSize";
    sInf->Fields[3].ParentTypeName = "TPM2_AC_Send_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_AC_Send_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //acDataIn
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "acDataIn";
    sInf->Fields[4].ParentTypeName = "TPM2_AC_Send_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_AC_Send_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //===================TPM2_AC_Send_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(1);
    TypeMap[TpmTypeId::AC_SendResponse_ID]=sInf;
    sInf->Name = "AC_SendResponse";
    sInf->MyTypeInfo=typeid(AC_SendResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //acDataOut
    sInf->Fields[0].ThisElementType = TpmTypeId::TPMS_AC_OUTPUT_ID;
    sInf->Fields[0].ThisElementTypeName = "TPMS_AC_OUTPUT";
    sInf->Fields[0].ElementSize = sizeof(TPMS_AC_OUTPUT);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "acDataOut";
    sInf->Fields[0].ParentTypeName = "AC_SendResponse";
    sInf->Fields[0].ParentType = TpmTypeId::AC_SendResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //===================TPM2_Policy_AC_SendSelect_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(8);
    TypeMap[TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_Policy_AC_SendSelect_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_Policy_AC_SendSelect_REQUEST).name();
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    //policySession
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "policySession";
    sInf->Fields[0].ParentTypeName = "TPM2_Policy_AC_SendSelect_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //objectNameSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "objectNameSize";
    sInf->Fields[1].ParentTypeName = "TPM2_Policy_AC_SendSelect_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //objectName
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "objectName";
    sInf->Fields[2].ParentTypeName = "TPM2_Policy_AC_SendSelect_REQUEST";
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //authHandleNameSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "authHandleNameSize";
    sInf->Fields[3].ParentTypeName = "TPM2_Policy_AC_SendSelect_REQUEST";
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //authHandleName
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "authHandleName";
    sInf->Fields[4].ParentTypeName = "TPM2_Policy_AC_SendSelect_REQUEST";
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //acNameSize
    sInf->Fields[5].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[5].ThisElementTypeName = "UINT16";
    sInf->Fields[5].ElementSize = sizeof(UINT16);
    sInf->Fields[5].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[5].ElementName = "acNameSize";
    sInf->Fields[5].ParentTypeName = "TPM2_Policy_AC_SendSelect_REQUEST";
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = FALSE;
    //acName
    sInf->Fields[6].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[6].ThisElementTypeName = "BYTE";
    sInf->Fields[6].ElementSize = sizeof(BYTE);
    sInf->Fields[6].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[6].ElementName = "acName";
    sInf->Fields[6].ParentTypeName = "TPM2_Policy_AC_SendSelect_REQUEST";
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    sInf->Fields[6].Sort = ElementSort::TpmValueType;
    sInf->Fields[6].IsArray = TRUE;
    sInf->Fields[6].AssociatedElement=5;
    //includeObject
    sInf->Fields[7].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[7].ThisElementTypeName = "BYTE";
    sInf->Fields[7].ElementSize = sizeof(BYTE);
    sInf->Fields[7].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[7].ElementName = "includeObject";
    sInf->Fields[7].ParentTypeName = "TPM2_Policy_AC_SendSelect_REQUEST";
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    sInf->Fields[7].Sort = ElementSort::TpmValueType;
    sInf->Fields[7].IsArray = FALSE;
    //===================TPM2_Policy_AC_SendSelect_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(0);
    TypeMap[TpmTypeId::Policy_AC_SendSelectResponse_ID]=sInf;
    sInf->Name = "Policy_AC_SendSelectResponse";
    sInf->MyTypeInfo=typeid(Policy_AC_SendSelectResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //===================TPM2_Vendor_TCG_Test_REQUEST
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2_Vendor_TCG_Test_REQUEST_ID]=sInf;
    sInf->Name = "TPM2_Vendor_TCG_Test_REQUEST";
    sInf->MyTypeInfo=typeid(TPM2_Vendor_TCG_Test_REQUEST).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //inputDataSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "inputDataSize";
    sInf->Fields[0].ParentTypeName = "TPM2_Vendor_TCG_Test_REQUEST";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Vendor_TCG_Test_REQUEST_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //inputData
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "inputData";
    sInf->Fields[1].ParentTypeName = "TPM2_Vendor_TCG_Test_REQUEST";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Vendor_TCG_Test_REQUEST_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2_Vendor_TCG_Test_RESPONSE
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::Vendor_TCG_TestResponse_ID]=sInf;
    sInf->Name = "Vendor_TCG_TestResponse";
    sInf->MyTypeInfo=typeid(Vendor_TCG_TestResponse).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //outputDataSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "outputDataSize";
    sInf->Fields[0].ParentTypeName = "Vendor_TCG_TestResponse";
    sInf->Fields[0].ParentType = TpmTypeId::Vendor_TCG_TestResponse_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //outputData
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "outputData";
    sInf->Fields[1].ParentTypeName = "Vendor_TCG_TestResponse";
    sInf->Fields[1].ParentType = TpmTypeId::Vendor_TCG_TestResponse_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TssObject
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TssObject_ID]=sInf;
    sInf->Name = "TssObject";
    sInf->MyTypeInfo=typeid(TssObject).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //Public
    sInf->Fields[0].ThisElementType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[0].ThisElementTypeName = "TPMT_PUBLIC";
    sInf->Fields[0].ElementSize = sizeof(TPMT_PUBLIC);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "Public";
    sInf->Fields[0].ParentTypeName = "TssObject";
    sInf->Fields[0].ParentType = TpmTypeId::TssObject_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //Sensitive
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMT_SENSITIVE_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMT_SENSITIVE";
    sInf->Fields[1].ElementSize = sizeof(TPMT_SENSITIVE);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "Sensitive";
    sInf->Fields[1].ParentTypeName = "TssObject";
    sInf->Fields[1].ParentType = TpmTypeId::TssObject_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //Private
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM2B_PRIVATE";
    sInf->Fields[2].ElementSize = sizeof(TPM2B_PRIVATE);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "Private";
    sInf->Fields[2].ParentTypeName = "TssObject";
    sInf->Fields[2].ParentType = TpmTypeId::TssObject_ID;
    sInf->Fields[2].Sort = ElementSort::TpmStruct;
    sInf->Fields[2].IsArray = FALSE;
    //===================PcrValue
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::PcrValue_ID]=sInf;
    sInf->Name = "PcrValue";
    sInf->MyTypeInfo=typeid(PcrValue).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //index
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT32";
    sInf->Fields[0].ElementSize = sizeof(UINT32);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "index";
    sInf->Fields[0].ParentTypeName = "PcrValue";
    sInf->Fields[0].ParentType = TpmTypeId::PcrValue_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //value
    sInf->Fields[1].ThisElementType = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[1].ThisElementTypeName = "TPMT_HA";
    sInf->Fields[1].ElementSize = sizeof(TPMT_HA);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "value";
    sInf->Fields[1].ParentTypeName = "PcrValue";
    sInf->Fields[1].ParentType = TpmTypeId::PcrValue_ID;
    sInf->Fields[1].Sort = ElementSort::TpmStruct;
    sInf->Fields[1].IsArray = FALSE;
    //===================SessionIn
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(6);
    TypeMap[TpmTypeId::SessionIn_ID]=sInf;
    sInf->Name = "SessionIn";
    sInf->MyTypeInfo=typeid(SessionIn).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //handle
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_HANDLE";
    sInf->Fields[0].ElementSize = sizeof(TPM_HANDLE);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "handle";
    sInf->Fields[0].ParentTypeName = "SessionIn";
    sInf->Fields[0].ParentType = TpmTypeId::SessionIn_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //nonceCallerSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "nonceCallerSize";
    sInf->Fields[1].ParentTypeName = "SessionIn";
    sInf->Fields[1].ParentType = TpmTypeId::SessionIn_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //nonceCaller
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "nonceCaller";
    sInf->Fields[2].ParentTypeName = "SessionIn";
    sInf->Fields[2].ParentType = TpmTypeId::SessionIn_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //attributes
    sInf->Fields[3].ThisElementType = TpmTypeId::TPMA_SESSION_ID;
    sInf->Fields[3].ThisElementTypeName = "TPMA_SESSION";
    sInf->Fields[3].ElementSize = sizeof(TPMA_SESSION);
    sInf->Fields[3].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[3].ElementName = "attributes";
    sInf->Fields[3].ParentTypeName = "SessionIn";
    sInf->Fields[3].ParentType = TpmTypeId::SessionIn_ID;
    sInf->Fields[3].Sort = ElementSort::TpmBitfield;
    sInf->Fields[3].IsArray = FALSE;
    //authSize
    sInf->Fields[4].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[4].ThisElementTypeName = "UINT16";
    sInf->Fields[4].ElementSize = sizeof(UINT16);
    sInf->Fields[4].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[4].ElementName = "authSize";
    sInf->Fields[4].ParentTypeName = "SessionIn";
    sInf->Fields[4].ParentType = TpmTypeId::SessionIn_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = FALSE;
    //auth
    sInf->Fields[5].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[5].ThisElementTypeName = "BYTE";
    sInf->Fields[5].ElementSize = sizeof(BYTE);
    sInf->Fields[5].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[5].ElementName = "auth";
    sInf->Fields[5].ParentTypeName = "SessionIn";
    sInf->Fields[5].ParentType = TpmTypeId::SessionIn_ID;
    sInf->Fields[5].Sort = ElementSort::TpmValueType;
    sInf->Fields[5].IsArray = TRUE;
    sInf->Fields[5].AssociatedElement=4;
    //===================SessionOut
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(5);
    TypeMap[TpmTypeId::SessionOut_ID]=sInf;
    sInf->Name = "SessionOut";
    sInf->MyTypeInfo=typeid(SessionOut).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //nonceTpmSize
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "nonceTpmSize";
    sInf->Fields[0].ParentTypeName = "SessionOut";
    sInf->Fields[0].ParentType = TpmTypeId::SessionOut_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //nonceTpm
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "nonceTpm";
    sInf->Fields[1].ParentTypeName = "SessionOut";
    sInf->Fields[1].ParentType = TpmTypeId::SessionOut_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //attributes
    sInf->Fields[2].ThisElementType = TpmTypeId::TPMA_SESSION_ID;
    sInf->Fields[2].ThisElementTypeName = "TPMA_SESSION";
    sInf->Fields[2].ElementSize = sizeof(TPMA_SESSION);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "attributes";
    sInf->Fields[2].ParentTypeName = "SessionOut";
    sInf->Fields[2].ParentType = TpmTypeId::SessionOut_ID;
    sInf->Fields[2].Sort = ElementSort::TpmBitfield;
    sInf->Fields[2].IsArray = FALSE;
    //authSize
    sInf->Fields[3].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[3].ThisElementTypeName = "UINT16";
    sInf->Fields[3].ElementSize = sizeof(UINT16);
    sInf->Fields[3].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[3].ElementName = "authSize";
    sInf->Fields[3].ParentTypeName = "SessionOut";
    sInf->Fields[3].ParentType = TpmTypeId::SessionOut_ID;
    sInf->Fields[3].Sort = ElementSort::TpmValueType;
    sInf->Fields[3].IsArray = FALSE;
    //auth
    sInf->Fields[4].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[4].ThisElementTypeName = "BYTE";
    sInf->Fields[4].ElementSize = sizeof(BYTE);
    sInf->Fields[4].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[4].ElementName = "auth";
    sInf->Fields[4].ParentTypeName = "SessionOut";
    sInf->Fields[4].ParentType = TpmTypeId::SessionOut_ID;
    sInf->Fields[4].Sort = ElementSort::TpmValueType;
    sInf->Fields[4].IsArray = TRUE;
    sInf->Fields[4].AssociatedElement=3;
    //===================CommandHeader
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::CommandHeader_ID]=sInf;
    sInf->Name = "CommandHeader";
    sInf->MyTypeInfo=typeid(CommandHeader).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //Tag
    sInf->Fields[0].ThisElementType = TpmTypeId::TPM_ST_ID;
    sInf->Fields[0].ThisElementTypeName = "TPM_ST";
    sInf->Fields[0].ElementSize = sizeof(TPM_ST);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "Tag";
    sInf->Fields[0].ParentTypeName = "CommandHeader";
    sInf->Fields[0].ParentType = TpmTypeId::CommandHeader_ID;
    sInf->Fields[0].Sort = ElementSort::TpmEnum;
    sInf->Fields[0].IsArray = FALSE;
    //CommandSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT32_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT32";
    sInf->Fields[1].ElementSize = sizeof(UINT32);
    sInf->Fields[1].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[1].ElementName = "CommandSize";
    sInf->Fields[1].ParentTypeName = "CommandHeader";
    sInf->Fields[1].ParentType = TpmTypeId::CommandHeader_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //CommandCode
    sInf->Fields[2].ThisElementType = TpmTypeId::TPM_CC_ID;
    sInf->Fields[2].ThisElementTypeName = "TPM_CC";
    sInf->Fields[2].ElementSize = sizeof(TPM_CC);
    sInf->Fields[2].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[2].ElementName = "CommandCode";
    sInf->Fields[2].ParentTypeName = "CommandHeader";
    sInf->Fields[2].ParentType = TpmTypeId::CommandHeader_ID;
    sInf->Fields[2].Sort = ElementSort::TpmEnum;
    sInf->Fields[2].IsArray = FALSE;
    //===================TSS_KEY
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(3);
    TypeMap[TpmTypeId::TSS_KEY_ID]=sInf;
    sInf->Name = "TSS_KEY";
    sInf->MyTypeInfo=typeid(TSS_KEY).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //publicPart
    sInf->Fields[0].ThisElementType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[0].ThisElementTypeName = "TPMT_PUBLIC";
    sInf->Fields[0].ElementSize = sizeof(TPMT_PUBLIC);
    sInf->Fields[0].ElementMarshallType = MarshallType::Normal;
    sInf->Fields[0].ElementName = "publicPart";
    sInf->Fields[0].ParentTypeName = "TSS_KEY";
    sInf->Fields[0].ParentType = TpmTypeId::TSS_KEY_ID;
    sInf->Fields[0].Sort = ElementSort::TpmStruct;
    sInf->Fields[0].IsArray = FALSE;
    //privatePartSize
    sInf->Fields[1].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[1].ThisElementTypeName = "UINT16";
    sInf->Fields[1].ElementSize = sizeof(UINT16);
    sInf->Fields[1].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[1].ElementName = "privatePartSize";
    sInf->Fields[1].ParentTypeName = "TSS_KEY";
    sInf->Fields[1].ParentType = TpmTypeId::TSS_KEY_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = FALSE;
    //privatePart
    sInf->Fields[2].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[2].ThisElementTypeName = "BYTE";
    sInf->Fields[2].ElementSize = sizeof(BYTE);
    sInf->Fields[2].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[2].ElementName = "privatePart";
    sInf->Fields[2].ParentTypeName = "TSS_KEY";
    sInf->Fields[2].ParentType = TpmTypeId::TSS_KEY_ID;
    sInf->Fields[2].Sort = ElementSort::TpmValueType;
    sInf->Fields[2].IsArray = TRUE;
    sInf->Fields[2].AssociatedElement=1;
    //===================TPM2B_DIGEST_Symcipher
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_DIGEST_Symcipher_ID]=sInf;
    sInf->Name = "TPM2B_DIGEST_Symcipher";
    sInf->MyTypeInfo=typeid(TPM2B_DIGEST_Symcipher).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_DIGEST_Symcipher";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_DIGEST_Symcipher_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_DIGEST_Symcipher";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_DIGEST_Symcipher_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPM2B_DIGEST_Keyedhash
    sInf = new StructMarshallInfo();
    sInf->Fields.resize(2);
    TypeMap[TpmTypeId::TPM2B_DIGEST_Keyedhash_ID]=sInf;
    sInf->Name = "TPM2B_DIGEST_Keyedhash";
    sInf->MyTypeInfo=typeid(TPM2B_DIGEST_Keyedhash).name();
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    //size
    sInf->Fields[0].ThisElementType = TpmTypeId::UINT16_ID;
    sInf->Fields[0].ThisElementTypeName = "UINT16";
    sInf->Fields[0].ElementSize = sizeof(UINT16);
    sInf->Fields[0].ElementMarshallType = MarshallType::ArrayCount;
    sInf->Fields[0].ElementName = "size";
    sInf->Fields[0].ParentTypeName = "TPM2B_DIGEST_Keyedhash";
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_DIGEST_Keyedhash_ID;
    sInf->Fields[0].Sort = ElementSort::TpmValueType;
    sInf->Fields[0].IsArray = FALSE;
    //buffer
    sInf->Fields[1].ThisElementType = TpmTypeId::BYTE_ID;
    sInf->Fields[1].ThisElementTypeName = "BYTE";
    sInf->Fields[1].ElementSize = sizeof(BYTE);
    sInf->Fields[1].ElementMarshallType = MarshallType::VariableLengthArray;
    sInf->Fields[1].ElementName = "buffer";
    sInf->Fields[1].ParentTypeName = "TPM2B_DIGEST_Keyedhash";
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_DIGEST_Keyedhash_ID;
    sInf->Fields[1].Sort = ElementSort::TpmValueType;
    sInf->Fields[1].IsArray = TRUE;
    sInf->Fields[1].AssociatedElement=0;
    //===================TPMU_HA
    sInf = new StructMarshallInfo();
    sInf->UnionSelector.resize(5);
    sInf->UnionType.resize(5);
    TypeMap[TpmTypeId::TPMU_HA_ID]=sInf;
    sInf->Name = "TPMU_HA";
    sInf->MyTypeInfo = typeid(TPMU_HA).name();
    sInf->UnionSelector[0] = (UINT32)TPM_ALG_ID::SHA1;
    sInf->UnionType[0] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[1] = (UINT32)TPM_ALG_ID::SHA256;
    sInf->UnionType[1] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[2] = (UINT32)TPM_ALG_ID::SHA384;
    sInf->UnionType[2] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[3] = (UINT32)TPM_ALG_ID::SHA512;
    sInf->UnionType[3] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[4] = (UINT32)TPM_ALG_ID::SM3_256;
    sInf->UnionType[4] = TpmTypeId::BYTE_ID;
    //===================TPMU_NAME
    sInf = new StructMarshallInfo();
    sInf->UnionSelector.resize(2);
    sInf->UnionType.resize(2);
    TypeMap[TpmTypeId::TPMU_NAME_ID]=sInf;
    sInf->Name = "TPMU_NAME";
    sInf->MyTypeInfo = typeid(TPMU_NAME).name();
    sInf->UnionSelector[0] = (UINT32)NameUnionTagValues::TAG_TPMU_NAME_TPMT_HA;
    sInf->UnionType[0] = TpmTypeId::TPMT_HA_ID;
    sInf->UnionSelector[1] = (UINT32)NameUnionTagValues::TAG_TPMU_NAME_TPM_HANDLE;
    sInf->UnionType[1] = TpmTypeId::TPM_HANDLE_ID;
    //===================TPMU_CAPABILITIES
    sInf = new StructMarshallInfo();
    sInf->UnionSelector.resize(10);
    sInf->UnionType.resize(10);
    TypeMap[TpmTypeId::TPMU_CAPABILITIES_ID]=sInf;
    sInf->Name = "TPMU_CAPABILITIES";
    sInf->MyTypeInfo = typeid(TPMU_CAPABILITIES).name();
    sInf->UnionSelector[0] = (UINT32)TPM_CAP::ALGS;
    sInf->UnionType[0] = TpmTypeId::TPML_ALG_PROPERTY_ID;
    sInf->UnionSelector[1] = (UINT32)TPM_CAP::HANDLES;
    sInf->UnionType[1] = TpmTypeId::TPML_HANDLE_ID;
    sInf->UnionSelector[2] = (UINT32)TPM_CAP::COMMANDS;
    sInf->UnionType[2] = TpmTypeId::TPML_CCA_ID;
    sInf->UnionSelector[3] = (UINT32)TPM_CAP::PP_COMMANDS;
    sInf->UnionType[3] = TpmTypeId::TPML_CC_ID;
    sInf->UnionSelector[4] = (UINT32)TPM_CAP::AUDIT_COMMANDS;
    sInf->UnionType[4] = TpmTypeId::TPML_CC_ID;
    sInf->UnionSelector[5] = (UINT32)TPM_CAP::PCRS;
    sInf->UnionType[5] = TpmTypeId::TPML_PCR_SELECTION_ID;
    sInf->UnionSelector[6] = (UINT32)TPM_CAP::TPM_PROPERTIES;
    sInf->UnionType[6] = TpmTypeId::TPML_TAGGED_TPM_PROPERTY_ID;
    sInf->UnionSelector[7] = (UINT32)TPM_CAP::PCR_PROPERTIES;
    sInf->UnionType[7] = TpmTypeId::TPML_TAGGED_PCR_PROPERTY_ID;
    sInf->UnionSelector[8] = (UINT32)TPM_CAP::ECC_CURVES;
    sInf->UnionType[8] = TpmTypeId::TPML_ECC_CURVE_ID;
    sInf->UnionSelector[9] = (UINT32)TPM_CAP::AUTH_POLICIES;
    sInf->UnionType[9] = TpmTypeId::TPML_TAGGED_POLICY_ID;
    //===================TPMU_ATTEST
    sInf = new StructMarshallInfo();
    sInf->UnionSelector.resize(8);
    sInf->UnionType.resize(8);
    TypeMap[TpmTypeId::TPMU_ATTEST_ID]=sInf;
    sInf->Name = "TPMU_ATTEST";
    sInf->MyTypeInfo = typeid(TPMU_ATTEST).name();
    sInf->UnionSelector[0] = (UINT32)TPM_ST::ATTEST_CERTIFY;
    sInf->UnionType[0] = TpmTypeId::TPMS_CERTIFY_INFO_ID;
    sInf->UnionSelector[1] = (UINT32)TPM_ST::ATTEST_CREATION;
    sInf->UnionType[1] = TpmTypeId::TPMS_CREATION_INFO_ID;
    sInf->UnionSelector[2] = (UINT32)TPM_ST::ATTEST_QUOTE;
    sInf->UnionType[2] = TpmTypeId::TPMS_QUOTE_INFO_ID;
    sInf->UnionSelector[3] = (UINT32)TPM_ST::ATTEST_COMMAND_AUDIT;
    sInf->UnionType[3] = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    sInf->UnionSelector[4] = (UINT32)TPM_ST::ATTEST_SESSION_AUDIT;
    sInf->UnionType[4] = TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID;
    sInf->UnionSelector[5] = (UINT32)TPM_ST::ATTEST_TIME;
    sInf->UnionType[5] = TpmTypeId::TPMS_TIME_ATTEST_INFO_ID;
    sInf->UnionSelector[6] = (UINT32)TPM_ST::ATTEST_NV;
    sInf->UnionType[6] = TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
    sInf->UnionSelector[7] = (UINT32)TPM_ST::ATTEST_NV_DIGEST;
    sInf->UnionType[7] = TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID;
    //===================TPMU_SYM_KEY_BITS
    sInf = new StructMarshallInfo();
    sInf->UnionSelector.resize(7);
    sInf->UnionType.resize(7);
    TypeMap[TpmTypeId::TPMU_SYM_KEY_BITS_ID]=sInf;
    sInf->Name = "TPMU_SYM_KEY_BITS";
    sInf->MyTypeInfo = typeid(TPMU_SYM_KEY_BITS).name();
    sInf->UnionSelector[0] = (UINT32)TPM_ALG_ID::TDES;
    sInf->UnionType[0] = TpmTypeId::TPMI_TDES_KEY_BITS_ID;
    sInf->UnionSelector[1] = (UINT32)TPM_ALG_ID::AES;
    sInf->UnionType[1] = TpmTypeId::TPMI_AES_KEY_BITS_ID;
    sInf->UnionSelector[2] = (UINT32)TPM_ALG_ID::SM4;
    sInf->UnionType[2] = TpmTypeId::TPMI_SM4_KEY_BITS_ID;
    sInf->UnionSelector[3] = (UINT32)TPM_ALG_ID::CAMELLIA;
    sInf->UnionType[3] = TpmTypeId::TPMI_CAMELLIA_KEY_BITS_ID;
    sInf->UnionSelector[4] = (UINT32)TPM_ALG_ID::ANY;
    sInf->UnionType[4] = TpmTypeId::TPM_KEY_BITS_ID;
    sInf->UnionSelector[5] = (UINT32)TPM_ALG_ID::XOR;
    sInf->UnionType[5] = TpmTypeId::TPMI_ALG_HASH_ID;
    sInf->UnionSelector[6] = (UINT32)TPM_ALG_ID::_NULL;
    sInf->UnionType[6] = TpmTypeId::TPMS_NULL_SYM_KEY_BITS_ID;
    //===================TPMU_SYM_MODE
    sInf = new StructMarshallInfo();
    sInf->UnionSelector.resize(7);
    sInf->UnionType.resize(7);
    TypeMap[TpmTypeId::TPMU_SYM_MODE_ID]=sInf;
    sInf->Name = "TPMU_SYM_MODE";
    sInf->MyTypeInfo = typeid(TPMU_SYM_MODE).name();
    sInf->UnionSelector[0] = (UINT32)TPM_ALG_ID::TDES;
    sInf->UnionType[0] = TpmTypeId::TPMI_ALG_SYM_MODE_ID;
    sInf->UnionSelector[1] = (UINT32)TPM_ALG_ID::AES;
    sInf->UnionType[1] = TpmTypeId::TPMI_ALG_SYM_MODE_ID;
    sInf->UnionSelector[2] = (UINT32)TPM_ALG_ID::SM4;
    sInf->UnionType[2] = TpmTypeId::TPMI_ALG_SYM_MODE_ID;
    sInf->UnionSelector[3] = (UINT32)TPM_ALG_ID::CAMELLIA;
    sInf->UnionType[3] = TpmTypeId::TPMI_ALG_SYM_MODE_ID;
    sInf->UnionSelector[4] = (UINT32)TPM_ALG_ID::ANY;
    sInf->UnionType[4] = TpmTypeId::TPMI_ALG_SYM_MODE_ID;
    sInf->UnionSelector[5] = (UINT32)TPM_ALG_ID::XOR;
    sInf->UnionType[5] = TpmTypeId::TPMS_XOR_SYM_MODE_ID;
    sInf->UnionSelector[6] = (UINT32)TPM_ALG_ID::_NULL;
    sInf->UnionType[6] = TpmTypeId::TPMS_NULL_SYM_MODE_ID;
    //===================TPMU_SYM_DETAILS
    sInf = new StructMarshallInfo();
    sInf->UnionSelector.resize(7);
    sInf->UnionType.resize(7);
    TypeMap[TpmTypeId::TPMU_SYM_DETAILS_ID]=sInf;
    sInf->Name = "TPMU_SYM_DETAILS";
    sInf->MyTypeInfo = typeid(TPMU_SYM_DETAILS).name();
    sInf->UnionSelector[0] = (UINT32)TPM_ALG_ID::TDES;
    sInf->UnionType[0] = TpmTypeId::TPMS_TDES_SYM_DETAILS_ID;
    sInf->UnionSelector[1] = (UINT32)TPM_ALG_ID::AES;
    sInf->UnionType[1] = TpmTypeId::TPMS_AES_SYM_DETAILS_ID;
    sInf->UnionSelector[2] = (UINT32)TPM_ALG_ID::SM4;
    sInf->UnionType[2] = TpmTypeId::TPMS_SM4_SYM_DETAILS_ID;
    sInf->UnionSelector[3] = (UINT32)TPM_ALG_ID::CAMELLIA;
    sInf->UnionType[3] = TpmTypeId::TPMS_CAMELLIA_SYM_DETAILS_ID;
    sInf->UnionSelector[4] = (UINT32)TPM_ALG_ID::ANY;
    sInf->UnionType[4] = TpmTypeId::TPMS_ANY_SYM_DETAILS_ID;
    sInf->UnionSelector[5] = (UINT32)TPM_ALG_ID::XOR;
    sInf->UnionType[5] = TpmTypeId::TPMS_XOR_SYM_DETAILS_ID;
    sInf->UnionSelector[6] = (UINT32)TPM_ALG_ID::_NULL;
    sInf->UnionType[6] = TpmTypeId::TPMS_NULL_SYM_DETAILS_ID;
    //===================TPMU_SENSITIVE_CREATE
    sInf = new StructMarshallInfo();
    sInf->UnionSelector.resize(2);
    sInf->UnionType.resize(2);
    TypeMap[TpmTypeId::TPMU_SENSITIVE_CREATE_ID]=sInf;
    sInf->Name = "TPMU_SENSITIVE_CREATE";
    sInf->MyTypeInfo = typeid(TPMU_SENSITIVE_CREATE).name();
    sInf->UnionSelector[0] = (UINT32)TPM_ALG_ID::ANY;
    sInf->UnionType[0] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[1] = (UINT32)TPM_ALG_ID::ANY2;
    sInf->UnionType[1] = TpmTypeId::TPMS_DERIVE_ID;
    //===================TPMU_SCHEME_KEYEDHASH
    sInf = new StructMarshallInfo();
    sInf->UnionSelector.resize(3);
    sInf->UnionType.resize(3);
    TypeMap[TpmTypeId::TPMU_SCHEME_KEYEDHASH_ID]=sInf;
    sInf->Name = "TPMU_SCHEME_KEYEDHASH";
    sInf->MyTypeInfo = typeid(TPMU_SCHEME_KEYEDHASH).name();
    sInf->UnionSelector[0] = (UINT32)TPM_ALG_ID::HMAC;
    sInf->UnionType[0] = TpmTypeId::TPMS_SCHEME_HMAC_ID;
    sInf->UnionSelector[1] = (UINT32)TPM_ALG_ID::XOR;
    sInf->UnionType[1] = TpmTypeId::TPMS_SCHEME_XOR_ID;
    sInf->UnionSelector[2] = (UINT32)TPM_ALG_ID::_NULL;
    sInf->UnionType[2] = TpmTypeId::TPMS_NULL_SCHEME_KEYEDHASH_ID;
    //===================TPMU_SIG_SCHEME
    sInf = new StructMarshallInfo();
    sInf->UnionSelector.resize(9);
    sInf->UnionType.resize(9);
    TypeMap[TpmTypeId::TPMU_SIG_SCHEME_ID]=sInf;
    sInf->Name = "TPMU_SIG_SCHEME";
    sInf->MyTypeInfo = typeid(TPMU_SIG_SCHEME).name();
    sInf->UnionSelector[0] = (UINT32)TPM_ALG_ID::RSASSA;
    sInf->UnionType[0] = TpmTypeId::TPMS_SIG_SCHEME_RSASSA_ID;
    sInf->UnionSelector[1] = (UINT32)TPM_ALG_ID::RSAPSS;
    sInf->UnionType[1] = TpmTypeId::TPMS_SIG_SCHEME_RSAPSS_ID;
    sInf->UnionSelector[2] = (UINT32)TPM_ALG_ID::ECDSA;
    sInf->UnionType[2] = TpmTypeId::TPMS_SIG_SCHEME_ECDSA_ID;
    sInf->UnionSelector[3] = (UINT32)TPM_ALG_ID::ECDAA;
    sInf->UnionType[3] = TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID;
    sInf->UnionSelector[4] = (UINT32)TPM_ALG_ID::SM2;
    sInf->UnionType[4] = TpmTypeId::TPMS_SIG_SCHEME_SM2_ID;
    sInf->UnionSelector[5] = (UINT32)TPM_ALG_ID::ECSCHNORR;
    sInf->UnionType[5] = TpmTypeId::TPMS_SIG_SCHEME_ECSCHNORR_ID;
    sInf->UnionSelector[6] = (UINT32)TPM_ALG_ID::HMAC;
    sInf->UnionType[6] = TpmTypeId::TPMS_SCHEME_HMAC_ID;
    sInf->UnionSelector[7] = (UINT32)TPM_ALG_ID::ANY;
    sInf->UnionType[7] = TpmTypeId::TPMS_SCHEME_HASH_ID;
    sInf->UnionSelector[8] = (UINT32)TPM_ALG_ID::_NULL;
    sInf->UnionType[8] = TpmTypeId::TPMS_NULL_SIG_SCHEME_ID;
    //===================TPMU_KDF_SCHEME
    sInf = new StructMarshallInfo();
    sInf->UnionSelector.resize(5);
    sInf->UnionType.resize(5);
    TypeMap[TpmTypeId::TPMU_KDF_SCHEME_ID]=sInf;
    sInf->Name = "TPMU_KDF_SCHEME";
    sInf->MyTypeInfo = typeid(TPMU_KDF_SCHEME).name();
    sInf->UnionSelector[0] = (UINT32)TPM_ALG_ID::MGF1;
    sInf->UnionType[0] = TpmTypeId::TPMS_SCHEME_MGF1_ID;
    sInf->UnionSelector[1] = (UINT32)TPM_ALG_ID::KDF1_SP800_56A;
    sInf->UnionType[1] = TpmTypeId::TPMS_SCHEME_KDF1_SP800_56A_ID;
    sInf->UnionSelector[2] = (UINT32)TPM_ALG_ID::KDF2;
    sInf->UnionType[2] = TpmTypeId::TPMS_SCHEME_KDF2_ID;
    sInf->UnionSelector[3] = (UINT32)TPM_ALG_ID::KDF1_SP800_108;
    sInf->UnionType[3] = TpmTypeId::TPMS_SCHEME_KDF1_SP800_108_ID;
    sInf->UnionSelector[4] = (UINT32)TPM_ALG_ID::_NULL;
    sInf->UnionType[4] = TpmTypeId::TPMS_NULL_KDF_SCHEME_ID;
    //===================TPMU_ASYM_SCHEME
    sInf = new StructMarshallInfo();
    sInf->UnionSelector.resize(12);
    sInf->UnionType.resize(12);
    TypeMap[TpmTypeId::TPMU_ASYM_SCHEME_ID]=sInf;
    sInf->Name = "TPMU_ASYM_SCHEME";
    sInf->MyTypeInfo = typeid(TPMU_ASYM_SCHEME).name();
    sInf->UnionSelector[0] = (UINT32)TPM_ALG_ID::ECDH;
    sInf->UnionType[0] = TpmTypeId::TPMS_KEY_SCHEME_ECDH_ID;
    sInf->UnionSelector[1] = (UINT32)TPM_ALG_ID::ECMQV;
    sInf->UnionType[1] = TpmTypeId::TPMS_KEY_SCHEME_ECMQV_ID;
    sInf->UnionSelector[2] = (UINT32)TPM_ALG_ID::RSASSA;
    sInf->UnionType[2] = TpmTypeId::TPMS_SIG_SCHEME_RSASSA_ID;
    sInf->UnionSelector[3] = (UINT32)TPM_ALG_ID::RSAPSS;
    sInf->UnionType[3] = TpmTypeId::TPMS_SIG_SCHEME_RSAPSS_ID;
    sInf->UnionSelector[4] = (UINT32)TPM_ALG_ID::ECDSA;
    sInf->UnionType[4] = TpmTypeId::TPMS_SIG_SCHEME_ECDSA_ID;
    sInf->UnionSelector[5] = (UINT32)TPM_ALG_ID::ECDAA;
    sInf->UnionType[5] = TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID;
    sInf->UnionSelector[6] = (UINT32)TPM_ALG_ID::SM2;
    sInf->UnionType[6] = TpmTypeId::TPMS_SIG_SCHEME_SM2_ID;
    sInf->UnionSelector[7] = (UINT32)TPM_ALG_ID::ECSCHNORR;
    sInf->UnionType[7] = TpmTypeId::TPMS_SIG_SCHEME_ECSCHNORR_ID;
    sInf->UnionSelector[8] = (UINT32)TPM_ALG_ID::RSAES;
    sInf->UnionType[8] = TpmTypeId::TPMS_ENC_SCHEME_RSAES_ID;
    sInf->UnionSelector[9] = (UINT32)TPM_ALG_ID::OAEP;
    sInf->UnionType[9] = TpmTypeId::TPMS_ENC_SCHEME_OAEP_ID;
    sInf->UnionSelector[10] = (UINT32)TPM_ALG_ID::ANY;
    sInf->UnionType[10] = TpmTypeId::TPMS_SCHEME_HASH_ID;
    sInf->UnionSelector[11] = (UINT32)TPM_ALG_ID::_NULL;
    sInf->UnionType[11] = TpmTypeId::TPMS_NULL_ASYM_SCHEME_ID;
    //===================TPMU_SIGNATURE
    sInf = new StructMarshallInfo();
    sInf->UnionSelector.resize(9);
    sInf->UnionType.resize(9);
    TypeMap[TpmTypeId::TPMU_SIGNATURE_ID]=sInf;
    sInf->Name = "TPMU_SIGNATURE";
    sInf->MyTypeInfo = typeid(TPMU_SIGNATURE).name();
    sInf->UnionSelector[0] = (UINT32)TPM_ALG_ID::RSASSA;
    sInf->UnionType[0] = TpmTypeId::TPMS_SIGNATURE_RSASSA_ID;
    sInf->UnionSelector[1] = (UINT32)TPM_ALG_ID::RSAPSS;
    sInf->UnionType[1] = TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID;
    sInf->UnionSelector[2] = (UINT32)TPM_ALG_ID::ECDSA;
    sInf->UnionType[2] = TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
    sInf->UnionSelector[3] = (UINT32)TPM_ALG_ID::ECDAA;
    sInf->UnionType[3] = TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
    sInf->UnionSelector[4] = (UINT32)TPM_ALG_ID::SM2;
    sInf->UnionType[4] = TpmTypeId::TPMS_SIGNATURE_SM2_ID;
    sInf->UnionSelector[5] = (UINT32)TPM_ALG_ID::ECSCHNORR;
    sInf->UnionType[5] = TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
    sInf->UnionSelector[6] = (UINT32)TPM_ALG_ID::HMAC;
    sInf->UnionType[6] = TpmTypeId::TPMT_HA_ID;
    sInf->UnionSelector[7] = (UINT32)TPM_ALG_ID::ANY;
    sInf->UnionType[7] = TpmTypeId::TPMS_SCHEME_HASH_ID;
    sInf->UnionSelector[8] = (UINT32)TPM_ALG_ID::_NULL;
    sInf->UnionType[8] = TpmTypeId::TPMS_NULL_SIGNATURE_ID;
    //===================TPMU_ENCRYPTED_SECRET
    sInf = new StructMarshallInfo();
    sInf->UnionSelector.resize(4);
    sInf->UnionType.resize(4);
    TypeMap[TpmTypeId::TPMU_ENCRYPTED_SECRET_ID]=sInf;
    sInf->Name = "TPMU_ENCRYPTED_SECRET";
    sInf->MyTypeInfo = typeid(TPMU_ENCRYPTED_SECRET).name();
    sInf->UnionSelector[0] = (UINT32)TPM_ALG_ID::ECC;
    sInf->UnionType[0] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[1] = (UINT32)TPM_ALG_ID::RSA;
    sInf->UnionType[1] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[2] = (UINT32)TPM_ALG_ID::SYMCIPHER;
    sInf->UnionType[2] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[3] = (UINT32)TPM_ALG_ID::KEYEDHASH;
    sInf->UnionType[3] = TpmTypeId::BYTE_ID;
    //===================TPMU_PUBLIC_ID
    sInf = new StructMarshallInfo();
    sInf->UnionSelector.resize(5);
    sInf->UnionType.resize(5);
    TypeMap[TpmTypeId::TPMU_PUBLIC_ID_ID]=sInf;
    sInf->Name = "TPMU_PUBLIC_ID";
    sInf->MyTypeInfo = typeid(TPMU_PUBLIC_ID).name();
    sInf->UnionSelector[0] = (UINT32)TPM_ALG_ID::KEYEDHASH;
    sInf->UnionType[0] = TpmTypeId::TPM2B_DIGEST_Keyedhash_ID;
    sInf->UnionSelector[1] = (UINT32)TPM_ALG_ID::SYMCIPHER;
    sInf->UnionType[1] = TpmTypeId::TPM2B_DIGEST_Symcipher_ID;
    sInf->UnionSelector[2] = (UINT32)TPM_ALG_ID::RSA;
    sInf->UnionType[2] = TpmTypeId::TPM2B_PUBLIC_KEY_RSA_ID;
    sInf->UnionSelector[3] = (UINT32)TPM_ALG_ID::ECC;
    sInf->UnionType[3] = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->UnionSelector[4] = (UINT32)TPM_ALG_ID::ANY;
    sInf->UnionType[4] = TpmTypeId::TPMS_DERIVE_ID;
    //===================TPMU_PUBLIC_PARMS
    sInf = new StructMarshallInfo();
    sInf->UnionSelector.resize(5);
    sInf->UnionType.resize(5);
    TypeMap[TpmTypeId::TPMU_PUBLIC_PARMS_ID]=sInf;
    sInf->Name = "TPMU_PUBLIC_PARMS";
    sInf->MyTypeInfo = typeid(TPMU_PUBLIC_PARMS).name();
    sInf->UnionSelector[0] = (UINT32)TPM_ALG_ID::KEYEDHASH;
    sInf->UnionType[0] = TpmTypeId::TPMS_KEYEDHASH_PARMS_ID;
    sInf->UnionSelector[1] = (UINT32)TPM_ALG_ID::SYMCIPHER;
    sInf->UnionType[1] = TpmTypeId::TPMS_SYMCIPHER_PARMS_ID;
    sInf->UnionSelector[2] = (UINT32)TPM_ALG_ID::RSA;
    sInf->UnionType[2] = TpmTypeId::TPMS_RSA_PARMS_ID;
    sInf->UnionSelector[3] = (UINT32)TPM_ALG_ID::ECC;
    sInf->UnionType[3] = TpmTypeId::TPMS_ECC_PARMS_ID;
    sInf->UnionSelector[4] = (UINT32)TPM_ALG_ID::ANY;
    sInf->UnionType[4] = TpmTypeId::TPMS_ASYM_PARMS_ID;
    //===================TPMU_SENSITIVE_COMPOSITE
    sInf = new StructMarshallInfo();
    sInf->UnionSelector.resize(5);
    sInf->UnionType.resize(5);
    TypeMap[TpmTypeId::TPMU_SENSITIVE_COMPOSITE_ID]=sInf;
    sInf->Name = "TPMU_SENSITIVE_COMPOSITE";
    sInf->MyTypeInfo = typeid(TPMU_SENSITIVE_COMPOSITE).name();
    sInf->UnionSelector[0] = (UINT32)TPM_ALG_ID::RSA;
    sInf->UnionType[0] = TpmTypeId::TPM2B_PRIVATE_KEY_RSA_ID;
    sInf->UnionSelector[1] = (UINT32)TPM_ALG_ID::ECC;
    sInf->UnionType[1] = TpmTypeId::TPM2B_ECC_PARAMETER_ID;
    sInf->UnionSelector[2] = (UINT32)TPM_ALG_ID::KEYEDHASH;
    sInf->UnionType[2] = TpmTypeId::TPM2B_SENSITIVE_DATA_ID;
    sInf->UnionSelector[3] = (UINT32)TPM_ALG_ID::SYMCIPHER;
    sInf->UnionType[3] = TpmTypeId::TPM2B_SYM_KEY_ID;
    sInf->UnionSelector[4] = (UINT32)TPM_ALG_ID::ANY;
    sInf->UnionType[4] = TpmTypeId::TPM2B_PRIVATE_VENDOR_SPECIFIC_ID;
    //===================TPMA_ALGORITHM
    sInf = new StructMarshallInfo();
    sInf->BitNames.resize(32);
    TypeMap[TpmTypeId::TPMA_ALGORITHM_ID] = sInf;
    sInf->Name = "TPMA_ALGORITHM";
    sInf->MyTypeInfo = typeid(TPMA_ALGORITHM).name();
    sInf->BitNames[0] = "asymmetric";
    sInf->BitNames[1] = "symmetric";
    sInf->BitNames[2] = "hash";
    sInf->BitNames[3] = "object";
    sInf->BitNames[8] = "signing";
    sInf->BitNames[9] = "encrypting";
    sInf->BitNames[10] = "method";
    //===================TPMA_OBJECT
    sInf = new StructMarshallInfo();
    sInf->BitNames.resize(32);
    TypeMap[TpmTypeId::TPMA_OBJECT_ID] = sInf;
    sInf->Name = "TPMA_OBJECT";
    sInf->MyTypeInfo = typeid(TPMA_OBJECT).name();
    sInf->BitNames[0] = "Reserved";
    sInf->BitNames[1] = "fixedTPM";
    sInf->BitNames[2] = "stClear";
    sInf->BitNames[3] = "Reserved";
    sInf->BitNames[4] = "fixedParent";
    sInf->BitNames[5] = "sensitiveDataOrigin";
    sInf->BitNames[6] = "userWithAuth";
    sInf->BitNames[7] = "adminWithPolicy";
    sInf->BitNames[10] = "noDA";
    sInf->BitNames[11] = "encryptedDuplication";
    sInf->BitNames[16] = "restricted";
    sInf->BitNames[17] = "decrypt";
    sInf->BitNames[18] = "sign";
    sInf->BitNames[18] = "encrypt";
    sInf->BitNames[19] = "x509sign";
    //===================TPMA_SESSION
    sInf = new StructMarshallInfo();
    sInf->BitNames.resize(8);
    TypeMap[TpmTypeId::TPMA_SESSION_ID] = sInf;
    sInf->Name = "TPMA_SESSION";
    sInf->MyTypeInfo = typeid(TPMA_SESSION).name();
    sInf->BitNames[0] = "continueSession";
    sInf->BitNames[1] = "auditExclusive";
    sInf->BitNames[2] = "auditReset";
    sInf->BitNames[5] = "decrypt";
    sInf->BitNames[6] = "encrypt";
    sInf->BitNames[7] = "audit";
    //===================TPMA_LOCALITY
    sInf = new StructMarshallInfo();
    sInf->BitNames.resize(8);
    TypeMap[TpmTypeId::TPMA_LOCALITY_ID] = sInf;
    sInf->Name = "TPMA_LOCALITY";
    sInf->MyTypeInfo = typeid(TPMA_LOCALITY).name();
    sInf->BitNames[0] = "LOC_ZERO";
    sInf->BitNames[1] = "LOC_ONE";
    sInf->BitNames[2] = "LOC_TWO";
    sInf->BitNames[3] = "LOC_THREE";
    sInf->BitNames[4] = "LOC_FOUR";
    //===================TPMA_PERMANENT
    sInf = new StructMarshallInfo();
    sInf->BitNames.resize(32);
    TypeMap[TpmTypeId::TPMA_PERMANENT_ID] = sInf;
    sInf->Name = "TPMA_PERMANENT";
    sInf->MyTypeInfo = typeid(TPMA_PERMANENT).name();
    sInf->BitNames[0] = "ownerAuthSet";
    sInf->BitNames[1] = "endorsementAuthSet";
    sInf->BitNames[2] = "lockoutAuthSet";
    sInf->BitNames[8] = "disableClear";
    sInf->BitNames[9] = "inLockout";
    sInf->BitNames[10] = "tpmGeneratedEPS";
    //===================TPMA_STARTUP_CLEAR
    sInf = new StructMarshallInfo();
    sInf->BitNames.resize(32);
    TypeMap[TpmTypeId::TPMA_STARTUP_CLEAR_ID] = sInf;
    sInf->Name = "TPMA_STARTUP_CLEAR";
    sInf->MyTypeInfo = typeid(TPMA_STARTUP_CLEAR).name();
    sInf->BitNames[0] = "phEnable";
    sInf->BitNames[1] = "shEnable";
    sInf->BitNames[2] = "ehEnable";
    sInf->BitNames[3] = "phEnableNV";
    sInf->BitNames[31] = "orderly";
    //===================TPMA_MEMORY
    sInf = new StructMarshallInfo();
    sInf->BitNames.resize(32);
    TypeMap[TpmTypeId::TPMA_MEMORY_ID] = sInf;
    sInf->Name = "TPMA_MEMORY";
    sInf->MyTypeInfo = typeid(TPMA_MEMORY).name();
    sInf->BitNames[0] = "sharedRAM";
    sInf->BitNames[1] = "sharedNV";
    sInf->BitNames[2] = "objectCopiedToRam";
    //===================TPMA_CC
    sInf = new StructMarshallInfo();
    sInf->BitNames.resize(32);
    TypeMap[TpmTypeId::TPMA_CC_ID] = sInf;
    sInf->Name = "TPMA_CC";
    sInf->MyTypeInfo = typeid(TPMA_CC).name();
    sInf->BitNames[22] = "nv";
    sInf->BitNames[23] = "extensive";
    sInf->BitNames[24] = "flushed";
    sInf->BitNames[28] = "rHandle";
    sInf->BitNames[29] = "V";
    //===================TPMA_MODES
    sInf = new StructMarshallInfo();
    sInf->BitNames.resize(32);
    TypeMap[TpmTypeId::TPMA_MODES_ID] = sInf;
    sInf->Name = "TPMA_MODES";
    sInf->MyTypeInfo = typeid(TPMA_MODES).name();
    sInf->BitNames[0] = "FIPS_140_2";
    //===================TPMA_X509_KEY_USAGE
    sInf = new StructMarshallInfo();
    sInf->BitNames.resize(32);
    TypeMap[TpmTypeId::TPMA_X509_KEY_USAGE_ID] = sInf;
    sInf->Name = "TPMA_X509_KEY_USAGE";
    sInf->MyTypeInfo = typeid(TPMA_X509_KEY_USAGE).name();
    sInf->BitNames[0] = "digitalSignature";
    sInf->BitNames[1] = "nonrepudiation";
    sInf->BitNames[1] = "contentCommitment";
    sInf->BitNames[2] = "keyEncipherment";
    sInf->BitNames[3] = "dataEncipherment";
    sInf->BitNames[4] = "keyAgreement";
    sInf->BitNames[5] = "keyCertSign";
    sInf->BitNames[6] = "crlSign";
    sInf->BitNames[7] = "encipherOnly";
    sInf->BitNames[8] = "decipherOnly";
    //===================TPM_NV_INDEX
    sInf = new StructMarshallInfo();
    sInf->BitNames.resize(32);
    TypeMap[TpmTypeId::TPM_NV_INDEX_ID] = sInf;
    sInf->Name = "TPM_NV_INDEX";
    sInf->MyTypeInfo = typeid(TPM_NV_INDEX).name();
    //===================TPMA_NV
    sInf = new StructMarshallInfo();
    sInf->BitNames.resize(32);
    TypeMap[TpmTypeId::TPMA_NV_ID] = sInf;
    sInf->Name = "TPMA_NV";
    sInf->MyTypeInfo = typeid(TPMA_NV).name();
    sInf->BitNames[0] = "PPWRITE";
    sInf->BitNames[1] = "OWNERWRITE";
    sInf->BitNames[2] = "AUTHWRITE";
    sInf->BitNames[3] = "POLICYWRITE";
    sInf->BitNames[10] = "POLICY_DELETE";
    sInf->BitNames[11] = "WRITELOCKED";
    sInf->BitNames[12] = "WRITEALL";
    sInf->BitNames[13] = "WRITEDEFINE";
    sInf->BitNames[14] = "WRITE_STCLEAR";
    sInf->BitNames[15] = "GLOBALLOCK";
    sInf->BitNames[16] = "PPREAD";
    sInf->BitNames[17] = "OWNERREAD";
    sInf->BitNames[18] = "AUTHREAD";
    sInf->BitNames[19] = "POLICYREAD";
    sInf->BitNames[25] = "NO_DA";
    sInf->BitNames[26] = "ORDERLY";
    sInf->BitNames[27] = "CLEAR_STCLEAR";
    sInf->BitNames[28] = "READLOCKED";
    sInf->BitNames[29] = "WRITTEN";
    sInf->BitNames[30] = "PLATFORMCREATE";
    sInf->BitNames[31] = "READ_STCLEAR";
    //===================NameUnionTagValues
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::NameUnionTagValues_ID] = sInf;
    sInf->Name = "NameUnionTagValues";
    sInf->MyTypeInfo = typeid(NameUnionTagValues).name();
    sInf->EnumNames[ (UINT32)(0)] = "TAG_TPMU_NAME_TPMT_HA";
    sInf->EnumNames[ (UINT32)(1)] = "TAG_TPMU_NAME_TPM_HANDLE";
    //===================TPM_ALG_ID
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_ALG_ID_ID] = sInf;
    sInf->Name = "TPM_ALG_ID";
    sInf->MyTypeInfo = typeid(TPM_ALG_ID).name();
    sInf->EnumNames[ (UINT32)(0x0000)] = "_ERROR";
    sInf->EnumNames[ (UINT32)(0x0001)] = "FIRST";
    sInf->EnumNames[ (UINT32)(0x0001)] = "RSA";
    sInf->EnumNames[ (UINT32)(0x0003)] = "TDES";
    sInf->EnumNames[ (UINT32)(0x0004)] = "SHA";
    sInf->EnumNames[ (UINT32)(0x0004)] = "SHA1";
    sInf->EnumNames[ (UINT32)(0x0005)] = "HMAC";
    sInf->EnumNames[ (UINT32)(0x0006)] = "AES";
    sInf->EnumNames[ (UINT32)(0x0007)] = "MGF1";
    sInf->EnumNames[ (UINT32)(0x0008)] = "KEYEDHASH";
    sInf->EnumNames[ (UINT32)(0x000A)] = "XOR";
    sInf->EnumNames[ (UINT32)(0x000B)] = "SHA256";
    sInf->EnumNames[ (UINT32)(0x000C)] = "SHA384";
    sInf->EnumNames[ (UINT32)(0x000D)] = "SHA512";
    sInf->EnumNames[ (UINT32)(0x0010)] = "_NULL";
    sInf->EnumNames[ (UINT32)(0x0012)] = "SM3_256";
    sInf->EnumNames[ (UINT32)(0x0013)] = "SM4";
    sInf->EnumNames[ (UINT32)(0x0014)] = "RSASSA";
    sInf->EnumNames[ (UINT32)(0x0015)] = "RSAES";
    sInf->EnumNames[ (UINT32)(0x0016)] = "RSAPSS";
    sInf->EnumNames[ (UINT32)(0x0017)] = "OAEP";
    sInf->EnumNames[ (UINT32)(0x0018)] = "ECDSA";
    sInf->EnumNames[ (UINT32)(0x0019)] = "ECDH";
    sInf->EnumNames[ (UINT32)(0x001A)] = "ECDAA";
    sInf->EnumNames[ (UINT32)(0x001B)] = "SM2";
    sInf->EnumNames[ (UINT32)(0x001C)] = "ECSCHNORR";
    sInf->EnumNames[ (UINT32)(0x001D)] = "ECMQV";
    sInf->EnumNames[ (UINT32)(0x0020)] = "KDF1_SP800_56A";
    sInf->EnumNames[ (UINT32)(0x0021)] = "KDF2";
    sInf->EnumNames[ (UINT32)(0x0022)] = "KDF1_SP800_108";
    sInf->EnumNames[ (UINT32)(0x0023)] = "ECC";
    sInf->EnumNames[ (UINT32)(0x0025)] = "SYMCIPHER";
    sInf->EnumNames[ (UINT32)(0x0026)] = "CAMELLIA";
    sInf->EnumNames[ (UINT32)(0x003F)] = "CMAC";
    sInf->EnumNames[ (UINT32)(0x0040)] = "CTR";
    sInf->EnumNames[ (UINT32)(0x0041)] = "OFB";
    sInf->EnumNames[ (UINT32)(0x0042)] = "CBC";
    sInf->EnumNames[ (UINT32)(0x0043)] = "CFB";
    sInf->EnumNames[ (UINT32)(0x0044)] = "ECB";
    sInf->EnumNames[ (UINT32)(0x0044)] = "LAST";
    sInf->EnumNames[ (UINT32)(0x7FFF)] = "ANY";
    sInf->EnumNames[ (UINT32)(0x7FFE)] = "ANY2";
    //===================TPM_ECC_CURVE
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_ECC_CURVE_ID] = sInf;
    sInf->Name = "TPM_ECC_CURVE";
    sInf->MyTypeInfo = typeid(TPM_ECC_CURVE).name();
    sInf->EnumNames[ (UINT32)(0x0000)] = "NONE";
    sInf->EnumNames[ (UINT32)(0x0001)] = "NIST_P192";
    sInf->EnumNames[ (UINT32)(0x0002)] = "NIST_P224";
    sInf->EnumNames[ (UINT32)(0x0003)] = "NIST_P256";
    sInf->EnumNames[ (UINT32)(0x0004)] = "NIST_P384";
    sInf->EnumNames[ (UINT32)(0x0005)] = "NIST_P521";
    sInf->EnumNames[ (UINT32)(0x0010)] = "BN_P256";
    sInf->EnumNames[ (UINT32)(0x0011)] = "BN_P638";
    sInf->EnumNames[ (UINT32)(0x0020)] = "SM2_P256";
    //===================SHA1
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::SHA1_ID] = sInf;
    sInf->Name = "SHA1";
    sInf->MyTypeInfo = typeid(SHA1).name();
    sInf->EnumNames[ (UINT32)(20)] = "DIGEST_SIZE";
    sInf->EnumNames[ (UINT32)(64)] = "BLOCK_SIZE";
    sInf->EnumNames[ (UINT32)(15)] = "DER_SIZE";
    //===================SHA256
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::SHA256_ID] = sInf;
    sInf->Name = "SHA256";
    sInf->MyTypeInfo = typeid(SHA256).name();
    sInf->EnumNames[ (UINT32)(32)] = "DIGEST_SIZE";
    sInf->EnumNames[ (UINT32)(64)] = "BLOCK_SIZE";
    sInf->EnumNames[ (UINT32)(19)] = "DER_SIZE";
    //===================SHA384
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::SHA384_ID] = sInf;
    sInf->Name = "SHA384";
    sInf->MyTypeInfo = typeid(SHA384).name();
    sInf->EnumNames[ (UINT32)(48)] = "DIGEST_SIZE";
    sInf->EnumNames[ (UINT32)(128)] = "BLOCK_SIZE";
    sInf->EnumNames[ (UINT32)(19)] = "DER_SIZE";
    //===================SHA512
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::SHA512_ID] = sInf;
    sInf->Name = "SHA512";
    sInf->MyTypeInfo = typeid(SHA512).name();
    sInf->EnumNames[ (UINT32)(64)] = "DIGEST_SIZE";
    sInf->EnumNames[ (UINT32)(128)] = "BLOCK_SIZE";
    sInf->EnumNames[ (UINT32)(19)] = "DER_SIZE";
    //===================SM3_256
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::SM3_256_ID] = sInf;
    sInf->Name = "SM3_256";
    sInf->MyTypeInfo = typeid(SM3_256).name();
    sInf->EnumNames[ (UINT32)(32)] = "DIGEST_SIZE";
    sInf->EnumNames[ (UINT32)(64)] = "BLOCK_SIZE";
    sInf->EnumNames[ (UINT32)(18)] = "DER_SIZE";
    //===================ImplementationConstants
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::ImplementationConstants_ID] = sInf;
    sInf->Name = "ImplementationConstants";
    sInf->MyTypeInfo = typeid(ImplementationConstants).name();
    sInf->EnumNames[ (UINT32)(1)] = "OSSL";
    sInf->EnumNames[ (UINT32)(2)] = "LTC";
    sInf->EnumNames[ (UINT32)(3)] = "MSBN";
    sInf->EnumNames[ (UINT32)(4)] = "SYMCRYPT";
    sInf->EnumNames[ (UINT32)(3)] = "HASH_COUNT";
    sInf->EnumNames[ (UINT32)(256)] = "MAX_SYM_KEY_BITS";
    sInf->EnumNames[ (UINT32)(((UINT32(0x100/*ImplementationConstants::MAX_SYM_KEY_BITS*/) + 7) / 8))] = "MAX_SYM_KEY_BYTES";
    sInf->EnumNames[ (UINT32)(16)] = "MAX_SYM_BLOCK_SIZE";
    sInf->EnumNames[ (UINT32)(UINT32(0x197/*TPM_CC::LAST*/))] = "MAX_CAP_CC";
    sInf->EnumNames[ (UINT32)(256)] = "MAX_RSA_KEY_BYTES";
    sInf->EnumNames[ (UINT32)(32)] = "MAX_AES_KEY_BYTES";
    sInf->EnumNames[ (UINT32)(48)] = "MAX_ECC_KEY_BYTES";
    sInf->EnumNames[ (UINT32)(32)] = "LABEL_MAX_BUFFER";
    sInf->EnumNames[ (UINT32)((UINT32(0x400/*Implementation::MAX_CAP_BUFFER*/)-sizeof(TPM_CAP)-sizeof(UINT32)))] = "MAX_CAP_DATA";
    sInf->EnumNames[ (UINT32)((UINT32(0x3F8/*ImplementationConstants::MAX_CAP_DATA*/) / 0x6 /*sizeof(TPMS_ALG_PROPERTY)*/))] = "MAX_CAP_ALGS";
    sInf->EnumNames[ (UINT32)((UINT32(0x3F8/*ImplementationConstants::MAX_CAP_DATA*/) / 0x4 /*sizeof(TPM_HANDLE)*/))] = "MAX_CAP_HANDLES";
    sInf->EnumNames[ (UINT32)((UINT32(0x3F8/*ImplementationConstants::MAX_CAP_DATA*/) / 0x8 /*sizeof(TPMS_TAGGED_PROPERTY)*/))] = "MAX_TPM_PROPERTIES";
    sInf->EnumNames[ (UINT32)((UINT32(0x3F8/*ImplementationConstants::MAX_CAP_DATA*/) / 0x8 /*sizeof(TPMS_TAGGED_PCR_SELECT)*/))] = "MAX_PCR_PROPERTIES";
    sInf->EnumNames[ (UINT32)((UINT32(0x3F8/*ImplementationConstants::MAX_CAP_DATA*/) / sizeof(TPM_ECC_CURVE)))] = "MAX_ECC_CURVES";
    sInf->EnumNames[ (UINT32)((UINT32(0x3F8/*ImplementationConstants::MAX_CAP_DATA*/) / 0x36 /*sizeof(TPMS_TAGGED_POLICY)*/))] = "MAX_TAGGED_POLICIES";
    sInf->EnumNames[ (UINT32)((UINT32(0x3F8/*ImplementationConstants::MAX_CAP_DATA*/) / 0x8 /*sizeof(TPMS_AC_OUTPUT)*/))] = "MAX_AC_CAPABILITIES";
    //===================Logic
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::Logic_ID] = sInf;
    sInf->Name = "Logic";
    sInf->MyTypeInfo = typeid(Logic).name();
    sInf->EnumNames[ (UINT32)(1)] = "TRUE";
    sInf->EnumNames[ (UINT32)(0)] = "FALSE";
    sInf->EnumNames[ (UINT32)(1)] = "YES";
    sInf->EnumNames[ (UINT32)(0)] = "NO";
    sInf->EnumNames[ (UINT32)(1)] = "SET";
    sInf->EnumNames[ (UINT32)(0)] = "CLEAR";
    //===================TPM_SPEC
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_SPEC_ID] = sInf;
    sInf->Name = "TPM_SPEC";
    sInf->MyTypeInfo = typeid(TPM_SPEC).name();
    sInf->EnumNames[ (UINT32)(0x322E3000)] = "FAMILY";
    sInf->EnumNames[ (UINT32)(00)] = "LEVEL";
    sInf->EnumNames[ (UINT32)(153)] = "VERSION";
    sInf->EnumNames[ (UINT32)(2019)] = "YEAR";
    sInf->EnumNames[ (UINT32)(28)] = "DAY_OF_YEAR";
    //===================TPM_GENERATED
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_GENERATED_ID] = sInf;
    sInf->Name = "TPM_GENERATED";
    sInf->MyTypeInfo = typeid(TPM_GENERATED).name();
    sInf->EnumNames[ (UINT32)(0xff544347)] = "VALUE";
    //===================TPM_CC
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_CC_ID] = sInf;
    sInf->Name = "TPM_CC";
    sInf->MyTypeInfo = typeid(TPM_CC).name();
    sInf->EnumNames[ (UINT32)(0x0000011F)] = "FIRST";
    sInf->EnumNames[ (UINT32)(0x0000011F)] = "NV_UndefineSpaceSpecial";
    sInf->EnumNames[ (UINT32)(0x00000120)] = "EvictControl";
    sInf->EnumNames[ (UINT32)(0x00000121)] = "HierarchyControl";
    sInf->EnumNames[ (UINT32)(0x00000122)] = "NV_UndefineSpace";
    sInf->EnumNames[ (UINT32)(0x00000124)] = "ChangeEPS";
    sInf->EnumNames[ (UINT32)(0x00000125)] = "ChangePPS";
    sInf->EnumNames[ (UINT32)(0x00000126)] = "Clear";
    sInf->EnumNames[ (UINT32)(0x00000127)] = "ClearControl";
    sInf->EnumNames[ (UINT32)(0x00000128)] = "ClockSet";
    sInf->EnumNames[ (UINT32)(0x00000129)] = "HierarchyChangeAuth";
    sInf->EnumNames[ (UINT32)(0x0000012A)] = "NV_DefineSpace";
    sInf->EnumNames[ (UINT32)(0x0000012B)] = "PCR_Allocate";
    sInf->EnumNames[ (UINT32)(0x0000012C)] = "PCR_SetAuthPolicy";
    sInf->EnumNames[ (UINT32)(0x0000012D)] = "PP_Commands";
    sInf->EnumNames[ (UINT32)(0x0000012E)] = "SetPrimaryPolicy";
    sInf->EnumNames[ (UINT32)(0x0000012F)] = "FieldUpgradeStart";
    sInf->EnumNames[ (UINT32)(0x00000130)] = "ClockRateAdjust";
    sInf->EnumNames[ (UINT32)(0x00000131)] = "CreatePrimary";
    sInf->EnumNames[ (UINT32)(0x00000132)] = "NV_GlobalWriteLock";
    sInf->EnumNames[ (UINT32)(0x00000133)] = "GetCommandAuditDigest";
    sInf->EnumNames[ (UINT32)(0x00000134)] = "NV_Increment";
    sInf->EnumNames[ (UINT32)(0x00000135)] = "NV_SetBits";
    sInf->EnumNames[ (UINT32)(0x00000136)] = "NV_Extend";
    sInf->EnumNames[ (UINT32)(0x00000137)] = "NV_Write";
    sInf->EnumNames[ (UINT32)(0x00000138)] = "NV_WriteLock";
    sInf->EnumNames[ (UINT32)(0x00000139)] = "DictionaryAttackLockReset";
    sInf->EnumNames[ (UINT32)(0x0000013A)] = "DictionaryAttackParameters";
    sInf->EnumNames[ (UINT32)(0x0000013B)] = "NV_ChangeAuth";
    sInf->EnumNames[ (UINT32)(0x0000013C)] = "PCR_Event";
    sInf->EnumNames[ (UINT32)(0x0000013D)] = "PCR_Reset";
    sInf->EnumNames[ (UINT32)(0x0000013E)] = "SequenceComplete";
    sInf->EnumNames[ (UINT32)(0x0000013F)] = "SetAlgorithmSet";
    sInf->EnumNames[ (UINT32)(0x00000140)] = "SetCommandCodeAuditStatus";
    sInf->EnumNames[ (UINT32)(0x00000141)] = "FieldUpgradeData";
    sInf->EnumNames[ (UINT32)(0x00000142)] = "IncrementalSelfTest";
    sInf->EnumNames[ (UINT32)(0x00000143)] = "SelfTest";
    sInf->EnumNames[ (UINT32)(0x00000144)] = "Startup";
    sInf->EnumNames[ (UINT32)(0x00000145)] = "Shutdown";
    sInf->EnumNames[ (UINT32)(0x00000146)] = "StirRandom";
    sInf->EnumNames[ (UINT32)(0x00000147)] = "ActivateCredential";
    sInf->EnumNames[ (UINT32)(0x00000148)] = "Certify";
    sInf->EnumNames[ (UINT32)(0x00000149)] = "PolicyNV";
    sInf->EnumNames[ (UINT32)(0x0000014A)] = "CertifyCreation";
    sInf->EnumNames[ (UINT32)(0x0000014B)] = "Duplicate";
    sInf->EnumNames[ (UINT32)(0x0000014C)] = "GetTime";
    sInf->EnumNames[ (UINT32)(0x0000014D)] = "GetSessionAuditDigest";
    sInf->EnumNames[ (UINT32)(0x0000014E)] = "NV_Read";
    sInf->EnumNames[ (UINT32)(0x0000014F)] = "NV_ReadLock";
    sInf->EnumNames[ (UINT32)(0x00000150)] = "ObjectChangeAuth";
    sInf->EnumNames[ (UINT32)(0x00000151)] = "PolicySecret";
    sInf->EnumNames[ (UINT32)(0x00000152)] = "Rewrap";
    sInf->EnumNames[ (UINT32)(0x00000153)] = "Create";
    sInf->EnumNames[ (UINT32)(0x00000154)] = "ECDH_ZGen";
    sInf->EnumNames[ (UINT32)(0x00000155)] = "HMAC";
    sInf->EnumNames[ (UINT32)(0x00000155)] = "MAC";
    sInf->EnumNames[ (UINT32)(0x00000156)] = "Import";
    sInf->EnumNames[ (UINT32)(0x00000157)] = "Load";
    sInf->EnumNames[ (UINT32)(0x00000158)] = "Quote";
    sInf->EnumNames[ (UINT32)(0x00000159)] = "RSA_Decrypt";
    sInf->EnumNames[ (UINT32)(0x0000015B)] = "HMAC_Start";
    sInf->EnumNames[ (UINT32)(0x0000015B)] = "MAC_Start";
    sInf->EnumNames[ (UINT32)(0x0000015C)] = "SequenceUpdate";
    sInf->EnumNames[ (UINT32)(0x0000015D)] = "Sign";
    sInf->EnumNames[ (UINT32)(0x0000015E)] = "Unseal";
    sInf->EnumNames[ (UINT32)(0x00000160)] = "PolicySigned";
    sInf->EnumNames[ (UINT32)(0x00000161)] = "ContextLoad";
    sInf->EnumNames[ (UINT32)(0x00000162)] = "ContextSave";
    sInf->EnumNames[ (UINT32)(0x00000163)] = "ECDH_KeyGen";
    sInf->EnumNames[ (UINT32)(0x00000164)] = "EncryptDecrypt";
    sInf->EnumNames[ (UINT32)(0x00000165)] = "FlushContext";
    sInf->EnumNames[ (UINT32)(0x00000167)] = "LoadExternal";
    sInf->EnumNames[ (UINT32)(0x00000168)] = "MakeCredential";
    sInf->EnumNames[ (UINT32)(0x00000169)] = "NV_ReadPublic";
    sInf->EnumNames[ (UINT32)(0x0000016A)] = "PolicyAuthorize";
    sInf->EnumNames[ (UINT32)(0x0000016B)] = "PolicyAuthValue";
    sInf->EnumNames[ (UINT32)(0x0000016C)] = "PolicyCommandCode";
    sInf->EnumNames[ (UINT32)(0x0000016D)] = "PolicyCounterTimer";
    sInf->EnumNames[ (UINT32)(0x0000016E)] = "PolicyCpHash";
    sInf->EnumNames[ (UINT32)(0x0000016F)] = "PolicyLocality";
    sInf->EnumNames[ (UINT32)(0x00000170)] = "PolicyNameHash";
    sInf->EnumNames[ (UINT32)(0x00000171)] = "PolicyOR";
    sInf->EnumNames[ (UINT32)(0x00000172)] = "PolicyTicket";
    sInf->EnumNames[ (UINT32)(0x00000173)] = "ReadPublic";
    sInf->EnumNames[ (UINT32)(0x00000174)] = "RSA_Encrypt";
    sInf->EnumNames[ (UINT32)(0x00000176)] = "StartAuthSession";
    sInf->EnumNames[ (UINT32)(0x00000177)] = "VerifySignature";
    sInf->EnumNames[ (UINT32)(0x00000178)] = "ECC_Parameters";
    sInf->EnumNames[ (UINT32)(0x00000179)] = "FirmwareRead";
    sInf->EnumNames[ (UINT32)(0x0000017A)] = "GetCapability";
    sInf->EnumNames[ (UINT32)(0x0000017B)] = "GetRandom";
    sInf->EnumNames[ (UINT32)(0x0000017C)] = "GetTestResult";
    sInf->EnumNames[ (UINT32)(0x0000017D)] = "Hash";
    sInf->EnumNames[ (UINT32)(0x0000017E)] = "PCR_Read";
    sInf->EnumNames[ (UINT32)(0x0000017F)] = "PolicyPCR";
    sInf->EnumNames[ (UINT32)(0x00000180)] = "PolicyRestart";
    sInf->EnumNames[ (UINT32)(0x00000181)] = "ReadClock";
    sInf->EnumNames[ (UINT32)(0x00000182)] = "PCR_Extend";
    sInf->EnumNames[ (UINT32)(0x00000183)] = "PCR_SetAuthValue";
    sInf->EnumNames[ (UINT32)(0x00000184)] = "NV_Certify";
    sInf->EnumNames[ (UINT32)(0x00000185)] = "EventSequenceComplete";
    sInf->EnumNames[ (UINT32)(0x00000186)] = "HashSequenceStart";
    sInf->EnumNames[ (UINT32)(0x00000187)] = "PolicyPhysicalPresence";
    sInf->EnumNames[ (UINT32)(0x00000188)] = "PolicyDuplicationSelect";
    sInf->EnumNames[ (UINT32)(0x00000189)] = "PolicyGetDigest";
    sInf->EnumNames[ (UINT32)(0x0000018A)] = "TestParms";
    sInf->EnumNames[ (UINT32)(0x0000018B)] = "Commit";
    sInf->EnumNames[ (UINT32)(0x0000018C)] = "PolicyPassword";
    sInf->EnumNames[ (UINT32)(0x0000018D)] = "ZGen_2Phase";
    sInf->EnumNames[ (UINT32)(0x0000018E)] = "EC_Ephemeral";
    sInf->EnumNames[ (UINT32)(0x0000018F)] = "PolicyNvWritten";
    sInf->EnumNames[ (UINT32)(0x00000190)] = "PolicyTemplate";
    sInf->EnumNames[ (UINT32)(0x00000191)] = "CreateLoaded";
    sInf->EnumNames[ (UINT32)(0x00000192)] = "PolicyAuthorizeNV";
    sInf->EnumNames[ (UINT32)(0x00000193)] = "EncryptDecrypt2";
    sInf->EnumNames[ (UINT32)(0x00000194)] = "AC_GetCapability";
    sInf->EnumNames[ (UINT32)(0x00000195)] = "AC_Send";
    sInf->EnumNames[ (UINT32)(0x00000196)] = "Policy_AC_SendSelect";
    sInf->EnumNames[ (UINT32)(0x00000197)] = "CertifyX509";
    sInf->EnumNames[ (UINT32)(0x00000197)] = "LAST";
    sInf->EnumNames[ (UINT32)(0x20000000)] = "CC_VEND";
    sInf->EnumNames[ (UINT32)(UINT32(0x20000000/*TPM_CC::CC_VEND*/)+0x0000)] = "Vendor_TCG_Test";
    //===================TPM_RC
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_RC_ID] = sInf;
    sInf->Name = "TPM_RC";
    sInf->MyTypeInfo = typeid(TPM_RC).name();
    sInf->EnumNames[ (UINT32)(0x000)] = "SUCCESS";
    sInf->EnumNames[ (UINT32)(0x01E)] = "BAD_TAG";
    sInf->EnumNames[ (UINT32)(0x100)] = "RC_VER1";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x000)] = "INITIALIZE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x001)] = "FAILURE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x003)] = "SEQUENCE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x00B)] = "PRIVATE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x019)] = "HMAC";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x020)] = "DISABLED";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x021)] = "EXCLUSIVE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x024)] = "AUTH_TYPE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x025)] = "AUTH_MISSING";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x026)] = "POLICY";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x027)] = "PCR";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x028)] = "PCR_CHANGED";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x02D)] = "UPGRADE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x02E)] = "TOO_MANY_CONTEXTS";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x02F)] = "AUTH_UNAVAILABLE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x030)] = "REBOOT";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x031)] = "UNBALANCED";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x042)] = "COMMAND_SIZE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x043)] = "COMMAND_CODE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x044)] = "AUTHSIZE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x045)] = "AUTH_CONTEXT";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x046)] = "NV_RANGE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x047)] = "NV_SIZE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x048)] = "NV_LOCKED";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x049)] = "NV_AUTHORIZATION";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x04A)] = "NV_UNINITIALIZED";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x04B)] = "NV_SPACE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x04C)] = "NV_DEFINED";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x050)] = "BAD_CONTEXT";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x051)] = "CPHASH";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x052)] = "PARENT";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x053)] = "NEEDS_TEST";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x054)] = "NO_RESULT";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x055)] = "SENSITIVE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_RC::RC_VER1*/) + 0x07F)] = "RC_MAX_FM0";
    sInf->EnumNames[ (UINT32)(0x080)] = "RC_FMT1";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x001)] = "ASYMMETRIC";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x002)] = "ATTRIBUTES";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x003)] = "HASH";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x004)] = "VALUE";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x005)] = "HIERARCHY";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x007)] = "KEY_SIZE";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x008)] = "MGF";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x009)] = "MODE";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x00A)] = "TYPE";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x00B)] = "HANDLE";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x00C)] = "KDF";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x00D)] = "RANGE";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x00E)] = "AUTH_FAIL";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x00F)] = "NONCE";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x010)] = "PP";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x012)] = "SCHEME";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x015)] = "SIZE";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x016)] = "SYMMETRIC";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x017)] = "TAG";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x018)] = "SELECTOR";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x01A)] = "INSUFFICIENT";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x01B)] = "SIGNATURE";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x01C)] = "KEY";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x01D)] = "POLICY_FAIL";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x01F)] = "INTEGRITY";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x020)] = "TICKET";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x022)] = "BAD_AUTH";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x023)] = "EXPIRED";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x024)] = "POLICY_CC";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x025)] = "BINDING";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x026)] = "CURVE";
    sInf->EnumNames[ (UINT32)(UINT32(0x80/*TPM_RC::RC_FMT1*/) + 0x027)] = "ECC_POINT";
    sInf->EnumNames[ (UINT32)(0x900)] = "RC_WARN";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x001)] = "CONTEXT_GAP";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x002)] = "OBJECT_MEMORY";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x003)] = "SESSION_MEMORY";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x004)] = "MEMORY";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x005)] = "SESSION_HANDLES";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x006)] = "OBJECT_HANDLES";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x007)] = "LOCALITY";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x008)] = "YIELDED";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x009)] = "CANCELED";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x00A)] = "TESTING";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x010)] = "REFERENCE_H0";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x011)] = "REFERENCE_H1";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x012)] = "REFERENCE_H2";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x013)] = "REFERENCE_H3";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x014)] = "REFERENCE_H4";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x015)] = "REFERENCE_H5";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x016)] = "REFERENCE_H6";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x018)] = "REFERENCE_S0";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x019)] = "REFERENCE_S1";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x01A)] = "REFERENCE_S2";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x01B)] = "REFERENCE_S3";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x01C)] = "REFERENCE_S4";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x01D)] = "REFERENCE_S5";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x01E)] = "REFERENCE_S6";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x020)] = "NV_RATE";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x021)] = "LOCKOUT";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x022)] = "RETRY";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x023)] = "NV_UNAVAILABLE";
    sInf->EnumNames[ (UINT32)(UINT32(0x900/*TPM_RC::RC_WARN*/) + 0x7F)] = "NOT_USED";
    sInf->EnumNames[ (UINT32)(0x040)] = "P";
    sInf->EnumNames[ (UINT32)(0x800)] = "S";
    sInf->EnumNames[ (UINT32)(0x100)] = "_1";
    sInf->EnumNames[ (UINT32)(0x200)] = "_2";
    sInf->EnumNames[ (UINT32)(0x300)] = "_3";
    sInf->EnumNames[ (UINT32)(0x400)] = "_4";
    sInf->EnumNames[ (UINT32)(0x500)] = "_5";
    sInf->EnumNames[ (UINT32)(0x600)] = "_6";
    sInf->EnumNames[ (UINT32)(0x700)] = "_7";
    sInf->EnumNames[ (UINT32)(0x800)] = "_8";
    sInf->EnumNames[ (UINT32)(0x900)] = "_9";
    sInf->EnumNames[ (UINT32)(0xA00)] = "A";
    sInf->EnumNames[ (UINT32)(0xB00)] = "B";
    sInf->EnumNames[ (UINT32)(0xC00)] = "C";
    sInf->EnumNames[ (UINT32)(0xD00)] = "D";
    sInf->EnumNames[ (UINT32)(0xE00)] = "E";
    sInf->EnumNames[ (UINT32)(0xF00)] = "F";
    sInf->EnumNames[ (UINT32)(0xF00)] = "N_MASK";
    sInf->EnumNames[ (UINT32)(0x40280001)] = "TSS_TCP_BAD_HANDSHAKE_RESP";
    sInf->EnumNames[ (UINT32)(0x40280002)] = "TSS_TCP_SERVER_TOO_OLD";
    sInf->EnumNames[ (UINT32)(0x40280003)] = "TSS_TCP_BAD_ACK";
    sInf->EnumNames[ (UINT32)(0x40280004)] = "TSS_TCP_BAD_RESP_LEN";
    sInf->EnumNames[ (UINT32)(0x40280005)] = "TSS_TCP_UNEXPECTED_STARTUP_RESP";
    sInf->EnumNames[ (UINT32)(0x40280006)] = "TSS_TCP_INVALID_SIZE_TAG";
    sInf->EnumNames[ (UINT32)(0x40280007)] = "TSS_TCP_DISCONNECTED";
    sInf->EnumNames[ (UINT32)(0x40280010)] = "TSS_DISPATCH_FAILED";
    sInf->EnumNames[ (UINT32)(0x40280011)] = "TSS_SEND_OP_FAILED";
    sInf->EnumNames[ (UINT32)(0x40280021)] = "TSS_RESP_BUF_TOO_SHORT";
    sInf->EnumNames[ (UINT32)(0x40280022)] = "TSS_RESP_BUF_INVALID_SESSION_TAG";
    sInf->EnumNames[ (UINT32)(0x80280400)] = "TBS_COMMAND_BLOCKED";
    sInf->EnumNames[ (UINT32)(0x80280401)] = "TBS_INVALID_HANDLE";
    sInf->EnumNames[ (UINT32)(0x80280402)] = "TBS_DUPLICATE_V_HANDLE";
    sInf->EnumNames[ (UINT32)(0x80280403)] = "TBS_EMBEDDED_COMMAND_BLOCKED";
    sInf->EnumNames[ (UINT32)(0x80280404)] = "TBS_EMBEDDED_COMMAND_UNSUPPORTED";
    sInf->EnumNames[ (UINT32)(0x80284000)] = "TBS_UNKNOWN_ERROR";
    sInf->EnumNames[ (UINT32)(0x80284001)] = "TBS_INTERNAL_ERROR";
    sInf->EnumNames[ (UINT32)(0x80284002)] = "TBS_BAD_PARAMETER";
    sInf->EnumNames[ (UINT32)(0x80284003)] = "TBS_INVALID_OUTPUT_POINTER";
    sInf->EnumNames[ (UINT32)(0x80284004)] = "TBS_INVALID_CONTEXT";
    sInf->EnumNames[ (UINT32)(0x80284005)] = "TBS_INSUFFICIENT_BUFFER";
    sInf->EnumNames[ (UINT32)(0x80284006)] = "TBS_IO_ERROR";
    sInf->EnumNames[ (UINT32)(0x80284007)] = "TBS_INVALID_CONTEXT_PARAM";
    sInf->EnumNames[ (UINT32)(0x80284008)] = "TBS_SERVICE_NOT_RUNNING";
    sInf->EnumNames[ (UINT32)(0x80284009)] = "TBS_TOO_MANY_CONTEXTS";
    sInf->EnumNames[ (UINT32)(0x8028400A)] = "TBS_TOO_MANY_RESOURCES";
    sInf->EnumNames[ (UINT32)(0x8028400B)] = "TBS_SERVICE_START_PENDING";
    sInf->EnumNames[ (UINT32)(0x8028400C)] = "TBS_PPI_NOT_SUPPORTED";
    sInf->EnumNames[ (UINT32)(0x8028400D)] = "TBS_COMMAND_CANCELED";
    sInf->EnumNames[ (UINT32)(0x8028400E)] = "TBS_BUFFER_TOO_LARGE";
    sInf->EnumNames[ (UINT32)(0x8028400F)] = "TBS_NOT_FOUND";
    sInf->EnumNames[ (UINT32)(0x80284010)] = "TBS_SERVICE_DISABLED";
    sInf->EnumNames[ (UINT32)(0x80284012)] = "TBS_ACCESS_DENIED";
    sInf->EnumNames[ (UINT32)(0x80284014)] = "TBS_PPI_FUNCTION_NOT_SUPPORTED";
    sInf->EnumNames[ (UINT32)(0x80284015)] = "TBS_OWNER_AUTH_NOT_FOUND";
    //===================TPM_CLOCK_ADJUST
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_CLOCK_ADJUST_ID] = sInf;
    sInf->Name = "TPM_CLOCK_ADJUST";
    sInf->MyTypeInfo = typeid(TPM_CLOCK_ADJUST).name();
    sInf->EnumNames[ (UINT32)(-3)] = "COARSE_SLOWER";
    sInf->EnumNames[ (UINT32)(-2)] = "MEDIUM_SLOWER";
    sInf->EnumNames[ (UINT32)(-1)] = "FINE_SLOWER";
    sInf->EnumNames[ (UINT32)(0)] = "NO_CHANGE";
    sInf->EnumNames[ (UINT32)(1)] = "FINE_FASTER";
    sInf->EnumNames[ (UINT32)(2)] = "MEDIUM_FASTER";
    sInf->EnumNames[ (UINT32)(3)] = "COARSE_FASTER";
    //===================TPM_EO
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_EO_ID] = sInf;
    sInf->Name = "TPM_EO";
    sInf->MyTypeInfo = typeid(TPM_EO).name();
    sInf->EnumNames[ (UINT32)(0x0000)] = "EQ";
    sInf->EnumNames[ (UINT32)(0x0001)] = "NEQ";
    sInf->EnumNames[ (UINT32)(0x0002)] = "SIGNED_GT";
    sInf->EnumNames[ (UINT32)(0x0003)] = "UNSIGNED_GT";
    sInf->EnumNames[ (UINT32)(0x0004)] = "SIGNED_LT";
    sInf->EnumNames[ (UINT32)(0x0005)] = "UNSIGNED_LT";
    sInf->EnumNames[ (UINT32)(0x0006)] = "SIGNED_GE";
    sInf->EnumNames[ (UINT32)(0x0007)] = "UNSIGNED_GE";
    sInf->EnumNames[ (UINT32)(0x0008)] = "SIGNED_LE";
    sInf->EnumNames[ (UINT32)(0x0009)] = "UNSIGNED_LE";
    sInf->EnumNames[ (UINT32)(0x000A)] = "BITSET";
    sInf->EnumNames[ (UINT32)(0x000B)] = "BITCLEAR";
    //===================TPM_ST
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_ST_ID] = sInf;
    sInf->Name = "TPM_ST";
    sInf->MyTypeInfo = typeid(TPM_ST).name();
    sInf->EnumNames[ (UINT32)(0x00C4)] = "RSP_COMMAND";
    sInf->EnumNames[ (UINT32)(0X8000)] = "_NULL";
    sInf->EnumNames[ (UINT32)(0x8001)] = "NO_SESSIONS";
    sInf->EnumNames[ (UINT32)(0x8002)] = "SESSIONS";
    sInf->EnumNames[ (UINT32)(0x8014)] = "ATTEST_NV";
    sInf->EnumNames[ (UINT32)(0x8015)] = "ATTEST_COMMAND_AUDIT";
    sInf->EnumNames[ (UINT32)(0x8016)] = "ATTEST_SESSION_AUDIT";
    sInf->EnumNames[ (UINT32)(0x8017)] = "ATTEST_CERTIFY";
    sInf->EnumNames[ (UINT32)(0x8018)] = "ATTEST_QUOTE";
    sInf->EnumNames[ (UINT32)(0x8019)] = "ATTEST_TIME";
    sInf->EnumNames[ (UINT32)(0x801A)] = "ATTEST_CREATION";
    sInf->EnumNames[ (UINT32)(0x801C)] = "ATTEST_NV_DIGEST";
    sInf->EnumNames[ (UINT32)(0x8021)] = "CREATION";
    sInf->EnumNames[ (UINT32)(0x8022)] = "VERIFIED";
    sInf->EnumNames[ (UINT32)(0x8023)] = "AUTH_SECRET";
    sInf->EnumNames[ (UINT32)(0x8024)] = "HASHCHECK";
    sInf->EnumNames[ (UINT32)(0x8025)] = "AUTH_SIGNED";
    sInf->EnumNames[ (UINT32)(0x8029)] = "FU_MANIFEST";
    //===================TPM_SU
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_SU_ID] = sInf;
    sInf->Name = "TPM_SU";
    sInf->MyTypeInfo = typeid(TPM_SU).name();
    sInf->EnumNames[ (UINT32)(0x0000)] = "CLEAR";
    sInf->EnumNames[ (UINT32)(0x0001)] = "STATE";
    //===================TPM_SE
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_SE_ID] = sInf;
    sInf->Name = "TPM_SE";
    sInf->MyTypeInfo = typeid(TPM_SE).name();
    sInf->EnumNames[ (UINT32)(0x00)] = "HMAC";
    sInf->EnumNames[ (UINT32)(0x01)] = "POLICY";
    sInf->EnumNames[ (UINT32)(0x03)] = "TRIAL";
    //===================TPM_CAP
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_CAP_ID] = sInf;
    sInf->Name = "TPM_CAP";
    sInf->MyTypeInfo = typeid(TPM_CAP).name();
    sInf->EnumNames[ (UINT32)(0x00000000)] = "FIRST";
    sInf->EnumNames[ (UINT32)(0x00000000)] = "ALGS";
    sInf->EnumNames[ (UINT32)(0x00000001)] = "HANDLES";
    sInf->EnumNames[ (UINT32)(0x00000002)] = "COMMANDS";
    sInf->EnumNames[ (UINT32)(0x00000003)] = "PP_COMMANDS";
    sInf->EnumNames[ (UINT32)(0x00000004)] = "AUDIT_COMMANDS";
    sInf->EnumNames[ (UINT32)(0x00000005)] = "PCRS";
    sInf->EnumNames[ (UINT32)(0x00000006)] = "TPM_PROPERTIES";
    sInf->EnumNames[ (UINT32)(0x00000007)] = "PCR_PROPERTIES";
    sInf->EnumNames[ (UINT32)(0x00000008)] = "ECC_CURVES";
    sInf->EnumNames[ (UINT32)(0x00000009)] = "AUTH_POLICIES";
    sInf->EnumNames[ (UINT32)(0x00000009)] = "LAST";
    sInf->EnumNames[ (UINT32)(0x00000100)] = "VENDOR_PROPERTY";
    //===================TPM_PT
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_PT_ID] = sInf;
    sInf->Name = "TPM_PT";
    sInf->MyTypeInfo = typeid(TPM_PT).name();
    sInf->EnumNames[ (UINT32)(0x00000000)] = "NONE";
    sInf->EnumNames[ (UINT32)(0x00000100)] = "PT_GROUP";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_GROUP*/) * 1)] = "PT_FIXED";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 0)] = "FAMILY_INDICATOR";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 1)] = "LEVEL";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 2)] = "REVISION";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 3)] = "DAY_OF_YEAR";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 4)] = "YEAR";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 5)] = "MANUFACTURER";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 6)] = "VENDOR_STRING_1";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 7)] = "VENDOR_STRING_2";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 8)] = "VENDOR_STRING_3";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 9)] = "VENDOR_STRING_4";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 10)] = "VENDOR_TPM_TYPE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 11)] = "FIRMWARE_VERSION_1";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 12)] = "FIRMWARE_VERSION_2";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 13)] = "INPUT_BUFFER";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 14)] = "HR_TRANSIENT_MIN";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 15)] = "HR_PERSISTENT_MIN";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 16)] = "HR_LOADED_MIN";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 17)] = "ACTIVE_SESSIONS_MAX";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 18)] = "PCR_COUNT";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 19)] = "PCR_SELECT_MIN";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 20)] = "CONTEXT_GAP_MAX";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 22)] = "NV_COUNTERS_MAX";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 23)] = "NV_INDEX_MAX";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 24)] = "MEMORY";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 25)] = "CLOCK_UPDATE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 26)] = "CONTEXT_HASH";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 27)] = "CONTEXT_SYM";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 28)] = "CONTEXT_SYM_SIZE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 29)] = "ORDERLY_COUNT";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 30)] = "MAX_COMMAND_SIZE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 31)] = "MAX_RESPONSE_SIZE";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 32)] = "MAX_DIGEST";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 33)] = "MAX_OBJECT_CONTEXT";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 34)] = "MAX_SESSION_CONTEXT";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 35)] = "PS_FAMILY_INDICATOR";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 36)] = "PS_LEVEL";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 37)] = "PS_REVISION";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 38)] = "PS_DAY_OF_YEAR";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 39)] = "PS_YEAR";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 40)] = "SPLIT_MAX";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 41)] = "TOTAL_COMMANDS";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 42)] = "LIBRARY_COMMANDS";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 43)] = "VENDOR_COMMANDS";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 44)] = "NV_BUFFER_MAX";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 45)] = "MODES";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_FIXED*/) + 46)] = "MAX_CAP_BUFFER";
    sInf->EnumNames[ (UINT32)(UINT32(0x100/*TPM_PT::PT_GROUP*/) * 2)] = "PT_VAR";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 0)] = "PERMANENT";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 1)] = "STARTUP_CLEAR";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 2)] = "HR_NV_INDEX";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 3)] = "HR_LOADED";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 4)] = "HR_LOADED_AVAIL";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 5)] = "HR_ACTIVE";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 6)] = "HR_ACTIVE_AVAIL";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 7)] = "HR_TRANSIENT_AVAIL";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 8)] = "HR_PERSISTENT";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 9)] = "HR_PERSISTENT_AVAIL";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 10)] = "NV_COUNTERS";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 11)] = "NV_COUNTERS_AVAIL";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 12)] = "ALGORITHM_SET";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 13)] = "LOADED_CURVES";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 14)] = "LOCKOUT_COUNTER";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 15)] = "MAX_AUTH_FAIL";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 16)] = "LOCKOUT_INTERVAL";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 17)] = "LOCKOUT_RECOVERY";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 18)] = "NV_WRITE_RECOVERY";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 19)] = "AUDIT_COUNTER_0";
    sInf->EnumNames[ (UINT32)(UINT32(0x200/*TPM_PT::PT_VAR*/) + 20)] = "AUDIT_COUNTER_1";
    //===================TPM_PT_PCR
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_PT_PCR_ID] = sInf;
    sInf->Name = "TPM_PT_PCR";
    sInf->MyTypeInfo = typeid(TPM_PT_PCR).name();
    sInf->EnumNames[ (UINT32)(0x00000000)] = "FIRST";
    sInf->EnumNames[ (UINT32)(0x00000000)] = "SAVE";
    sInf->EnumNames[ (UINT32)(0x00000001)] = "EXTEND_L0";
    sInf->EnumNames[ (UINT32)(0x00000002)] = "RESET_L0";
    sInf->EnumNames[ (UINT32)(0x00000003)] = "EXTEND_L1";
    sInf->EnumNames[ (UINT32)(0x00000004)] = "RESET_L1";
    sInf->EnumNames[ (UINT32)(0x00000005)] = "EXTEND_L2";
    sInf->EnumNames[ (UINT32)(0x00000006)] = "RESET_L2";
    sInf->EnumNames[ (UINT32)(0x00000007)] = "EXTEND_L3";
    sInf->EnumNames[ (UINT32)(0x00000008)] = "RESET_L3";
    sInf->EnumNames[ (UINT32)(0x00000009)] = "EXTEND_L4";
    sInf->EnumNames[ (UINT32)(0x0000000A)] = "RESET_L4";
    sInf->EnumNames[ (UINT32)(0x00000011)] = "NO_INCREMENT";
    sInf->EnumNames[ (UINT32)(0x00000012)] = "DRTM_RESET";
    sInf->EnumNames[ (UINT32)(0x00000013)] = "POLICY";
    sInf->EnumNames[ (UINT32)(0x00000014)] = "AUTH";
    sInf->EnumNames[ (UINT32)(0x00000014)] = "LAST";
    //===================TPM_PS
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_PS_ID] = sInf;
    sInf->Name = "TPM_PS";
    sInf->MyTypeInfo = typeid(TPM_PS).name();
    sInf->EnumNames[ (UINT32)(0x00000000)] = "MAIN";
    sInf->EnumNames[ (UINT32)(0x00000001)] = "PC";
    sInf->EnumNames[ (UINT32)(0x00000002)] = "PDA";
    sInf->EnumNames[ (UINT32)(0x00000003)] = "CELL_PHONE";
    sInf->EnumNames[ (UINT32)(0x00000004)] = "SERVER";
    sInf->EnumNames[ (UINT32)(0x00000005)] = "PERIPHERAL";
    sInf->EnumNames[ (UINT32)(0x00000006)] = "TSS";
    sInf->EnumNames[ (UINT32)(0x00000007)] = "STORAGE";
    sInf->EnumNames[ (UINT32)(0x00000008)] = "AUTHENTICATION";
    sInf->EnumNames[ (UINT32)(0x00000009)] = "EMBEDDED";
    sInf->EnumNames[ (UINT32)(0x0000000A)] = "HARDCOPY";
    sInf->EnumNames[ (UINT32)(0x0000000B)] = "INFRASTRUCTURE";
    sInf->EnumNames[ (UINT32)(0x0000000C)] = "VIRTUALIZATION";
    sInf->EnumNames[ (UINT32)(0x0000000D)] = "TNC";
    sInf->EnumNames[ (UINT32)(0x0000000E)] = "MULTI_TENANT";
    sInf->EnumNames[ (UINT32)(0x0000000F)] = "TC";
    //===================TPM_HT
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_HT_ID] = sInf;
    sInf->Name = "TPM_HT";
    sInf->MyTypeInfo = typeid(TPM_HT).name();
    sInf->EnumNames[ (UINT32)(0x00)] = "PCR";
    sInf->EnumNames[ (UINT32)(0x01)] = "NV_INDEX";
    sInf->EnumNames[ (UINT32)(0x02)] = "HMAC_SESSION";
    sInf->EnumNames[ (UINT32)(0x02)] = "LOADED_SESSION";
    sInf->EnumNames[ (UINT32)(0x03)] = "POLICY_SESSION";
    sInf->EnumNames[ (UINT32)(0x03)] = "SAVED_SESSION";
    sInf->EnumNames[ (UINT32)(0x40)] = "PERMANENT";
    sInf->EnumNames[ (UINT32)(0x80)] = "TRANSIENT";
    sInf->EnumNames[ (UINT32)(0x81)] = "PERSISTENT";
    sInf->EnumNames[ (UINT32)(0x90)] = "AC";
    //===================TPM_RH
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_RH_ID] = sInf;
    sInf->Name = "TPM_RH";
    sInf->MyTypeInfo = typeid(TPM_RH).name();
    sInf->EnumNames[ (UINT32)(0x40000000)] = "FIRST";
    sInf->EnumNames[ (UINT32)(0x40000000)] = "SRK";
    sInf->EnumNames[ (UINT32)(0x40000001)] = "OWNER";
    sInf->EnumNames[ (UINT32)(0x40000002)] = "REVOKE";
    sInf->EnumNames[ (UINT32)(0x40000003)] = "TRANSPORT";
    sInf->EnumNames[ (UINT32)(0x40000004)] = "OPERATOR";
    sInf->EnumNames[ (UINT32)(0x40000005)] = "ADMIN";
    sInf->EnumNames[ (UINT32)(0x40000006)] = "EK";
    sInf->EnumNames[ (UINT32)(0x40000007)] = "_NULL";
    sInf->EnumNames[ (UINT32)(0x40000008)] = "UNASSIGNED";
    sInf->EnumNames[ (UINT32)(0x40000009)] = "RS_PW";
    sInf->EnumNames[ (UINT32)(0x4000000A)] = "LOCKOUT";
    sInf->EnumNames[ (UINT32)(0x4000000B)] = "ENDORSEMENT";
    sInf->EnumNames[ (UINT32)(0x4000000C)] = "PLATFORM";
    sInf->EnumNames[ (UINT32)(0x4000000D)] = "PLATFORM_NV";
    sInf->EnumNames[ (UINT32)(0x40000010)] = "AUTH_00";
    sInf->EnumNames[ (UINT32)(0x4000010F)] = "AUTH_FF";
    sInf->EnumNames[ (UINT32)(0x4000010F)] = "LAST";
    //===================TPM_NT
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_NT_ID] = sInf;
    sInf->Name = "TPM_NT";
    sInf->MyTypeInfo = typeid(TPM_NT).name();
    sInf->EnumNames[ (UINT32)(0x0)] = "ORDINARY";
    sInf->EnumNames[ (UINT32)(0x1)] = "COUNTER";
    sInf->EnumNames[ (UINT32)(0x2)] = "BITS";
    sInf->EnumNames[ (UINT32)(0x4)] = "EXTEND";
    sInf->EnumNames[ (UINT32)(0x8)] = "PIN_FAIL";
    sInf->EnumNames[ (UINT32)(0x9)] = "PIN_PASS";
    //===================TPM_AT
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_AT_ID] = sInf;
    sInf->Name = "TPM_AT";
    sInf->MyTypeInfo = typeid(TPM_AT).name();
    sInf->EnumNames[ (UINT32)(0x00000000)] = "ANY";
    sInf->EnumNames[ (UINT32)(0x00000001)] = "_ERROR";
    sInf->EnumNames[ (UINT32)(0x00000002)] = "PV1";
    sInf->EnumNames[ (UINT32)(0x80000000)] = "VEND";
    //===================TPM_AE
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_AE_ID] = sInf;
    sInf->Name = "TPM_AE";
    sInf->MyTypeInfo = typeid(TPM_AE).name();
    sInf->EnumNames[ (UINT32)(0x00000000)] = "NONE";
    //===================PLATFORM
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::PLATFORM_ID] = sInf;
    sInf->Name = "PLATFORM";
    sInf->MyTypeInfo = typeid(PLATFORM).name();
    sInf->EnumNames[ (UINT32)(UINT32(0x322E3000/*TPM_SPEC::FAMILY*/))] = "FAMILY";
    sInf->EnumNames[ (UINT32)(UINT32(0x0/*TPM_SPEC::LEVEL*/))] = "LEVEL";
    sInf->EnumNames[ (UINT32)(UINT32(0x99/*TPM_SPEC::VERSION*/))] = "VERSION";
    sInf->EnumNames[ (UINT32)(UINT32(0x7E3/*TPM_SPEC::YEAR*/))] = "YEAR";
    sInf->EnumNames[ (UINT32)(UINT32(0x1C/*TPM_SPEC::DAY_OF_YEAR*/))] = "DAY_OF_YEAR";
    //===================Implementation
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::Implementation_ID] = sInf;
    sInf->Name = "Implementation";
    sInf->MyTypeInfo = typeid(Implementation).name();
    sInf->EnumNames[ (UINT32)(UINT32(0x0/*Logic::NO*/))] = "FIELD_UPGRADE_IMPLEMENTED";
    sInf->EnumNames[ (UINT32)(32)] = "RADIX_BITS";
    sInf->EnumNames[ (UINT32)(4)] = "HASH_ALIGNMENT";
    sInf->EnumNames[ (UINT32)(4)] = "SYMMETRIC_ALIGNMENT";
    sInf->EnumNames[ (UINT32)(UINT32(0x1/*ImplementationConstants::OSSL*/))] = "HASH_LIB";
    sInf->EnumNames[ (UINT32)(UINT32(0x1/*ImplementationConstants::OSSL*/))] = "SYM_LIB";
    sInf->EnumNames[ (UINT32)(UINT32(0x1/*ImplementationConstants::OSSL*/))] = "MATH_LIB";
    sInf->EnumNames[ (UINT32)(24)] = "PLATFORM_PCR";
    sInf->EnumNames[ (UINT32)(((UINT32(0x18/*Implementation::PLATFORM_PCR*/) + 7) / 8))] = "PCR_SELECT_MIN";
    sInf->EnumNames[ (UINT32)(24)] = "IMPLEMENTATION_PCR";
    sInf->EnumNames[ (UINT32)(((UINT32(0x18/*Implementation::IMPLEMENTATION_PCR*/) + 7) / 8))] = "PCR_SELECT_MAX";
    sInf->EnumNames[ (UINT32)(17)] = "DRTM_PCR";
    sInf->EnumNames[ (UINT32)(0)] = "HCRTM_PCR";
    sInf->EnumNames[ (UINT32)(5)] = "NUM_LOCALITIES";
    sInf->EnumNames[ (UINT32)(3)] = "MAX_HANDLE_NUM";
    sInf->EnumNames[ (UINT32)(64)] = "MAX_ACTIVE_SESSIONS";
    sInf->EnumNames[ (UINT32)(3)] = "MAX_LOADED_SESSIONS";
    sInf->EnumNames[ (UINT32)(3)] = "MAX_SESSION_NUM";
    sInf->EnumNames[ (UINT32)(3)] = "MAX_LOADED_OBJECTS";
    sInf->EnumNames[ (UINT32)(2)] = "MIN_EVICT_OBJECTS";
    sInf->EnumNames[ (UINT32)(1)] = "NUM_POLICY_PCR_GROUP";
    sInf->EnumNames[ (UINT32)(1)] = "NUM_AUTHVALUE_PCR_GROUP";
    sInf->EnumNames[ (UINT32)(1264)] = "MAX_CONTEXT_SIZE";
    sInf->EnumNames[ (UINT32)(1024)] = "MAX_DIGEST_BUFFER";
    sInf->EnumNames[ (UINT32)(2048)] = "MAX_NV_INDEX_SIZE";
    sInf->EnumNames[ (UINT32)(1024)] = "MAX_NV_BUFFER_SIZE";
    sInf->EnumNames[ (UINT32)(1024)] = "MAX_CAP_BUFFER";
    sInf->EnumNames[ (UINT32)(16384)] = "NV_MEMORY_SIZE";
    sInf->EnumNames[ (UINT32)(8)] = "MIN_COUNTER_INDICES";
    sInf->EnumNames[ (UINT32)(16)] = "NUM_STATIC_PCR";
    sInf->EnumNames[ (UINT32)(64)] = "MAX_ALG_LIST_SIZE";
    sInf->EnumNames[ (UINT32)(32)] = "PRIMARY_SEED_SIZE";
    sInf->EnumNames[ (UINT32)(UINT32(0x6/*ALG_ID_VALUE::AES_VALUE*/))] = "CONTEXT_ENCRYPT_ALG";
    sInf->EnumNames[ (UINT32)(12)] = "NV_CLOCK_UPDATE_INTERVAL";
    sInf->EnumNames[ (UINT32)(1)] = "NUM_POLICY_PCR";
    sInf->EnumNames[ (UINT32)(4096)] = "MAX_COMMAND_SIZE";
    sInf->EnumNames[ (UINT32)(4096)] = "MAX_RESPONSE_SIZE";
    sInf->EnumNames[ (UINT32)(8)] = "ORDERLY_BITS";
    sInf->EnumNames[ (UINT32)(128)] = "MAX_SYM_DATA";
    sInf->EnumNames[ (UINT32)(64)] = "MAX_RNG_ENTROPY_SIZE";
    sInf->EnumNames[ (UINT32)(512)] = "RAM_INDEX_SPACE";
    sInf->EnumNames[ (UINT32)(0x00010001)] = "RSA_DEFAULT_PUBLIC_EXPONENT";
    sInf->EnumNames[ (UINT32)(UINT32(0x1/*Logic::YES*/))] = "ENABLE_PCR_NO_INCREMENT";
    sInf->EnumNames[ (UINT32)(UINT32(0x1/*Logic::YES*/))] = "CRT_FORMAT_RSA";
    sInf->EnumNames[ (UINT32)(0)] = "VENDOR_COMMAND_COUNT";
    sInf->EnumNames[ (UINT32)(1024)] = "MAX_VENDOR_BUFFER_SIZE";
    sInf->EnumNames[ (UINT32)(8192)] = "TPM_MAX_DERIVATION_BITS";
    sInf->EnumNames[ (UINT32)(20)] = "SIZE_OF_X509_SERIAL_NUMBER";
    sInf->EnumNames[ (UINT32)(((UINT32(0x100/*ImplementationConstants::MAX_RSA_KEY_BYTES*/) * 5) / 2))] = "RSA_PRIVATE_SIZE";
    sInf->EnumNames[ (UINT32)(UINT32(0x280/*Implementation::RSA_PRIVATE_SIZE*/))] = "PRIVATE_VENDOR_SPECIFIC_BYTES";
    //===================TPM_HC
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::TPM_HC_ID] = sInf;
    sInf->Name = "TPM_HC";
    sInf->MyTypeInfo = typeid(TPM_HC).name();
    sInf->EnumNames[ (UINT32)(0x00FFFFFF)] = "HR_HANDLE_MASK";
    sInf->EnumNames[ (UINT32)(0xFF000000)] = "HR_RANGE_MASK";
    sInf->EnumNames[ (UINT32)(24)] = "HR_SHIFT";
    sInf->EnumNames[ (UINT32)((UINT32(0x0/*TPM_HT::PCR*/) << UINT32(0x18/*TPM_HC::HR_SHIFT*/)))] = "HR_PCR";
    sInf->EnumNames[ (UINT32)((UINT32(0x2/*TPM_HT::HMAC_SESSION*/) << UINT32(0x18/*TPM_HC::HR_SHIFT*/)))] = "HR_HMAC_SESSION";
    sInf->EnumNames[ (UINT32)((UINT32(0x3/*TPM_HT::POLICY_SESSION*/) << UINT32(0x18/*TPM_HC::HR_SHIFT*/)))] = "HR_POLICY_SESSION";
    sInf->EnumNames[ (UINT32)((UINT32(0x80/*TPM_HT::TRANSIENT*/) << UINT32(0x18/*TPM_HC::HR_SHIFT*/)))] = "HR_TRANSIENT";
    sInf->EnumNames[ (UINT32)((UINT32(0x81/*TPM_HT::PERSISTENT*/) << UINT32(0x18/*TPM_HC::HR_SHIFT*/)))] = "HR_PERSISTENT";
    sInf->EnumNames[ (UINT32)((UINT32(0x1/*TPM_HT::NV_INDEX*/) << UINT32(0x18/*TPM_HC::HR_SHIFT*/)))] = "HR_NV_INDEX";
    sInf->EnumNames[ (UINT32)((UINT32(0x40/*TPM_HT::PERMANENT*/) << UINT32(0x18/*TPM_HC::HR_SHIFT*/)))] = "HR_PERMANENT";
    sInf->EnumNames[ (UINT32)((UINT32(0x0/*TPM_HC::HR_PCR*/) + 0))] = "PCR_FIRST";
    sInf->EnumNames[ (UINT32)((UINT32(0x0/*TPM_HC::PCR_FIRST*/) + UINT32(0x18/*Implementation::IMPLEMENTATION_PCR*/)-1))] = "PCR_LAST";
    sInf->EnumNames[ (UINT32)((UINT32(0x2000000/*TPM_HC::HR_HMAC_SESSION*/) + 0))] = "HMAC_SESSION_FIRST";
    sInf->EnumNames[ (UINT32)((UINT32(0x2000000/*TPM_HC::HMAC_SESSION_FIRST*/)+UINT32(0x40/*Implementation::MAX_ACTIVE_SESSIONS*/)-1))] = "HMAC_SESSION_LAST";
    sInf->EnumNames[ (UINT32)(UINT32(0x2000000/*TPM_HC::HMAC_SESSION_FIRST*/))] = "LOADED_SESSION_FIRST";
    sInf->EnumNames[ (UINT32)(UINT32(0x200003F/*TPM_HC::HMAC_SESSION_LAST*/))] = "LOADED_SESSION_LAST";
    sInf->EnumNames[ (UINT32)((UINT32(0x3000000/*TPM_HC::HR_POLICY_SESSION*/) + 0))] = "POLICY_SESSION_FIRST";
    sInf->EnumNames[ (UINT32)((UINT32(0x3000000/*TPM_HC::POLICY_SESSION_FIRST*/) + UINT32(0x40/*Implementation::MAX_ACTIVE_SESSIONS*/)-1))] = "POLICY_SESSION_LAST";
    sInf->EnumNames[ (UINT32)((UINT32(0x80000000/*TPM_HC::HR_TRANSIENT*/) + 0))] = "TRANSIENT_FIRST";
    sInf->EnumNames[ (UINT32)(UINT32(0x3000000/*TPM_HC::POLICY_SESSION_FIRST*/))] = "ACTIVE_SESSION_FIRST";
    sInf->EnumNames[ (UINT32)(UINT32(0x300003F/*TPM_HC::POLICY_SESSION_LAST*/))] = "ACTIVE_SESSION_LAST";
    sInf->EnumNames[ (UINT32)((UINT32(0x80000000/*TPM_HC::TRANSIENT_FIRST*/)+UINT32(0x3/*Implementation::MAX_LOADED_OBJECTS*/)-1))] = "TRANSIENT_LAST";
    sInf->EnumNames[ (UINT32)((UINT32(0x81000000/*TPM_HC::HR_PERSISTENT*/) + 0))] = "PERSISTENT_FIRST";
    sInf->EnumNames[ (UINT32)((UINT32(0x81000000/*TPM_HC::PERSISTENT_FIRST*/) + 0x00FFFFFF))] = "PERSISTENT_LAST";
    sInf->EnumNames[ (UINT32)((UINT32(0x81000000/*TPM_HC::PERSISTENT_FIRST*/) + 0x00800000))] = "PLATFORM_PERSISTENT";
    sInf->EnumNames[ (UINT32)((UINT32(0x1000000/*TPM_HC::HR_NV_INDEX*/) + 0))] = "NV_INDEX_FIRST";
    sInf->EnumNames[ (UINT32)((UINT32(0x1000000/*TPM_HC::NV_INDEX_FIRST*/) + 0x00FFFFFF))] = "NV_INDEX_LAST";
    sInf->EnumNames[ (UINT32)(UINT32(0x40000000/*TPM_RH::FIRST*/))] = "PERMANENT_FIRST";
    sInf->EnumNames[ (UINT32)(UINT32(0x4000010F/*TPM_RH::LAST*/))] = "PERMANENT_LAST";
    sInf->EnumNames[ (UINT32)(((UINT32(0x1/*TPM_HT::NV_INDEX*/) << UINT32(0x18/*TPM_HC::HR_SHIFT*/)) + 0xD00000))] = "HR_NV_AC";
    sInf->EnumNames[ (UINT32)((UINT32(0x1D00000/*TPM_HC::HR_NV_AC*/) + 0))] = "NV_AC_FIRST";
    sInf->EnumNames[ (UINT32)((UINT32(0x1D00000/*TPM_HC::HR_NV_AC*/) + 0x0000FFFF))] = "NV_AC_LAST";
    sInf->EnumNames[ (UINT32)((UINT32(0x90/*TPM_HT::AC*/) << UINT32(0x18/*TPM_HC::HR_SHIFT*/)))] = "HR_AC";
    sInf->EnumNames[ (UINT32)((UINT32(0x90000000/*TPM_HC::HR_AC*/) + 0))] = "AC_FIRST";
    sInf->EnumNames[ (UINT32)((UINT32(0x90000000/*TPM_HC::HR_AC*/) + 0x0000FFFF))] = "AC_LAST";
    //===================ALG_ID_VALUE
    sInf = new StructMarshallInfo();
    sInf->EnumNames.clear();
    TypeMap[TpmTypeId::ALG_ID_VALUE_ID] = sInf;
    sInf->Name = "ALG_ID_VALUE";
    sInf->MyTypeInfo = typeid(ALG_ID_VALUE).name();
    sInf->EnumNames[ (UINT32)(0x0000)] = "ERROR_VALUE";
    sInf->EnumNames[ (UINT32)(0x0001)] = "FIRST_VALUE";
    sInf->EnumNames[ (UINT32)(0x0001)] = "RSA_VALUE";
    sInf->EnumNames[ (UINT32)(0x0003)] = "TDES_VALUE";
    sInf->EnumNames[ (UINT32)(0x0004)] = "SHA_VALUE";
    sInf->EnumNames[ (UINT32)(0x0004)] = "SHA1_VALUE";
    sInf->EnumNames[ (UINT32)(0x0005)] = "HMAC_VALUE";
    sInf->EnumNames[ (UINT32)(0x0006)] = "AES_VALUE";
    sInf->EnumNames[ (UINT32)(0x0007)] = "MGF1_VALUE";
    sInf->EnumNames[ (UINT32)(0x0008)] = "KEYEDHASH_VALUE";
    sInf->EnumNames[ (UINT32)(0x000A)] = "XOR_VALUE";
    sInf->EnumNames[ (UINT32)(0x000B)] = "SHA256_VALUE";
    sInf->EnumNames[ (UINT32)(0x000C)] = "SHA384_VALUE";
    sInf->EnumNames[ (UINT32)(0x000D)] = "SHA512_VALUE";
    sInf->EnumNames[ (UINT32)(0x0010)] = "NULL_VALUE";
    sInf->EnumNames[ (UINT32)(0x0012)] = "SM3_256_VALUE";
    sInf->EnumNames[ (UINT32)(0x0013)] = "SM4_VALUE";
    sInf->EnumNames[ (UINT32)(0x0014)] = "RSASSA_VALUE";
    sInf->EnumNames[ (UINT32)(0x0015)] = "RSAES_VALUE";
    sInf->EnumNames[ (UINT32)(0x0016)] = "RSAPSS_VALUE";
    sInf->EnumNames[ (UINT32)(0x0017)] = "OAEP_VALUE";
    sInf->EnumNames[ (UINT32)(0x0018)] = "ECDSA_VALUE";
    sInf->EnumNames[ (UINT32)(0x0019)] = "ECDH_VALUE";
    sInf->EnumNames[ (UINT32)(0x001A)] = "ECDAA_VALUE";
    sInf->EnumNames[ (UINT32)(0x001B)] = "SM2_VALUE";
    sInf->EnumNames[ (UINT32)(0x001C)] = "ECSCHNORR_VALUE";
    sInf->EnumNames[ (UINT32)(0x001D)] = "ECMQV_VALUE";
    sInf->EnumNames[ (UINT32)(0x0020)] = "KDF1_SP800_56A_VALUE";
    sInf->EnumNames[ (UINT32)(0x0021)] = "KDF2_VALUE";
    sInf->EnumNames[ (UINT32)(0x0022)] = "KDF1_SP800_108_VALUE";
    sInf->EnumNames[ (UINT32)(0x0023)] = "ECC_VALUE";
    sInf->EnumNames[ (UINT32)(0x0025)] = "SYMCIPHER_VALUE";
    sInf->EnumNames[ (UINT32)(0x0026)] = "CAMELLIA_VALUE";
    sInf->EnumNames[ (UINT32)(0x003F)] = "CMAC_VALUE";
    sInf->EnumNames[ (UINT32)(0x0040)] = "CTR_VALUE";
    sInf->EnumNames[ (UINT32)(0x0041)] = "OFB_VALUE";
    sInf->EnumNames[ (UINT32)(0x0042)] = "CBC_VALUE";
    sInf->EnumNames[ (UINT32)(0x0043)] = "CFB_VALUE";
    sInf->EnumNames[ (UINT32)(0x0044)] = "ECB_VALUE";
    sInf->EnumNames[ (UINT32)(0x0044)] = "LAST_VALUE";
    sInf->EnumNames[ (UINT32)(0x7FFF)] = "ANY_VALUE";
    sInf->EnumNames[ (UINT32)(0x7FFE)] = "ANY2_VALUE";
    return;
};
